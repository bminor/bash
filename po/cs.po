# Czech tranlation for bash.
# Copyright (C) 2008 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Petr Pisar <petr.pisar@atlas.cz>, 2008, 2009, 2010, 2011, 2012, 2013, 2014.
# Petr Pisar <petr.pisar@atlas.cz>, 2015, 2016, 2018, 2019, 2020, 2022, 2023.
# Petr Pisar <petr.pisar@atlas.cz>, 2025.
#
# alias → alias
# subscript → podskript
# subroutine → podprogram
# completion options → možnosti doplňování
# shell option → přepínač shellu (shopt)
# Názvy signálů a stavů procesu by měly souhlasit se signal(7).
msgid ""
msgstr ""
"Project-Id-Version: bash 5.3-rc2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-22 09:37-0400\n"
"PO-Revision-Date: 2025-06-03 21:27+02:00\n"
"Last-Translator: Petr Pisar <petr.pisar@atlas.cz>\n"
"Language-Team: Czech <translation-team-cs@lists.sourceforge.net>\n"
"Language: cs\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=3; plural=(n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2;\n"

#: arrayfunc.c:63
msgid "bad array subscript"
msgstr "chybný podskript pole"

#: arrayfunc.c:466 builtins/declare.def:748 variables.c:2196 variables.c:2225
#: variables.c:3099
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: odstraňuje se atribut odkazu na název"

#: arrayfunc.c:493 builtins/declare.def:920
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: číslované pole nelze převést na pole asociativní"

#: arrayfunc.c:789
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: přes nečíselný indexu nelze dosadit"

#: arrayfunc.c:841
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: při přiřazovaní asociativního pole se musí použít podskript"

#: bashhist.c:464
msgid "cannot create"
msgstr "nelze vytvořit"

#: bashline.c:4642
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: pro příkaz nelze nalézt klávesovou mapu "

#: bashline.c:4813
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: první nebílý znak není „\"“"

#: bashline.c:4842
#, c-format
msgid "no closing `%c' in %s"
msgstr "ne zavírající „%c“ v %s"

#: bashline.c:4873
#, c-format
msgid "%s: missing separator"
msgstr "%s: chybí oddělovač"

#: bashline.c:4920
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "„%s“: v mapě kláves příkazů nelze zrušit vazbu"

#: braces.c:340
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "závorková expanze: nelze alokovat paměť pro %s"

# TODO: pluralize
#: braces.c:403
#, c-format
msgid "brace expansion: failed to allocate memory for %s elements"
msgstr "závorková expanze: alokace paměti pro %s prvků selhala"

#: braces.c:462
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "závorková expanze: alokace paměti pro „%s“ selhala"

#: builtins/alias.def:131 variables.c:1789
#, c-format
msgid "`%s': invalid alias name"
msgstr "„%s“: chybný název aliasu"

#: builtins/bind.def:123
msgid "line editing not enabled"
msgstr "upravování řádku není povoleno"

#: builtins/bind.def:208
#, c-format
msgid "`%s': invalid keymap name"
msgstr "„%s“: chybný název klávesové mapy"

#: builtins/bind.def:277
msgid "cannot read"
msgstr "nelze číst"

#: builtins/bind.def:353 builtins/bind.def:382
#, c-format
msgid "`%s': unknown function name"
msgstr "„%s“: neznámé jméno funkce"

#: builtins/bind.def:361
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s není svázán s žádnou klávesou.\n"

#: builtins/bind.def:365
#, c-format
msgid "%s can be invoked via "
msgstr "%s lze vyvolat přes "

#: builtins/bind.def:401 builtins/bind.def:418
#, c-format
msgid "`%s': cannot unbind"
msgstr "„%s“: nelze zrušit vazbu"

#: builtins/break.def:80 builtins/break.def:125
msgid "loop count"
msgstr "počet smyček"

#: builtins/break.def:145
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "má smysl jen ve smyčkách „for“, „while“ nebo „until“"

#: builtins/caller.def:135
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Vrátí kontext aktuálního podprogramu.\n"
"    \n"
"    Bez VÝRAZU vrátí „$řádek $název_souboru“. S VÝRAZEM vrátí\n"
"    „$řádek $podprogram $název_souboru“; tuto zvláštní informaci lze\n"
"    využít pro výpis zásobníku volání.\n"
"    \n"
"    Hodnota VÝRAZU určuje, kolik rámců volání se má zpětně projít od toho\n"
"    současného; vrcholový rámec má číslo 0.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací 0, pokud shell provádí shellovou funkci a VÝRAZ je platný."

#: builtins/cd.def:321
msgid "HOME not set"
msgstr "není nestavena HOME"

#: builtins/cd.def:329 builtins/common.c:143 builtins/fc.def:293 test.c:946
msgid "too many arguments"
msgstr "příliš mnoho argumentů"

#: builtins/cd.def:335
msgid "null directory"
msgstr "adresář s prázdným názvem"

#: builtins/cd.def:345
msgid "OLDPWD not set"
msgstr "není nastaveno OLDPWD"

#: builtins/common.c:91
#, c-format
msgid "line %d: "
msgstr "řádek %d: "

#: builtins/common.c:117 error.c:227
#, c-format
msgid "warning: "
msgstr "varování: "

#: builtins/common.c:131
#, c-format
msgid "%s: usage: "
msgstr "%s: užití: "

#: builtins/common.c:178 shell.c:524 shell.c:865
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: přepínač vyžaduje argument"

#: builtins/common.c:184
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: vyžadován číselný argument"

#: builtins/common.c:190
#, c-format
msgid "%s: not found"
msgstr "%s: nenalezeno"

#: builtins/common.c:198 shell.c:878
#, c-format
msgid "%s: invalid option"
msgstr "%s: chybný přepínač"

#: builtins/common.c:204
#, c-format
msgid "%s: invalid option name"
msgstr "%s: chybný název přepínače"

#: builtins/common.c:210 error.c:461
#, c-format
msgid "`%s': not a valid identifier"
msgstr "„%s“: není platným identifikátorem"

#: builtins/common.c:219
msgid "invalid octal number"
msgstr "neplatné osmičkové číslo"

#: builtins/common.c:221
msgid "invalid hex number"
msgstr "chybné šestnáctkové číslo"

#: builtins/common.c:223 expr.c:1577 expr.c:1591
msgid "invalid number"
msgstr "chybné číslo"

#: builtins/common.c:230
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: chybné určení signálu"

#: builtins/common.c:236
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "„%s“: není PID ani platným označením úlohy"

#: builtins/common.c:242 error.c:455
#, c-format
msgid "%s: readonly variable"
msgstr "%s: proměnná pouze pro čtení"

#: builtins/common.c:248
#, c-format
msgid "%s: cannot assign"
msgstr "%s: nelze přiřadit"

#: builtins/common.c:255
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s mimo rozsah"

#: builtins/common.c:255 builtins/common.c:257
msgid "argument"
msgstr "argument"

#: builtins/common.c:257
#, c-format
msgid "%s out of range"
msgstr "%s mimo rozsah"

#: builtins/common.c:264
#, c-format
msgid "%s: no such job"
msgstr "%s: žádná taková úloha"

#: builtins/common.c:271
#, c-format
msgid "%s: no job control"
msgstr "%s: žádné řízení úloh"

#: builtins/common.c:273
msgid "no job control"
msgstr "žádné řízení úloh"

#: builtins/common.c:279
#, c-format
msgid "%s: invalid job specification"
msgstr "%s: chybné určení úlohy"

#: builtins/common.c:289
#, c-format
msgid "%s: restricted"
msgstr "%s: omezeno"

#: builtins/common.c:291
msgid "restricted"
msgstr "omezeno"

#: builtins/common.c:298
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: není vestavěným příkazem shellu"

#: builtins/common.c:307
msgid "write error"
msgstr "chyba zápisu"

#: builtins/common.c:314
msgid "error setting terminal attributes"
msgstr "chyba při nastavování vlastností terminálu"

#: builtins/common.c:316
msgid "error getting terminal attributes"
msgstr "chyba při získávání vlastností terminálu"

#: builtins/common.c:611
msgid "error retrieving current directory"
msgstr "chyba při zjišťování současného adresáře"

#: builtins/common.c:675 builtins/common.c:677
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: nejednoznačné určení úlohy"

#: builtins/common.c:709
#, c-format
msgid "%s: job specification requires leading `%%'"
msgstr "%s: zadání úlohy vyžaduje na začátku „%%“"

#: builtins/common.c:937
msgid "help not available in this version"
msgstr "k této verzi není dostupná nápověda"

#: builtins/common.c:1005
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: není (proměnnou typu) indexované pole"

#: builtins/common.c:1028 builtins/set.def:964 variables.c:3868
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: nelze zrušit: %s jen pro čtení"

#: builtins/common.c:1033 builtins/set.def:930 variables.c:3873
#, c-format
msgid "%s: cannot unset"
msgstr "%s: nelze zrušit"

#: builtins/complete.def:285
#, c-format
msgid "%s: invalid action name"
msgstr "%s: neplatný název akce"

#: builtins/complete.def:501 builtins/complete.def:644
#: builtins/complete.def:899
#, c-format
msgid "%s: no completion specification"
msgstr "%s: žádné doplňování neurčeno"

#: builtins/complete.def:703
msgid "warning: -F option may not work as you expect"
msgstr "varování: přepínač -F možná nebude dělat, co jste čekali"

#: builtins/complete.def:705
msgid "warning: -C option may not work as you expect"
msgstr "varování: přepínač -C možná nebude dělat, co jste čekali"

#: builtins/complete.def:872
msgid "not currently executing completion function"
msgstr "doplňovací funkce se právě nevykonává"

#: builtins/declare.def:139
msgid "can only be used in a function"
msgstr "může být použito jen ve funkci"

#: builtins/declare.def:471
msgid "cannot use `-f' to make functions"
msgstr "„-f“ nelze použít na výrobu funkce"

#: builtins/declare.def:499 execute_cmd.c:6320
#, c-format
msgid "%s: readonly function"
msgstr "%s: funkce jen pro čtení"

#: builtins/declare.def:556 builtins/declare.def:843
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: proměnná s odkazem nemůže být polem"

#: builtins/declare.def:567 variables.c:3346
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s: proměnná s odkazem na název nemůže odkazovat sama na sebe"

#: builtins/declare.def:572 variables.c:2035 variables.c:3343
#, c-format
msgid "%s: circular name reference"
msgstr "%s: kruhový odkaz na název"

#: builtins/declare.def:576 builtins/declare.def:850 builtins/declare.def:859
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "„%s“: neplatný název proměnné pro odkaz na název"

#: builtins/declare.def:908
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: takto nelze likvidovat pole"

#: builtins/declare.def:914
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: asociativní pole nelze převést na číslované pole"

#: builtins/declare.def:943
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s: přiřazení do složeného pole uzavřeného v uvozovkách je zastaralé"

#: builtins/enable.def:149 builtins/enable.def:157
msgid "dynamic loading not available"
msgstr "dynamické nahrávání není dostupné"

#: builtins/enable.def:389
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "sdílený objekt %s nelze otevřít: %s"

#: builtins/enable.def:408
#, c-format
msgid "%s: builtin names may not contain slashes"
msgstr "%s: názvy vestavěných příkazů nesmí obsahovat lomítka"

#: builtins/enable.def:423
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "ve sdílením objektu %2$s nelze nalézt %1$s: %3$s"

#: builtins/enable.def:440
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: vestavěné příkazy již dynamicky zavedeny"

#: builtins/enable.def:444
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "zaváděcí funkce pro %s vrací chybu (%d): nezavedeno"

#: builtins/enable.def:565
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: není dynamicky nahráno"

#: builtins/enable.def:591
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: nelze smazat: %s"

#: builtins/evalfile.c:137 builtins/hash.def:190 execute_cmd.c:6140
#, c-format
msgid "%s: is a directory"
msgstr "%s: je adresářem"

#: builtins/evalfile.c:143
#, c-format
msgid "%s: not a regular file"
msgstr "%s: není obyčejný soubor"

#: builtins/evalfile.c:152
#, c-format
msgid "%s: file is too large"
msgstr "%s: soubor je příliš velký"

#: builtins/evalfile.c:189 builtins/evalfile.c:207 execute_cmd.c:6222
#: shell.c:1687
msgid "cannot execute binary file"
msgstr "binární soubor nelze spustit"

#: builtins/evalstring.c:478
#, c-format
msgid "%s: ignoring function definition attempt"
msgstr "%s: pokus o definici funkce se ignoruje"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:249
msgid "cannot execute"
msgstr "nelze provést"

# XXX: Toto je zpráva interaktivního shellu při příkazu exit informující
# o odhlášení
#: builtins/exit.def:61
#, c-format
msgid "logout\n"
msgstr "odhlášení\n"

#: builtins/exit.def:85
msgid "not login shell: use `exit'"
msgstr "toto není login shell: použijte „exit“"

#: builtins/exit.def:116
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Jsou zde pozastavené úlohy.\n"

#: builtins/exit.def:118
#, c-format
msgid "There are running jobs.\n"
msgstr "Jsou zde běžící úlohy.\n"

#: builtins/fc.def:284 builtins/fc.def:391 builtins/fc.def:435
msgid "no command found"
msgstr "žádný příkaz nenalezen"

#: builtins/fc.def:381 builtins/fc.def:386 builtins/fc.def:425
#: builtins/fc.def:430
msgid "history specification"
msgstr "určení historie"

#: builtins/fc.def:462
msgid "cannot open temp file"
msgstr "dočasný soubor nelze otevřít"

#: builtins/fg_bg.def:150 builtins/jobs.def:293
msgid "current"
msgstr "současný"

#: builtins/fg_bg.def:159
#, c-format
msgid "job %d started without job control"
msgstr "úloha %d spuštěna bez správy úloh"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: chybný přepínač – %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: přepínač vyžaduje argument – %c\n"

#: builtins/hash.def:88
msgid "hashing disabled"
msgstr "hashování zakázáno"

#: builtins/hash.def:144
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: tabulka hashů je prázdná\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "zásahů\tpříkaz\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Příkazy shellu shodující se s klíčovým slovem „"
msgstr[1] "Příkazy shellu shodující se s klíčovými slovy „"
msgstr[2] "Příkazy shellu shodující se s klíčovými slovy „"

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"“\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid "no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr "žádné téma nápovědy se nehodí pro „%s“. Zkuste „help help“ nebo „man -k %s“ nebo „info %s“."

#: builtins/help.def:214
msgid "cannot open"
msgstr "nelze otevřít"

#: builtins/help.def:264 builtins/help.def:306 builtins/history.def:306
#: builtins/history.def:325 builtins/read.def:909
msgid "read error"
msgstr "chyba čtení"

#: builtins/help.def:517
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Tyto příkazy shellu jsou vnitřně definovány. Napište „help“, abyste získali\n"
"tento seznam. Podrobnosti o funkci „název“ získáte příkazem „help název“.\n"
"Příkazem „info bash“ získáte obecné informace o tomto shellu.\n"
"Použijte „man -k“ nebo „info“, chcete-li zjistit více o příkazech, které\n"
"na tomto seznamu nejsou.\n"
"\n"
"Hvězdička (*) vedle jména znamená, že příkaz je zakázán.\n"
"\n"

#: builtins/history.def:164
msgid "cannot use more than one of -anrw"
msgstr "nelze použít více jak jeden z -anrw"

#: builtins/history.def:197 builtins/history.def:209 builtins/history.def:220
#: builtins/history.def:245 builtins/history.def:252
msgid "history position"
msgstr "místo v historii"

#: builtins/history.def:280
msgid "empty filename"
msgstr "prázdný název souboru"

#: builtins/history.def:282 subst.c:8226
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: parametr null nebo nenastaven"

#: builtins/history.def:362
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: neplatný časový údaj"

#: builtins/history.def:470
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: expanze historie selhala"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "s „-x“ nejsou dovoleny další přepínače"

#: builtins/kill.def:214
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: argumenty musí být proces nebo identifikátor úlohy"

#: builtins/kill.def:280
msgid "Unknown error"
msgstr "Neznámá chyba"

#: builtins/let.def:96 builtins/let.def:120 expr.c:647 expr.c:665
msgid "expression expected"
msgstr "očekáván výraz"

#: builtins/mapfile.def:249 builtins/read.def:373
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: chybné určení deskriptoru souboru"

#: builtins/mapfile.def:257 builtins/read.def:380
msgid "invalid file descriptor"
msgstr "neplatný deskriptor souboru"

#: builtins/mapfile.def:266 builtins/mapfile.def:304
#, c-format
msgid "%s: invalid line count"
msgstr "%s: chybný počet řádků"

#: builtins/mapfile.def:277
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: chybný počátek pole"

#: builtins/mapfile.def:294
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: neplatné množství mezi voláními"

#: builtins/mapfile.def:327
msgid "empty array variable name"
msgstr "prázdný název proměnné typu pole"

#: builtins/mapfile.def:347
msgid "array variable support required"
msgstr "je vyžadována podpora proměnných typu pole"

#: builtins/printf.def:483
#, c-format
msgid "`%s': missing format character"
msgstr "„%s“: postrádám formátovací znak"

#: builtins/printf.def:609
#, c-format
msgid "`%c': invalid time format specification"
msgstr "„%c“: chybné určení časového limitu"

#: builtins/printf.def:711
msgid "string length"
msgstr "délka řetězce"

#: builtins/printf.def:811
#, c-format
msgid "`%c': invalid format character"
msgstr "„%c“: neplatný formátovací znak"

#: builtins/printf.def:928
#, c-format
msgid "format parsing problem: %s"
msgstr "potíže s rozebráním formátovacího řetězce: %s"

#: builtins/printf.def:1113
msgid "missing hex digit for \\x"
msgstr "u \\x chybí šestnáctková číslovka"

#: builtins/printf.def:1128
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "u \\%c chybí unikódová číslovka"

#: builtins/pushd.def:198
msgid "no other directory"
msgstr "žádný další adresář"

#: builtins/pushd.def:358 builtins/pushd.def:383
#, c-format
msgid "%s: invalid argument"
msgstr "%s: chybný argument"

#: builtins/pushd.def:501
msgid "<no current directory>"
msgstr "<žádný aktuální adresář>"

#: builtins/pushd.def:543
msgid "directory stack empty"
msgstr "prázdný zásobník adresářů"

#: builtins/pushd.def:545
msgid "directory stack index"
msgstr "pořadí v zásobníku adresářů"

#: builtins/pushd.def:708
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Zobrazí seznam právě zapamatovaných adresářů. Adresáře si najdou svoji\n"
"    cestu na seznam příkazem „pushd“ a procházet seznamem zpět lze příkazem\n"
"    „popd“.\n"
"    \n"
"    Přepínače:\n"
"      -c\tvyprázdní zásobník adresářů tím, že smaže všechny jeho prvky\n"
"      -l\tnevypisuje adresáře relativní vašemu domovskému adresáři pomocí\n"
"    \tvlnkové předpony\n"
"      -p\tvypíše zásobník adresářů stylem jedna položka na jeden řádek\n"
"      -v\tvypíše zásobník adresářů stylem jedna položka na jeden řádek\n"
"    \tuvozená svojí pozicí na zásobníku\n"
"    \n"
"    Argumenty:\n"
"      +N\tZobrazí N. položku počítáno zleva na seznamu, který zobrazuje\n"
"    \tdirs, když je vyvolán bez přepínačů, počínaje nulou.\n"
"    \n"
"      -N\tZobrazí N. položku počítáno zprava na seznamu, který zobrazuje\n"
"    \tdirs, když je vyvolán bez přepínačů, počínaje nulou."

#: builtins/pushd.def:730
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Přidá adresář na vrchol zásobníku adresářů nebo zásobník zrotuje tak,\n"
"    že nový vrchol zásobníku se stane současným pracovním adresářem. Bez\n"
"    argumentů prohodí dva vrchní adresáře.\n"
"    \n"
"    Přepínače:\n"
"      -n\tPotlačí obvyklou změnu adresáře, když se na zásobník přidávají\n"
"    \tadresáře, takže změněn bude pouze zásobník.\n"
"    \n"
"    Argumenty:\n"
"      +N\tZrotuje zásobník tak, že N. adresář (počítáno zleva na seznamu\n"
"    \tzobrazovaném pomocí „dirs“, počínaje nulou) se dostane na vrchol.\n"
"    \n"
"      -N\tZrotuje zásobník tak, že N. adresář (počítáno zprava na seznamu\n"
"    \tzobrazovaném pomocí „dirs“, počínaje nulou) se dostane na vrchol.\n"
"    \n"
"      ADRESÁŘ\n"
"    \tPřidá ADRESÁŘ na vrchol zásobníku adresářů a učiní jej novým\n"
"    \tsoučasným pracovním adresářem.\n"
"    \n"
"    Zásobník adresářů si můžete prohlédnout příkazem „dirs“."

#: builtins/pushd.def:755
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Odstraní položku ze zásobníku adresářů. Bez argumentů odstraní adresář\n"
"    z vrcholu zásobníku a přepne se do nového vrcholového adresáře.\n"
"    \n"
"    Přepínače:\n"
"      -n\tPotlačí obvyklou změnu adresáře, když se ze zásobníku odebírají\n"
"    \tadresáře, takže změněn bude pouze zásobník.\n"
"    \n"
"    Argumenty:\n"
"      +N\tOdstraní N. položku počítáno zleva na seznamu zobrazovaném pomocí\n"
"    \t„dirs“, počínaje nulou. Na příklad: „popd +0“ odstraní první\n"
"    \tadresář, „popd -1“ druhý.\n"
"    \n"
"      -N\tOdstraní N. položku počítáno zprava na seznamu zobrazovaném pomocí\n"
"    \t„dirs“, počínaje nulou. Na příklad: „popd -0“ odstraní poslední\n"
"    \tadresář, „popd -1“ další vedle posledního.\n"
"    \n"
"    Zásobník adresářů si můžete prohlédnout příkazem „dirs“."

#: builtins/read.def:346
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: chybné určení časového limitu"

#: builtins/return.def:73
msgid "can only `return' from a function or sourced script"
msgstr "„return“ lze provést jen z funkce nebo skriptu načteného přes „source“"

#: builtins/set.def:863
msgid "cannot simultaneously unset a function and a variable"
msgstr "funkci i proměnnou nelze rušit současně"

#: builtins/set.def:981
#, c-format
msgid "%s: not an array variable"
msgstr "%s: není (proměnnou typu) pole"

#: builtins/setattr.def:187
#, c-format
msgid "%s: not a function"
msgstr "%s: není funkcí"

#: builtins/setattr.def:192
#, c-format
msgid "%s: cannot export"
msgstr "%s: nelze exportovat"

#: builtins/shift.def:74 builtins/shift.def:86
msgid "shift count"
msgstr "počet shiftů"

#: builtins/shopt.def:332
msgid "cannot set and unset shell options simultaneously"
msgstr "přepínač shellu nelze zároveň nastavit a zrušit"

#: builtins/shopt.def:457
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: chybný název přepínače shellu"

#: builtins/source.def:143
msgid "filename argument required"
msgstr "vyžadován argument s názvem souboru"

#: builtins/source.def:179
#, c-format
msgid "%s: file not found"
msgstr "%s: soubor nenalezen"

#: builtins/suspend.def:105
msgid "cannot suspend"
msgstr "nelze pozastavit"

#: builtins/suspend.def:111
msgid "cannot suspend a login shell"
msgstr "login shell nelze pozastavit"

#: builtins/test.def:146 test.c:926
msgid "missing `]'"
msgstr "postrádám „]“"

#: builtins/type.def:231
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s je alias na „%s“\n"

#: builtins/type.def:252
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s je klíčové slovo shellu\n"

#: builtins/type.def:270 builtins/type.def:314
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s je zvláštní součást shellu\n"

#: builtins/type.def:289
#, c-format
msgid "%s is a function\n"
msgstr "%s je funkce\n"

#: builtins/type.def:316
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s je součást shellu\n"

#: builtins/type.def:338 builtins/type.def:425
#, c-format
msgid "%s is %s\n"
msgstr "%s je %s\n"

#: builtins/type.def:358
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s je zahashován (%s)\n"

#: builtins/ulimit.def:403
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: chybný argument s limitou"

#: builtins/ulimit.def:429
#, c-format
msgid "`%c': bad command"
msgstr "„%c“: chybný příkaz"

#: builtins/ulimit.def:465 builtins/ulimit.def:748
msgid "cannot get limit"
msgstr "limit nelze zjistit"

#: builtins/ulimit.def:498
msgid "limit"
msgstr "limit"

#: builtins/ulimit.def:511 builtins/ulimit.def:812
msgid "cannot modify limit"
msgstr "limit nelze změnit"

#: builtins/umask.def:114
msgid "octal number"
msgstr "osmičkové číslo"

#: builtins/umask.def:256
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "„%c“: chybný operátor symbolických práv"

#: builtins/umask.def:345
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "„%c“: chybný znak symbolický práv "

#: error.c:83 error.c:311 error.c:313 error.c:315
msgid " line "
msgstr " řádek "

#: error.c:151
#, c-format
msgid "last command: %s\n"
msgstr "poslední příkaz: %s\n"

#: error.c:159
#, c-format
msgid "Aborting..."
msgstr "Ukončuji…"

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:244
#, c-format
msgid "INFORM: "
msgstr "INFORMACE: "

#: error.c:261
#, c-format
msgid "DEBUG warning: "
msgstr "LADICÍ upozornění: "

#: error.c:413
msgid "unknown command error"
msgstr "chyba neznámého příkazu"

#: error.c:414
msgid "bad command type"
msgstr "chybný druh příkazu"

#: error.c:415
msgid "bad connector"
msgstr "chybný konektor"

#: error.c:416
msgid "bad jump"
msgstr "chybný skok"

#: error.c:449
#, c-format
msgid "%s: unbound variable"
msgstr "%s: nevázaná proměnná"

#: eval.c:260
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\ačasový limit pro čekání na vstup vypršel: automatické odhlášení\n"

#: execute_cmd.c:606
msgid "cannot redirect standard input from /dev/null"
msgstr "standardní vstup nelze přesměrovat z /dev/null"

#: execute_cmd.c:1412
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: „%c“: chybný formátovací znak"

#: execute_cmd.c:2493
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr "execute_coproc: koproces [%d:%s] stále existuje"

#: execute_cmd.c:2647
msgid "pipe error"
msgstr "chyba v rouře"

#: execute_cmd.c:4100
#, c-format
msgid "invalid regular expression `%s': %s"
msgstr "neplatný regulární výraz „%s“: %s"

#: execute_cmd.c:4102
#, c-format
msgid "invalid regular expression `%s'"
msgstr "neplatný regulární výraz „%s“"

#: execute_cmd.c:5056
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: maximální úroveň zanoření funkce eval byla překročena (%d)"

#: execute_cmd.c:5069
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: maximální úroveň zanoření funkce source byla překročena (%d)"

#: execute_cmd.c:5198
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: maximální úroveň zanoření funkcí byla překročena (%d)"

#: execute_cmd.c:5754
msgid "command not found"
msgstr "příkaz nenalezen"

#: execute_cmd.c:5783
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: omezeno: v názvu příkazu nesmí být „/“"

#: execute_cmd.c:6176
msgid "bad interpreter"
msgstr "chybný interpretr"

#: execute_cmd.c:6185
#, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: nelze spustit: požadovaný soubor neexistuje"

#: execute_cmd.c:6361
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "deskriptor souboru %d nelze duplikovat na deskriptor %d"

#: expr.c:272
msgid "expression recursion level exceeded"
msgstr "úroveň rekurze výrazu byla překročena"

#: expr.c:300
msgid "recursion stack underflow"
msgstr "zásobník rekurze podtekl"

#: expr.c:485
msgid "arithmetic syntax error in expression"
msgstr "aritmetická syntaktická chyba ve výrazu"

#: expr.c:529
msgid "attempted assignment to non-variable"
msgstr "pokus o přiřazení do ne-proměnné"

#: expr.c:538
msgid "arithmetic syntax error in variable assignment"
msgstr "aritmetická syntaktická chyba v přiřazení do proměnné"

#: expr.c:552 expr.c:917
msgid "division by 0"
msgstr "dělení nulou"

#: expr.c:600
msgid "bug: bad expassign token"
msgstr "chyba: chybný expassing token"

#: expr.c:654
msgid "`:' expected for conditional expression"
msgstr "v podmíněném výrazu očekávána „:“"

#: expr.c:979
msgid "exponent less than 0"
msgstr "mocnitel menší než 0"

#: expr.c:1040
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "po přednostním zvýšení nebo snížení očekáván identifikátor"

#: expr.c:1067
msgid "missing `)'"
msgstr "postrádám „)“"

#: expr.c:1120 expr.c:1507
msgid "arithmetic syntax error: operand expected"
msgstr "aritmetická syntaktická chyba: očekáván operand"

#: expr.c:1468 expr.c:1489
msgid "--: assignment requires lvalue"
msgstr "--: přiřazení vyžaduje objekt, do kterého lze uložit hodnotu (l-value)"

#: expr.c:1470 expr.c:1491
msgid "++: assignment requires lvalue"
msgstr "++: přiřazení vyžaduje objekt, do kterého lze uložit hodnotu (l-value)"

#: expr.c:1509
msgid "arithmetic syntax error: invalid arithmetic operator"
msgstr "aritmetická syntaktická chyba: chybný aritmetický operátor"

#: expr.c:1532
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (chybný token je „%s“)"

#: expr.c:1595
msgid "invalid arithmetic base"
msgstr "chybný aritmetický základ"

#: expr.c:1604
msgid "invalid integer constant"
msgstr "chybná celočíselná konstanta"

#: expr.c:1620
msgid "value too great for base"
msgstr "hodnot je pro základ příliš velká"

#: expr.c:1671
#, c-format
msgid "%s: expression error\n"
msgstr "%s: chyba výrazu\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: rodičovské adresáře nejsou přístupné"

#: general.c:459
#, c-format
msgid "`%s': is a special builtin"
msgstr "„%s“: je zvláštní vestavěný příkaz shellu"

#: input.c:98 subst.c:6542
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "na deskriptoru %d nelze resetovat režim nodelay"

#: input.c:254
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "nový deskriptor souboru pro vstup bashe z deskr. %d nelze alokovat"

#: input.c:262
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: buffer již pro nový deskriptor %d existuje"

#: jobs.c:549
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pgrp roury"

#: jobs.c:910
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_delete: SMYČKA: psi (%d) == storage[psi].bucket_next"

#: jobs.c:962
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_search: SMYČKA: psi (%d) == storage[psi].bucket_next"

#: jobs.c:1380
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "forknutý PID %d se objevil v běžící úloze %d"

#: jobs.c:1496
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "mažu pozastavenou úlohu %d se skupinou procesů %ld"

#: jobs.c:1620
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: PID %5ld (%s) označen za stále živého"

#: jobs.c:1949
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: žádný takový PID"

#: jobs.c:1963
#, c-format
msgid "Signal %d"
msgstr "Signál %d"

# XXX: (úloha) dokončna. Používat ženský rod i unásledujících. Jedná se
# o výpis úloh.
#: jobs.c:1974 jobs.c:2000
msgid "Done"
msgstr "Dokončena"

#: jobs.c:1979 siglist.c:123
msgid "Stopped"
msgstr "Pozastavena"

#: jobs.c:1983
#, c-format
msgid "Stopped(%s)"
msgstr "Pozastavena (%s)"

#: jobs.c:1987
msgid "Running"
msgstr "Běží"

#: jobs.c:2004
#, c-format
msgid "Done(%d)"
msgstr "Dokončena (%d)"

#: jobs.c:2006
#, c-format
msgid "Exit %d"
msgstr "Ukončena %d"

#: jobs.c:2009
msgid "Unknown status"
msgstr "Stav neznámý"

#: jobs.c:2105
#, c-format
msgid "(core dumped) "
msgstr "(core dumped [obraz paměti uložen]) "

#: jobs.c:2124
#, c-format
msgid "  (wd: %s)"
msgstr "  (cwd: %s)"

#: jobs.c:2391
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "setpgid na potomku (z %ld na %ld)"

#: jobs.c:2754 nojobs.c:640
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: PID %ld není potomkem tohoto shellu"

#: jobs.c:3052
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: Žádný záznam o procesu %ld"

#: jobs.c:3410
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: úloha %d je pozastavena"

#: jobs.c:3838
#, c-format
msgid "%s: no current jobs"
msgstr "%s: žádné současné úlohy"

#: jobs.c:3845
#, c-format
msgid "%s: job has terminated"
msgstr "%s: úloha skončila"

#: jobs.c:3854
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: úloha %d je již na pozadí"

#: jobs.c:4092
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld: zapíná se WNOHANG, aby se zabránilo neurčitému zablokování"

#: jobs.c:4641
#, c-format
msgid "%s: line %d: "
msgstr "%s: řádek %d: "

#: jobs.c:4657 nojobs.c:895
#, c-format
msgid " (core dumped)"
msgstr " (core dumped [obraz paměti uložen])"

#: jobs.c:4677 jobs.c:4697
#, c-format
msgid "(wd now: %s)\n"
msgstr "(cwd nyní: %s)\n"

#: jobs.c:4741
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp selhalo"

#: jobs.c:4797
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: správa úloh nefunguje na pozadí"

#: jobs.c:4813
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: disciplína linky"

#: jobs.c:4823
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:4844 jobs.c:4853
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "nelze nastavit skupinu procesů terminálu (%d)"

#: jobs.c:4858
msgid "no job control in this shell"
msgstr "žádná správa úloh v tomto shellu"

#: lib/malloc/malloc.c:364
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: předpoklad nesplněn: %s\n"

#: lib/malloc/malloc.c:375
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: zbabraný předpoklad\r\n"

#: lib/malloc/malloc.c:376 lib/malloc/malloc.c:925
msgid "unknown"
msgstr "není známo"

#: lib/malloc/malloc.c:876
msgid "malloc: block on free list clobbered"
msgstr "malloc: blok v seznamu uvolněných zbit"

#: lib/malloc/malloc.c:961
msgid "free: called with already freed block argument"
msgstr "free: zavoláno s argumentem již uvolněného bloku"

#: lib/malloc/malloc.c:964
msgid "free: called with unallocated block argument"
msgstr "free: zavoláno s argumentem nenaalokovaného bloku"

#: lib/malloc/malloc.c:982
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: zjištěno podtečení, mh_nbytes mimo rozsah"

#: lib/malloc/malloc.c:988
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: zjištěno podtečení, magic8 poškozeno"

#: lib/malloc/malloc.c:995
msgid "free: start and end chunk sizes differ"
msgstr "free: velikosti počátečního a koncového kusu se liší"

#: lib/malloc/malloc.c:1155
msgid "realloc: called with unallocated block argument"
msgstr "realloc: zavoláno s argumentem nenaalokovaného bloku"

#: lib/malloc/malloc.c:1170
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: zjištěno podtečení, mh_nbytes mimo rozsah"

#: lib/malloc/malloc.c:1176
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: zjištěno podtečení, magic8 poškozeno"

#: lib/malloc/malloc.c:1184
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: velikosti počátečního a koncového kusu se liší"

#: lib/malloc/table.c:179
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: tabulka alokací je plná FIND_ALLOC?\n"

#: lib/malloc/table.c:188
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p již obsažen v tabulce jako alokovaný?\n"

#: lib/malloc/table.c:237
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p již obsažen v tabulce jako volný?\n"

#: lib/sh/fmtulong.c:90
msgid "invalid base"
msgstr "chybný základ"

#: lib/sh/netopen.c:161
#, c-format
msgid "%s: host unknown"
msgstr "%s: stroj není znám"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: invalid service"
msgstr "%s: chybná služba"

#: lib/sh/netopen.c:294
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: chybné určení síťové cesty"

#: lib/sh/netopen.c:332
msgid "network operations not supported"
msgstr "síťové operace nejsou podporovány"

#: locale.c:226 locale.c:228 locale.c:301 locale.c:303
msgid "cannot change locale"
msgstr "národní prostředí nelze změnit"

#: mailcheck.c:435
msgid "You have mail in $_"
msgstr "V $_ máte poštu"

#: mailcheck.c:460
msgid "You have new mail in $_"
msgstr "V $_ máte novou poštu"

#: mailcheck.c:476
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Pošta v %s je přečtená\n"

#: make_cmd.c:286
msgid "syntax error: arithmetic expression required"
msgstr "chyba syntaxe: vyžadován aritmetický výraz"

#: make_cmd.c:288
msgid "syntax error: `;' unexpected"
msgstr "chyba syntaxe: neočekávaný „;“"

#: make_cmd.c:289
#, c-format
msgid "syntax error: `((%s))'"
msgstr "chyba syntaxe: „((%s))“"

#: make_cmd.c:523
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: chybný druh instrukce %d"

#: make_cmd.c:627
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "„here“ dokument na řádku %d ukončen koncem souboru (požadováno „%s“)"

#: make_cmd.c:722
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: instrukce přesměrování „%d“ mimo rozsah"

#: parse.y:2572
#, c-format
msgid "shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line truncated"
msgstr "shell_getc: shell_input_line_size (%zu) přesahuje SIZE_MAX (%lu): řádek zkrácen"

#: parse.y:2864
msgid "script file read error"
msgstr "chyba při čtení ze souboru skriptu"

#: parse.y:3101
msgid "maximum here-document count exceeded"
msgstr "maximální počet here dokumentů překročen"

#: parse.y:3901 parse.y:4799 parse.y:6859
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "neočekávaný konec souboru při hledání znaku odpovídajícímu „%c“"

#: parse.y:5006
msgid "unexpected EOF while looking for `]]'"
msgstr "neočekávaný konec souboru při hledání „]]“"

# XXX: Condional means condition (adj.) probably. Can English distinguish
# between the condition (podmínkový) and the code branch (podmíněný)? Check
# for all "conditional" string occurences.
#: parse.y:5011
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "chyba syntaxe ve výrazu podmínky: neočekávaný token „%s“"

#: parse.y:5015
msgid "syntax error in conditional expression"
msgstr "chyba syntaxe ve výrazu podmínky"

#: parse.y:5093
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "neočekávaný token „%s“, očekávána „)“"

#: parse.y:5097
msgid "expected `)'"
msgstr "očekávána „)“"

#: parse.y:5127
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "neočekávaný argument „%s“ u podmínkového unárního operátoru"

#: parse.y:5131
msgid "unexpected argument to conditional unary operator"
msgstr "neočekávaný argument u podmínkového unárního operátoru"

#: parse.y:5178
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "neočekávaný token „%s“, očekáván podmínkový binární operátor"

#: parse.y:5182
msgid "conditional binary operator expected"
msgstr "očekáván podmínkový binární operátor"

#: parse.y:5211
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "neočekávaný argument „%s„ u podmínkového binárního operátoru"

#: parse.y:5215
msgid "unexpected argument to conditional binary operator"
msgstr "neočekávaný argument u podmínkového binárního operátoru"

#: parse.y:5226
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "neočekávaný token „%c“ v podmínkovém příkazu"

#: parse.y:5229
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "neočekávaný token „%s“ v podmínkovém příkazu"

#: parse.y:5233
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "neočekávaný token %d v podmínkovém příkazu"

#: parse.y:6827
#, c-format
msgid "syntax error near unexpected token `%s' while looking for matching `%c'"
msgstr "syntaktická chyba poblíž neočekávaného tokenu „%s“ při hledání znaku odpovídajícímu „%c“"

#: parse.y:6829
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "chyba syntaxe poblíž neočekávaného tokenu „%s“"

#: parse.y:6848
#, c-format
msgid "syntax error near `%s'"
msgstr "chyba syntaxe poblíž „%s“"

#: parse.y:6867
#, c-format
msgid "syntax error: unexpected end of file from `%s' command on line %d"
msgstr "chyba syntaxe: nenadálý konec souboru v příkazu „%s“ na řádu %d"

#: parse.y:6869
#, c-format
msgid "syntax error: unexpected end of file from command on line %d"
msgstr "chyba syntaxe: nenadálý konec souboru v příkazu na řádku %d"

#: parse.y:6873
msgid "syntax error: unexpected end of file"
msgstr "chyba syntaxe: nenadálý konec souboru"

#: parse.y:6873
msgid "syntax error"
msgstr "chyba syntaxe"

#: parse.y:6922
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Shell lze ukončit příkazem „%s“.\n"

#: parse.y:7120
msgid "unexpected EOF while looking for matching `)'"
msgstr "nenadálý konec souboru při hledání odpovídající „)“"

#: pathexp.c:897
msgid "invalid glob sort type"
msgstr "chybný druh řazení globů"

#: pcomplete.c:1070
#, c-format
msgid "completion: function `%s' not found"
msgstr "doplňování: funkce „%s“ nenalezena"

#: pcomplete.c:1654
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr "programmable_completion: %s: možná smyčka opakování"

#: pcomplib.c:176
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: NULLOVÝ COMPSPEC"

#: print_cmd.c:324
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: chybná propojka „%d“"

#: print_cmd.c:399
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: neplatný deskriptor souboru"

#: print_cmd.c:404
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: nullový ukazatel na soubor"

# fd, fp a fileno jsou identifikátory v kódu
#: print_cmd.c:408
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace: fd (%d) != fileno fp (%d)"

#: print_cmd.c:1597
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: „%c“: chybný formátovací znak"

#: redir.c:146 redir.c:194
msgid "file descriptor out of range"
msgstr "deskriptor souboru mimo rozsah"

#: redir.c:201
msgid "ambiguous redirect"
msgstr "nejednoznačné přesměrování"

#: redir.c:205
msgid "cannot overwrite existing file"
msgstr "existující soubor nelze přepsat"

#: redir.c:210
msgid "restricted: cannot redirect output"
msgstr "omezeno: výstup nelze přesměrovat"

#: redir.c:215
msgid "cannot create temp file for here-document"
msgstr "pro „here“ dokument nelze vytvořit dočasný soubor"

#: redir.c:219
msgid "cannot assign fd to variable"
msgstr "deskriptor souboru nelze přiřadit do proměnné"

#: redir.c:639
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "/dev/(tcp|udp)/host/port není bez síťování podporováno"

#: redir.c:945 redir.c:1062 redir.c:1124 redir.c:1291
msgid "redirection error: cannot duplicate fd"
msgstr "chyba přesměrování: deskriptor souboru nelze duplikovat"

#: shell.c:359
msgid "could not find /tmp, please create!"
msgstr "nelze nalézt /tmp, vytvořte jej, prosím!"

#: shell.c:363
msgid "/tmp must be a valid directory name"
msgstr "/tmp musí být platným názvem pro adresář"

#: shell.c:827
msgid "pretty-printing mode ignored in interactive shells"
msgstr "v interaktivních shellech se režim krásného výpisu nepoužije"

#: shell.c:969
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: chybný přepínač"

#: shell.c:1354
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "UID nelze nastavit na %d: efektivní UID je %d"

#: shell.c:1370
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "GID nelze nastavit na %d: efektivní GID je %d"

#: shell.c:1559
msgid "cannot start debugger; debugging mode disabled"
msgstr "debuger nelze spustit, ladicí režim zakázán"

#: shell.c:1672
#, c-format
msgid "%s: Is a directory"
msgstr "%s: Je adresářem"

#: shell.c:1748 shell.c:1750
msgid "error creating buffered stream"
msgstr "chyba při vytváření proudu s vyrovnávací pamětí"

#: shell.c:1899
msgid "I have no name!"
msgstr "Nemám žádné jméno!"

#: shell.c:2063
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, verze %s-(%s)\n"

#: shell.c:2064
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Použití:\t%s [Dlouhý GNU přepínač] [přepínač]…\n"
"\t%s [Dlouhý GNU přepínač] [přepínač] skriptový_soubor…\n"

#: shell.c:2066
msgid "GNU long options:\n"
msgstr "Dlouhé GNU přepínače:\n"

#: shell.c:2070
msgid "Shell options:\n"
msgstr "Přepínače shellu:\n"

#: shell.c:2071
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-ilrsD nebo -c příkaz nebo -O shopt_přepínač\t(pouze při vyvolání)\n"

#: shell.c:2090
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s nebo -o přepínač\n"

#: shell.c:2096
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "Podrobnosti o přepínačích shellu získáte tím, že napíšete „%s -c \"help set\"“.\n"

#: shell.c:2097
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr ""
"Podrobnosti o příkazech vestavěných do shellu získáte tím, že\n"
"napište „%s -c help“.\n"

#: shell.c:2098
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Chyby nahlásíte příkazem „bashbug“.\n"

#: shell.c:2100
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "Domovská stránka bashe: <http://www.gnu.org/software/bash>\n"

#: shell.c:2101
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Obecný návod na použití softwaru GNU: <http://www.gnu.org/gethelp/>\n"

#: sig.c:809
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: neplatná operace"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Falešný signál"

# Překlady názvů signálů převzaty (s mírnými úpravami) z české překladu
# manuálové stránky signal(7). 
#: siglist.c:51
msgid "Hangup"
msgstr "Linka terminálu zavěšena"

#: siglist.c:55
msgid "Interrupt"
msgstr "Přerušení"

#: siglist.c:59
msgid "Quit"
msgstr "Ukončení"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Neplatná instrukce"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "Přerušení při ladění"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Ukončení funkcí abort()"

#: siglist.c:79
msgid "EMT instruction"
msgstr "Instrukce EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Výjimka při práci s pohyblivou řádovou čárkou"

#: siglist.c:87
msgid "Killed"
msgstr "Zabit"

#: siglist.c:91
msgid "Bus error"
msgstr "Chyba sběrnice"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Chyba segmentace"

#: siglist.c:99
msgid "Bad system call"
msgstr "Špatné volání systému"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Z roury nikdo nečte"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Signál časovače"

#: siglist.c:111
msgid "Terminated"
msgstr "Ukončit"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Čekají urgentní I/O data"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Pozastaveno (signálem)"

#: siglist.c:127
msgid "Continue"
msgstr "Pokračovat"

#: siglist.c:135
msgid "Child death or stop"
msgstr "Potomek byl pozastaven nebo zemřel"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Pozastaveno (vstupem TTY)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Pozastaveno (výstupem na TTY)"

#: siglist.c:147
msgid "I/O ready"
msgstr "I/O je připraveno"

#: siglist.c:151
msgid "CPU limit"
msgstr "Dosažen limit procesorového času"

#: siglist.c:155
msgid "File limit"
msgstr "Dosažen limit velikosti souboru"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Časovač (virtuální)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Časovač (profilovací)"

#: siglist.c:167
msgid "Window changed"
msgstr "Změna okna"

# XXX: SIGLOST
#: siglist.c:171
msgid "Record lock"
msgstr "Zámek záznamu"

#: siglist.c:175
msgid "User signal 1"
msgstr "Uživatelský signal 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Uživatelský signál 2"

# FIXME: HFT znamená High Frequency Timer? Zkontrolovat i další výskyty
#: siglist.c:183
msgid "HFT input data pending"
msgstr "vstupní data HFT čekají"

#: siglist.c:187
msgid "power failure imminent"
msgstr "hrozí selhání napájení"

#: siglist.c:191
msgid "system crash imminent"
msgstr "hrozí selhání systému"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "přesunout proces na jiný procesor"

#: siglist.c:199
msgid "programming error"
msgstr "chyba programování"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "Režim HFT sledování přidělen"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "Režim HFT sledování odebrán"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "HFT zvuková posloupnost byla dokončena"

#: siglist.c:215
msgid "Information request"
msgstr "Požadavek o informaci"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Neznámý signál č. %d"

#: subst.c:1503 subst.c:1795 subst.c:2001
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "chybná substituce: v %2$s chybí uzavírací „%1$s“"

#: subst.c:3601
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: seznam nelze přiřadit do prvku pole"

#: subst.c:6381 subst.c:6397
msgid "cannot make pipe for process substitution"
msgstr "nelze vyrobit rouru za účelem substituce procesu"

#: subst.c:6457
msgid "cannot make child for process substitution"
msgstr "nelze vytvořit potomka za účelem substituce procesu"

#: subst.c:6532
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "pojmenovanou rouru %s nelze otevřít pro čtení"

#: subst.c:6534
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "pojmenovanou rouru %s nelze otevřít pro zápis"

#: subst.c:6557
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "pojmenovanou rouru %s nelze zdvojit jako deskriptor %d"

#: subst.c:6723
msgid "command substitution: ignored null byte in input"
msgstr "substituce příkazu: nulový bajt ve vstupu ignorován"

#: subst.c:6962
msgid "function_substitute: cannot open anonymous file for output"
msgstr "function_substitute: anonymní soubor nelze otevřít pro výstup"

#: subst.c:7036
msgid "function_substitute: cannot duplicate anonymous file as standard output"
msgstr "function_substitute: anonymní soubor nelze zdvojit jako standardní výstup"

#: subst.c:7210 subst.c:7231
msgid "cannot make pipe for command substitution"
msgstr "nelze vytvořit rouru pro substituci příkazu"

#: subst.c:7282
msgid "cannot make child for command substitution"
msgstr "nelze vytvořit potomka pro substituci příkazu"

#: subst.c:7315
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: rouru nelze zdvojit jako deskriptor 1"

#: subst.c:7813 subst.c:10989
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: neplatný název proměnné pro odkaz na název"

#: subst.c:7906 subst.c:7924 subst.c:8100
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: chybná nepřímá expanze"

#: subst.c:7940 subst.c:8108
#, c-format
msgid "%s: invalid variable name"
msgstr "%s: chybný název proměnné"

#: subst.c:8125 subst.c:10271 subst.c:10298
#, c-format
msgid "%s: bad substitution"
msgstr "%s: chybná substituce"

#: subst.c:8224
#, c-format
msgid "%s: parameter not set"
msgstr "%s: parametr nenastaven"

#: subst.c:8480 subst.c:8495
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: výraz podřetězce < 0"

#: subst.c:10397
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: takto nelze přiřazovat"

#: subst.c:10855
msgid "future versions of the shell will force evaluation as an arithmetic substitution"
msgstr "budoucá verze tohoto shellu budou vynucovat vyhodnocení jako aritmetickou substituci"

#: subst.c:11563
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "chybná substituce: v %s chybí uzavírací „`“"

#: subst.c:12636
#, c-format
msgid "no match: %s"
msgstr "žádná shoda: %s"

#: test.c:156
msgid "argument expected"
msgstr "očekáván argument"

#: test.c:164
#, c-format
msgid "%s: integer expected"
msgstr "%s: očekáváno celé číslo"

#: test.c:292
msgid "`)' expected"
msgstr "očekávána „)“"

#: test.c:294
#, c-format
msgid "`)' expected, found %s"
msgstr "očekávána „)“, nalezeno %s"

#: test.c:488 test.c:831
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: očekáván binární operátor"

#: test.c:792 test.c:795
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: očekáván unární operátor"

#: test.c:944
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "chyba syntaxe: neočekávaný řetězec „%s“"

#: trap.c:225
msgid "invalid signal number"
msgstr "neplatné číslo signálu"

#: trap.c:358
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "obsluha signálů: maximální úroveň zanoření obsluhy signálů byla překročena (%d)"

#: trap.c:455
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: chybná hodnota v trap_list[%d]: %p"

#: trap.c:459
#, c-format
msgid "run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr "run_pending_traps: obsluha signálu je SIG_DFL, přeposílám %d (%s) sobě"

#: trap.c:592
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: chybný signál %d"

#: unwind_prot.c:246 unwind_prot.c:292
msgid "frame not found"
msgstr "rámec nenalezen"

#: variables.c:441
#, c-format
msgid "error importing function definition for `%s'"
msgstr "chyba při importu definice „%s“"

#: variables.c:864
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "úroveň shellu (%d) příliš vysoká, resetuji na 1"

#: variables.c:2191 variables.c:2220 variables.c:2278 variables.c:2297
#: variables.c:2315 variables.c:2350 variables.c:2378 variables.c:2405
#: variables.c:2431 variables.c:3274 variables.c:3282 variables.c:3797
#: variables.c:3841
#, c-format
msgid "%s: maximum nameref depth (%d) exceeded"
msgstr "%s: maximální hloubka odkazů na názvy (nameref) (%d) překročena"

#: variables.c:2641
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: žádný kontext funkce v aktuálním rozsahu"

#: variables.c:2660
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: hodnotu nelze do proměnné přiřadit"

#: variables.c:2831 variables.c:2884
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr "%s: z nekompatibilního typu nelze hodnotu zdědit"

#: variables.c:3437
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: přiřazení čísla odkazu na název"

#: variables.c:4387
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: žádný kontext funkce v aktuálním rozsahu"

#: variables.c:4816
#, c-format
msgid "%s has null exportstr"
msgstr "%s: má nullový exportstr"

#: variables.c:4821 variables.c:4830
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "neplatný znak %d v exportstr pro %s"

#: variables.c:4836
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "v exportstr pro %s chybí „=“"

#: variables.c:5354
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: hlava shell_variables není kontextem funkce"

#: variables.c:5367
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: chybí kontext global_variables"

#: variables.c:5457
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: hlava shell_variables není dočasným rozsahem prostředí"

#: variables.c:6448
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: nelze otevřít jako SOUBOR"

#: variables.c:6453
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: neplatná hodnota pro deskriptor trasovacího souboru"

#: variables.c:6497
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: hodnota kompatibility je mimo rozsah"

#: version.c:50
msgid "Copyright (C) 2025 Free Software Foundation, Inc."
msgstr "Copyright © 2025 Free Software Foundation, Inc."

#: version.c:51
msgid "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
msgstr "Licence GPLv3+: GNU GPL verze 3 nebo novější <http://gnu.org/licenses/gpl.html>\n"

#: version.c:90
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, verze %s (%s)\n"

#: version.c:95
msgid "This is free software; you are free to change and redistribute it."
msgstr "Toto je svobodné programové vybavení: máte právo jej měnit a šířit."

#: version.c:96
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "VEŠKERÉ ZÁRUKY chybí, jak jen zákon dovoluje."

#: xmalloc.c:84
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: nelze alokovat %'lu bajtů (alokováno %'lu bajtů)"

#: xmalloc.c:86
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: nelze alokovat %'lu bajtů"

#: xmalloc.c:164
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: nelze alokovat %'lu bajtů (alokováno %'lu bajtů)"

#: xmalloc.c:166
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: nelze alokovat %'lu bajtů"

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [název[=hodnota] …]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] název [název…]"

#: builtins.c:53
msgid "bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr "bind [-lpsvPSVX] [-m klávmapa] [-f soubor] [-q název] [-u název] [-r klávposl] [-x klávposl:příkaz-shellu] [klávposl:readline-funkce nebo readline-příkaz]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [vestavěný-příkaz-shellu [argument…]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [výraz]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]]] [-@] [dir]"
msgstr "cd [-L|[-P [-e]]] [-@] [adresář]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] příkaz [argument…]"

#: builtins.c:78
msgid "declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] [name ...]"
msgstr "declare [-aAfFgiIlnrtux] [název[=hodnota]…] nebo declare [-p] [-aAfFilnrtux] [název…]"

#: builtins.c:80
msgid "typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] [name ...]"
msgstr "typeset [-aAfFgiIlnrtux] název[=hodnota]… nebo typeset -p [-aAfFilnrtux] [název…]"

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [přepínač] název[=hodnota]…"

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [argument…]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [argument…]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f soubor] [název…]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [argument…]"

#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts řetězec_přepínačů název [argument…]"

#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a název] [příkaz [argument…]] [přesměrování…]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e enázev] [-lnr] [první] [poslední] nebo fc -s [vzor=náhrada] [příkaz]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [úloha]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [úloha…]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p název_cesty] [-dt] [název…]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [vzorek…]"

#: builtins.c:123
msgid "history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]"
msgstr "history [-c] [-d pozice] [n] nebo history -anrw [jméno_souboru] nebo history -ps argument [argument…]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [úloha…] nebo jobs -x příkaz [argumenty]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [úloha… | PID…]"

#: builtins.c:134
msgid "kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]"
msgstr "kill [-s sigspec | -n číssig | -sigspec] pid | úloha… nebo kill -l [sigspec]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let argument [argument…]"

#: builtins.c:138
msgid "read [-Eers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]"
msgstr "read [-Eers] [-a pole] [-d oddělovač] [-i text] [-n p_znaků] [-N p_znaků] [-p výzva] [-t limit] [-u fd] [jméno…]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCEHPT] [-o název_přepínače] [--] [-] [argument…]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [jméno…]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p [-f]"
msgstr "export [-fn] [název[=hodnota]…] nebo export -p [-f]"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [název[=hodnota]…] nebo readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source [-p path] filename [arguments]"
msgstr "source [-p cesta] název_souboru [argumenty]"

#: builtins.c:154
msgid ". [-p path] filename [arguments]"
msgstr ". [-p cesta] název_souboru [argumenty]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [výraz]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ argument… ]"

#: builtins.c:166
msgid "trap [-Plp] [[action] signal_spec ...]"
msgstr "trap [-Plp] [[akce] signal_spec…]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] název [název…]"

#: builtins.c:171
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [mód]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p proměnná] [id…]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [pid…]"

#: builtins.c:184
msgid "! PIPELINE"
msgstr "! KOLONA"

#: builtins.c:186
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NÁZEV [in SLOVECH…] ; do PŘÍKAZY; done"

#: builtins.c:188
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( výr1; výr2; výr3 )); do PŘÍKAZY; done"

#: builtins.c:190
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NÁZEV [in SLOVA…;] do PŘÍKAZY; done"

#: builtins.c:192
msgid "time [-p] pipeline"
msgstr "time [-p] kolona"

#: builtins.c:194
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case SLOVO in [VZOR [| VZOR]…) PŘÍKAZY ;;]… esac"

#: builtins.c:196
msgid "if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi"
msgstr "if PŘÍKAZY; then PŘÍKAZY; [ elif PŘÍKAZY; then PŘÍKAZY; ]… [ else PŘÍKAZY; ] fi"

#: builtins.c:198
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while PŘÍKAZY; do PŘÍKAZY-2; done"

#: builtins.c:200
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until PŘÍKAZY; do PŘÍKAZY-2; done"

#: builtins.c:202
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [NÁZEV] příkaz [přesměrování]"

#: builtins.c:204
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function jméno { PŘÍKAZY ; } nebo jméno () { PŘÍKAZY ; }"

#: builtins.c:206
msgid "{ COMMANDS ; }"
msgstr "{ PŘÍKAZY ; }"

#: builtins.c:208
msgid "job_spec [&]"
msgstr "úloha [&]"

#: builtins.c:210
msgid "(( expression ))"
msgstr "(( výraz ))"

#: builtins.c:212
msgid "[[ expression ]]"
msgstr "[[ výraz ]]"

# XXX: "variable" je literál na seznamy vestavěných příkazů
#: builtins.c:214
msgid "variables - Names and meanings of some shell variables"
msgstr "variables – názvy a významy některých proměnných shellu"

#: builtins.c:217
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | adresář]"

#: builtins.c:221
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:225
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:228
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [název_volby…]"

#: builtins.c:230
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v proměnná] formát [argumenty]"

#: builtins.c:233
msgid "complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]"
msgstr "complete [-abcdefgjksuv] [-pr] [-DEI] [-o přepínač] [-A akce] [-G globvzor] [-W seznam_slov] [-F funkce] [-C příkaz] [-X filtrvzor] [-P předpona] [-S přípona] [název…]"

#: builtins.c:237
msgid "compgen [-V varname] [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr "compgen [-V název_proměnné] [-abcdefgjksuv] [-o přepínač] [-A akce] [-G globový_vzor] [-W seznam_slov] [-F funkce] [-C příkaz] [-X filtrvzor] [-P předpona] [-S přípona] [slovo]"

#: builtins.c:241
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o možnost] [-DEI] [název…]"

#: builtins.c:244
msgid "mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "mapfile [-d oddělovač] [-n počet] [-O počátek] [-s počet] [-t] [-u FD] [-C volání] [-c množství] [pole]"

#: builtins.c:246
msgid "readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "readarray [-d oddělovač] [-n počet] [-O počátek] [-s počet] [-t] [-u FD] [-C volání] [-c množství] [pole]"

#: builtins.c:258
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has been\n"
"    defined."
msgstr ""
"Definuje nebo zobrazí aliasy.\n"
"    \n"
"    „alias“ bez argumentů vypíše na standardní výstup seznam aliasů ve znovu\n"
"    použitelném formátu NÁZEV=HODNOTA.\n"
"    \n"
"    Jinak bude definován alias pro každý NÁZEV, který má zadanou HODNOTU.\n"
"    Závěrečná mezera v HODNOTĚ způsobí, že při expanzi bude následující slovo\n"
"    zkontrolováno na substituci aliasů.\n"
"    \n"
"    Přepínače:\n"
"      -p\tvypíše všechny definované aliasy ve znovu použitelném formátu\n"
"    \n"
"    Návratový kód:\n"
"    alias vrátí pravdu, pokud nebyl zadán NÁZEV, pro který není žádný alias\n"
"    definován."

#: builtins.c:280
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Odstraní každý NÁZEV ze seznamů definovaných aliasů.\n"
"    \n"
"    Přepínače:\n"
"      -a\todstraní všechny definice aliasů\n"
"    Vrátí úspěch, pokud NÁZEV není neexistující alias."

#: builtins.c:293
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their values\n"
"      -s                 List key sequences that invoke macros and their values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    If arguments remain after option processing, the -p and -P options treat\n"
"    them as readline command names and restrict output to those names.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Nastaví klávesové zkratky a proměnné Readline.\n"
"    \n"
"    Naváže posloupnost kláves na Readline funkci nebo makro nebo nastaví\n"
"    Readline proměnnou. Syntaxe nepřepínačových argumentů je shodná se\n"
"    syntaxí ~/.inputrc, ale musí být zadána jako jediný argument:\n"
"    např. bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Přepínače:\n"
"      -m  klávmapa       Použije KLÁVMAPU jako klávesovou mapu pro trvání\n"
"                         tohoto příkazu. Možné klávesové mapy jsou emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command a vi-insert.\n"
"      -l                 Vypíše seznam názvů funkcí.\n"
"      -P                 Vypíše seznam názvů funkcí a klávesových vazeb.\n"
"      -p                 Vypíše seznam funkcí a klávesových vazeb ve formátu,\n"
"                         který lze použít jako vstup.\n"
"      -S                 Vypíše seznam posloupností kláves,\n"
"                         které vyvolávají makra, a jejich hodnoty.\n"
"      -s                 Vypíše seznam posloupností kláves,\n"
"                         která vyvolávají makra, a jejich hodnoty ve formátu,\n"
"                         který lze použít jako vstup.\n"
"      -V                 Vypíše seznam názvů proměnných a hodnot.\n"
"      -v                 Vypíše seznam názvů proměnných a hodnot ve formátu,\n"
"                         který lze použít jako vstup.\n"
"      -q  název-funkce   Dotáže se, které klávesy vyvolají zadanou funkci.\n"
"      -u  název-funkce   Zruší všechny vazby na klávesy, které jsou napojeny\n"
"                         na zadanou funkci.\n"
"      -r  klávposl       Odstraní vazbu na KLÁVPOSL.\n"
"      -f  soubor         Načte vazby kláves ze SOUBORU.\n"
"      -x  klávposl:příkaz-shellu\n"
"                         Způsobí, že bude vykonán PŘÍKAZ-SHELLU, když bude\n"
"                         zadána KLÁVPOSL.\n"
"      -X                 Vypíše posloupnosti kláves a příkazy přidružené přes\n"
"                         přepínač -x ve formátu, který lze použít jako vstup.\n"
"    \n"
"    Pokud po zpracování přepínačů zbudou argumenty, přepínače -p a -P je\n"
"    budou považovat za názvy příkazů Readline a omezí výstup na tyto názvy.\n"
"    \n"
"    Návratový kód:\n"
"    bind vrací 0, pokud není zadán nerozpoznaný přepínač nebo nedojde k chybě."

#: builtins.c:335
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Ukončí smyčku for, whle nebo until.\n"
"    \n"
"    Ukončí smyčku FOR, WHILE nebo UNTIL. Je-li zadáno N, ukončí N\n"
"    obklopujících smyček.\n"
"    \n"
"    Návratový kód:\n"
"    Návratový kód je 0, pokud N je větší nebo rovno 1."

#: builtins.c:347
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Obnoví smyčku for, while nebo until.\n"
"    \n"
"    Přejde k další iteraci obklopující smyčky FOR, WHILE nebo UNTIL.\n"
"    Je-li zadáno N, bude tak učiněno v N. obklopující smyčce.    \n"
"    Návratový kód:\n"
"    Návratový kód je 0, pokud N je větší nebo rovno 1."

#: builtins.c:359
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Provede vestavěný příkaz shellu.\n"
"    \n"
"    Provede VESTAVĚNÝ-PŘÍKAZ-SHELLU s argumenty ARGUMENTY, aniž by se uplatnilo\n"
"    vyhledávání příkazu. Toto se hodí, když si přejete reimplementovat\n"
"    vestavěný příkaz shellu jako funkci shellu, avšak potřebujete spustit\n"
"    vestavěný příkaz uvnitř této funkce.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací návratový kód VESTAVĚNÉHO-PŘÍKAZU-SHELLU, nebo nepravdu, pokud\n"
"    VESTAVĚNÝ-PŘÍKAZ-SHELLU není vestavěným příkazem shellu."

#: builtins.c:374
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Vrátí kontext aktuálního podprogramu.\n"
"    \n"
"    Bez VÝRAZU vrátí „$řádek $název_souboru“. S VÝRAZEM vrátí\n"
"    „$řádek $podprogram $název_souboru“; tuto zvláštní informaci lze\n"
"    využít pro výpis zásobníku volání.\n"
"    \n"
"    Hodnota VÝRAZU určuje, kolik rámců volání se má zpětně projít od toho\n"
"    současného; vrcholový rámec má číslo 0.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací 0, pokud shell provádí shellovou funkci a VÝRAZ je platný."

#: builtins.c:392
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of the\n"
"    HOME shell variable. If DIR is \"-\", it is converted to $OLDPWD.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n"
"    A null directory name is the same as the current directory.  If DIR begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is set,\n"
"    the word is assumed to be  a variable name.  If that variable has a value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Změní pracovní adresář shellu.\n"
"    \n"
"    Změní aktuální adresář na ADR. Výchozí ADR je hodnota proměnné shellu\n"
"    HOME. Je-li ADR „-“, změní se na $OLDPWD.\n"
"    \n"
"    Proměnná CDPATH definuje vyhledávací cestu pro adresář obsahující ADR.\n"
"    Názvy náhradních adresářů v CDPATH se oddělují dvojtečkou (:). Prázdný\n"
"    název adresáře je stejný jako aktuální adresář. Začíná-li ADR na lomítko\n"
"    (/), nebude CDPATH použita.\n"
"    \n"
"    Nebude-li adresář nalezen a přepínač shellu „cdable_vars“ bude nastaven,\n"
"    pak se dané slovo zkusí jakožto název proměnné. Má-li taková proměnná\n"
"    hodnotu, pak její hodnota se použije jako ADR.\n"
"    \n"
"    Přepínače:\n"
"      -L  vynutí následování symbolických odkazů: vyhodnotí symbolické\n"
"          odkazy v ADR po zpracování všech výskytů „..“\n"
"      -P  nařizuje použít fyzickou adresářovou strukturu namísto\n"
"          následování symbolických odkazů: vyhodnotí symbolické odkazy v ADR\n"
"          před zpracováním všech výskytů „..“\n"
"      -e  je-li zadán přepínač -P a současný pracovní adresář nelze\n"
"          zdárně zjistit, skončí s nenulovým návratovým kódem\n"
"      -@  na systémech, které to podporují, vydává soubor s rozšířenými\n"
"          atributy jako adresář obsahující atributy souboru\n"
"    \n"
"    Symbolické odkazy se implicitně následují, jako by bylo zadáno „-L“.\n"
"    „..“ se zpracovávají tak, že se odstraní bezprostředně předcházející\n"
"    část cesty až k lomítku nebo začátku ADR.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací 0, byl-li adresář změněn a, byl-li zadán -P, $PWD byla úspěšně\n"
"    nastavena. Jinak vrací nenulovou hodnotu."

#: builtins.c:430
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Vypíše název současného pracovního adresáře.\n"
"    \n"
"    Přepínače:\n"
"      -L  vypíše hodnotu $PWD, pokud pojmenovává současný pracovní\n"
"          adresář\n"
"      -P  vypíše fyzický adresář prostý všech symbolických odkazů\n"
"    \n"
"    Implicitně se „pwd“ chová, jako by bylo zadáno „-L“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací 0, nebyl-li zadán neplatný přepínač a mohl-li být současný\n"
"    adresář přečten."

#: builtins.c:447
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Prázdný příkaz.\n"
"    \n"
"    Žádný účinek, tento příkaz nic nedělá.\n"
"    \n"
"    Návratový kód:\n"
"    Vždy uspěje."

#: builtins.c:458
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Vrátí výsledek úspěchu.\n"
"    \n"
"    Návratový kód:\n"
"    Vždy uspěje."

#: builtins.c:467
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Vrátí výsledek neúspěchu.\n"
"    \n"
"    Návratový kód:\n"
"    Vždy selže."

#: builtins.c:476
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a single word indicating the command or filename that\n"
"            invokes COMMAND\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Provede jednoduchý příkaz nebo zobrazí podrobnosti o příkazech.\n"
"    \n"
"    Spustí PŘÍKAZ s ARGUMENTY ignoruje funkce shellu, nebo zobrazí informace\n"
"    o zadaných PŘÍKAZECH. Lze využít, když je třeba vyvolat příkazy z disku,\n"
"    přičemž existuje funkce stejného jména.\n"
"    \n"
"    Přepínače:\n"
"      -p  pro PATH bude použita implicitní hodnota, která zaručuje,\n"
"          že budou nalezeny všechny standardní nástroje\n"
"      -v  zobrazí slovo určující příkaz nebo název souboru, který vyvolá PŘÍKAZ\n"
"      -V  zobrazí podrobnější popis každého PŘÍKAZU\n"
"    \n"
"    Návratový kód:\n"
"    Vrací návratový kód PŘÍKAZU, nebo selže, nebyl–li příkaz nalezen."

#: builtins.c:496
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute, except for a,\n"
"    A, and r.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the `local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Nastaví hodnoty a atributy proměnných.\n"
"    \n"
"    Deklaruje proměnné a nastaví jim atributy. Nejsou-li zadány NÁZVY,\n"
"    zobrazí atributy a hodnoty všech proměnných.\n"
"    \n"
"    Přepínače:\n"
"      -f  omezí akci nebo výpis na názvy funkcí a deklarace\n"
"      -F  omezí výpis jen na názvy funkcí (a číslo řádku a název\n"
"          zdrojového souboru, je-li zapnuto ladění)\n"
"      -g  vytváří globální proměnné, je-li voláno z funkce shellu,\n"
"          jinak ignorováno\n"
"      -I  vytváří-li se lokální proměnná, zdědí atributy a hodnotu\n"
"          od proměnné stejného jména v předchozím rozsahu platnosti\n"
"      -p  zobrazí atributy a hodnotu každého NÁZVU\n"
"    \n"
"    Přepínače, které nastavují atributy:\n"
"      -a  učiní NÁZVY číslovanými poli (je-li podporováno)\n"
"      -A  učiní NÁZVY asociativními poli (je-li podporováno)\n"
"      -i  přiřadí NÁZVŮM atribut „integer“ (celé číslo)\n"
"      -l  převede hodnotu každého NÁZVU na malá písmena v době přiřazení\n"
"      -n  učiní NÁZEV odkazem na proměnnou pojmenovanou podle své hodnoty\n"
"      -r  učiní NÁZVY jen pro čtení\n"
"      -t  přiřadí NÁZVŮM atribut „trace“ (sledování)\n"
"      -u  převede hodnotu každého NÁZVU na velká písmena v době přiřazení\n"
"      -x  vyexportuje NÁZVY\n"
"    \n"
"    Pomocí „+“ namísto „-“ daný atribut vypnete. Kromě přepínačů a, A a r.\n"
"    \n"
"    Proměnné s atributem integer jsou aritmeticky vyhodnoceny (vizte příkaz\n"
"    „let“), jakmile je do proměnné přiřazeno.\n"
"    \n"
"    Je-li použito uvnitř funkce, učiní „declare“ NÁZVY lokálními stejně jako\n"
"    příkaz „local“. Přepínač „-g“ toto chování potlačí.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací úspěch, pokud nebyl zadán neplatný přepínač a nedošlo k chybě při\n"
"    přiřazování do proměnné."

#: builtins.c:539
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Nastaví hodnoty a atributy proměnných.\n"
"    \n"
"    Synonymum pro „declare“. Vizte „help declare“."

#: builtins.c:547
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    If any NAME is \"-\", local saves the set of shell options and restores\n"
"    them when the function returns.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Definuje lokální proměnné.\n"
"    \n"
"    Vytvoří lokální proměnnou pojmenovanou NÁZEV a přiřadí jí HODNOTU. PŘEPÍNAČ\n"
"    smí být jakýkoliv přepínač přípustný u „declare“.\n"
"    \n"
"    Je-li kterýkoliv NÁZEV „-“, local uloží současnou množinu přepínačů shellu\n"
"    a při návratu z funkce ji obnoví.\n"
"    \n"
"    Lokální proměnné lze použít jen uvnitř funkcí, budou viditelné jen v dané\n"
"    funkci a jejích potomcích.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací úspěch, nebyl-li zadán neplatný přepínač, nenastala-li chyba při\n"
"    přiřazování do proměnné a vykonává-li shell funkci."

#: builtins.c:567
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Vypíše své argumenty na standardní výstup.\n"
"    \n"
"    Zobrazí své ARGUMENTY oddělené jednou mezerou a zakončené novým řádkem\n"
"    na standardní výstup.\n"
"    \n"
"    Přepínače:\n"
"      -n  nepřipojuje nový řádek\n"
"      -e  zapne interpretování následujících znaků uvozených zpětným lomítkem\n"
"      -E  explicitně potlačí interpretování znaků uvozených zpětným lomítkem\n"
"    \n"
"    „echo“ interpretuje následující znaky uvozené zpětným lomítkem:\n"
"      \\a  poplach (zvonek)\n"
"      \\b  backspace\n"
"      \\c  potlačí další výstup\n"
"      \\e  znak escapu\n"
"      \\E  znak escapu\n"
"      \\f  posun formuláře (form feed)\n"
"      \\n  nový řádek\n"
"      \\r  návrat vozíku\n"
"      \\t  vodorovný tabulátor\n"
"      \\v  svislý tabulátor\n"
"      \\\\  zpětné lomítko\n"
"      \\0nnn  znak, jehož ASCII kód je NNN (osmičkově). NNN smí být\n"
"             0 až 3 osmičkové číslice\n"
"      \\xHH  osmibitový znak, jehož hodnota je HH (šestnáctkově). HH smí\n"
"            být jedna nebo dvě šestnáctkové číslice\n"
"      \\uHHHH  unikódový znak, jehož šestnáctková hodnota je HHHH.\n"
"              HHHH smí být jedna až čtyři šestnáctkové číslice\n"
"      \\UHHHHHHHH  unikódový znak, jehož šestnáctková hodnota je HHHHHHHH.\n"
"                  HHHHHHHH smí být jedna až osm šestnáctkových číslic.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací úspěch, nedojde-li k chybě zápisu na výstup."

#: builtins.c:607
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Vypíše argumenty na standardní výstup.\n"
"    \n"
"    Na standardním výstupu zobrazí ARGUMENTY následované odřádkováním.\n"
"    \n"
"    Přepínače:\n"
"      -n\tneodřádkovává\n"
"    \n"
"    Vrací úspěch, nedojte-li k chybě zápisu na výstup."

#: builtins.c:622
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    On systems with dynamic loading, the shell variable BASH_LOADABLES_PATH\n"
"    defines a search path for the directory containing FILENAMEs that do\n"
"    not contain a slash. It may include \".\" to force a search of the current\n"
"    directory.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Povoluje a zakazuje vestavěné příkazy shellu.\n"
"    \n"
"    Povoluje a zakazuje vestavěné příkazy shellu. Zakázání vám umožní\n"
"    spustit program z disku, který má stejné jméno jako vestavěný příkaz\n"
"    shellu, aniž byste museli zadávat celou cestu.\n"
"    \n"
"    Přepínače:\n"
"      -a\tvypíše seznam vestavěných příkazů a vyznačí, který je a který není\n"
"    \tpovolen\n"
"      -n\tzakáže každý NÁZEV nebo zobrazí seznam zakázaných vestavěných\n"
"    \tpříkazů\n"
"      -p\tvypíše seznam vestavěných příkazů ve znovu použitelné podobě\n"
"      -s\tvypíše pouze názvy posixových „speciálních“ vestavěných příkazů\n"
"    \n"
"    Přepínače řídící dynamické nahrávání:\n"
"      -f\tZavede vestavěný příkaz NÁZEV ze sdíleného objektu NÁZEV_SOUBORU\n"
"      -d\tOdstraní vestavění příkaz zavedený pomocí –f\n"
"    \n"
"    Bez přepínačů povolí všechny NÁZVY.\n"
"    \n"
"    Na systémech s dynamickým nahráváním shellová proměnná\n"
"    BASH_LOADABLES_PATH definuje vyhledávací cestu pro adresář obsahující\n"
"    NÁZVY_SOUBORŮ, které nemají lomítko. Cesta smí obsahovat „.“ pro vynucení\n"
"    vyhledávání v pracovním adresáři.\n"
"    \n"
"    Abyste používali „test“ z $PATH namísto verze vestavěné do shellu,\n"
"    napište „enable -n test“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací úspěch, je-li NÁZEV vestavěným příkazem shellu a nevyskytne-li\n"
"    se chyba."

#: builtins.c:655
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Spustí argumenty jako příkaz shellu.\n"
"    \n"
"    ARGUMENTY sloučí do jediného řetězce, použije jej jako vstup shellu\n"
"    a vykoná výsledné příkazy.\n"
"    Návratový kód:\n"
"    Vrátí návratový kód příkazu, nebo úspěch, byl-li příkaz prázdný."

#: builtins.c:667
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Rozebere přepínačové argumenty.\n"
"    \n"
"    Getopts se používá v shellových procedurách na rozebrání pozičních\n"
"    parametrů jakožto přepínačů.\n"
"    \n"
"    ŘETĚZEC_PŘEPÍNAČŮ obsahuje písmena přepínačů, které mají být rozeznány.\n"
"    Je-li písmeno následováno dvojtečkou, po přepínači se očekává argument,\n"
"    který by měl být od přepínače oddělen bílým místem.\n"
"    \n"
"    Pokaždé když je getopts zavolán, je následující přepínač umístěn do\n"
"    proměnné $name (proměnná je inicializována, neexistuje-li) a pořadí\n"
"    dalšího argumentu, který čeká na zpracování, do proměnné shellu OPTIND.\n"
"    OPTIND je inicializována na 1 vždy, když je zavolán shell nebo shellový\n"
"    skript. Pokud přepínač vyžaduje argument, getopts umístí tento argument\n"
"    do proměnné shellu OPTARG.\n"
"    \n"
"    getopts hlásí chyby jedním ze dvou způsobů. Pokud prvním znakem\n"
"    ŘETĚZCE_PŘEPÍNAČŮ je dvojtečka, getopts hlásí chyby tichým způsobem.\n"
"    V tomto režimu žádné chybové zprávy nejsou vypisovány. Když se narazí na\n"
"    neplatný přepínač, getopts umístí tento znak do OPTARG. Pokud není nalezen\n"
"    povinný argument, getopts umístí „:“ do NAME a OPTARG nastaví na znak\n"
"    nalezeného přepínače. Pokud getopts nepracuje v tomto tichém režimu a je\n"
"    nalezen neplatný přepínač, getopts umístí „?“ do NAME a zruší OPTARG. Když\n"
"    nenajde povinný argument, je do NAME zapsán „?“, OPTARG zrušen a vytištěna\n"
"    diagnostická zpráva.\n"
"    \n"
"    Pokud proměnná shellu OPTERR má hodnotu 0, getopts vypne vypisování\n"
"    chybových zpráv, dokonce i když první znak ŘETĚZCE_PŘEPÍNAČŮ není\n"
"    dvojtečka. Výchozí hodnota OPTERR je 1.\n"
"    \n"
"    Normálně getopts zpracovává poziční parametry, avšak jsou-li argumenty\n"
"    zadány jako hodnoty ARG, budou rozebrány tyto namísto pozičních.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, byl-li nalezen nějaký přepínač. Neúspěch vrátí, když dojde\n"
"    na konec přepínačů nebo nastane-li chyba."

#: builtins.c:709
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error occurs."
msgstr ""
"Nahradí shell zadaným příkazem.\n"
"    \n"
"    Vykoná PŘÍKAZ, přičemž nahradí tento shell zadaným programem.  ARGUMENTY\n"
"    se stanou argumenty PŘÍKAZU. Není-li PŘÍKAZ zadán, přesměrování zapůsobí\n"
"    v tomto shellu.\n"
"    \n"
"    Přepínače:\n"
"      -a název  předá název jakožto nultý argument PŘÍKAZU\n"
"      -c        spustí PŘÍKAZ s prázdným prostředím\n"
"      -t        do nultého argumentu PŘÍKAZU umístí pomlčku\n"
"    \n"
"    Pokud příkaz nemůže být proveden, neinteraktivní shell bude ukončen,\n"
"    pokud přepínač shellu „execfail“ není nastaven.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud byl PŘÍKAZ nalezen a nedošlo k chybě přesměrování."

#: builtins.c:730
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Ukončí shell.\n"
"    \n"
"    Ukončí tento shell se stavem N. Bez N bude návratový kód roven kódu\n"
"    posledně prováděného příkazu."

#: builtins.c:739
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not executed\n"
"    in a login shell."
msgstr ""
"Ukončí přihlašovací shell.\n"
"    \n"
"    Ukončí přihlašovací (login) shell se stavem N. Nebyl-li příkaz zavolán\n"
"    z přihlašovacího shellu, vrátí chybu."

#: builtins.c:749
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    The history builtin also operates on the history list.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error occurs."
msgstr ""
"Zobrazí nebo vykoná příkazy ze seznamu historie.\n"
"    \n"
"    fc se používá na vypsání, úpravu a znovu provedení příkazů ze seznamu\n"
"    historie. PRVNÍ a POSLEDNÍ mohou být čísla určující rozsah nebo PRVNÍ může být\n"
"    řetězec, což určuje nejnovější příkaz začínající na zadaný řetězec.\n"
"    \n"
"    Přepínače:\n"
"       -e ENÁZEV\tvybere editor. Implicitní je FCEDIT, pak EDITOR, pak vi.\n"
"       -l\tvypisuje řádky namísto jejich upravování\n"
"       -n\tvypne číslování řádků při jejich vypisování\n"
"       -r\tobrátí pořadí řádků (nejnovější budou první)\n"
"    \n"
"    Forma příkazu „fc -s [vzor=náhrada…] [příkaz]“ znamená, že PŘÍKAZ bude\n"
"    po nahrazení STARÝ=NOVÝ znovu vykonán.\n"
"    \n"
"    Užitečný alias je r='fc -s', takže napsání „r cc“ spustí poslední příkaz\n"
"    začínající na „cc“ a zadání „r“ znovu spustí poslední příkaz.\n"
"    \n"
"    Vestavěný příkaz history rovněž pracuje se seznamem historie.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch nebo kód provedeného příkazu. Nenulový kód, vyskytne-li se\n"
"    chyba."

#: builtins.c:781
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Přepne úlohu na popředí.\n"
"    \n"
"    Přesune úlohu určenou pomocí ÚLOHA na popředí a učiní ji aktuální úlohou.\n"
"    Není-li ÚLOHA zadána, použije se úloha, o které si shell myslí, že je\n"
"    aktuální.\n"
"    \n"
"    Návratový kód:\n"
"    Kód úlohy přesunuté do popředí, nebo došlo-li k chybě, kód selhání."

#: builtins.c:796
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Přesune úlohy do pozadí.\n"
"    \n"
"    Přepne každou úlohu určenou pomocí ÚLOHA na pozadí, jako by byla\n"
"    spuštěna s „&“. Ne-li ÚLOHA uvedena, použije se úloha, o které si shell\n"
"    myslí, že je aktuální.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud je správa úloh zapnuta a nedošlo-li k nějaké chybě."

#: builtins.c:810
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Zapamatuje si nebo zobrazí umístění programu.\n"
"    \n"
"    Pro každý NÁZEV je určena plná cesta k příkazu a je zapamatována. Nejsou-li\n"
"    zadány žádné argumenty, budou vypsány informace o zapamatovaných příkazech.\n"
"    \n"
"    Přepínače:\n"
"      -d        zapomene zapamatovaná umístění každého NÁZVU\n"
"      -l        vypíše v takové podobě, kterou lze opět použít jako vstup\n"
"      -p cesta  použije NÁZEV_CESTY jako plnou cestu k NÁZVU\n"
"      -r        zapomene všechna zapamatovaná umístění\n"
"      -t        vypíše zapamatované umístění každého NÁZVU a každému umístění\n"
"                předepíše odpovídající NÁZEV, bylo zadáno více NÁZVŮ\n"
"    Argumenty:\n"
"      NÁZEV     Každý NÁZEV je vyhledán v $PATH a přidán do seznamu\n"
"                zapamatovaných příkazů.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud byl NÁZEV nalezen a nebyl-li zadán neplatný přepínač."

#: builtins.c:835
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is given."
msgstr ""
"Zobrazí podrobnosti o vestavěných příkazech.\n"
"    \n"
"    Zobrazí stručný souhrn vestavěných příkazů. Je-li zadán VZOREK,\n"
"    vrátí podrobnou nápovědu ke všem příkazům odpovídajícím VZORKU, jinak je\n"
"    vytištěn seznam syntaxe vestavěných příkazů.\n"
"    \n"
"    Přepínače:\n"
"      -d  vypíše krátké pojednání na každé téma\n"
"      -m  zobrazí použití v jakoby manuálovém formátu\n"
"      -s  vypíše pouze krátký popis použití o každém příkazu odpovídajícímu\n"
"          VZORKU\n"
"    \n"
"    Argumenty:\n"
"      VZOREK  Vzorek určující téma nápovědy\n"
"    \n"
"    Návratový kód:\n"
"    Vrací úspěch, pokud byl nalezen VZOREK a nebyl zadán neplatný přepínač."

#: builtins.c:859
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"      -d start-end\tdelete the history entries beginning at position START\n"
"    \t\tthrough position END.\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used. If FILENAME is not supplied\n"
"    and HISTFILE is unset or null, the -a, -n, -r, and -w options have\n"
"    no effect and return success.\n"
"    \n"
"    The fc builtin also operates on the history list.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Zobrazí nebo upraví seznam historie.\n"
"    \n"
"    Zobrazí seznam historie s očíslovanými řádky. Řádky vypsané s „*“ byly\n"
"    změněny. Argument N říká, že se vypíše pouze posledních N řádek.\n"
"    \n"
"    Přepínače:\n"
"      -c  vyprázdní seznam historie smazáním všech položek\n"
"      -d pozice  smaže položku ze seznamu historie na pozici POZICE. Záporné\n"
"          pozice se počítají od konce seznamu historie.\n"
"      -d začátek-konec  smaže položky ze seznamu historie od pozice START\n"
"          do pozice KONEC.\n"
"    \n"
"      -a  připojí řádky historie z této relace do souboru historie\n"
"      -n  načte všechny řádky historie, které ještě nebyly načteny,\n"
"          ze souboru historie a připojí je do seznamu historie\n"
"      -r  načte soubor historie a obsah připojí do seznamu historie\n"
"      -w  zapíše současnou historii do souboru historie\n"
"    \n"
"      -p  provede expanzi historie na každém ARGUMENTU a výsledek zobrazí,\n"
"          aniž by cokoliv uložil do seznamu historie\n"
"      -s  připojí ARGUMENTY do seznamu historie jako jednu položku\n"
"    \n"
"    Je-li zadáno JMÉNO_SOUBORU, tak ten je použit jako soubor historie. Jinak\n"
"    pokud proměnná HISTFILE má hodnotu, tato je použita. Není-li JMÉNO_SOUBORU\n"
"    zadáno a HISTFILE není nastavena nebo je prázdná, přepínače -a, -n, -r\n"
"    a -w pozbudou účinku a navrácen bude kód úspěchu.\n"
"    \n"
"    Je-li proměnná HISTTIMEFORMAT nastavena a není-li prázdná, její hodnota\n"
"    se použije jako formátovací řetězec pro strftime(3) při výpisu časových\n"
"    razítek spojených s každou položkou historie. Jinak žádná časová razítka\n"
"    nebudou vypisována.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a nedošlo k chybě."

#: builtins.c:902
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Zobrazí stav úloh.\n"
"    \n"
"    Vypíše aktivní úlohy. ÚLOHA omezuje výstup na danou úlohu. Bez uvedení\n"
"    přepínačů bude vypsán stav všech aktivních úloh.\n"
"    \n"
"    Přepínače:\n"
"      -l  vypíše navíc ID procesů\n"
"      -n  vypíše pouze procesy, které od minulého oznámení změnily stav\n"
"      -p  vypíše pouze ID procesů\n"
"      -r  zúží výstup jen na běžící úlohy\n"
"      -s  zúží výstup jen na pozastavené úlohy\n"
"    \n"
"    Je-li použito -x, bude spuštěn příkaz, jakmile všechny úlohy uvedené mezi\n"
"    ARGUMENTY budou nahrazeny ID procesu, který je vedoucím skupiny dané úlohy.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a nevyskytla se chyba.\n"
"    Byl-ly použit přepínač -x, vrátí návratový kód PŘÍKAZU."

#: builtins.c:929
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Odstraní úlohy ze současného shellu.\n"
"    \n"
"    Z tabulky aktivních úloh odebere každou ÚLOHU. Nebudou-li ÚLOHY zadány,\n"
"    shell použije vlastní představu o současné úloze.\n"
"    \n"
"    Přepínače:\n"
"      -a  odstraní všechny úlohy, pokud nebyla žádná ÚLOHA určena\n"
"      -h  označí každou ÚLOHU tak, že jí nebude zaslán SIGHUP, až shell sám\n"
"          obdrží tento signál\n"
"      -r  odstraní jen běžící úlohy\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač nebo ÚLOHA."

#: builtins.c:948
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Zašle signál úloze.\n"
"    \n"
"    Zašle procesu určeném PID (nebo ÚLOHOU) signál zadaný pomocí SIGSPEC\n"
"    nebo ČÍSSIG. Není-li SIGSPEC ani ČÍSSIG zadán, pak se předpokládá SIGTERM.\n"
"    \n"
"    Přepínače:\n"
"      -s sig  SIG je název signálu\n"
"      -n sig  SIG je číslo signálu\n"
"      -l      vypíše čísla signálů; pokud „-l“ následují argumenty, má\n"
"              se za to, že se jedná o čísla signálů, pro které se mají vyspat\n"
"              jejich názvy.\n"
"      -L      synonymum pro -l\n"
"    \n"
"    Kill je vestavěný příkaz shellu ze dvou důvodů: umožňuje použít\n"
"    identifikátory úloh namísto ID procesů a umožní zabíjet procesy i poté,\n"
"    co jste dosáhli limitu počtu procesů, které smíte vytvořit.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a nedošlo k chybě."

#: builtins.c:972
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Vyhodnotí aritmetický výraz.\n"
"    \n"
"    Vyhodnotí každý ARGUMENT jako aritmetický výraz. Vyhodnocení je\n"
"    prováděno v celých číslech o pevné šířce bez kontrol přetečení, avšak\n"
"    dělení 0 je zachyceno a označeno za chybu. Následující seznam operátorů\n"
"    je rozdělen do skupin podle úrovní přednosti. Skupiny jsou seřazeny\n"
"    v sestupném pořadí přednosti.\n"
"    \n"
"    \tid++, id--\tnásledné zvýšení, snížení proměnné\n"
"    \t++id, --id\tpřednostní zvýšení, snížení proměnné\n"
"    \t-, +\t\tunární mínus, plus\n"
"    \t!, ~\t\tlogická a bitová negace\n"
"    \t**\t\tumocnění\n"
"    \t*, /, %\t\tnásobení, dělení, zbytková třída\n"
"    \t+, -\t\tsčítání, odečítání\n"
"    \t<<, >>\t\tlevý a pravý bitový posun\n"
"    \t<=, >=, <, >\tporovnání\n"
"    \t==, !=\t\trovnost, nerovnost\n"
"    \t&\t\tbitové a zároveň (AND)\n"
"    \t^\t\tbitové vylučující nebo (XOR)\n"
"    \t|\t\tbitové nebo (OR)\n"
"    \t&&\t\tlogické a zároveň (AND)\n"
"    \t||\t\tlogické nebo (OR)\n"
"    \tVÝRAZ ? VÝRAZ : VÝRAZ\n"
"    \t\t\tpodmíněný operátor\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tpřiřazení\n"
"    \n"
"    Proměnné shellu jsou povolené operandy. Název proměnné je uvnitř výrazu\n"
"    nahrazen její hodnotou (s automatickým převodem na celé číslo pevné šířky).\n"
"    Proměnná nemusí mít atribut integer (číslo) zapnutý, aby byla použitelná\n"
"    ve výrazu.\n"
"    \n"
"    Operátory se vyhodnocují v pořadí přednosti. Podvýrazy v závorkách jsou\n"
"    vyhodnoceny přednostně a smí přebít pravidla přednosti uvedená výše.\n"
"    \n"
"    Návratový kód:\n"
"    Pokud poslední ARGUMENT je vyhodnocen na 0, let vrátí 1. Jinak je\n"
"    navrácena 0."

#: builtins.c:1017
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as word\n"
"    delimiters. By default, the backslash character escapes delimiter characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -E\tuse Readline to obtain the line and use the bash default\n"
"    \t\tcompletion instead of Readline's default completion\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times out\n"
"    (in which case it's greater than 128), a variable assignment error occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Načte ze standardního vstupu jeden řádek a rozdělí jej na položky.\n"
"    \n"
"    Ze standardního vstupu, nebo deskriptoru souboru FD, je-li zadán\n"
"    přepínač -u, je načten jeden řádek. Řádek se rozdělí na části jako při\n"
"    dělení na slova a první slovo je přiřazeno do prvního JMÉNA, druhé slovo\n"
"    do druhého JMÉNA a tak dále, přičemž přebývající slova se přiřadí do\n"
"    posledního JMÉNA. Pouze znaky uvedené v $IFS jsou považovány za\n"
"    oddělovače slov. Ve výchozím nastavení znak zpětného lomítka ruší\n"
"    zvláštní význam znaků oddělovače a nového řádku.\n"
"    \n"
"    Nejsou-li uvedena žádná JMÉNA, načtený řádek bude uložen do proměnné REPLY.\n"
"    \n"
"    Přepínače:\n"
"      -a pole       načtená slova budou přiřazena do postupných prvků POLE\n"
"                    počínaje indexem nula\n"
"      -d oddělovač  pokračuje, dokud není načten první znak ODDĚLOVAČE\n"
"                    namísto nového řádku\n"
"      -e            načte řádek pomocí knihovny Readline\n"
"      -E            načte řádek pomocí knihovny Readline a místo výchozího\n"
"                    doplňování knihovnou Readline použije výchozí doplňování\n"
"                    bashem\n"
"      -i text       použije TEXT jako prvotní text pro Readline\n"
"      -n p_znaků    vrátí řízení po načtení P_ZNAKŮ znaků, místo čekání na\n"
"                    nový řádek, avšak respektuje oddělovač, je-li méně než\n"
"                    P_ZNAKŮ\n"
"      -N p_znaků    vrátí řízení pouze po načtení přesně P_ZNAKŮ znaků,\n"
"                    pokud se neobjeví konec souboru nebo nevyprší limit,\n"
"                    ignoruje jakýkoliv oddělovač\n"
"      -p výzva      vypíše řetězec VÝZVA bez závěrečného nového řádku dříve,\n"
"                    než se zahájí načítání\n"
"      -r            nepovolí zpětná lomítka pro escapování jakýchkoliv znaků\n"
"      -s            vstup pocházející z terminálu nebude zobrazován\n"
"      -t limit      umožní vypršení časového limitu a vrácení chyby, pokud\n"
"                    nebude načten celý řádek do LIMIT sekund. Hodnota proměnné\n"
"                    TMOUT představuje implicitní limit. LIMIT smí být desetinné\n"
"                    číslo. Je-li LIMIT 0, read okamžitě skončí, aniž by zkusil\n"
"                    načíst jakákoliv data, a vrátí úspěch, jen bude-li na\n"
"                    zadaném deskriptoru souboru připraven vstup. Návratový\n"
"                    kód bude větší než 128, pokud časový limit bude překročen.\n"
"      -u fd         čte z deskriptoru souboru FD namísto standardního vstupu\n"
"    \n"
"    Návratový kód:\n"
"    Návratový kód je nula, pokud se nenarazí na konec souboru, časový limit\n"
"    pro čtení nevyprší (pak je větší než 128), nedojde k chybě při\n"
"    přiřazování do proměnné, nebo není poskytnut neplatný deskriptor souboru\n"
"    jako argument -u."

#: builtins.c:1067
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Návrat z shellové funkce.\n"
"    \n"
"    Způsobí ukončení funkce nebo skriptu načteného přes „source“ s návratovou\n"
"    hodnotou určenou N. Je-li N vynecháno, návratový kód bude roven poslednímu\n"
"    příkazu vykonanému uvnitř dotyčné funkce nebo skriptu.\n"
"    \n"
"    Návratová hodnota:\n"
"    Vrátí N, nebo selže, pokud shell neprovádí funkci nebo skript."

#: builtins.c:1080
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    If -o is supplied with no option-name, set prints the current shell\n"
"    option settings. If +o is supplied with no option-name, set prints a\n"
"    series of set commands to recreate the current option settings.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Nastaví nebo zruší hodnoty přepínačů shellu a pozičních parametrů.\n"
"    \n"
"    Změní hodnoty atributům shellu a pozičním parametrům, nebo zobrazí názvy\n"
"    a hodnoty proměnných shellu.\n"
"    \n"
"    Přepínače:\n"
"      -a  Označí měněné nebo vytvářené proměnné pro export.\n"
"      -b  Neprodleně oznámí ukončení úlohy.\n"
"      -e  Neprodleně skončí, pokud nějaký příkaz skončí s nenulovým kódem.\n"
"      -f  Zakáže vytváření jmen souborů (globbing).\n"
"      -h  Zapamatuje si umístění příkazů tehdy, když jsou vyhledány.\n"
"      -k  Všechny přiřazovací argumenty budou umístěny do prostředí\n"
"          příkazu. Nejenom ty, co předchází název příkazu.\n"
"      -m  Správa úloh je zapnuta.\n"
"      -n  Příkazy načte, ale neprovede je.\n"
"      -o NÁZEV_PŘEPÍNAČE\n"
"          Nastaví proměnnou odpovídající NÁZVU_PŘEPÍNAČE:\n"
"              allexport    stejné jako -a\n"
"              braceexpand  stejné jako -B\n"
"              emacs        použije emacsový způsob editace na řádku\n"
"              errexit      stejné jako -e\n"
"              errtrace     stejné jako -E\n"
"              functrace    stejné jako -T\n"
"              hashall      stejné jako -h\n"
"              histexpand   stejné jako -H\n"
"              history      zapne historii příkazů\n"
"              ignoreeof    shell neskončí, když načte EOF (konec souboru)\n"
"              interactive-comments\n"
"                           povolí, aby se v interaktivních příkazech\n"
"                           objevovaly komentáře\n"
"              keyword      stejné jako -k\n"
"              monitor      stejné jako -m\n"
"              noclobber    stejné jako -C\n"
"              noexec       stejné jako -n\n"
"              noglob       stejné jako -f\n"
"              nolog        v současnosti přijímáno, ale ignorováno\n"
"              notify       stejné jako -b\n"
"              nounset      stejné jako -u\n"
"              onecmd       stejné jako -t\n"
"              physical     stejné jako -P\n"
"              pipefail     návratová hodnota kolony je status posledního\n"
"                           příkazu, který skončil s nenulovým kódem.\n"
"                           Návratová hodnota je nula, pokud žádný z příkazů\n"
"                           neskončil s nenulovým kódem.\n"
"              posix        změní chování bashe tam, kde implicitní chování\n"
"                           se liší od standardu 1003.2, tak, aby bylo\n"
"                           v souladu se standardem\n"
"              privileged   stejné jako -p\n"
"              verbose      stejné jako -v\n"
"              vi           použije vi způsob editace na řádku\n"
"              xtrace       stejné jako -x\n"
"      -p  Zapnuto, kdykoliv reálné a efektivní ID uživatele se neshodují.\n"
"          Vypne zpracování souboru $ENV a importování shellových funkcí.\n"
"          Vypnutí tohoto přepínače způsobí, že efektivní UID a GID budou\n"
"          nastavena na reálná UID a GID.\n"
"      -t  Skončí po načtení a provedení jednoho příkazu.\n"
"      -u  Při substituci považuje nenastavené proměnné za chybu.\n"
"      -v  Vstupní řádky shellu se budou vypisovat tak, jak budou načítány.\n"
"      -x  Vypisuje příkazy a jejich argumenty tak, jak jsou spouštěny.\n"
"      -B  Shell bude provádět závorkovou (brace) expanzi.\n"
"      -C  Je-li nastaveno, zakáže přepsání již existujících běžných souborů\n"
"          při přesměrování výstupu.\n"
"      -E  Je-li nastaveno, trap ERR (zachytávání chyb) bude děděn do\n"
"          funkcí shellu.\n"
"      -H  Zapne ! způsob nahrazování historie. Tento příznak je automaticky\n"
"          zapnut při interaktivním shellu.\n"
"      -P  Je-li nastaveno, nebudou vyhodnocovány symbolické odkazy při\n"
"          provádění příkazů jako změna pracovního adresáře pomocí „cd“.\n"
"      -T  Je-li nastaveno, trap DEBUG (obsluha ladění) a RETURN (návrat\n"
"          z podprogramu) bude děděn do funkcí shellu.\n"
"      --  Přiřadí jakékoliv zbývající argumenty do pozičních parametrů.\n"
"          Neexistují-li žádné zbývající argumenty, poziční parametry budou\n"
"          odstraněny.\n"
"      -   Přiřadí jakékoliv zbývající argumenty do pozičních parametrů.\n"
"          Přepínače -x a -v budou vypnuty.\n"
"    \n"
"    Je-li zadáno -o bez názvu přepínače, set vypíše současné nastavení\n"
"    shellu. Je-li zadáno +o bez názvu přepínače, set vypíše posloupnost příkazů\n"
"    set, které obnoví současné nastavení.\n"
"    \n"
"    Použití + místo - způsobí, že tyto příznaky budou vypnuty. Příznaky lze též\n"
"    použít při volání shellu. Aktuální množinu příznaků je možno nalézt v $-.\n"
"    Přebývajících n ARGUMENTŮ jsou poziční parametry a budou přiřazeny,\n"
"    v pořadí, do $1, $2, … $n. Nejsou-li zadány žádné ARGUMENTY, budou\n"
"    vytištěny všechny proměnné shellu.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný argument."

#: builtins.c:1169
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Odstraňuje hodnoty a atributy proměnných a funkcí shellu.\n"
"    \n"
"    Pro každé JMÉNO odstraní odpovídající proměnnou nebo funkci.\n"
"    \n"
"    Přepínače:\n"
"      -f  považuje každé JMÉNO za funkci shellu\n"
"      -v  považuje každé JMÉNO za proměnnou shellu\n"
"      -n  považuje každé JMÉNO za odkaz na název a odstraní proměnnou samu\n"
"          namísto proměnné, na kterou odkazuje\n"
"    \n"
"    Bez těchto dvou příznaků unset nejprve zkusí zrušit proměnnou a pokud toto\n"
"    selže, tak zkusí zrušit funkci.\n"
"    \n"
"    Některé proměnné nelze odstranit. Vizte příkaz „readonly“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a JMÉNO není jen pro\n"
"    čtení."

#: builtins.c:1191
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables or functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Nastaví atribut exportovat proměnné shellu.\n"
"    \n"
"    Každý NÁZEV je označen pro automatické exportování do prostředí následně\n"
"    prováděných příkazů. Je-li zadána HODNOTA, před exportem přiřadí HODNOTU.\n"
"    \n"
"    Přepínače:\n"
"      -f\tvztahuje se na funkce shellu\n"
"      -n\todstraní vlastnost exportovat každému NÁZVU\n"
"      -p\tzobrazí seznam všech exportovaných proměnných a funkcí\n"
"    \n"
"    Argument „--“ zakazuje zpracování dalších přepínačů.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač nebo NÁZEV."

#: builtins.c:1210
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Označí proměnné shellu za nezměnitelné.\n"
"    \n"
"    Označí každý NÁZEV jako jen pro čtení, hodnoty těchto NÁZVŮ nebude možné\n"
"    změnit následným přiřazením. Je-li zadána HODNOTA, před označením za jen\n"
"    pro čtení přiřadí HODNOTU.\n"
"    \n"
"    Přepínače:\n"
"      -a  vztahuje se na proměnné typu číslované pole\n"
"      -A  vztahuje se na proměnné typu asociativní pole\n"
"      -f  vztahuje se funkce shellu\n"
"      -p  zobrazí seznam všech proměnných nebo funkcí jen pro čtení\n"
"          v závislosti podle toho, zda-li byl zadán přepínač -f\n"
"    \n"
"    Argument „--“ zakáže zpracování dalších přepínačů.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač nebo NÁZEV."

#: builtins.c:1232
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Posune poziční parametry.\n"
"    \n"
"    Přejmenuje poziční parametry $N+1, $N+2, … na $1, $2, …\n"
"    Není-li zadáno N, předpokládá se 1.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud N není záporný a není větší než $#."

#: builtins.c:1244 builtins.c:1260
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell. If the\n"
"    -p option is supplied, the PATH argument is treated as a colon-\n"
"    separated list of directories to search for FILENAME. If -p is not\n"
"    supplied, $PATH is searched to find FILENAME. If any ARGUMENTS are\n"
"    supplied, they become the positional parameters when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Vykoná příkazy ze souboru v současném shellu.\n"
"    \n"
"    Načte a provede příkazy z NÁZEV_SOUBORU v tomto shellu. Je-li zadán\n"
"    přepínač -p, je argument PATH považován za dvojtečkou oddělený seznam\n"
"    adresářů, v kterých se bude NÁZEV_SOUBORU hledat. Není-li -p zadán,\n"
"    NÁZEV_SOUBORU se bude hledat v proměnné PATH. Jsou-li zadány nějaké\n"
"    ARGUMENTY, stanou se pozičními parametry při vykonávání NÁZVU_SOUBORU.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací návratový kód posledního provedeného příkazu z NÁZVU_SOUBORU.\n"
"    Selže, pokud NÁZEV_SOUBORU nelze načíst."

#: builtins.c:1277
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells and shells without job control cannot be\n"
"    suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell or job\n"
"    \t\tcontrol is not enabled.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Pozastaví běh shellu.\n"
"    \n"
"    Pozastaví provádění tohoto shellu do doby, něž bude obdržen signál\n"
"    SIGCONT. Není-li vynuceno, přihlašovací shell a shell bez řízení úloh\n"
"    nelze pozastavit.\n"
"    \n"
"    Přepínače:\n"
"      -f    vynutí pozastavení, i když se jedná o přihlašovací (login) shell\n"
"            nebo když je řízení úloh vypnuto.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací úspěch, pokud je správa úloh zapnuta a nevyskytla se chyba."

#: builtins.c:1295
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Vyhodnotí podmínkový výraz.\n"
"    \n"
"    Skončí s kódem 0 (pravda) nebo 1 (nepravda) podle vyhodnocení VÝRAZU.\n"
"    Výraz smí být unární nebo binární. Unární výrazy se často používají pro\n"
"    zjištění stavu souboru. Rovněž jsou k dispozici řetězcové operátory a\n"
"    operátory číselného porovnání.\n"
"    \n"
"    Chování testu závisí na počtu argumentů. Úplnou specifikaci si lze\n"
"    přečíst v manuálové stránce bashe.\n"
"    \n"
"    Souborové operátory:\n"
"    \n"
"      -a SOUBOR      Pravda, pokud soubor existuje.\n"
"      -b SOUBOR      Pravda, pokud soubor je blokovým zařízením.\n"
"      -c SOUBOR      Pravda, pokud soubor je znakovým zařízením.\n"
"      -d SOUBOR      Pravda, pokud soubor je adresářem.\n"
"      -e SOUBOR      Pravda, pokud soubor existuje.\n"
"      -f SOUBOR      Pravda, pokud soubor existuje a je to běžný soubor.\n"
"      -g SOUBOR      Pravda, pokud soubor je SGID.\n"
"      -h SOUBOR      Pravda, pokud soubor je symbolickým odkazem.\n"
"      -L SOUBOR      Pravda, pokud soubor je symbolickým odkazem.\n"
"      -k SOUBOR      Pravda, pokud soubor má nastavený „sticky“ bit.\n"
"      -p SOUBOR      Pravda, pokud soubor je pojmenovanou rourou.\n"
"      -r SOUBOR      Pravda, pokud soubor je vámi čitelný.\n"
"      -s SOUBOR      Pravda, pokud soubor existuje a je neprázdný.\n"
"      -S SOUBOR      Pravda, pokud soubor je socketem.\n"
"      -t FD          Pravda, pokud FD (deskriptor souboru) je otevřený na\n"
"                     terminálu.\n"
"      -u SOUBOR      Pravda, pokud soubor je SUID.\n"
"      -w SOUBOR      Pravda, pokud soubor je vámi zapisovatelný.\n"
"      -x SOUBOR      Pravda, pokud soubor je vámi spustitelný.\n"
"      -O SOUBOR      Pravda, pokud soubor je vámi efektivně vlastněn.\n"
"      -G SOUBOR      Pravda, pokud soubor je efektivně vlastněn vaší\n"
"                     skupinou.\n"
"      -N SOUBOR      Pravda, pokud soubor byl změněn po posledním čtení.\n"
"    \n"
"      SOUBOR1 -nt SOUBOR2\n"
"                     Pravda, pokud je SOUBOR1 novější než SOUBOR2 (podle času\n"
"                     změny obsahu).\n"
"    \n"
"      SOUBOR1 -ot SOUBOR2\n"
"                     Pravda, pokud SOUBOR1 je starší než SOUBOR2.\n"
"    \n"
"      SOUBOR1 -ef SOUBOR2\n"
"                     Pravda, pokud SOUBOR1 je pevným odkazem na SOUBOR2.\n"
"    \n"
"    Řetězcové operátory:\n"
"    \n"
"      -z ŘETĚZEC     Pravda, pokud ŘETĚZEC je prázdný.\n"
"    \n"
"      -n ŘETĚZEC\n"
"         ŘETĚZEC     Pravda, pokud ŘETĚZEC není prázdný.\n"
"    \n"
"      ŘETĚZEC1 = ŘETĚZEC2\n"
"                     Pravda, pokud jsou řetězce shodné.\n"
"      ŘETĚZEC1 != ŘETĚZEC2\n"
"                     Pravda, pokud se řetězce neshodují.\n"
"      ŘETĚZEC1 < ŘETĚZEC2\n"
"                     Pravda, pokud se ŘETĚZEC1 řadí lexikograficky před\n"
"                     ŘETĚZEC2.\n"
"      ŘETĚZEC1 > ŘETĚZEC2\n"
"                     Pravda, pokud se ŘETĚZEC1 řadí lexikograficky za\n"
"                     ŘETĚZEC2.\n"
"    \n"
"    Další operátory:\n"
"    \n"
"      -o PŘEPÍNAČ    Pravda, pokud je přepínač shellu PŘEPÍNAČ zapnut.\n"
"      -v PROMĚNNÁ    Pravda, pokud je proměnná shellu PROMĚNNÁ nastavena\n"
"      -R PROMĚNNÁ    Pravda, pokud je proměnná shellu PROMĚNNÁ nastavena a\n"
"                     jedná se odkaz na název.\n"
"      ! VÝRAZ        Pravda, pokud je VÝRAZ nepravdivý.\n"
"      VÝRAZ1 -a VÝRAZ2\n"
"                     Pravda, pokud oba VÝRAZ1 I VÝRAZ2 jsou pravdivé.\n"
"      VÝRAZ1 -o VÝRAZ2\n"
"                     Pravda, pokud VÝRAZ1 NEBO VÝRAZ2 je pravdivý.\n"
"    \n"
"      ARGUMENT1 OP ARGUMENT2\n"
"                     Aritmetické testy. OP je jeden z -eq, -ne, -lt,\n"
"                     -le, -gt nebo -ge.\n"
"    \n"
"    Aritmetické binární operátory vracejí pravdu, pokud ARGUMENT1 je roven,\n"
"    neroven, menší než, menší než nebo roven, větší než, větší než nebo\n"
"    roven ARGUMENTU2.    \n"
"    Návratový kód:\n"
"    Vrací úspěch, je-li VÝRAZ vyhodnocen jako pravdivý. Selže, je-li VÝRAZ\n"
"    vyhodnocen jako nepravdivý nebo je-li zadán neplatný argument."

#: builtins.c:1377
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Vyhodnotí podmínkový výraz.\n"
"    \n"
"    Toto je synonymum pro vestavěný příkaz „test“, až na to, že poslední\n"
"    argument musí být doslovně „]“, aby se shodoval s otevírající „[“."

#: builtins.c:1386
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Zobrazí časy procesu.\n"
"    \n"
"    Vypíše celkovou dobu procesu shellu a všech jeho potomků, kterou strávili\n"
"    v uživatelském a jaderném (system) prostoru.\n"
"    \n"
"    Návratový kód:\n"
"    Vždy uspěje."

#: builtins.c:1398
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives signals\n"
"    or other conditions.\n"
"    \n"
"    ACTION is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ACTION is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ACTION is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ACTION is executed on exit from the shell.\n"
"    If a SIGNAL_SPEC is DEBUG, ACTION is executed before every simple command\n"
"    and selected other commands. If a SIGNAL_SPEC is RETURN, ACTION is\n"
"    executed each time a shell function or a script run by the . or source\n"
"    builtins finishes executing.  A SIGNAL_SPEC of ERR means to execute ACTION\n"
"    each time a command's failure would cause the shell to exit when the -e\n"
"    option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands associated\n"
"    with each trapped signal in a form that may be reused as shell input to\n"
"    restore the same signal dispositions.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC in a\n"
"    \t\tform that may be reused as shell input; or for all trapped\n"
"    \t\tsignals if no arguments are supplied\n"
"      -P\tdisplay the trap commands associated with each SIGNAL_SPEC. At least\n"
"    \t\tone SIGNAL_SPEC must be supplied. -P and -p cannot be used\n"
"    \t\ttogether.\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is given."
msgstr ""
"Zachytávání signálů a jiných událostí.\n"
"    \n"
"    Definuje a aktivuje obsluhy, které budou spuštěny, když shell obdrží\n"
"    signály nebo nastanou určité podmínky.\n"
"    \n"
"    Příkaz AKCE bude načten a proveden, až shell obdrží signál(y) SIGNAL_SPEC.\n"
"    Pokud AKCE chybí (a je zadán jeden SIGNAL_SPEC) nebo je „-“, každý určený\n"
"    signál bude přenastaven zpět na svoji původní hodnotu.\n"
"    Je-li AKCE prázdný řetězec, každý SIGNAL_SPEC bude shellem a příkazy\n"
"    z něj spuštěnými ignorován.\n"
"    \n"
"    Je-li SIGNAL_SPEC „EXIT (0)“, bude AKCE provedena při ukončování tohoto\n"
"    shellu. Je-li SIGNAL_SPEC „DEBUG“, bude AKCE provedena před každým\n"
"    jednoduchým příkazem a dalšími vybranými příkazy. Je-li SIGNAL_SPEC\n"
"    „RETURN“, bude AKCE provedena vždy, když skončí běh funkce shellu nebo\n"
"    skriptu spuštěného přes vestavěný příkaz „.“ nebo „source“.  SIGNAL_SPEC\n"
"    „ERR“ znamená, že AKCE bude provedena pokaždé, když by selhání příkazu\n"
"    způsobilo ukončení shellu (je-li zapnut přepínač -e).\n"
"    \n"
"    Nejsou-li poskytnuty žádné argumenty, trap vypíše seznam příkazů navázaných\n"
"    na každý zachytávaný signál a to ve tvaru, který může být použit jako vstup\n"
"    shellu vedoucí k obnovení obsluhy signálů do současné podoby.\n"
"    \n"
"    Přepínače:\n"
"      -l  vypíše seznam jmen signálů a jim odpovídajících čísel\n"
"      -p  zobrazí příkazy navázané na každý SIGNAL_SPEC ve tvaru, který lze\n"
"          použít jako vstup shellu, nebo nebyl-li zadán žádný argument,\n"
"          navázané na všechny zachytávané signály\n"
"      -P  zobrazí příkazy navázané na každý SIGNAL_SPEC. Musí být zadán\n"
"          alespoň jeden SIGNAL_SPEC. Přepínače -P a -p nelze použít současně.\n"
"    \n"
"    Každý SIGNAL_SPEC je buďto jméno signálu ze <signal.h>, nebo číslo signálu.\n"
"    U jmen signálů nezáleží na velikosti písmen a předpona SIG je nepovinná.\n"
"    Aktuálnímu shellu lze zaslat signál pomocí „kill -signal $$“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud SIGSPEC a zadané přepínače jsou platné."

#: builtins.c:1441
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not found."
msgstr ""
"Zobrazí informace o typu příkazu.\n"
"    \n"
"    O každém NÁZVU řekne, jak by byl interpretován, kdyby byl použit jako\n"
"    název příkazu.\n"
"    \n"
"    Přepínače\n"
"      -a  zobrazí všechna místa, kde se nalézá spustitelný program\n"
"          pojmenovaný NÁZEV. To zahrnuje aliasy, vestavěné příkazy a funkce\n"
"          jen a pouze tehdy, když není rovněž použit přepínač -p.\n"
"      -f  potlačí hledání mezi funkcemi shellu\n"
"      -P  vynutí prohledání PATH na každý NÁZEV, dokonce i když se\n"
"          jedná o alias, vestavěný příkaz nebo funkci, a vrátí název\n"
"          souboru na disku, který by byl spuštěn\n"
"      -p  buď vrátí jméno souboru na disku, který by byl spuštěn,\n"
"          nebo nic, pokud „type -t NÁZEV“ by nevrátil „file“ (soubor)\n"
"      -t  vypíše jedno slovo z těchto: „alias“, „keyword“, „function“,\n"
"          „builtin“, „file“ nebo „“, je-li NÁZEV alias, klíčové slovo\n"
"          shellu, shellová funkce, vestavěný příkaz shellu, soubor na\n"
"          disku nebo nenalezený příkaz\n"
"    \n"
"    Argumenty:\n"
"      NÁZEV  Název příkazu určený k výkladu.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud všechny NÁZVY byly nalezeny. Selže, pokud některé\n"
"    nalezeny nebyly."

#: builtins.c:1472
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds;\n"
"    -p, which is in increments of 512 bytes; -R, which is in microseconds;\n"
"    -b, which is in bytes; and -e, -i, -k, -n, -q, -r, -u, -x, and -P,\n"
"    which accept unscaled values.\n"
"    \n"
"    When in posix mode, values supplied with -c and -f are in 512-byte\n"
"    increments.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Upravuje omezení (limity) zdrojů shellu.\n"
"    \n"
"    Poskytuje kontrolu nad zdroji dostupnými shellu a procesům z něj\n"
"    spuštěných (na systémech, které takovou kontrolu umožňují).\n"
"    \n"
"    Přepínače:\n"
"      -S  použije se „měkké“ (soft) omezení zdroje\n"
"      -H  použije se „tvrdé“ (hard) omezení zdroje\n"
"      -a  nahlásí všechna současná omezení (limity)\n"
"      -b  velikost vyrovnávací paměti socketů\n"
"      -c  maximální velikost vytvářených core souborů (výpis paměti programu)\n"
"      -d  maximální velikost datového segmentu procesu\n"
"      -e  maximální plánovací priorita („nice“)\n"
"      -f  maximální velikost souborů zapsaných shellem a jeho potomky\n"
"      -i  maximální počet čekajících signálů\n"
"      -k  maximální počet jaderných front událostí („kqueue“) alokovaných\n"
"          pro tento proces\n"
"      -l  maximální velikost paměti, kterou může proces zamknout\n"
"      -m  maximální velikost rezidentní paměti (resident set size)\n"
"      -n  maximální počet otevřených deskriptorů souboru\n"
"      -p  velikost vyrovnávací paměti rour\n"
"      -q  maximální počet bajtů ve frontě posixových zpráv\n"
"      -r  maximální priorita plánování v reálném čase\n"
"      -s  maximální velikost zásobníku\n"
"      -t  maximální množství procesorového času v sekundách\n"
"      -u  maximální počet procesů uživatele\n"
"      -v  velikost virtuální paměti\n"
"      -x  maximální počet zámků na souborech\n"
"      -P  maximální počet pseudoterminálů\n"
"      -R  maximální doba, po kterou proces plánovaný v reálném čase, může\n"
"          běžet, než se zablokuje\n"
"      -T  maximální počet vláken\n"
"    \n"
"    Ne všechny přepínače jsou dostupné na všech platformách.\n"
"    \n"
"    Je-li zadán LIMIT, jedná se o novou hodnotu daného zdroje. Zvláštní\n"
"    hodnoty LIMITU „soft“, „hard“ a „unlimited“ znamenají současný měkký\n"
"    limit, současný tvrdý limit a žádný limit. V opačném případě bude\n"
"    zobrazena současná hodnota limitu daného zdroje. Není-li zadán žádný\n"
"    přepínač, pak se předpokládá -f.\n"
"    \n"
"    Hodnoty jsou v násobcích 1024 bajtů, kromě -t, která je v sekundách,\n"
"    -p, která je v násobcích 512 bajtů, -R, která je v mikrosekundách,\n"
"    -b, která je v bajtech a -e, -i, -k, -n, -q, -r, -u, -x a -P, což jsou\n"
"    absolutní počty.\n"
"    \n"
"    V režimu POSIXu hodnoty -c a -f jsou v násobcích 512.\n"
"    \n"
"    Návratová hodnota:\n"
"    Vrací úspěch, pokud nebyl zadán neplatný přepínač a nevyskytla se chyba."

#: builtins.c:1527
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Zobrazí nebo nastaví uživatelskou masku práv.\n"
"    \n"
"    Nastaví Uživatelskou masku práv vytvářených souborů na MÓD. Je-li\n"
"    MÓD vynechán, bude vytištěna současná hodnota masky.\n"
"    \n"
"    Začíná-li MÓD číslicí, bude interpretován jako osmičkové číslo, jinak\n"
"    jako řetězec symbolického zápisu práv tak, jak jej chápe chmod(1).\n"
"    \n"
"    Přepínače:\n"
"      -p\tje-li MÓD vynechán, bude výstup v podobě, kterou lze použít\n"
"    \tjako vstup\n"
"      -S\tučiní výstup symbolický, jinak bude výstupem osmičkové číslo\n"
"    \n"
"    Návratový kód\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný MÓD nebo přepínač."

#: builtins.c:1547
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Počká na dokončení úlohy a vrátí její návratový kód.\n"
"    \n"
"    Počká na každý proces určený ID, což může být ID procesu nebo identifikace\n"
"    úlohy, a nahlásí jeho návratový kód. Není-li ID zadáno, počká na všechny\n"
"    právě aktivní dětské procesy a návratovým kódem bude nula. Je-li ID\n"
"    identifikátorem úlohy, počká na všechny procesy z kolony dané úlohy.\n"
"    \n"
"    Je-li zadán přepínač -n, počká na ukončení jedné úlohy ze seznamu ID\n"
"    nebo nebyla-li zadána žádná ID, počká na ukončení další úlohy a vrátí\n"
"    její návratový kód.\n"
"    \n"
"    Je-li zadán přepínač -p, identifikátor procesu nebo úlohy, jehož\n"
"    návratový kód se má vrátit, bude přiřazen do proměnné uvedené v argumentu\n"
"    tohoto přepínače. Na začátku je před jakýmkoliv přiřazením je proměnná\n"
"    zrušena. To je užitečné pouze spolu s přepínačem -n.\n"
"    \n"
"    Je-li zadán přepínač -f a je-li zapnuta správa úloh, počká na ukončení\n"
"    ukončení zadaného ID, místo aby čekal na změnu jeho stavu.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód posledního ID. Selže, pokud ID není platné nebo byl zadán\n"
"    neplatný přepínač nebo byl použit přepínač -n a shell nemá žádné\n"
"    nevyhodnocené potomky."

#: builtins.c:1578
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an invalid\n"
"    option is given."
msgstr ""
"Počká na dokončení procesu a vrátí jeho návratový kód.\n"
"    \n"
"    Počká na každý proces určený PID a nahlásí jeho návratový kód. Není-li\n"
"    PID zadán, bude se čekat na všechny právě aktivní procesy potomků a\n"
"    návratová hodnota bude nula. PID musí být ID procesu.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód posledního PID. Selže, pokud PID není platný nebo byl zadán\n"
"    neplatný přepínač."

#: builtins.c:1593
msgid ""
"Execute PIPELINE, which can be a simple command, and negate PIPELINE's\n"
"    return status.\n"
"    \n"
"    Exit Status:\n"
"    The logical negation of PIPELINE's return status."
msgstr ""
"Vykoná KOLONU, což může být prostý příkaz, a neguje návratový kód\n"
"    KOLONY.\n"
"    \n"
"    Návratový kód:\n"
"    Logická negace návratového kódu KOLONY."

#: builtins.c:1603
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Pro každý prvek seznamu vykoná příkazy.\n"
"    \n"
"    Smyčka „for“ provede posloupnost příkazů pro každý prvek v seznamu položek.\n"
"    Pokud „in SLOVECH…;“ není přítomno, pak se předpokládá „in \"$@\"“. NÁZEV\n"
"    bude postupně nastaven na každý prvek ve SLOVECH a PŘÍKAZY budou provedeny.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy provedeného příkazu."

#: builtins.c:1617
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Aritmetická smyčka for.\n"
"    \n"
"    Ekvivalentní k\n"
"    \t(( VÝR1 ))\n"
"    \twhile (( VÝR2 )); do\n"
"    \t\tPŘÍKAZY\n"
"    \t\t(( VÝR3 ))\n"
"    \tdone\n"
"    VÝR1, VÝR2 a VÝR3 jsou aritmetické výrazy. Chybí-li některý výraz,\n"
"    chová se, jako by byl vyhodnocen na 1.    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy vykonaného příkazu."

#: builtins.c:1635
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Vybere slova ze seznamu a vykoná příkazy.\n"
"    \n"
"    SLOVA jsou expandována a vytvoří seznam slov. Množina expandovaných slov\n"
"    je vytištěna na standardní chybový výstup, každé předchází číslo.  Není-li\n"
"    „in SLOVA“ přítomno, předpokládá se „in \"$@\"“. Pak je zobrazena výzva PS3\n"
"    a jeden řádek načten ze standardního vstupu. Pokud je řádek tvořen číslem\n"
"    odpovídajícím jednomu ze zobrazených slov, pak NÁZEV bude nastaven na toto\n"
"    slovo. Pokud je řádek prázdný, SLOVA a výzva budou znovu zobrazeny. Je-li\n"
"    načten EOF (konec souboru), příkaz končí. Načtení jakékoliv jiné hodnoty\n"
"    nastaví NÁZEV na prázdný řetězec. Načtený řádek bude uložen do proměnné\n"
"    REPLY. Po každém výběru budou provedeny PŘÍKAZY, dokud nebude vykonán\n"
"    příkaz „break“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy prováděného příkazu."

#: builtins.c:1656
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Nahlásí čas spotřebovaný prováděním kolony.\n"
"    \n"
"    Vykoná KOLONU a zobrazí přehled reálného času, uživatelského\n"
"    procesorového času a systémového procesorového času stráveného prováděním\n"
"    KOLONY poté, co skončí.\n"
"    \n"
"    Přepínače:\n"
"      -p\tzobrazí přehled časů v přenositelném posixovém formátu\n"
"    \n"
"    Hodnota proměnné TIMEFORMAT se použije jako specifikace výstupního formátu.\n"
"    \n"
"    Návratový kód:\n"
"    Návratová hodnota je návratová hodnota KOLONY."

#: builtins.c:1673
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Provede příkazy podle shody se vzorem.\n"
"    \n"
"    Výběrově provede PŘÍKAZY na základě shody SLOVA se VZOREM. Znak „|“\n"
"    se používá na oddělení násobných VZORŮ.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy provedeného příkazu."

#: builtins.c:1685
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of the\n"
"    entire construct is the exit status of the last command executed, or zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Vykoná příkazy na základě splnění podmínky.\n"
"    \n"
"    Provede seznam „if PŘÍKAZŮ“. Bude-li jeho návratový kód nula, pak bude\n"
"    proveden seznam „then PŘÍKAZŮ“. Jinak bude proveden popořadě každý seznam\n"
"    „elif PŘÍKAZŮ“ a bude-li jeho návratový kód nula, odpovídající seznam\n"
"    „then PŘÍKAZŮ“ bude proveden a příkaz if skončí. V opačném případě bude\n"
"    proveden seznam „else PŘÍKAZŮ“, pokud existuje. Návratová hodnota celé\n"
"    konstrukce je návratovou hodnotou posledního provedeného příkazu nebo nula,\n"
"    pokud žádná z testovaných podmínek není pravdivá.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy provedeného příkazu."

#: builtins.c:1702
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Vykonává příkazy, dokud test úspěšně prochází.\n"
"    \n"
"    Expanduje a provádí PŘÍKAZY-2 tak dlouho, dokud poslední příkaz v PŘÍKAZECH\n"
"    má nulový návratový kód.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy provedeného příkazu."

#: builtins.c:1714
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Vykonává příkazy, dokud test končí neúspěšně.\n"
"    \n"
"    Expanduje a provádí PŘÍKAZY-2 tak dlouho, dokud poslední příkaz v PŘÍKAZECH\n"
"    má nenulový návratový kód.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy provedeného příkazu."

#: builtins.c:1726
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Vytvoří koproces pojmenovaný NÁZEV.\n"
"    \n"
"    Vykoná PŘÍKAZ asynchronně, přičemž jeho standardní výstup a standardní\n"
"    vstup budou napojeny rourou na souborové deskriptory uvedené v poli NÁZEV\n"
"    tohoto shellu pod indexem 0 a 1. Implicitní NÁZEV je „COPROC“.\n"
"    \n"
"    Návratový kód:\n"
"    Příkaz coproc vrací návratový kód 0."

#: builtins.c:1740
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Definuje funkci shellu.\n"
"    \n"
"    Vytvoří shellovou funkci pojmenovanou NÁZEV. Volána jakožto jednoduchý\n"
"    příkaz spustí PŘÍKAZY v kontextu volajícího shellu. Je-li vyvolán NÁZEV,\n"
"    budou funkci předány argumenty jako $1…$n a název funkce bude umístěn do\n"
"    $FUNCNAME.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud NÁZEV není jen pro čtení."

#: builtins.c:1754
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Seskupí příkazy do jednotky.\n"
"    \n"
"    Spustí množinu příkazů v jedné skupině. Toto je jeden ze způsobů,\n"
"    jak přesměrovat celou množinu příkazů.    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy spuštěného příkazu."

#: builtins.c:1766
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Obnoví úlohu do popředí.\n"
"    \n"
"    Ekvivalent k argumentu ÚLOHA příkazu „fg“. Obnoví pozastavenou úlohu\n"
"    nebo úlohu na pozadí. ÚLOHA může určovat buď název úlohy, nebo číslo úlohy.\n"
"    Přidání „&“ za ÚLOHU přesune úlohu na pozadí, jako by identifikátor úlohy\n"
"    byl argumentem příkazu „bg“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód obnovené úlohy."

#: builtins.c:1781
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Vyhodnotí aritmetický výraz.\n"
"    \n"
"    VÝRAZ bude vyhodnocen podle pravidel aritmetického vyhodnocování.\n"
"    Ekvivalentní k „let \"VÝRAZ\"“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí 1, pokud se VÝRAZ vyhodnotí na 0. Jinak vrátí 0."

# XXX: „coniditional command“ znamená podmínka, výraz podmínky. Nikoliv
# příkaz, který by byl vykonán na základě splnění jiné podmínky. Tj. překlad
# „podmíněný příkaz“ je chybný.
# Toto je nápověda k vestavěnému příkazu „[“.
#: builtins.c:1793
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries used\n"
"    by the `test' builtin, and may be combined using the following operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Vykoná podmínkový příkaz.\n"
"    \n"
"    Vrátí status 0 nebo 1 podle vyhodnocení výrazu podmínky VÝRAZ. Výrazy\n"
"    se skládají ze stejných primitiv jako u vestavěného příkazu „test“ a\n"
"    mohou být kombinovány za pomoci následujících operátorů:\n"
"    \n"
"      ( VÝRAZ )\tVrátí hodnotu VÝRAZU\n"
"      ! VÝRAZ\t\tPravda, pokud VÝRAZ je nepravdivý; jinak nepravda\n"
"      VÝR1 && VÝR2\tPravda, pokud oba VÝR1 i VÝR2 jsou pravdivé;\n"
"    \t\tjinak nepravda\n"
"      VÝR1 || VÝR2\tPravda, pokud VÝR1 nebo VÝR2 je pravdivý; jinak nepravda\n"
"    \n"
"    Jsou-li použity operátory „==“ a „!=“, řetězec napravo od operátoru je\n"
"    použit jako vzor a bude uplatněno porovnávání proti vzoru. Je-li použit\n"
"    operátor „=~, řetězec napravo do operátoru je uvažován jako regulární\n"
"    výraz.\n"
"    \n"
"    Operátory && a || nevyhodnocují VÝR2, pokud VÝR1 je dostatečný na určení\n"
"    hodnoty výrazu.\n"
"    \n"
"    Návratový kód:\n"
"    0 nebo 1 podle hodnoty VÝRAZU."

#: builtins.c:1819
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Názvu běžných proměnných shellu a jejich význam.\n"
"    \n"
"    BASH_VERSION\tInformace o verzi tohoto Bashe.\n"
"    CDPATH\tDvojtečkou oddělený seznam adresářů, který se prohledává\n"
"    \t\tna adresáře zadané jako argumenty u „cd“.\n"
"    GLOBIGNORE\tDvojtečkou oddělený seznam vzorů popisujících jména souborů,\n"
"    \t\tkterá budou ignorována při expanzi cest.\n"
"    HISTFILE\tJméno souboru, kde je uložena historie vašich příkazů.\n"
"    HISTFILESIZE\tMaximální počet řádků, které tento soubor smí obsahovat.\n"
"    HISTSIZE\tMaximální počet řádků historie, které jsou dostupné uvnitř\n"
"    \t\tběžícího shellu.\n"
"    HOME\tCelá cesta do vašeho domovského adresáře.\n"
"    HOSTNAME\tJméno současného stroje.\n"
"    HOSTTYPE\tDruh CPU, na které tento Bash běží.\n"
"    IGNOREEOF\tŘídí reakci shellu na přijetí znaku EOF (konec souboru)\n"
"    \t\tpři samotném vstupu. Je-li nastaveno, pak její hodnota udává\n"
"    \t\tpočet znaků EOF, které mohou bezprostředně následovat na prázdném\n"
"    \t\třádku, dříve než shell skončí (implicitní hodnota je 10). Není-li\n"
"    \t\tnastaveno, EOF značí konec vstupu.\n"
"    MACHTYPE\tŘetězec popisující systém, na kterém tento Bash běží.\n"
"    MAILCHECK\tJak často, v sekundách, kontroluje Bash novou poštu.\n"
"    MAILPATH\tDvojtečkou oddělený seznam názvů souborů, které Bash\n"
"    \t\tkontroluje na novou poštu.\n"
"    OSTYPE\tVerze Unixu, na kterém tento Bash běží.\n"
"    PATH\tDvojtečkou oddělený seznam adresářů, které jsou prohledávány\n"
"    \t\tna příkazy.\n"
"    PROMPT_COMMAND\tPříkaz, který je proveden před vytištěním každé\n"
"    \t\tprimární výzvy shellu.\n"
"    PS1\t\tŘetězec prvotní výzvy shellu.\n"
"    PS2\t\tŘetězec druhotné výzvy shellu.\n"
"    PWD\t\tCelé jméno cesty do aktuálního adresáře.\n"
"    SHELLOPTS\tDvojtečkou oddělený seznam zapnutých přepínačů shellu.\n"
"    TERM\tNázev druhu současného terminálu.\n"
"    TIMEFORMAT\tVýstupní formát časové statistiky zobrazované vyhrazeným\n"
"    \t\tslovem „time“.\n"
"    auto_resume\tNeprázdná hodnota znamená, že slovo příkazu objevující se\n"
"    \t\tna řádce automaticky je nejprve vyhledáno v seznamu\n"
"    \t\tprávě pozastavených úloh. Je-li tam nalezeno, daná úloha bude\n"
"    \t\tpřepnuta na popředí. Hodnota „exact“ znamená, že slovo příkazu\n"
"    \t\tse musí přesně shodovat s příkazem v seznamu pozastavených úloh.\n"
"    \t\tHodnota „substring“ znamená, že slovo příkazu se musí shodovat\n"
"    \t\ts podřetězcem úlohy. Jakákoliv jiná hodnota znamená, že příkaz\n"
"    \t\tmusí být předponou pozastavené úlohy.\n"
"    histchars\tZnaky řídící expanzi historie a rychlé nahrazování.\n"
"    \t\tPrvní znak je znak nahrazení historie, obvykle „!“. Druhý je\n"
"    \t\tznak „rychlého nahrazování“, obvykle „^“. Třetí je znak\n"
"    \t\t„komentáře historie“, obvykle „#“.\n"
"    HISTIGNORE\tDvojtečkou oddělený seznam vzorů používaný na\n"
"    \t\trozlišení, které příkazy by měly být uloženy do seznamu\n"
"    \t\thistorie.\n"

#: builtins.c:1876
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Přidá adresáře do zásobníku.\n"
"    \n"
"    Přidá adresář na vrchol zásobníku adresářů nebo zásobník zrotuje tak,\n"
"    že nový vrchol zásobníku se stane současným pracovním adresářem. Bez\n"
"    argumentů prohodí dva vrchní adresáře.\n"
"    \n"
"    Přepínače:\n"
"      -n  Potlačí obvyklou změnu adresáře, když se na zásobník přidávají\n"
"          adresáře, takže změněn bude pouze zásobník.\n"
"    \n"
"    Argumenty:\n"
"      +N  Zrotuje zásobník tak, že N. adresář (počítáno zleva na seznamu\n"
"          zobrazovaném pomocí „dirs“, počínaje nulou) se dostane na vrchol.\n"
"    \n"
"      -N  Zrotuje zásobník tak, že N. adresář (počítáno zprava na seznamu\n"
"          zobrazovaném pomocí „dirs“, počínaje nulou) se dostane na vrchol.\n"
"    \n"
"      ADRESÁŘ\n"
"          Přidá ADRESÁŘ na vrchol zásobníku adresářů a učiní jej novým\n"
"          současným pracovním adresářem.\n"
"    \n"
"    Zásobník adresářů si můžete prohlédnout příkazem „dirs“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný argument a změna adresáře\n"
"    neselhala."

#: builtins.c:1910
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Odebere adresáře ze zásobníku.\n"
"    \n"
"    Odstraní položky ze zásobníku adresářů. Bez argumentů odstraní adresář\n"
"    z vrcholu zásobníku a přepne do nového adresáře na vrchu zásobníku.\n"
"    \n"
"    Přepínače:\n"
"      -n  Potlačí obvyklou změnu adresáře, když se ze zásobníku odebírají\n"
"          adresáře, takže změněn bude pouze zásobník.\n"
"    \n"
"    Argumenty:\n"
"      +N  Odstraní N. položku počítáno zleva na seznamu zobrazovaném\n"
"          pomocí „dirs“, počínaje nulou. Na příklad: „popd +0“ odstraní\n"
"          první adresář, „popd -1“ druhý.\n"
"    \n"
"      -N  Odstraní N. položku počítáno zprava na seznamu zobrazovaném\n"
"          pomocí „dirs“, počínaje nulou. Na příklad: „popd -0“ odstraní\n"
"          poslední adresář, „popd -1“ další vedle posledního.\n"
"    \n"
"    Zásobník adresářů si můžete prohlédnout příkazem „dirs“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný argument nebo neselhala změna\n"
"    adresáře."

#: builtins.c:1940
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Zobrazí zásobník adresářů.\n"
"    \n"
"    Zobrazí seznam právě pamatovaných adresářů. Adresáře si najdou cestu\n"
"    na seznam příkazem „pushd“ a procházet seznamem zpět lze příkazem „popd“.\n"
"    \n"
"    Přepínače:\n"
"      -c  vyprázdní zásobník adresářů tím, že smaže všechny jeho prvky\n"
"      -l  nevypíše vlnkou zkrácené verze adresářů, které jsou relativní\n"
"          vašemu domovskému adresáři\n"
"      -p  vypíše zásobník adresářů po jedné položce na řádek\n"
"      -v  vypíše zásobník adresářů po jedné položce na řádek, přičemž\n"
"          názvu adresáře předřadí jeho umístění na zásobníku\n"
"    \n"
"    Argumenty:\n"
"      +N  zobrazí N. položku počítáno zleva na seznamu, který zobrazuje\n"
"          dirs, když je vyvolán bez přepínačů, počínaje nulou.\n"
"    \n"
"      -N  zobrazí N. položku počítáno zprava na seznamu, který zobrazuje\n"
"          dirs, když je vyvolán bez přepínačů, počínaje nulou.    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a nevyskytla se chyba."

#: builtins.c:1971
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Zapne nebo vypne volby (přepínače) shellu.\n"
"    \n"
"    Změní nastavení každého přepínače shellu NÁZEV_VOLBY. Bez přepínačových\n"
"    argumentů vypíše každý zadaný NÁZEV_VOLBY, nebo seznam všech přepínačů\n"
"    shellu, nebyl-li zadán žádný NÁZEV_VOLBY, s příznakem, zda je, nebo\n"
"    není přepínač nastaven.\n"
"    Přepínače:\n"
"      -o\tomezí NÁZVY_VOLEB na ty, které jsou definovány pro použití\n"
"    \ts „set -o“\n"
"      -p\tvypíše každou volbu shellu s určením jejího stavu\n"
"      -q\tpotlačí výstup\n"
"      -s\tzapne [set] každý NÁZEV_VOLBY\n"
"      -u\tvypne [unset] každý NÁZEV_VOLBY\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, je-li NÁZEV_VOLBY zapnut. Selže, byl-li zadán neplatný\n"
"    přepínač nebo je-li NÁZEV_VOLBY vypnut."

#: builtins.c:1992
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: plain\n"
"    characters, which are simply copied to standard output; character escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format characters csndiouxXeEfFgGaA described\n"
"    in printf(3), printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or assignment\n"
"    error occurs."
msgstr ""
"Naformátuje a vypíše ARGUMENTY podle definice FORMÁTU.\n"
"    \n"
"    Přepínače:\n"
"      -v proměnná  výstup umístí do proměnné shellu PROMĚNNÁ namísto\n"
"                   odeslání na standardní výstup.\n"
"    \n"
"    FORMÁT je řetězec znaků, který obsahuje tři druhy objektů: obyčejné znaky,\n"
"    které jsou prostě zkopírovány na standardní výstup, posloupnosti escapových\n"
"    znaků, které jsou zkonvertovány a zkopírovány na standardní výstup a\n"
"    formátovací definice, z nichž každá způsobí vytištění dalšího argumentu.\n"
"    \n"
"    Vedle standardních formátovacích znaků csndiouxXeEfFgGaA popsaných\n"
"    v printf(3), tento příkaz printf rovněž rozeznává:\n"
"    \n"
"      %b           expanduje posloupnosti escapované zpětným lomítkem\n"
"                   v odpovídajícím argumentu\n"
"      %q           oescapuje argument takovým způsobem, že jej bude možné\n"
"                   použít jako vstup shellu\n"
"      %Q           jako %q, ale použije libovolnou přesnost na neescapovaný\n"
"                   argument před samotným escapováním\n"
"      %(FORMÁT)T   vypíše řetězec data-času tak, jako by to byl výstup\n"
"                   funkce strftime(3) s formátovacím řetězcem FORMÁT\n"
"    \n"
"    FORMÁT lze znovu použít podle potřeby ke zpracování všech argumentů. Je-li\n"
"    zde méně argumentů, než FORMÁT vyžaduje, nadbytečné formátovací znaky\n"
"    se budou chovat, jako by nulová hodnota nebo nulový řetězec, jak je třeba,\n"
"    byly zadány.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a nedošlo k chybě\n"
"    zápisu nebo přiřazení."

#: builtins.c:2028
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no options\n"
"    or NAMEs are supplied, display existing completion specifications in a way\n"
"    that allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Určuje, jak budou argumenty doplňovány pomocí knihovny Readline.\n"
"    \n"
"    Pro každý NÁZEV udává, jak se budou doplňovat argumenty. Nejsou-li zadány\n"
"    žádné přepínače, ani NÁZVY, budou vypsány existující pravidla doplňování\n"
"    v podobě vhodné pro jejich znovu užití jako vstup.\n"
"    \n"
"    Přepínače:\n"
"      -p  vypíše existující pravidla doplňování v znovu použitelném tvaru\n"
"      -r  odstraní pro každý NÁZEV doplňovací pravidlo, nebo není-li zadán\n"
"          žádný NÁZEV, zruší všechna pravidla\n"
"      -D  použije pravidla doplňování a akce jako implicitní pro příkazy,\n"
"          které nemají žádné určité pravidlo doplňování definováno\n"
"      -E  použije pravidla doplňování a akce na „prázdné“ příkazy –\n"
"          pravidla doplňování se uplatní na prázdný řádek\n"
"      -I  použije pravidla doplňování a akce na první slovo (obvykle příkaz)\n"
"    \n"
"    Použije-li se doplňování, akce se uplatní v pořadí, v jakém jsou vypsány\n"
"    přepínače psané velkými písmeny výše. Je-li zadáno více přepínačů,\n"
"    přepínač -D bude upřednostněn před přepínačem -E. Oba přepínače přebíjejí\n"
"    přepínač -I.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a nevyskytla se chyba."

#: builtins.c:2058
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is present, generate matches\n"
"    against WORD.\n"
"    \n"
"    If the -V option is supplied, store the possible completions in the indexed\n"
"    array VARNAME instead of printing them to the standard output.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Zobrazí možná doplnění v závislosti na přepínačích.\n"
"    \n"
"    Je zamýšleno pro použití uvnitř shellových funkcí generujících možná\n"
"    doplnění. Je-li přítomen volitelný argument SLOVO, budou vygenerovány\n"
"    shody se SLOVEM.\n"
"    \n"
"    Je-li zadán přepínač -V, uloží možná doplnění do indexovaného pole\n"
"    NÁZEV_PROMĚNNÉ, namísto jejich vypsání na standardní výstup.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a nevyskytla se chyba."

#: builtins.c:2076
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, print\n"
"    the completion options for each NAME or the current completion specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Upraví nebo zobrazí možnosti doplňování.\n"
"    \n"
"    Pozmění možnosti doplňování každého NÁZVU, nebo, není-li zadán žádný\n"
"    NÁZEV, právě prováděného doplňování. Nejsou-li zadány žádné MOŽNOSTI,\n"
"    vypíše možnosti doplňování každého NÁZVU nebo definic právě prováděného\n"
"    doplňování.\n"
"    \n"
"    Přepínače:\n"
"    \t-o možnost\tNastaví možnost doplňování MOŽNOST každému NÁZVU\n"
"    \t-D\t\tZmění možnosti doplňování „implicitnímu“ příkazu\n"
"    \t-E\t\tZmění možnosti doplňování „prázdnému“ příkazu\n"
"    \t-I\t\tZmění možnosti doplňování prvnímu slovu\n"
"    \n"
"    Pomocí „+o“ namísto „-o“ zadanou možnost vypnete.\n"
"    \n"
"    Argumenty:\n"
"    Každý NÁZEV odkazuje na příkaz, pro který musí být předem definováno\n"
"    pravidlo (definice) doplňování pomocí vestavěného příkazu „complete“.\n"
"    Nejsou-li zadány žádné NÁZVY, musí být compopt volán funkcí, která právě\n"
"    generuje doplňování. Změněny pak budou možnosti tohoto právě prováděného\n"
"    generátoru doplňování.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a NÁZEV měl definováno\n"
"    pravidlo doplňování."

#: builtins.c:2107
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly or\n"
"    not an indexed array."
msgstr ""
"Načte řádky ze standardního vstupu do proměnné typu indexované pole.\n"
"    \n"
"    Načte řádky ze standardního vstupu nebo z deskriptoru souboru FD, byl-li\n"
"    zadán přepínač -u, do proměnné POLE, která je typu indexované pole.\n"
"    Implicitním POLEM je proměnná MAPFILE.\n"
"    \n"
"    Přepínače:\n"
"      -d oddělovač  Řádky zakončí ODDĚLOVAČEM namísto znakem nového řádku\n"
"      -n počet      Zkopíruje nejvýše POČET řádků. Je-li POČET 0,\n"
"                    zkopíruje všechny řádky\n"
"      -O počátek    Přiřazování do POLE začne na indexu POČÁTEK,\n"
"                    výchozí index je 0\n"
"      -s počet      Zahodí prvních POČET načtených řádků\n"
"      -t            Odstraní znak konce řádku z každého načteného řádku\n"
"      -u fd         Řádky čte z deskriptoru souboru FD namísto ze\n"
"                    standardního vstupu\n"
"      -C volání     Vyhodnotí VOLÁNÍ pokaždé, když je načteno MNOŽSTVÍ\n"
"                    řádků\n"
"      -c množství   Udává počet řádků, které je třeba přečíst, mezi\n"
"                    každým zavoláním VOLÁNÍ\n"
"    \n"
"    Argumenty:\n"
"      POLE          Název proměnné typu pole, do které budou přiřazena data\n"
"    \n"
"    Je-li uvedeno -C bez -c, implicitní množství bude 5000. Vyhodnocovanému\n"
"    VOLÁNÍ budou jako dodatečné argumenty předány index prvku pole, do\n"
"    kterého se má vzápětí přiřazovat, a řádek, který má být přiřazen do\n"
"    tohoto prvku.\n"
"    \n"
"    Nebude-li explicitně udán počátek, mapfile vyprázdní POLE před tím,\n"
"    než do něj začne přiřazovat.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač, POLE nebylo jen pro\n"
"    čtení a bylo indexovaným polem."

#: builtins.c:2143
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Načte řádky ze souboru do proměnné typu pole.\n"
"    \n"
"    Synonymum pro „mapfile“."

#~ msgid ""
#~ "Returns the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
#~ "    \"$line $subroutine $filename\"; this extra information can be used to\n"
#~ "    provide a stack trace.\n"
#~ "    \n"
#~ "    The value of EXPR indicates how many call frames to go back before the\n"
#~ "    current one; the top frame is frame 0."
#~ msgstr ""
#~ "Vrátí kontext volání aktuálního podprogramu.\n"
#~ "    \n"
#~ "    Bez VÝRAZU vrátí „$řádek $název_souboru“. S VÝRAZEM vrátí\n"
#~ "    „$řádek $podprogram $název_souboru“; tuto dodatečnou informaci lze\n"
#~ "    využít pro výpis zásobníku volání.\n"
#~ "    \n"
#~ "    Hodnota VÝRAZU určuje, kolik rámců volání se má zpětně projít od toho\n"
#~ "    současného; vrcholový rámec má číslo 0."

#, c-format
#~ msgid "%s: cannot open: %s"
#~ msgstr "%s: nelze otevřít: %s"

#, c-format
#~ msgid "%s: inlib failed"
#~ msgstr "%s: inlib selhala"

#, c-format
#~ msgid "warning: %s: %s"
#~ msgstr "varování: %s: %s"

#, c-format
#~ msgid "%s: %s"
#~ msgstr "%s: %s"

#, c-format
#~ msgid "%s: cannot execute binary file: %s"
#~ msgstr "%s: binární soubor nelze spustit: %s"

#, c-format
#~ msgid "setlocale: LC_ALL: cannot change locale (%s)"
#~ msgstr "setlocale: LC_ALL: národní prostředí nelze změnit (%s)"

#, c-format
#~ msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
#~ msgstr "setlocale: LC_ALL: národní prostředí nelze změnit (%s): %s"

#, c-format
#~ msgid "setlocale: %s: cannot change locale (%s): %s"
#~ msgstr "setlocale: %s: národní prostředí nelze změnit (%s): %s"

#~ msgid "%s: invalid associative array key"
#~ msgstr "%s: neplatný klíč asociativního pole"

#~ msgid ""
#~ "Returns the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns "
#~ msgstr ""
#~ "Vrátí kontext aktuálního volání podprogramu.\n"
#~ "    \n"
#~ "    Bez VÝRAZU vrátí "

#~ msgid "add_process: process %5ld (%s) in the_pipeline"
#~ msgstr "add_process: proces %5ld (%s) do the_pipeline"

#~ msgid "Unknown Signal #"
#~ msgstr "Neznámé číslo signálu"

#~ msgid "Copyright (C) 2018 Free Software Foundation, Inc."
#~ msgstr "Copyright © 2018 Free Software Foundation, Inc."

#~ msgid "Copyright (C) 2014 Free Software Foundation, Inc."
#~ msgstr "Copyright © 2014 Free Software Foundation, Inc."

#~ msgid ":"
#~ msgstr ":"

#~ msgid "true"
#~ msgstr "true"

#~ msgid "false"
#~ msgstr "false"

#~ msgid "times"
#~ msgstr "times"

#~ msgid "Copyright (C) 2009 Free Software Foundation, Inc.\n"
#~ msgstr "Copyright © 2009 Free Software Foundation, Inc.\n"

#~ msgid "License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>\n"
#~ msgstr "Licence GPLv2+: GNU GPL verze 2 nebo novější <http://gnu.org/licenses/gpl.html>\n"

#~ msgid ""
#~ ".  With EXPR, returns\n"
#~ "    "
#~ msgstr ""
#~ ".  S VÝRAZEM vrátí\n"
#~ "    "

#~ msgid ""
#~ "; this extra information can be used to\n"
#~ "    provide a stack trace.\n"
#~ "    \n"
#~ "    The value of EXPR indicates how many call frames to go back before the\n"
#~ "    current one; the top frame is frame 0."
#~ msgstr ""
#~ "; tato dodatečná informace může být\n"
#~ "    použita jako výpis zásobníku volání.\n"
#~ "    \n"
#~ "    Hodnota VÝRAZU určuje, kolik rámců volání jít zpět před současný,\n"
#~ "    vrcholový rámec je rámce 0."

#~ msgid "xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr "xrealloc: nelze přealokovat %'lu bajtů (%'lu bajtů alokováno)"

#~ msgid "xrealloc: cannot allocate %lu bytes"
#~ msgstr "xrealloc: nelze alokovat %'lu bajtů"

#~ msgid "xrealloc: %s:%d: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr "xrealloc: %s:%d: nelze přealokovat %'lu bajtů (%'lu bajtů alokováno)"

#~ msgid " "
#~ msgstr " "

#~ msgid "Without EXPR, returns returns \"$line $filename\".  With EXPR,"
#~ msgstr "Bez VÝRAZU vrací „$line $filename“. S VÝRAZEM "

#~ msgid "returns \"$line $subroutine $filename\"; this extra information"
#~ msgstr "vrací „$line $subroutine $filename“. Tyto údaje"

#~ msgid "can be used used to provide a stack trace."
#~ msgstr "lze využít při výpisu zásobníku volání."

#~ msgid "The value of EXPR indicates how many call frames to go back before the"
#~ msgstr "Hodnota VÝRAZ značí, kolik rámců volání se má jít zpět před"

#~ msgid "current one; the top frame is frame 0."
#~ msgstr "současný rámec, vrcholový rámec má číslo 0."

#~ msgid "%s: invalid number"
#~ msgstr "%s: chybné číslo"

#~ msgid "Shell commands matching keywords `"
#~ msgstr "Příkazy shellu shodující se s klíčovými slovy „"

#~ msgid "Display the list of currently remembered directories.  Directories"
#~ msgstr "Zobrazí seznam právě zapamatovaných adresářů. Adresáře"

#~ msgid "find their way onto the list with the `pushd' command; you can get"
#~ msgstr "se na seznam umisťují příkazem „pushd“, předchozí stav seznamu lze"

#~ msgid "back up through the list with the `popd' command."
#~ msgstr "vrátit příkazem „popd“."

#~ msgid "The -l flag specifies that `dirs' should not print shorthand versions"
#~ msgstr "Příznak -l značí, že „dirs“ nemá vypisovat zkrácené verze adresářů,"

#~ msgid "of directories which are relative to your home directory.  This means"
#~ msgstr "které leží pod vaším domovským adresářem. To znamená, že „~/bin“"

#~ msgid "that `~/bin' might be displayed as `/homes/bfox/bin'.  The -v flag"
#~ msgstr "smí být zobrazen jako „/homes/bfox/bin“. Příznak -v způsobí, že"

#~ msgid "causes `dirs' to print the directory stack with one entry per line,"
#~ msgstr "„dirs“ vypíše zásobník adresářů záznam po záznamu na samostatné řádky"

#~ msgid "prepending the directory name with its position in the stack.  The -p"
#~ msgstr "a před název adresáře uvede jeho pořadí v zásobníku. Příznak -p"

#~ msgid "flag does the same thing, but the stack position is not prepended."
#~ msgstr "dělá to samé, ale bez informace o umístění na zásobníku."

#~ msgid "The -c flag clears the directory stack by deleting all of the elements."
#~ msgstr "Příznak -c vyprázdní zásobník smazáním všem prvků."

#~ msgid "+N   displays the Nth entry counting from the left of the list shown by"
#~ msgstr "+N   zobrazí N. položku počítáno zleva na seznamu, který by ukázal"

#~ msgid "     dirs when invoked without options, starting with zero."
#~ msgstr "     příkaz dirs bez jakýchkoliv přepínačů, počítáno od nuly."

#~ msgid "-N   displays the Nth entry counting from the right of the list shown by"
#~ msgstr "-N   zobrazí N. položku počítáno zprava na seznamu, který by ukázal"

#~ msgid "Adds a directory to the top of the directory stack, or rotates"
#~ msgstr "Přidá adresář na vrchol zásobníku adresářů, nebo rotuje zásobník tak,"

#~ msgid "the stack, making the new top of the stack the current working"
#~ msgstr "že nový vrchol zásobníku se stane pracovním adresářem."

#~ msgid "directory.  With no arguments, exchanges the top two directories."
#~ msgstr "Bez argumentů prohodí horní dva adresáře."

#~ msgid "+N   Rotates the stack so that the Nth directory (counting"
#~ msgstr "+N   Zrotuje zásobník tak, že N. adresář (počítáno"

#~ msgid "     from the left of the list shown by `dirs', starting with"
#~ msgstr "     zleva seznamu, který by ukázal „dirs“, počínaje od"

#~ msgid "     zero) is at the top."
#~ msgstr "     nuly) se dostane na vrchol."

#~ msgid "-N   Rotates the stack so that the Nth directory (counting"
#~ msgstr "-N   Zrotuje zásobník tak, že N. adresář (počítáno"

#~ msgid "     from the right of the list shown by `dirs', starting with"
#~ msgstr "     zprava seznamu, který by ukázal „dirs“, počínaje od"

#~ msgid "-n   suppress the normal change of directory when adding directories"
#~ msgstr "-n   potlačí obvyklou změnu pracovního adresáře při přidávání adresářů"

#~ msgid "     to the stack, so only the stack is manipulated."
#~ msgstr "     na zásobník, takže se změní jen obsah zásobníku."

#~ msgid "dir  adds DIR to the directory stack at the top, making it the"
#~ msgstr "adr  přidá ADR na vrchol zásobníku adresářů a učiní jej"

#~ msgid "     new current working directory."
#~ msgstr "     novým pracovním adresářem."

#~ msgid "You can see the directory stack with the `dirs' command."
#~ msgstr "Zásobník adresářů si lze prohlédnout příkazem „dirs“."

#~ msgid "Removes entries from the directory stack.  With no arguments,"
#~ msgstr "Odstraní položky ze zásobníku adresářů. Bez argumentů"

#~ msgid "removes the top directory from the stack, and cd's to the new"
#~ msgstr "odstraní adresář z vrcholu zásobníku a přepne se do nového"

#~ msgid "+N   removes the Nth entry counting from the left of the list"
#~ msgstr "+N   odstraní N. položku počítáno zleva na seznamu,"

#~ msgid "     shown by `dirs', starting with zero.  For example: `popd +0'"
#~ msgstr "     který by ukázal „dirs“, počínaje nulou. Například „popd +0“"

#~ msgid "     removes the first directory, `popd +1' the second."
#~ msgstr "     odstraní první adresář, „popd +1“ druhý."

#~ msgid "-N   removes the Nth entry counting from the right of the list"
#~ msgstr "-N   odstraní N. položku počítáno zprava na seznamu,"

#~ msgid "     shown by `dirs', starting with zero.  For example: `popd -0'"
#~ msgstr "     který by ukázal „dirs“, počínaje nulou. Například: „popd -0“"

#~ msgid "     removes the last directory, `popd -1' the next to last."
#~ msgstr "     odstraní poslední adresář, “popd -1“ předposlední."

#~ msgid "-n   suppress the normal change of directory when removing directories"
#~ msgstr "-n   potlačí obvyklou změnu pracovního adresáře při odebírání adresářů"

#~ msgid "     from the stack, so only the stack is manipulated."
#~ msgstr "     ze zásobníku, takže pouze zásobník dozná změny."

#~ msgid "allocated"
#~ msgstr "alokováno"

#~ msgid "freed"
#~ msgstr "uvolněno"

#~ msgid "requesting resize"
#~ msgstr "požadující velikost"

#~ msgid "just resized"
#~ msgstr "právě změněna velikost"

#~ msgid "bug: unknown operation"
#~ msgstr "chyba: neznámá operace"

#~ msgid "malloc: watch alert: %p %s "
#~ msgstr "malloc: výstraha sledování: %p %s"

#~ msgid ""
#~ "Exit from within a FOR, WHILE or UNTIL loop.  If N is specified,\n"
#~ "    break N levels."
#~ msgstr "Ukončí smyčku FOR, WHILE nebo UNTIL. Je-li zadáno N, ukončí N úrovní."

#~ msgid ""
#~ "Run a shell builtin.  This is useful when you wish to rename a\n"
#~ "    shell builtin to be a function, but need the functionality of the\n"
#~ "    builtin within the function itself."
#~ msgstr ""
#~ "Spustí vestavěný příkaz shellu. Toto se hodí, přejete-li si přejmenovat\n"
#~ "    vestavěný příkaz na funkci, avšak funkcionalitu vestavěného příkazu\n"
#~ "    potřebujete v téže funkci."

#~ msgid ""
#~ "Print the current working directory.  With the -P option, pwd prints\n"
#~ "    the physical directory, without any symbolic links; the -L option\n"
#~ "    makes pwd follow symbolic links."
#~ msgstr ""
#~ "Vypíše současný pracovní adresář. S přepínačem -P vypíše pwd fyzický\n"
#~ "    adresář prostý všech symbolický odkazů; přepínač -L přinutí pwd\n"
#~ "    následovat symbolické odkazy."

#~ msgid "Return a successful result."
#~ msgstr "Vrací výsledek úspěchu."

#~ msgid ""
#~ "Runs COMMAND with ARGS ignoring shell functions.  If you have a shell\n"
#~ "    function called `ls', and you wish to call the command `ls', you can\n"
#~ "    say \"command ls\".  If the -p option is given, a default value is used\n"
#~ "    for PATH that is guaranteed to find all of the standard utilities.  If\n"
#~ "    the -V or -v option is given, a string is printed describing COMMAND.\n"
#~ "    The -V option produces a more verbose description."
#~ msgstr ""
#~ "Spustí PŘÍKAZ s ARGUMENTY ignoruje funkce shellu. Máte-li shellovou\n"
#~ "    funkci pojmenovanou „ls“, a chcete-li zavolat příkaz „ls“, použijte\n"
#~ "    „command ls“. Je-li zadán přepínač -p, bude pro PATH použita implicitní\n"
#~ "    hodnota, která zaručuje, že budou nalezeny všechny standardní nástroje.\n"
#~ "    Je-li zadán přepínač -V nebo -v, bude vytištěn řetězec popisující PŘÍKAZ.\n"
#~ "    Přepínač -V produkuje podrobnější popis."

#~ msgid ""
#~ "Declare variables and/or give them attributes.  If no NAMEs are\n"
#~ "    given, then display the values of variables instead.  The -p option\n"
#~ "    will display the attributes and values of each NAME.\n"
#~ "    \n"
#~ "    The flags are:\n"
#~ "    \n"
#~ "      -a\tto make NAMEs arrays (if supported)\n"
#~ "      -f\tto select from among function names only\n"
#~ "      -F\tto display function names (and line number and source file name if\n"
#~ "    \tdebugging) without definitions\n"
#~ "      -i\tto make NAMEs have the `integer' attribute\n"
#~ "      -r\tto make NAMEs readonly\n"
#~ "      -t\tto make NAMEs have the `trace' attribute\n"
#~ "      -x\tto make NAMEs export\n"
#~ "    \n"
#~ "    Variables with the integer attribute have arithmetic evaluation (see\n"
#~ "    `let') done when the variable is assigned to.\n"
#~ "    \n"
#~ "    When displaying values of variables, -f displays a function's name\n"
#~ "    and definition.  The -F option restricts the display to function\n"
#~ "    name only.\n"
#~ "    \n"
#~ "    Using `+' instead of `-' turns off the given attribute instead.  When\n"
#~ "    used in a function, makes NAMEs local, as with the `local' command."
#~ msgstr ""
#~ "Deklaruje proměnné a/nebo jim nastaví atributy. Nejsou-li zadány NÁZVY,\n"
#~ "    tak místo toho zobrazí hodnoty proměnných. Přepínač -p zobrazí atributy\n"
#~ "    a hodnoty pro každý NÁZEV.\n"
#~ "    \n"
#~ "    Příznaky jsou:\n"
#~ "    \n"
#~ "      -a\tučiní NÁZVY poli (je-li podporováno)\n"
#~ "      -f\tvybírá pouze mezi názvy funkcí\n"
#~ "      -F\tzobrazí názvy funkcí (a číslo řádku a název zdrojového souboru,\n"
#~ "        \tje-li zapnuto ladění) bez definic\n"
#~ "      -i\tpřiřadí NÁZVŮM atribut „integer“ (číslo)\n"
#~ "      -r\tučiní NÁZVY jen pro čtení\n"
#~ "      -t\tpřiřadí NÁZVŮM atribut „trace“ (sledování)\n"
#~ "      -x\tvyexportuje NÁZVY\n"
#~ "    \n"
#~ "    Proměnné s atributem integer jsou aritmeticky vyhodnoceny (vizte „let“),\n"
#~ "    když je do proměnné přiřazováno.\n"
#~ "    \n"
#~ "    Při zobrazování hodnot proměnných -f zobrazí názvy a definice funkcí.\n"
#~ "    Přepínač -F omezí výpis jen na názvy funkcí.\n"
#~ "    \n"
#~ "    Pomocí „+“ namísto „-“ daný atribut odeberete. Je-li použito uvnitř\n"
#~ "    funkce, učiní NÁZVY lokální stejně jako příkaz „local“."

#~ msgid "Obsolete.  See `declare'."
#~ msgstr "Zastaralé. Vizte „declare“."

#~ msgid ""
#~ "Create a local variable called NAME, and give it VALUE.  LOCAL\n"
#~ "    can only be used within a function; it makes the variable NAME\n"
#~ "    have a visible scope restricted to that function and its children."
#~ msgstr ""
#~ "Vytvoří lokální proměnnou pojmenovanou NÁZEV a přiřadí jí HODNOTU.\n"
#~ "    LOCAL smí být použito jen uvnitř funkcí. Učiní proměnnou NÁZEV viditelnou\n"
#~ "    jen v dané funkci a jejích potomcích."

#~ msgid "Output the ARGs.  If -n is specified, the trailing newline is suppressed."
#~ msgstr "Vypíše ARGUMENTY. Je-li zadáni -n, závěrečný konec řádku bude potlačen."

#~ msgid ""
#~ "Enable and disable builtin shell commands.  This allows\n"
#~ "    you to use a disk command which has the same name as a shell\n"
#~ "    builtin without specifying a full pathname.  If -n is used, the\n"
#~ "    NAMEs become disabled; otherwise NAMEs are enabled.  For example,\n"
#~ "    to use the `test' found in $PATH instead of the shell builtin\n"
#~ "    version, type `enable -n test'.  On systems supporting dynamic\n"
#~ "    loading, the -f option may be used to load new builtins from the\n"
#~ "    shared object FILENAME.  The -d option will delete a builtin\n"
#~ "    previously loaded with -f.  If no non-option names are given, or\n"
#~ "    the -p option is supplied, a list of builtins is printed.  The\n"
#~ "    -a option means to print every builtin with an indication of whether\n"
#~ "    or not it is enabled.  The -s option restricts the output to the POSIX.2\n"
#~ "    `special' builtins.  The -n option displays a list of all disabled builtins."
#~ msgstr ""
#~ "Povolí nebo zakáže vestavěný příkaz shellu. To vám umožňuje použít\n"
#~ "    příkaz z disku, který má stejné jméno jako vestavěný příkaz shellu, aniž\n"
#~ "    byste museli zadávat celou cestu. Je-li použito -n, NÁZVY se stanou\n"
#~ "    zakázanými, jinak budou povoleny. Například „test“ z PATH namísto verze\n"
#~ "    vestavěné do shellu lze používat tak, že napíšete „enable -n test“. Na\n"
#~ "    systémech podporujících dynamické zavádění přepínač -f může být použit\n"
#~ "    pro zavedení nových vestavěných příkazů ze sdíleného objektu NÁZEV_SOUBORU.\n"
#~ "    Přepínač -d odstraní vestavěný příkaz zavedený přes -f. Není-li zadán\n"
#~ "    žádný přepínač nebo je-li zadán přepínač -p, bude vypsán seznam vestavěných\n"
#~ "    příkazů. Přepínač -a znamená, že budou vypsány všechny vestavěné příkazy a\n"
#~ "    u každého bude vyznačeno, zda je povolen nebo zakázán. Přepínač -s omezí\n"
#~ "    výpis na příkazy uvedené v POSIX.2. Přepínač -n zobrazí seznam všech\n"
#~ "    zakázaných vestavěných příkazů."

#~ msgid "Read ARGs as input to the shell and execute the resulting command(s)."
#~ msgstr "Načte ARGUMENTY jako vstup shellu a výsledný příkaz(y) provede."

#~ msgid ""
#~ "Exec FILE, replacing this shell with the specified program.\n"
#~ "    If FILE is not specified, the redirections take effect in this\n"
#~ "    shell.  If the first argument is `-l', then place a dash in the\n"
#~ "    zeroth arg passed to FILE, as login does.  If the `-c' option\n"
#~ "    is supplied, FILE is executed with a null environment.  The `-a'\n"
#~ "    option means to make set argv[0] of the executed process to NAME.\n"
#~ "    If the file cannot be executed and the shell is not interactive,\n"
#~ "    then the shell exits, unless the shell option `execfail' is set."
#~ msgstr ""
#~ "Provede SOUBOR, přičemž nahradí tento shell zadaným programem.\n"
#~ "    Není-li SOUBOR zadán, přesměrování zapůsobí v tomto shellu. Je-li prvním\n"
#~ "    argumentem „-l“, bude do nultého argumentu SOUBORU umístěna pomlčka tak,\n"
#~ "    jak to dělá login. Je-li zadán přepínač „-c“, bude SOUBOR spuštěn\n"
#~ "    s prázdným prostředím. Přepínač „-a“ znamená, že argv[0] prováděného\n"
#~ "    procesu bude nastaven na NÁZEV. Pokud soubor nemůže být proveden a shell\n"
#~ "    není interaktivní, pak shell bude ukončen, pokud přepínač shellu\n"
#~ "    „execfail“ není nastaven."

#~ msgid "Logout of a login shell."
#~ msgstr "Odhlásí z přihlašovacího (login) shellu."

#~ msgid ""
#~ "For each NAME, the full pathname of the command is determined and\n"
#~ "    remembered.  If the -p option is supplied, PATHNAME is used as the\n"
#~ "    full pathname of NAME, and no path search is performed.  The -r\n"
#~ "    option causes the shell to forget all remembered locations.  The -d\n"
#~ "    option causes the shell to forget the remembered location of each NAME.\n"
#~ "    If the -t option is supplied the full pathname to which each NAME\n"
#~ "    corresponds is printed.  If multiple NAME arguments are supplied with\n"
#~ "    -t, the NAME is printed before the hashed full pathname.  The -l option\n"
#~ "    causes output to be displayed in a format that may be reused as input.\n"
#~ "    If no arguments are given, information about remembered commands is displayed."
#~ msgstr ""
#~ "Pro každý NÁZEV je určena plná cesta k příkazu a je zapamatována.\n"
#~ "    Za použití přepínače -p se vezme NÁZEV_CESTY za plnou cestu k NÁZVU a\n"
#~ "    žádné vyhledávání cesty se nekoná. Přepínač -r způsobí, že shell zapomene\n"
#~ "    všechny zapamatovaná umístění. Přepínač -d způsobí, že shell zapomene\n"
#~ "    zapamatovaná umístění každého NÁZVU. Je-li zadán přepínač -t, bude vypsána\n"
#~ "    plná cesta ke každému NÁZVU. Je-li s -t zadáno více NÁZVŮ, NÁZEV bude\n"
#~ "    vypsán před uloženou celou cestou. Přepínač -l vytvoří takový výstup,\n"
#~ "    který lze opět použít jako vstup. Nejsou-li zadány žádné argumenty,\n"
#~ "    budou vypsány informace o zapamatovaných příkazech."

#~ msgid ""
#~ "Display helpful information about builtin commands.  If PATTERN is\n"
#~ "    specified, gives detailed help on all commands matching PATTERN,\n"
#~ "    otherwise a list of the builtins is printed.  The -s option\n"
#~ "    restricts the output for each builtin command matching PATTERN to\n"
#~ "    a short usage synopsis."
#~ msgstr ""
#~ "Zobrazí užitečné informace o vestavěných příkazech. Je-li zadán VZOREK,\n"
#~ "    vrátí podrobnou nápovědu ke všem příkazům odpovídajícím VZORKU, jinak je\n"
#~ "    vytištěn seznam vestavěných příkazů. Přepínač -s omezí výstup o každém\n"
#~ "    vestavěném příkazu odpovídajícího VZORKU na stručný popis použití."

#~ msgid ""
#~ "By default, removes each JOBSPEC argument from the table of active jobs.\n"
#~ "    If the -h option is given, the job is not removed from the table, but is\n"
#~ "    marked so that SIGHUP is not sent to the job if the shell receives a\n"
#~ "    SIGHUP.  The -a option, when JOBSPEC is not supplied, means to remove all\n"
#~ "    jobs from the job table; the -r option means to remove only running jobs."
#~ msgstr ""
#~ "Implicitně odstraní každý argument ÚLOHA z tabulky aktivních úloh. Je-li\n"
#~ "    zadán přepínač -h, úloha není odstraněna z tabulky, ale je označena tak.\n"
#~ "    že úloze nebude zaslán SIGHUP, když shell obdrží SIGHUP. Přepínač -a,\n"
#~ "    pokud není uvedena ÚLOHA, znamená, že všechny úlohy budou odstraněny\n"
#~ "    z tabulky úloh. Přepínač -r znamená, že pouze běžící úlohy budou\n"
#~ "    odstraněny."

#~ msgid ""
#~ "Causes a function to exit with the return value specified by N.  If N\n"
#~ "    is omitted, the return status is that of the last command."
#~ msgstr ""
#~ "Způsobí ukončení funkce s návratovou hodnotou uvedenou v N. Je-li\n"
#~ "    N vynecháno, návratový kód je roven poslednímu příkazu."

#~ msgid ""
#~ "For each NAME, remove the corresponding variable or function.  Given\n"
#~ "    the `-v', unset will only act on variables.  Given the `-f' flag,\n"
#~ "    unset will only act on functions.  With neither flag, unset first\n"
#~ "    tries to unset a variable, and if that fails, then tries to unset a\n"
#~ "    function.  Some variables cannot be unset; also see readonly."
#~ msgstr ""
#~ "Pro každé JMÉNO odstraní odpovídající proměnnou nebo funkci.\n"
#~ "    Spolu s „-v“ bude unset fungovat jen na proměnné. S příznakem „-f“ bude\n"
#~ "    unset fungovat jen na funkce. Bez těchto dvou příznaků unset nejprve zkusí\n"
#~ "    zrušit proměnnou a pokud toto selže, tak zkusí zrušit funkci. Některé\n"
#~ "    proměnné nelze odstranit. Taktéž vizte příkaz „readonly“."

#~ msgid ""
#~ "NAMEs are marked for automatic export to the environment of\n"
#~ "    subsequently executed commands.  If the -f option is given,\n"
#~ "    the NAMEs refer to functions.  If no NAMEs are given, or if `-p'\n"
#~ "    is given, a list of all names that are exported in this shell is\n"
#~ "    printed.  An argument of `-n' says to remove the export property\n"
#~ "    from subsequent NAMEs.  An argument of `--' disables further option\n"
#~ "    processing."
#~ msgstr ""
#~ "NÁZVY jsou označeny pro automatické exportování do prostředí následně\n"
#~ "    prováděných příkazů. Je-li zadán přepínač -f, NÁZVY se vztahují k funkcím.\n"
#~ "    Nejsou-li zadány žádné NÁZVY nebo je-li zadáno „-p“, bude vytištěn seznam\n"
#~ "    všech názvů, které jsou v tomto shellu exportovány. Argument „-n“ nařizuje\n"
#~ "    odstranit vlastnost exportovat z následujících NÁZVŮ. Argument „--“\n"
#~ "    zakazuje zpracování dalších přepínačů."

#~ msgid ""
#~ "The given NAMEs are marked readonly and the values of these NAMEs may\n"
#~ "    not be changed by subsequent assignment.  If the -f option is given,\n"
#~ "    then functions corresponding to the NAMEs are so marked.  If no\n"
#~ "    arguments are given, or if `-p' is given, a list of all readonly names\n"
#~ "    is printed.  The `-a' option means to treat each NAME as\n"
#~ "    an array variable.  An argument of `--' disables further option\n"
#~ "    processing."
#~ msgstr ""
#~ "Zadané NÁZVY budou označeny jako jen pro čtení a hodnoty těchto NÁZVŮ\n"
#~ "    nebude možné změnit následným přiřazením. Je-li zadán přepínač -f, pak\n"
#~ "    funkce těchto NÁZVŮ budou takto označeny. Nejsou-li zadány žádné argumenty\n"
#~ "    nebo je-li zadáno „-p“, bude vytištěn seznam všech jmen jen pro čtení.\n"
#~ "    Přepínač „-a“ znamená, že s každým NÁZVEM bude zacházeno jako s proměnnou\n"
#~ "    typu pole. Argument „--“ zakáže zpracování dalších přepínačů."

#~ msgid ""
#~ "The positional parameters from $N+1 ... are renamed to $1 ...  If N is\n"
#~ "    not given, it is assumed to be 1."
#~ msgstr ""
#~ "Poziční parametry budou přejmenovány z $N+1 na $1 atd. Není-li N zadáno,\n"
#~ "    předpokládá se 1."

#~ msgid ""
#~ "Suspend the execution of this shell until it receives a SIGCONT\n"
#~ "    signal.  The `-f' if specified says not to complain about this\n"
#~ "    being a login shell if it is; just suspend anyway."
#~ msgstr ""
#~ "Pozastaví provádění tohoto shellu do doby, něž bude obdržen signál\n"
#~ "    SIGCONT. „-f“, je-li zadán, potlačí stížnost na to, že se jedná\n"
#~ "    o přihlašovací shell (pokud tomu tak je), a prostě pozastaví činnost."

#~ msgid ""
#~ "Print the accumulated user and system times for processes run from\n"
#~ "    the shell."
#~ msgstr ""
#~ "Vypíše celkovou dobu procesu spuštěného z shellu, kterou strávil\n"
#~ "    v uživatelském a jaderném (system) prostoru."

#~ msgid ""
#~ "For each NAME, indicate how it would be interpreted if used as a\n"
#~ "    command name.\n"
#~ "    \n"
#~ "    If the -t option is used, `type' outputs a single word which is one of\n"
#~ "    `alias', `keyword', `function', `builtin', `file' or `', if NAME is an\n"
#~ "    alias, shell reserved word, shell function, shell builtin, disk file,\n"
#~ "    or unfound, respectively.\n"
#~ "    \n"
#~ "    If the -p flag is used, `type' either returns the name of the disk\n"
#~ "    file that would be executed, or nothing if `type -t NAME' would not\n"
#~ "    return `file'.\n"
#~ "    \n"
#~ "    If the -a flag is used, `type' displays all of the places that contain\n"
#~ "    an executable named `file'.  This includes aliases, builtins, and\n"
#~ "    functions, if and only if the -p flag is not also used.\n"
#~ "    \n"
#~ "    The -f flag suppresses shell function lookup.\n"
#~ "    \n"
#~ "    The -P flag forces a PATH search for each NAME, even if it is an alias,\n"
#~ "    builtin, or function, and returns the name of the disk file that would\n"
#~ "    be executed."
#~ msgstr ""
#~ "O každém NÁZVU řekne, jak by byl interpretován, kdyby byl použit jako\n"
#~ "    název příkazu.\n"
#~ "    \n"
#~ "    Je-li použit přepínač -t, „type“ vypíše jedno slovo z těchto: „alias“,\n"
#~ "    „keyword“, „function“, „builtin“, „file“ nebo „“, je-li NÁZEV alias,\n"
#~ "    klíčové slovo shellu, shellová funkce, vestavěný příkaz shellu, soubor\n"
#~ "    na disku nebo nenalezený soubor.\n"
#~ "    \n"
#~ "    Je-li použit přepínač -p, „type“ buď vrátí jméno souboru na disku, který\n"
#~ "    by byl spuštěn, nebo nic, pokud „type -t NÁZEV“ by nevrátil „file“.\n"
#~ "    \n"
#~ "    Je-li použit přepínač -a, „type“ zobrazí všechna místa, kde se nalézá\n"
#~ "    spustitelný program pojmenovaný „soubor“. To zahrnuje aliasy, vestavěné\n"
#~ "    příkazy a funkce jen a pouze tehdy, když není rovněž použit přepínač -p.\n"
#~ "    \n"
#~ "    Přepínač -f potlačí hledání mezi funkcemi shellu.\n"
#~ "    \n"
#~ "    Přepínač -P vynutí prohledání PATH na každý NÁZEV, dokonce i když se\n"
#~ "    jedná o alias, vestavěný příkaz nebo funkci, a vrátí název souboru na\n"
#~ "    disku, který by byl spuštěn."

#~ msgid ""
#~ "The user file-creation mask is set to MODE.  If MODE is omitted, or if\n"
#~ "    `-S' is supplied, the current value of the mask is printed.  The `-S'\n"
#~ "    option makes the output symbolic; otherwise an octal number is output.\n"
#~ "    If `-p' is supplied, and MODE is omitted, the output is in a form\n"
#~ "    that may be used as input.  If MODE begins with a digit, it is\n"
#~ "    interpreted as an octal number, otherwise it is a symbolic mode string\n"
#~ "    like that accepted by chmod(1)."
#~ msgstr ""
#~ "Uživatelská maska práv vytvářených souborů je nastavena na MÓD. Je-li\n"
#~ "    MÓD vynechán nebo je-li uvedeno „-S“, bude vytištěna současná hodnota\n"
#~ "    masky. Přepínač „-S“ učiní výstup symbolický, jinak bude výstupem\n"
#~ "    osmičkové číslo. Je-li zadáno „-p“ a MÓD je vynechán, bude výstup ve\n"
#~ "    formátu, který lze použít jako vstup. Začíná-li MÓD číslicí, bude\n"
#~ "    interpretován jako osmičkové číslo, jinak jako řetězec symbolického zápisu\n"
#~ "    práv tak, jak jej chápe chmod(1)."

#~ msgid ""
#~ "Wait for the specified process and report its termination status.  If\n"
#~ "    N is not given, all currently active child processes are waited for,\n"
#~ "    and the return code is zero.  N is a process ID; if it is not given,\n"
#~ "    all child processes of the shell are waited for."
#~ msgstr ""
#~ "Počká na zadaný proces a nahlásí jeho návratový kód. Není-li N zadáno,\n"
#~ "    bude se čekat na všechny právě aktivní procesy potomků a návratová hodnota\n"
#~ "    bude nula. N je ID procesu. Není-li zadáno, bude se čekat na všechny\n"
#~ "    procesy potomků tohoto shellu."

#~ msgid ""
#~ "Create a simple command invoked by NAME which runs COMMANDS.\n"
#~ "    Arguments on the command line along with NAME are passed to the\n"
#~ "    function as $0 .. $n."
#~ msgstr ""
#~ "Vytvoří jednoduchý příkaz volaný JMÉNEM, který spustí PŘÍKAZY. Argumenty\n"
#~ "    z příkazové řádky spolu se JMÉNEM budou předány do funkce jako $0…$n."

#~ msgid ""
#~ "Toggle the values of variables controlling optional behavior.\n"
#~ "    The -s flag means to enable (set) each OPTNAME; the -u flag\n"
#~ "    unsets each OPTNAME.  The -q flag suppresses output; the exit\n"
#~ "    status indicates whether each OPTNAME is set or unset.  The -o\n"
#~ "    option restricts the OPTNAMEs to those defined for use with\n"
#~ "    `set -o'.  With no options, or with the -p option, a list of all\n"
#~ "    settable options is displayed, with an indication of whether or\n"
#~ "    not each is set."
#~ msgstr ""
#~ "Přepne hodnoty proměnných řídící volitelné chování. Přepínač -s znamená,\n"
#~ "    že se každý NÁZEV_VOLBY zapne (nastaví). Přepínač -u každý NÁZEV_VOLBY\n"
#~ "    vypne. Přepínač -q potlačí výstup. Zda je nebo není nastaven každý\n"
#~ "    NÁZEV_VOLBY, indikuje návratový kód. Přepínač -o omezí NÁZVY_VOLEB na ty,\n"
#~ "    které jsou definovány pro použití s „set -o“. Bez přepínačů nebo\n"
#~ "    s přepínačem -p je zobrazen seznam všech nastavitelných voleb včetně\n"
#~ "    indikace, zda je každá nastavena."

#~ msgid ""
#~ "For each NAME, specify how arguments are to be completed.\n"
#~ "    If the -p option is supplied, or if no options are supplied, existing\n"
#~ "    completion specifications are printed in a way that allows them to be\n"
#~ "    reused as input.  The -r option removes a completion specification for\n"
#~ "    each NAME, or, if no NAMEs are supplied, all completion specifications."
#~ msgstr ""
#~ "U každého NÁZVU sdělí, jak budou argumenty doplněny. Je-li zadán\n"
#~ "    přepínač -p nebo není-li zadán přepínač žádný, budou existující definice\n"
#~ "    doplňování vytištěny tak. že je bude možné znovu použít jako vstup.\n"
#~ "    Přepínač -r odstraní definici doplnění pro každý NÁZEV nebo chybí-li NÁZVY,\n"
#~ "    odstraní všechny definice."
