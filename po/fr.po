# Messages français pour GNU concernant bash.
# Copyright (C) 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Michel Robitaille <robitail@IRO.UMontreal.CA>, 2004
# Christophe Combelles <ccomb@free.fr>, 2008, 2009, 2010, 2011
# Frédéric Marchal <fmarchal@perso.be>, 2022
msgid ""
msgstr ""
"Project-Id-Version: bash-5.2-rc1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-11 14:50-0500\n"
"PO-Revision-Date: 2022-06-19 10:44+0200\n"
"Last-Translator: Frédéric Marchal <fmarchal@perso.be>\n"
"Language-Team: French <traduc@traduc.org>\n"
"Language: fr\n";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=2; plural=(n >= 2);\n"

#: arrayfunc.c:66
msgid "bad array subscript"
msgstr "mauvais indice de tableau"

#: arrayfunc.c:471 builtins/declare.def:709 variables.c:2242 variables.c:2268
#: variables.c:3101
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: retire l'attribut nameref"

#: arrayfunc.c:496 builtins/declare.def:868
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s : impossible de convertir un tableau indexé en associatif"

#: arrayfunc.c:777
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s : impossible d'assigner à un index non numérique"

#: arrayfunc.c:822
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s : %s : l'assignation d'un tableau associatif doit se faire avec un indice"

#: bashhist.c:455
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s : impossible de créer : %s"

#: bashline.c:4479
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command : impossible de trouver le mappage clavier pour la commande"

#: bashline.c:4637
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s : le premier caractère non vide n'est pas « \" »"

#: bashline.c:4666
#, c-format
msgid "no closing `%c' in %s"
msgstr "pas de « %c » de fermeture dans %s"

#: bashline.c:4697
#, c-format
msgid "%s: missing colon separator"
msgstr "%s : virgule de séparation manquante"

#: bashline.c:4733
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "« %s » : impossible à délier dans la commande keymap"

#: braces.c:327
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "expansion des accolades : impossible d'allouer la mémoire pour %s"

#: braces.c:406
#, c-format
msgid "brace expansion: failed to allocate memory for %u elements"
msgstr "expansion des accolades : échec lors de l'allocation mémoire pour %u éléments"

#: braces.c:451
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "expansion des accolades : échec de l'allocation mémoire pour « %s »"

#: builtins/alias.def:131 variables.c:1817
#, c-format
msgid "`%s': invalid alias name"
msgstr "« %s » : nom d'alias non valable"

#: builtins/bind.def:122 builtins/bind.def:125
msgid "line editing not enabled"
msgstr "édition de ligne non activée"

#: builtins/bind.def:212
#, c-format
msgid "`%s': invalid keymap name"
msgstr "« %s » : nom du mappage clavier invalide"

#: builtins/bind.def:252
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s : impossible de lire : %s"

#: builtins/bind.def:328 builtins/bind.def:358
#, c-format
msgid "`%s': unknown function name"
msgstr "« %s » : nom de fonction inconnu"

#: builtins/bind.def:336
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s n'est lié à aucune touche.\n"

#: builtins/bind.def:340
#, c-format
msgid "%s can be invoked via "
msgstr "%s peut être appelé via "

#: builtins/bind.def:378 builtins/bind.def:395
#, c-format
msgid "`%s': cannot unbind"
msgstr "« %s » : impossible à délier"

#: builtins/break.def:77 builtins/break.def:119
msgid "loop count"
msgstr "nombre de boucles"

#: builtins/break.def:139
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "ceci n'a un sens que dans une boucle « for », « while » ou « until »"

#: builtins/caller.def:136
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
"Renvoie le contexte de l'appel de sous-routine actuel.\n"
"    \n"
"    Sans EXPR, renvoie « $ligne $nomfichier ».  Avec EXPR,\n"
"    renvoie « $ligne $sousroutine $nomfichier »; ces informations supplémentaires\n"
"    peuvent être utilisées pour fournir une trace de la pile.\n"
"    \n"
"    La valeur de EXPR indique le nombre de cadres d'appels duquel il faut revenir en arrière\n"
"    avant le cadre actuel ; le cadre supérieur est le cadre 0."

#: builtins/cd.def:327
msgid "HOME not set"
msgstr "« HOME » non défini"

#: builtins/cd.def:335 builtins/common.c:161 test.c:916
msgid "too many arguments"
msgstr "trop d'arguments"

#: builtins/cd.def:342
msgid "null directory"
msgstr "répertoire nul"

#: builtins/cd.def:353
msgid "OLDPWD not set"
msgstr "« OLDPWD » non défini"

#: builtins/common.c:96
#, c-format
msgid "line %d: "
msgstr "ligne %d : "

#: builtins/common.c:134 error.c:264
#, c-format
msgid "warning: "
msgstr "avertissement :"

#: builtins/common.c:148
#, c-format
msgid "%s: usage: "
msgstr "%s : utilisation :"

#: builtins/common.c:193 shell.c:524 shell.c:866
#, c-format
msgid "%s: option requires an argument"
msgstr "%s : l'option nécessite un argument"

#: builtins/common.c:200
#, c-format
msgid "%s: numeric argument required"
msgstr "%s : argument numérique nécessaire"

#: builtins/common.c:207
#, c-format
msgid "%s: not found"
msgstr "%s : non trouvé"

#: builtins/common.c:216 shell.c:879
#, c-format
msgid "%s: invalid option"
msgstr "%s : option non valable"

#: builtins/common.c:223
#, c-format
msgid "%s: invalid option name"
msgstr "%s : nom d'option non valable"

#: builtins/common.c:230 execute_cmd.c:2402 general.c:368 general.c:373
#, c-format
msgid "`%s': not a valid identifier"
msgstr "« %s » : identifiant non valable"

#: builtins/common.c:240
msgid "invalid octal number"
msgstr "nombre octal non valable"

#: builtins/common.c:242
msgid "invalid hex number"
msgstr "nombre hexadécimal non valable"

#: builtins/common.c:244 expr.c:1574
msgid "invalid number"
msgstr "nombre non valable"

#: builtins/common.c:252
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s : indication de signal non valable"

#: builtins/common.c:259
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "« %s » : ce n'est pas un n° de processus ou une spécification de tâche valable"

#: builtins/common.c:266 error.c:536
#, c-format
msgid "%s: readonly variable"
msgstr "%s : variable en lecture seule"

#: builtins/common.c:273
#, c-format
msgid "%s: cannot assign"
msgstr "%s : impossible d'assigner"

#: builtins/common.c:281
#, c-format
msgid "%s: %s out of range"
msgstr "%s : %s hors plage"

#: builtins/common.c:281 builtins/common.c:283
msgid "argument"
msgstr "argument"

#: builtins/common.c:283
#, c-format
msgid "%s out of range"
msgstr "%s hors plage"

#: builtins/common.c:291
#, c-format
msgid "%s: no such job"
msgstr "%s : tâche inexistante"

#: builtins/common.c:299
#, c-format
msgid "%s: no job control"
msgstr "%s : pas de contrôle de tâche"

#: builtins/common.c:301
msgid "no job control"
msgstr "pas de contrôle de tâche"

#: builtins/common.c:311
#, c-format
msgid "%s: restricted"
msgstr "%s : restreint"

#: builtins/common.c:313
msgid "restricted"
msgstr "restreint"

#: builtins/common.c:321
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s : ceci n'est pas une primitive du shell"

#: builtins/common.c:330
#, c-format
msgid "write error: %s"
msgstr "erreur d'écriture : %s"

#: builtins/common.c:338
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "erreur lors de la définition de l'attribut du terminal : %s"

#: builtins/common.c:340
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "erreur lors de la récupération de l'attribut du terminal : %s"

#: builtins/common.c:642
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s : erreur de détermination du répertoire actuel : %s : %s\n"

#: builtins/common.c:708 builtins/common.c:710
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s : spécification de tâche ambiguë"

#: builtins/common.c:971
msgid "help not available in this version"
msgstr "l'aide n'est pas disponible dans cette version"

#: builtins/common.c:1038 builtins/set.def:953 variables.c:3825
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s : « unset » impossible : %s est en lecture seule"

#: builtins/common.c:1043 builtins/set.def:932 variables.c:3830
#, c-format
msgid "%s: cannot unset"
msgstr "%s : « unset » impossible"

#: builtins/complete.def:287
#, c-format
msgid "%s: invalid action name"
msgstr "%s : nom d'action non valable"

#: builtins/complete.def:486 builtins/complete.def:642
#: builtins/complete.def:873
#, c-format
msgid "%s: no completion specification"
msgstr "%s : pas d'indication de complètement"

#: builtins/complete.def:696
msgid "warning: -F option may not work as you expect"
msgstr "avertissement : l'option « -F » peut fonctionner différemment de ce à quoi vous vous attendez"

#: builtins/complete.def:698
msgid "warning: -C option may not work as you expect"
msgstr "avertissement : l'option « -C » peut fonctionner différemment de ce à quoi vous vous attendez"

#: builtins/complete.def:846
msgid "not currently executing completion function"
msgstr "fonction de complétion actuellement non en cours d'exécution"

#: builtins/declare.def:137
msgid "can only be used in a function"
msgstr "utilisable seulement dans une fonction"

#: builtins/declare.def:437
msgid "cannot use `-f' to make functions"
msgstr "« -f » ne peut pas être utilisé pour fabriquer des fonctions"

#: builtins/declare.def:464 execute_cmd.c:6132
#, c-format
msgid "%s: readonly function"
msgstr "%s : fonction en lecture seule"

#: builtins/declare.def:521 builtins/declare.def:804
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s : la variable de référence ne peut pas être un tableau"

#: builtins/declare.def:532 variables.c:3359
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s : références bouclées sur la même variable interdites"

#: builtins/declare.def:537 variables.c:2072 variables.c:3278 variables.c:3286
#: variables.c:3356
#, c-format
msgid "%s: circular name reference"
msgstr "%s : référence de nom circulaire"

#: builtins/declare.def:541 builtins/declare.def:811 builtins/declare.def:820
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "« %s » : nom de variable invalide pour une référence de nom"

#: builtins/declare.def:856
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s : impossible de détruire des variables tableaux de cette façon"

#: builtins/declare.def:862 builtins/read.def:887
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s : impossible de convertir un tableau indexé en tableau associatif"

#: builtins/declare.def:891
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s : l'assignation d'un tableau composé entre apostrophes est dépréciée"

#: builtins/enable.def:145 builtins/enable.def:153
msgid "dynamic loading not available"
msgstr "chargement dynamique non disponible"

#: builtins/enable.def:376
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "impossible d'ouvrir l'objet partagé %s : %s"

#: builtins/enable.def:405
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "impossible de trouver %s dans l'objet partagé %s : %s"

#: builtins/enable.def:422
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s : la primitive dynamique a déjà été chargée"

#: builtins/enable.def:426
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "la fonction de chargement de %s retourne un échec (%d) : pas chargé"

#: builtins/enable.def:551
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s : non chargé dynamiquement"

#: builtins/enable.def:577
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s : impossible d'effacer : %s"

#: builtins/evalfile.c:138 builtins/hash.def:185 execute_cmd.c:5959
#, c-format
msgid "%s: is a directory"
msgstr "%s : ceci est un répertoire"

#: builtins/evalfile.c:144
#, c-format
msgid "%s: not a regular file"
msgstr "%s : ceci n'est pas un fichier régulier"

#: builtins/evalfile.c:153
#, c-format
msgid "%s: file is too large"
msgstr "%s : le fichier est trop grand"

#: builtins/evalfile.c:188 builtins/evalfile.c:206 shell.c:1673
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s : ne peut exécuter le fichier binaire"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:246
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s : impossible d'exécuter : %s"

#: builtins/exit.def:64
#, c-format
msgid "logout\n"
msgstr "déconnexion\n"

#: builtins/exit.def:89
msgid "not login shell: use `exit'"
msgstr "ce n'est pas un shell de connexion : utilisez « exit »"

#: builtins/exit.def:121
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Il y a des tâches stoppées.\n"

#: builtins/exit.def:123
#, c-format
msgid "There are running jobs.\n"
msgstr "Il y a des tâches en cours d'exécution.\n"

#: builtins/fc.def:275 builtins/fc.def:373 builtins/fc.def:417
msgid "no command found"
msgstr "aucune commande trouvée"

#: builtins/fc.def:363 builtins/fc.def:368 builtins/fc.def:407
#: builtins/fc.def:412
msgid "history specification"
msgstr "indication d'historique"

#: builtins/fc.def:444
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s : impossible d'ouvrir le fichier temporaire : %s"

#: builtins/fg_bg.def:152 builtins/jobs.def:284
msgid "current"
msgstr "courant"

#: builtins/fg_bg.def:161
#, c-format
msgid "job %d started without job control"
msgstr "tâche %d démarrée sans contrôle de tâche"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s : option non permise -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s : l'option nécessite un argument -- %c\n"

#: builtins/hash.def:91
msgid "hashing disabled"
msgstr "hachage désactivé"

#: builtins/hash.def:139
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s : table de hachage vide\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "occurrences\tcommande\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Commandes du shell correspondant au mot-clé « "
msgstr[1] "Commandes du shell correspondant aux mots-clés « "

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"'\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid "no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr "Aucune rubrique d'aide ne correspond à « %s ». Essayez « help help », « man -k %s » ou « info %s »."

#: builtins/help.def:223
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s : impossible d'ouvrir : %s"

#: builtins/help.def:523
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Ces commandes de shell sont définies de manière interne. Saisissez « help » pour voir cette liste.\n"
"Tapez « help nom » pour en savoir plus sur la fonction qui s'appelle « nom ».\n"
"Utilisez « info bash » pour en savoir plus sur le shell en général.\n"
"Utilisez « man -k » ou « info » pour en savoir plus sur les commandes qui\n"
"ne font pas partie de cette liste.\n"
"\n"
"Une astérisque (*) à côté d'un nom signifie que la commande est désactivée.\n"
"\n"

#: builtins/history.def:159
msgid "cannot use more than one of -anrw"
msgstr "impossible d'utiliser plus d'une option parmi « -anrw »"

#: builtins/history.def:192 builtins/history.def:204 builtins/history.def:215
#: builtins/history.def:228 builtins/history.def:240 builtins/history.def:247
msgid "history position"
msgstr "position dans l'historique"

#: builtins/history.def:338
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s : horodatage non valable"

#: builtins/history.def:449
#, c-format
msgid "%s: history expansion failed"
msgstr "%s : l'expansion de l'historique a échoué"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s : « inlib » a échoué"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "pas d'autre option permise avec « -x »"

#: builtins/kill.def:211
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s : les arguments doivent être des identifiants de tâche ou de processus"

#: builtins/kill.def:274
msgid "Unknown error"
msgstr "Erreur inconnue"

#: builtins/let.def:97 builtins/let.def:122 expr.c:640 expr.c:658
msgid "expression expected"
msgstr "une expression est attendue"

#: builtins/mapfile.def:180
#, c-format
msgid "%s: not an indexed array"
msgstr "%s : n'est pas un tableau indexé"

#: builtins/mapfile.def:276 builtins/read.def:336
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s : spécification de descripteur de fichier non valable"

#: builtins/mapfile.def:284 builtins/read.def:343
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d : descripteur de fichier non valable : %s"

#: builtins/mapfile.def:293 builtins/mapfile.def:331
#, c-format
msgid "%s: invalid line count"
msgstr "%s : nombre de lignes non valable"

#: builtins/mapfile.def:304
#, c-format
msgid "%s: invalid array origin"
msgstr "%s : origine de tableau non valable"

#: builtins/mapfile.def:321
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s : quantum de callback non valable"

#: builtins/mapfile.def:354
msgid "empty array variable name"
msgstr "nom de variable tableau vide"

#: builtins/mapfile.def:375
msgid "array variable support required"
msgstr "nécessité de prise en charge des variables tableaux"

#: builtins/printf.def:430
#, c-format
msgid "`%s': missing format character"
msgstr "« %s » : caractère de format manquant"

#: builtins/printf.def:485
#, c-format
msgid "`%c': invalid time format specification"
msgstr "« %c » : spécification de format d'heure incorrecte"

#: builtins/printf.def:708
#, c-format
msgid "`%c': invalid format character"
msgstr "« %c » : caractère de format non permis"

#: builtins/printf.def:734
#, c-format
msgid "warning: %s: %s"
msgstr "avertissement : %s: %s"

#: builtins/printf.def:822
#, c-format
msgid "format parsing problem: %s"
msgstr "problème d'analyse du format : %s"

#: builtins/printf.def:919
msgid "missing hex digit for \\x"
msgstr "chiffre hexadécimal manquant pour \\x"

#: builtins/printf.def:934
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "chiffre unicode manquant pour \\%c"

#: builtins/pushd.def:199
msgid "no other directory"
msgstr "pas d'autre répertoire"

#: builtins/pushd.def:360
#, c-format
msgid "%s: invalid argument"
msgstr "%s : argument non valable"

#: builtins/pushd.def:480
msgid "<no current directory>"
msgstr "<aucun répertoire courant>"

#: builtins/pushd.def:524
msgid "directory stack empty"
msgstr "pile de répertoire vide"

#: builtins/pushd.def:526
msgid "directory stack index"
msgstr "indice de pile de répertoire"

#: builtins/pushd.def:701
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Affiche la liste des répertoires actuellement mémorisés. Les répertoires\n"
"   sont insérés dans la liste avec la commande « pushd ». Vous pouvez remonter\n"
"   dans la liste en enlevant des éléments avec la commande « popd ».\n"
"    \n"
"     Options :\n"
"      -c\tefface la pile des répertoires en enlevant tous les éléments.\n"
"      -l\tn'affiche pas les versions raccourcies (avec ~) des répertoires\n"
"    \trelativement à votre répertoire personnel\n"
"      -p\taffiche la pile des répertoires avec un élément par ligne\n"
"      -v\taffiche la pile des répertoires avec un élément par ligne préfixé\n"
"    \tavec la position dans la pile\n"
"    \n"
"    Arguments :\n"
"    +N\tAffiche le Nième élément en comptant de zéro depuis la gauche de la\n"
"    liste affichée par « dirs » lorsque celle-ci est appelée sans option.\n"
"    \n"
"    -N\tAffiche le Nième élément en comptant de zéro depuis la droite de la\n"
"    liste affichée par « dirs » lorsque celle-ci est appelée sans option."

#: builtins/pushd.def:723
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Ajoute un répertoire en haut de la pile des répertoires, ou permute\n"
"    la pile de façon que le répertoire en haut de la pile devienne\n"
"    le nouveau répertoire de travail. S'il n'y a pas d'argument, les deux\n"
"    répertoires en haut de la pile sont échangés.\n"
"    \n"
"    Options :\n"
"    -n\tNe change pas de répertoire de travail lorsque des répertoires\n"
"    \tsont ajoutés à la pile, de façon que seule la pile soit manipulée\n"
"    \n"
"    Arguments :\n"
"    +N\tPermute la pile de façon que le Nième répertoire se place en haut,\n"
"    \ten comptant de zéro depuis la gauche de la liste fournie par « dirs ».\n"
"    \n"
"    -N\tPermute la pile de façon que le Nième répertoire se place en haut,\n"
"    \ten comptant de zéro depuis la droite de la liste fournie par « dirs ».\n"
"    \n"
"      dir\tAjoute le répertoire DIR en haut de la pile, et en fait le nouveau\n"
"    \trépertoire de travail.\n"
"    \n"
"    Vous pouvez voir la pile des répertoires avec la commande « dirs »."

#: builtins/pushd.def:748
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Enlève des éléments de la pile des répertoires. S'il n'y a pas\n"
"    d'argument, le répertoire en haut de la pile est enlevé,\n"
"    et le nouveau sommet de la pile devient le répertoire de travail.\n"
"    \n"
"    Options :\n"
"    -n\tNe change pas de répertoire de travail lorsque des répertoires\n"
"    \tsont enlevés de la pile, de façon que seule la pile soit manipulée.\n"
"    \n"
"    Arguments :\n"
"    +N\tEnlève le Nième répertoire, en comptant de zéro depuis la gauche\n"
"    \tde la liste fournie par « dirs ». Par exemple : « popd +0 »\n"
"    \tenlève le premier répertoire, « popd +1 » le deuxième.\n"
"    \n"
"    -N\tEnlève le Nième répertoire, en comptant de zéro depuis la droite\n"
"    \tde la liste fournie par « dirs ». Par exemple : « popd -0 »\n"
"    \tenlève le dernier répertoire, « popd -1 » l'avant-dernier.\n"
"    \n"
"    Vous pouvez voir la pile des répertoires avec la commande « dirs »."

#: builtins/read.def:308
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s : spécification de délai d'expiration non valable"

#: builtins/read.def:827
#, c-format
msgid "read error: %d: %s"
msgstr "erreur de lecture : %d : %s"

#: builtins/return.def:68
msgid "can only `return' from a function or sourced script"
msgstr "« return » n'est possible que depuis une fonction ou depuis un script exécuté par « source »"

#: builtins/set.def:869
msgid "cannot simultaneously unset a function and a variable"
msgstr "« unset » ne peut pas s'appliquer simultanément à une fonction et à une variable"

#: builtins/set.def:969
#, c-format
msgid "%s: not an array variable"
msgstr "%s : n'est pas une variable tableau"

#: builtins/setattr.def:189
#, c-format
msgid "%s: not a function"
msgstr "%s : n'est pas une fonction"

#: builtins/setattr.def:194
#, c-format
msgid "%s: cannot export"
msgstr "%s : impossible d'exporter"

#: builtins/shift.def:72 builtins/shift.def:79
msgid "shift count"
msgstr "nombre de « shift »"

#: builtins/shopt.def:323
msgid "cannot set and unset shell options simultaneously"
msgstr "les options du shell ne peuvent pas être simultanément activées et désactivées"

#: builtins/shopt.def:444
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s : nom d'option du shell non valable"

#: builtins/source.def:128
msgid "filename argument required"
msgstr "nom de fichier nécessaire en argument"

#: builtins/source.def:154
#, c-format
msgid "%s: file not found"
msgstr "%s : fichier introuvable"

#: builtins/suspend.def:102
msgid "cannot suspend"
msgstr "suspension impossible"

#: builtins/suspend.def:112
msgid "cannot suspend a login shell"
msgstr "un shell de connexion ne peut pas être suspendu"

#: builtins/type.def:235
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s est un alias vers « %s »\n"

#: builtins/type.def:256
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s est un mot-clé du shell\n"

#: builtins/type.def:275
#, c-format
msgid "%s is a function\n"
msgstr "%s est une fonction\n"

#: builtins/type.def:299
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s est une primitive spéciale du shell\n"

#: builtins/type.def:301
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s est une primitive du shell\n"

#: builtins/type.def:323 builtins/type.def:408
#, c-format
msgid "%s is %s\n"
msgstr "%s est %s\n"

#: builtins/type.def:343
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s est haché (%s)\n"

#: builtins/ulimit.def:400
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s : argument de limite non valable"

#: builtins/ulimit.def:426
#, c-format
msgid "`%c': bad command"
msgstr "« %c » : mauvaise commande"

#: builtins/ulimit.def:464
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s : impossible d'obtenir la limite : %s"

#: builtins/ulimit.def:490
msgid "limit"
msgstr "limite"

#: builtins/ulimit.def:502 builtins/ulimit.def:802
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s : impossible de modifier la limite : %s"

#: builtins/umask.def:115
msgid "octal number"
msgstr "nombre octal"

#: builtins/umask.def:232
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "« %c » : opérateur de mode symbolique non valable"

#: builtins/umask.def:287
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "« %c » : caractère de mode symbolique non valable"

#: error.c:89 error.c:373 error.c:375 error.c:377
msgid " line "
msgstr " ligne "

#: error.c:164
#, c-format
msgid "last command: %s\n"
msgstr "dernière commande : %s\n"

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr "Annulation…"

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:287
#, c-format
msgid "INFORM: "
msgstr "INFORM : "

#: error.c:310
#, c-format
msgid "DEBUG warning: "
msgstr "avertissement de DÉBOGAGE :"

#: error.c:488
msgid "unknown command error"
msgstr "erreur de commande inconnue"

#: error.c:489
msgid "bad command type"
msgstr "mauvais type de commande"

#: error.c:490
msgid "bad connector"
msgstr "mauvais connecteur"

#: error.c:491
msgid "bad jump"
msgstr "mauvais saut"

#: error.c:529
#, c-format
msgid "%s: unbound variable"
msgstr "%s : variable sans liaison"

#: eval.c:243
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\aattente de données expirée : déconnexion automatique\n"

#: execute_cmd.c:555
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "l'entrée standard ne peut pas être redirigée depuis /dev/null : %s"

#: execute_cmd.c:1317
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT : « %c » : caractère de format non valable"

#: execute_cmd.c:2391
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr "execute_coproc: coproc [%d:%s] existe encore"

#: execute_cmd.c:2524
msgid "pipe error"
msgstr "erreur de tube"

#: execute_cmd.c:4923
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval : dépassement de la profondeur maximum d'imbrication d'évaluations (%d)"

#: execute_cmd.c:4935
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s : dépassement de la profondeur maximum d'imbrication de sources (%d)"

#: execute_cmd.c:5043
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s : dépassement de la profondeur maximum d'imbrication de fonctions (%d)"

#: execute_cmd.c:5598
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s : restriction : « / » ne peut pas être spécifié dans un nom de commande"

#: execute_cmd.c:5715
#, c-format
msgid "%s: command not found"
msgstr "%s : commande introuvable"

#: execute_cmd.c:5957
#, c-format
msgid "%s: %s"
msgstr "%s : %s"

#: execute_cmd.c:5975
#, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s : ne peut exécuter : le fichier requis n'a pas été trouvé"

#: execute_cmd.c:6000
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s : %s : mauvais interpréteur"

#: execute_cmd.c:6037
#, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s : impossible d'exécuter le fichier binaire : %s"

#: execute_cmd.c:6123
#, c-format
msgid "`%s': is a special builtin"
msgstr "« %s » : est une primitive spéciale"

#: execute_cmd.c:6175
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "impossible de dupliquer le fd %d vers le fd %d"

#: expr.c:263
msgid "expression recursion level exceeded"
msgstr "dépassement du niveau de récursivité dans l'expression"

#: expr.c:291
msgid "recursion stack underflow"
msgstr "débordement négatif de la pile de récursivité"

#: expr.c:478
msgid "syntax error in expression"
msgstr "erreur de syntaxe dans l'expression"

#: expr.c:522
msgid "attempted assignment to non-variable"
msgstr "tentative d'affectation à une non-variable"

#: expr.c:531
msgid "syntax error in variable assignment"
msgstr "erreur de syntaxe dans l'affectation d'une variable"

#: expr.c:545 expr.c:912
msgid "division by 0"
msgstr "division par 0"

#: expr.c:593
msgid "bug: bad expassign token"
msgstr "bogue : mauvais symbole pour expassign"

#: expr.c:647
msgid "`:' expected for conditional expression"
msgstr "« : » attendu pour une expression conditionnelle"

#: expr.c:973
msgid "exponent less than 0"
msgstr "exposant négatif"

#: expr.c:1030
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "identifiant attendu après un pré-incrément ou un pré-décrément"

#: expr.c:1057
msgid "missing `)'"
msgstr "« ) » manquante"

#: expr.c:1108 expr.c:1492
msgid "syntax error: operand expected"
msgstr "erreur de syntaxe : opérande attendu"

#: expr.c:1494
msgid "syntax error: invalid arithmetic operator"
msgstr "erreur de syntaxe : opérateur arithmétique non valable"

#: expr.c:1518
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s : %s (le symbole erroné est « %s »)"

#: expr.c:1578
msgid "invalid arithmetic base"
msgstr "base arithmétique non valable"

#: expr.c:1587
msgid "invalid integer constant"
msgstr "constante entière invalide"

#: expr.c:1603
msgid "value too great for base"
msgstr "valeur trop grande pour la base"

#: expr.c:1652
#, c-format
msgid "%s: expression error\n"
msgstr "%s : erreur d'expression\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd : ne peut accéder aux répertoires parents"

#: input.c:99 subst.c:6208
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "impossible de réinitialiser le mode « nodelay » pour le fd %d"

#: input.c:266
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "impossible d'allouer un nouveau descripteur de fichier pour l'entrée de bash depuis le fd %d"

#: input.c:274
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input : le tampon existe déjà pour le nouveau fd %d"

#: jobs.c:543
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline : pgrp pipe"

#: jobs.c:907
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:960
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:1279
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "le processus cloné n°%d apparaît dans la tâche en fonctionnement %d"

#: jobs.c:1397
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "suppression de la tâche stoppée %d avec le groupe de processus %ld"

#: jobs.c:1502
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process : pid %5ld (%s) signalé toujours en vie"

#: jobs.c:1839
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid : %ld : n° de processus inexistant"

#: jobs.c:1854
#, c-format
msgid "Signal %d"
msgstr "Signal %d"

#: jobs.c:1868 jobs.c:1894
msgid "Done"
msgstr "Fini"

#: jobs.c:1873 siglist.c:123
msgid "Stopped"
msgstr "Stoppé"

#: jobs.c:1877
#, c-format
msgid "Stopped(%s)"
msgstr "Stoppé(%s)"

#: jobs.c:1881
msgid "Running"
msgstr "En cours d'exécution"

#: jobs.c:1898
#, c-format
msgid "Done(%d)"
msgstr "Fini(%d)"

#: jobs.c:1900
#, c-format
msgid "Exit %d"
msgstr "Termine %d"

#: jobs.c:1903
msgid "Unknown status"
msgstr "État inconnu"

#: jobs.c:1990
#, c-format
msgid "(core dumped) "
msgstr "(core dumped)"

#: jobs.c:2009
#, c-format
msgid "  (wd: %s)"
msgstr "  (wd : %s)"

#: jobs.c:2250
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "fils setpgid (%ld à %ld)"

#: jobs.c:2608 nojobs.c:666
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait : le processus n°%ld n'est pas un fils de ce shell"

#: jobs.c:2884
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for : Aucun enregistrement du processus n°%ld"

#: jobs.c:3223
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job : la tâche %d est stoppée"

#: jobs.c:3551
#, c-format
msgid "%s: no current jobs"
msgstr "%s : pas de tâche actuelle"

#: jobs.c:3558
#, c-format
msgid "%s: job has terminated"
msgstr "%s : la tâche s'est terminée"

#: jobs.c:3567
#, c-format
msgid "%s: job %d already in background"
msgstr "%s : la tâche %d est déjà en arrière plan"

#: jobs.c:3793
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld : activation de WNOHANG pour éviter un blocage définitif"

#: jobs.c:4307
#, c-format
msgid "%s: line %d: "
msgstr "%s : ligne %d : "

#: jobs.c:4321 nojobs.c:921
#, c-format
msgid " (core dumped)"
msgstr " (core dumped)"

#: jobs.c:4333 jobs.c:4346
#, c-format
msgid "(wd now: %s)\n"
msgstr "(maintenant, wd : %s)\n"

#: jobs.c:4378
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control : getpgrp a échoué"

#: jobs.c:4434
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control : pas de contrôle de tâche en tâche de fond"

#: jobs.c:4450
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control : discipline de ligne"

#: jobs.c:4460
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control : setpgid"

#: jobs.c:4481 jobs.c:4490
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "impossible de régler le groupe de processus du terminal (%d)"

#: jobs.c:4495
msgid "no job control in this shell"
msgstr "pas de contrôle de tâche dans ce shell"

#: lib/malloc/malloc.c:367
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc : échec de l'assertion : %s\n"

#: lib/malloc/malloc.c:383
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc : %s:%d : assertion manquée\r\n"

#: lib/malloc/malloc.c:384 lib/malloc/malloc.c:941
msgid "unknown"
msgstr "inconnu"

#: lib/malloc/malloc.c:892
msgid "malloc: block on free list clobbered"
msgstr "malloc : bloc écrasé sur liste libre"

#: lib/malloc/malloc.c:980
msgid "free: called with already freed block argument"
msgstr "free : appelé avec un bloc déjà libéré comme argument"

#: lib/malloc/malloc.c:983
msgid "free: called with unallocated block argument"
msgstr "free : appelé avec un bloc non alloué comme argument"

#: lib/malloc/malloc.c:1001
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free : débordement négatif détecté ; « mh_nbytes » est hors plage"

#: lib/malloc/malloc.c:1007
msgid "free: underflow detected; magic8 corrupted"
msgstr "free : débordement négatif détecté ; « magic8 » est hors plage"

#: lib/malloc/malloc.c:1014
msgid "free: start and end chunk sizes differ"
msgstr "free : les tailles de fragment au début et à la fin sont différentes"

#: lib/malloc/malloc.c:1176
msgid "realloc: called with unallocated block argument"
msgstr "realloc : appelé avec un bloc non alloué comme argument"

#: lib/malloc/malloc.c:1191
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc : débordement négatif détecté ; « mh_nbytes » est hors plage"

#: lib/malloc/malloc.c:1197
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc : débordement négatif détecté ; « magic8 » est hors plage"

#: lib/malloc/malloc.c:1205
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc : les tailles de fragment au début et à la fin sont différentes"

#: lib/malloc/table.c:191
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc : la table d'allocation est pleine avec FIND_ALLOC ?\n"

#: lib/malloc/table.c:200
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc : %p déjà alloué selon la table ?\n"

#: lib/malloc/table.c:253
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free : %p déjà libre selon la table ?\n"

#: lib/sh/fmtulong.c:102
msgid "invalid base"
msgstr "base non valable"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s : hôte inconnu"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: service non valable"

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s : mauvaise spécification de chemin réseau"

#: lib/sh/netopen.c:347
msgid "network operations not supported"
msgstr "opérations sur le réseau non prises en charge"

#: locale.c:219
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale : LC_ALL : impossible de changer le paramètre de langue (%s)"

#: locale.c:221
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale : LC_ALL :  impossible de changer le paramètre de langue (%s) : %s"

#: locale.c:294
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale : %s : impossible de changer le paramètre de langue (%s)"

#: locale.c:296
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale : %s : impossible de changer le paramètre de langue (%s) : %s"

#: mailcheck.c:439
msgid "You have mail in $_"
msgstr "Vous avez du courrier dans $_"

#: mailcheck.c:464
msgid "You have new mail in $_"
msgstr "Vous avez du nouveau courrier dans $_"

#: mailcheck.c:480
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Le courrier dans %s a été lu\n"

#: make_cmd.c:314
msgid "syntax error: arithmetic expression required"
msgstr "erreur de syntaxe : expression arithmétique nécessaire"

#: make_cmd.c:316
msgid "syntax error: `;' unexpected"
msgstr "erreur de syntaxe : « ; » non attendu"

#: make_cmd.c:317
#, c-format
msgid "syntax error: `((%s))'"
msgstr "erreur de syntaxe : « ((%s)) »"

#: make_cmd.c:569
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document : le type d'instruction %d est incorrect"

#: make_cmd.c:668
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "« here-document » à la ligne %d délimité par la fin du fichier (au lieu de « %s »)"

#: make_cmd.c:769
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection : l'instruction de redirection « %d » est hors plage"

#: parse.y:2428
#, c-format
msgid "shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line truncated"
msgstr "shell_getc: shell_input_line_size (%zu) dépasse SIZE_MAX (%lu): ligne tronquée"

#: parse.y:2921
msgid "maximum here-document count exceeded"
msgstr "nombre maximum de documents en ligne (« here-document ») dépassé"

#: parse.y:3684 parse.y:4244 parse.y:6148
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "fin de fichier (EOF) prématurée lors de la recherche du « %c » correspondant"

#: parse.y:4452
msgid "unexpected EOF while looking for `]]'"
msgstr "fin de fichier (EOF) prématurée lors de la recherche de « ]] »"

#: parse.y:4457
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "erreur de syntaxe dans une expression conditionnelle : symbole « %s » inattendu"

#: parse.y:4461
msgid "syntax error in conditional expression"
msgstr "erreur de syntaxe dans une expression conditionnelle"

#: parse.y:4539
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "symbole inattendu « %s » au lieu de « ) »"

#: parse.y:4543
msgid "expected `)'"
msgstr "« ) » attendu"

#: parse.y:4571
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "argument inattendu « %s » pour l'opérateur conditionnel à un argument"

#: parse.y:4575
msgid "unexpected argument to conditional unary operator"
msgstr "argument inattendu pour l'opérateur conditionnel à un argument"

#: parse.y:4621
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "symbole « %s » trouvé à la place d'un opérateur binaire conditionnel"

#: parse.y:4625
msgid "conditional binary operator expected"
msgstr "opérateur binaire conditionnel attendu"

#: parse.y:4647
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "argument « %s » inattendu pour l'opérateur binaire conditionnel"

#: parse.y:4651
msgid "unexpected argument to conditional binary operator"
msgstr "argument inattendu pour l'opérateur binaire conditionnel"

#: parse.y:4662
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "symbole « %c » inattendu dans la commande conditionnelle"

#: parse.y:4665
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "symbole « %s » inattendu dans la commande conditionnelle"

#: parse.y:4669
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "symbole « %d » inattendu dans la commande conditionnelle"

#: parse.y:6118
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "erreur de syntaxe près du symbole inattendu « %s »"

#: parse.y:6137
#, c-format
msgid "syntax error near `%s'"
msgstr "erreur de syntaxe près de « %s »"

#: parse.y:6151
msgid "syntax error: unexpected end of file"
msgstr "erreur de syntaxe : fin de fichier prématurée"

#: parse.y:6151
msgid "syntax error"
msgstr "erreur de syntaxe"

#: parse.y:6216
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Utilisez « %s » pour quitter le shell.\n"

#: parse.y:6394
msgid "unexpected EOF while looking for matching `)'"
msgstr "fin de fichier (EOF) prématurée lors de la recherche d'une « ) » correspondante"

#: pcomplete.c:1132
#, c-format
msgid "completion: function `%s' not found"
msgstr "complètement : fonction « %s » non trouvée"

#: pcomplete.c:1722
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr "programmable_completion: %s: boucle de ré-essai possible"

#: pcomplib.c:182
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert : %s : NULL COMPSPEC"

#: print_cmd.c:302
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command : mauvais connecteur « %d »"

#: print_cmd.c:375
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set : %d : descripteur de fichier non valable"

#: print_cmd.c:380
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set : pointeur de fichier NULL"

#: print_cmd.c:384
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != fileno xtrace fp (%d)"

#: print_cmd.c:1545
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf : « %c » : caractère de format invalide"

#: redir.c:150 redir.c:198
msgid "file descriptor out of range"
msgstr "descripteur de fichier hors plage"

#: redir.c:205
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s : redirection ambiguë"

#: redir.c:209
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s : impossible d'écraser le fichier existant"

#: redir.c:214
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s : restreint : impossible de rediriger la sortie"

#: redir.c:219
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "impossible de créer un fichier temporaire pour le « here-document » : %s"

#: redir.c:223
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s : impossible d'affecter le descripteur de fichier à la variable"

#: redir.c:650
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "/dev/(tcp|udp)/host/port non pris en charge sans réseau"

#: redir.c:945 redir.c:1065 redir.c:1130 redir.c:1303
msgid "redirection error: cannot duplicate fd"
msgstr "erreur de redirection : impossible de dupliquer le descripteur de fichier"

#: shell.c:353
msgid "could not find /tmp, please create!"
msgstr "« /tmp » introuvable, veuillez le créer !"

#: shell.c:357
msgid "/tmp must be a valid directory name"
msgstr "« /tmp » doit être un nom de répertoire valable"

#: shell.c:826
msgid "pretty-printing mode ignored in interactive shells"
msgstr "le mode d'affichage amélioré est ignoré dans les shells interactifs"

#: shell.c:972
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c : option non valable"

#: shell.c:1343
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "impossible de changer le uid en %d : uid effectif %d"

#: shell.c:1354
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "impossible de changer le gid en %d: gid effectif %d"

#: shell.c:1544
msgid "cannot start debugger; debugging mode disabled"
msgstr "impossible de démarrer le débogueur: mode déboguage désactivé"

#: shell.c:1658
#, c-format
msgid "%s: Is a directory"
msgstr "%s : Ceci est un répertoire"

#: shell.c:1907
msgid "I have no name!"
msgstr "Je n'ai pas de nom !"

#: shell.c:2061
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, version %s-(%s)\n"

#: shell.c:2062
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Utilisation :\t%s [option longue GNU] [option] ...\n"
"\t%s [option longue GNU] [option] fichier-script ...\n"

#: shell.c:2064
msgid "GNU long options:\n"
msgstr "Options longues GNU :\n"

#: shell.c:2068
msgid "Shell options:\n"
msgstr "Options du shell :\n"

#: shell.c:2069
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-ilrsD ou -c commande ou -O shopt_option\t\t(invocation seulement)\n"

#: shell.c:2088
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s ou -o option\n"

#: shell.c:2094
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "Pour en savoir plus sur les options du shell, saisissez « %s -c \"help set\" ».\n"

#: shell.c:2095
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "Pour en savoir plus sur les primitives du shell, saisissez « %s -c help ».\n"

#: shell.c:2096
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Utilisez la commande « bashbug » pour faire un rapport de bogue.\n"

#: shell.c:2098
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "page d'accueil de bash : <http://www.gnu.org/software/bash>\n"

#: shell.c:2099
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Aide générale sur l'utilisation de logiciels GNU : <http://www.gnu.org/gethelp/>\n"

#: sig.c:765
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask : %d : opération non valable"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Signal falsifié"

#: siglist.c:51
msgid "Hangup"
msgstr "Raccroche"

#: siglist.c:55
msgid "Interrupt"
msgstr "Interrompt"

#: siglist.c:59
msgid "Quit"
msgstr "Quitte"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Instruction incorrecte"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "trace/trap BPT"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Instruction ABORT"

#: siglist.c:79
msgid "EMT instruction"
msgstr "Instruction EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Exception en virgule flottante"

#: siglist.c:87
msgid "Killed"
msgstr "Tué"

#: siglist.c:91
msgid "Bus error"
msgstr "Erreur de bus"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Erreur de segmentation"

#: siglist.c:99
msgid "Bad system call"
msgstr "Mauvais appel système"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Tube brisé"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Horloge d'alarme"

#: siglist.c:111
msgid "Terminated"
msgstr "Terminé"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Condition d'E/S urgente"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Stoppé (signal)"

#: siglist.c:127
msgid "Continue"
msgstr "Continue"

#: siglist.c:135
msgid "Child death or stop"
msgstr "Mort ou arrêt du fils"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Stoppé (entrée tty)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Stoppé (sortie tty)"

#: siglist.c:147
msgid "I/O ready"
msgstr "E/S prête"

#: siglist.c:151
msgid "CPU limit"
msgstr "Limite CPU"

#: siglist.c:155
msgid "File limit"
msgstr "Limite fichier"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Alarme (virtuelle)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Alarme (profile)"

#: siglist.c:167
msgid "Window changed"
msgstr "Fenêtre changée"

#: siglist.c:171
msgid "Record lock"
msgstr "Verrou d'enregistrement"

#: siglist.c:175
msgid "User signal 1"
msgstr "Signal utilisateur 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Signal utilisateur 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "données d'entrée HFT en attente"

#: siglist.c:187
msgid "power failure imminent"
msgstr "coupure d'alimentation imminente"

#: siglist.c:191
msgid "system crash imminent"
msgstr "panne système imminente"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "migration processus vers un autre CPU"

#: siglist.c:199
msgid "programming error"
msgstr "erreur de programmation"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "Mode de surveillance HFT accordé"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "Mode de surveillance HFT rétracté"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "Séquence de son HFT terminée"

#: siglist.c:215
msgid "Information request"
msgstr "Demande d'information"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Signal n°%d inconnu"

#: subst.c:1480 subst.c:1670
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "Mauvaise substitution : pas de « %s » de fermeture dans %s"

#: subst.c:3307
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s : impossible d'affecter une liste à un élément de tableau"

#: subst.c:6048 subst.c:6064
msgid "cannot make pipe for process substitution"
msgstr "impossible de fabriquer un tube pour une substitution de processus"

#: subst.c:6124
msgid "cannot make child for process substitution"
msgstr "impossible de fabriquer un fils pour une substitution de processus"

#: subst.c:6198
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "impossible d'ouvrir le tube nommé « %s » en lecture"

#: subst.c:6200
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "impossible d'ouvrir le tube nommé « %s » en écriture"

#: subst.c:6223
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "impossible de dupliquer le tube nommé « %s » vers le fd %d"

#: subst.c:6370
msgid "command substitution: ignored null byte in input"
msgstr "substitution de commande: octet nul ignoré en entrée"

#: subst.c:6533
msgid "cannot make pipe for command substitution"
msgstr "impossible de fabriquer un tube pour une substitution de commande"

#: subst.c:6580
msgid "cannot make child for command substitution"
msgstr "impossible de fabriquer un processus fils pour une substitution de commande"

#: subst.c:6613
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute : impossible de dupliquer le tube vers le fd 1"

#: subst.c:7082 subst.c:10252
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s : nom de variable invalide pour une référence de nom"

#: subst.c:7178 subst.c:7196 subst.c:7369
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s : expansion indirecte invalide"

#: subst.c:7212 subst.c:7377
#, c-format
msgid "%s: invalid variable name"
msgstr "%s: nom de variable invalide"

#: subst.c:7478
#, c-format
msgid "%s: parameter not set"
msgstr "%s : paramètre non défini"

#: subst.c:7480
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s : paramètre vide ou non défini"

#: subst.c:7727 subst.c:7742
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s : expression de sous-chaîne négative"

#: subst.c:9560 subst.c:9587
#, c-format
msgid "%s: bad substitution"
msgstr "%s : mauvaise substitution"

#: subst.c:9678
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s : affectation impossible de cette façon"

#: subst.c:10111
msgid "future versions of the shell will force evaluation as an arithmetic substitution"
msgstr "les versions futures du shell forceront l'évaluation comme une substitution arithmétique"

#: subst.c:10795
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "mauvais remplacement : pas de « ` » de fermeture dans %s"

#: subst.c:11874
#, c-format
msgid "no match: %s"
msgstr "pas de correspondance : %s"

#: test.c:147
msgid "argument expected"
msgstr "argument attendu"

#: test.c:156
#, c-format
msgid "%s: integer expression expected"
msgstr "%s : nombre entier attendu comme expression"

#: test.c:265
msgid "`)' expected"
msgstr "« ) » attendue"

#: test.c:267
#, c-format
msgid "`)' expected, found %s"
msgstr "« ) » attendue au lieu de %s"

#: test.c:469 test.c:814
#, c-format
msgid "%s: binary operator expected"
msgstr "%s : opérateur binaire attendu"

#: test.c:771 test.c:774
#, c-format
msgid "%s: unary operator expected"
msgstr "%s : opérateur unaire attendu"

#: test.c:896
msgid "missing `]'"
msgstr "« ] » manquant"

#: test.c:914
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "erreur de syntaxe : « %s » non attendu"

#: trap.c:220
msgid "invalid signal number"
msgstr "numéro de signal non valable"

#: trap.c:323
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "gestionnaire trap : dépassement de la profondeur maximum du gestionnaire « trap » (%d)"

#: trap.c:412
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps : mauvaise valeur dans trap_list[%d] : %p"

#: trap.c:416
#, c-format
msgid "run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr "run_pending_traps : le gestionnaire de signal est SIG_DFL, renvoi de %d (%s) à moi-même"

#: trap.c:509
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler : mauvais signal %d"

#: variables.c:424
#, c-format
msgid "error importing function definition for `%s'"
msgstr "erreur lors de l'importation de la définition de fonction pour « %s »"

#: variables.c:838
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "niveau de shell trop élevé (%d), initialisation à 1"

#: variables.c:2642
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable : aucun contexte de fonction dans le champ d'application actuel"

#: variables.c:2661
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s : la variable ne peut se voir assigner une valeur"

#: variables.c:2818 variables.c:2874
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr "%s : impossible d'hériter de la valeur d'un type incompatible"

#: variables.c:3459
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s : assigne un entier à la référence de nom"

#: variables.c:4390
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables : aucun contexte de fonction dans le champ d'application actuel"

#: variables.c:4757
#, c-format
msgid "%s has null exportstr"
msgstr "%s a un « exportstr » nul"

#: variables.c:4762 variables.c:4771
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "caractère %d non valable dans « exportstr » pour %s"

#: variables.c:4777
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "pas de « = » dans « exportstr » pour %s"

#: variables.c:5317
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context : le début de « shell_variables » n'est pas un contexte de fonction"

#: variables.c:5330
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context : aucun contexte à « global_variables »"

#: variables.c:5410
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope : le début de « shell_variables » n'est pas un champ d'application temporaire d'environnement"

#: variables.c:6400
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s : %s : impossible d'ouvrir comme FILE"

#: variables.c:6405
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s : %s : valeur non valable pour un descripteur de fichier de trace"

#: variables.c:6450
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s : %s : valeur de compatibilité hors plage"

#: version.c:46 version2.c:46
msgid "Copyright (C) 2022 Free Software Foundation, Inc."
msgstr "Copyright (C) 2022 Free Software Foundation, Inc."

#: version.c:47 version2.c:47
msgid "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
msgstr "Licence GPLv3+ : GNU GPL version 3 ou ultérieure <http://gnu.org/licenses/gpl.html>\n"

#: version.c:86 version2.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, version %s (%s)\n"

#: version.c:91 version2.c:91
msgid "This is free software; you are free to change and redistribute it."
msgstr "Ceci est un logiciel libre ; vous être libre de le modifier et de le redistribuer."

#: version.c:92 version2.c:92
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "AUCUNE GARANTIE n'est fournie, dans les limites permises par la loi."

#: xmalloc.c:93
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s : impossible d'allouer %lu octets (%lu octets alloués)"

#: xmalloc.c:95
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s : impossible d'allouer %lu octets"

#: xmalloc.c:165
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s : %s:%d : impossible d'allouer %lu octets (%lu octets alloués)"

#: xmalloc.c:167
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s : %s:%d : impossible d'allouer %lu octets"

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [nom[=valeur] ... ]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] nom [nom ...]"

#: builtins.c:53
msgid "bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr "bind [-lpvsPSVX] [-m keymap] [-f nomfichier] [-q nom] [-u nom] [-r seqtouche] [-x seqtouche:commande-shell] [seqtouche:fonction-readline ou commande-readline]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [shell-builtin [arg ...]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [expr]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]] [-@]] [dir]"
msgstr "cd [-L|[-P [-e]] [-@]] [rép]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] commande [arg ...]"

#: builtins.c:78
msgid "declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] [name ...]"
msgstr "declare [-aAfFgiIlnrtux] [nom[=valeur] ...] ou declare -p [-aAfFilnrtux] [nom ...]"

#: builtins.c:80
msgid "typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] [name ...]"
msgstr "typeset [-aAfFgiIlnrtux] nom[=valeur] ... ou typeset -p [-aAfFilnrtux] [nom ...]"

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [option] nom[=valeur] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [arg ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [arg ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f nomfichier] [nom ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [arg ...]"

#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts chaineopts nom [arg ...]"

#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a nom] [commande [argument ...]] [redirection ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e ename] [-lnr] [premier] [dernier] ou fc -s [motif=nouveau] [commande]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [job_spec]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [job_spec ...]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p nomchemin] [-dt] [nom ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [motif ...]"

#: builtins.c:123
msgid "history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]"
msgstr "history [-c] [-d décalage] [n] ou history -anrw [nomfichier] ou history -ps arg [arg...]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [jobspec ...] ou jobs -x commande [args]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [jobspec ... | pid ...]"

#: builtins.c:134
msgid "kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]"
msgstr "kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... ou kill -l [sigspec]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let arg [arg ...]"

#: builtins.c:138
msgid "read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]"
msgstr "read [-ers] [-a tableau] [-d delim] [-i texte] [-n ncars] [-N ncars] [-p prompt] [-t timeout] [-u fd] [nom ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCEHPT] [-o nom-option] [--] [-] [arg ...]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [nom ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [nom[=valeur] ...] ou export -p"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [nom[=valeur] ...] ou readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source filename [arguments]"
msgstr "source nom_fichier [arguments]"

#: builtins.c:154
msgid ". filename [arguments]"
msgstr ". nom_fichier [arguments]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [expr]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ arg... ]"

#: builtins.c:166
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[arg] signal_spec ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] nom [nom ...]"

#: builtins.c:171
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limite]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [mode]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p var] [id ...]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [pid ...]"

#: builtins.c:184
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NOM [in MOTS ... ] ; do COMMANDES; done"

#: builtins.c:186
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( exp1; exp2; exp3 )); do COMMANDES; done"

#: builtins.c:188
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NOM [in MOTS ... ;] do COMMANDES; done"

#: builtins.c:190
msgid "time [-p] pipeline"
msgstr "time [-p] pipeline"

#: builtins.c:192
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case MOT in [MOTIF [| MOTIF]...) COMMANDES ;;]... esac"

#: builtins.c:194
msgid "if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi"
msgstr "if COMMANDES; then COMMANDES; [ elif COMMANDES; then COMMANDES; ]... [ else COMMANDES; ] fi"

#: builtins.c:196
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while COMMANDES; do COMMANDES-2; done"

#: builtins.c:198
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until COMMANDES; do COMMANDES-2; done"

#: builtins.c:200
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [NOM] commande [redirections]"

#: builtins.c:202
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function nom { COMMANDES ; } ou nom () { COMMANDES ; }"

#: builtins.c:204
msgid "{ COMMANDS ; }"
msgstr "{ COMMANDES ; }"

#: builtins.c:206
msgid "job_spec [&]"
msgstr "job_spec [&]"

#: builtins.c:208
msgid "(( expression ))"
msgstr "(( expression ))"

#: builtins.c:210
msgid "[[ expression ]]"
msgstr "[[ expression ]]"

#: builtins.c:212
msgid "variables - Names and meanings of some shell variables"
msgstr "variables - Noms et significations de certaines variables du shell"

#: builtins.c:215
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | rép]"

#: builtins.c:219
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:223
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:226
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [nom_opt ...]"

#: builtins.c:228
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] format [arguments]"

#: builtins.c:231
msgid "complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]"
msgstr "complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G motif_glob] [-W liste_mots] [-F fonction] [-C commande] [-X motif_filtre] [-P prefixe] [-S suffixe] [nom ...]"

#: builtins.c:235
msgid "compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr "compgen [-abcdefgjksuv] [-o option] [-A action] [-G motif_glob] [-W liste_mots] [-F fonction] [-C commande] [-X motif_filtre] [-P prefixe] [-S suffixe] [mot]"

#: builtins.c:239
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o option] [-DEI] [nom ...]"

#: builtins.c:242
msgid "mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "mapfile [-d délim] [-n nombre] [-O origine] [-s nombre] [-t] [-u fd] [-C callback] [-c quantum] [tableau]"

#: builtins.c:244
msgid "readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "readarray [-d delim] [-n nombre] [-O origine] [-s nombre] [-t] [-u fd] [-C callback] [-c quantum] [tableau]"

#: builtins.c:256
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has been\n"
"    defined."
msgstr ""
"Définit ou affiche des alias.\n"
"    \n"
"    Sans argument, « alias » affiche la liste des alias dans le format réutilisable\n"
"    « alias NOM=VALEUR » sur la sortie standard.\n"
"    \n"
"    Sinon, un alias est défini pour chaque NOM dont la VALEUR est donnée.\n"
"    Une espace à la fin de la VALEUR entraîne la vérification du mot suivant pour\n"
"    déterminer si un alias doit être remplacé lorsque l'alias est développé.\n"
"    \n"
"    Options :\n"
"      -p\tAffiche tous les alias actuels dans un format réutilisable\n"
"    \n"
"    Code de sortie :\n"
"    « alias » renvoie la valeur vraie à moins que NOM ne soit fourni et que celui-ci n'aie\n"
"    pas d'alias."

#: builtins.c:278
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Enlève chaque NOM de la liste des alias actuels.\n"
"    \n"
"    Options :\n"
"      -a\tretire toutes les définitions d'alias\n"
"    \n"
"    Renvoie le code de succès à moins que NOM ne soit pas un alias existant."

#: builtins.c:291
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their values\n"
"      -s                 List key sequences that invoke macros and their values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Définit les associations de touches et les variables de « Readline ».\n"
"    \n"
"    Associe une séquence de touches à une fonction « Readline » ou une macro, ou définit une\n"
"    variable « Readline ». La syntaxe des arguments non-options est équivalente à celle\n"
"    du fichier ~/.inputrc, mais doivent être transmis comme arguments uniques :\n"
"    ex : bind '\"\\C-x\\C-r\" : re-read-init-file'.\n"
"    \n"
"    Options :\n"
"      -m  keymap         Utilise KEYMAP comme mappage clavier pendant la\n"
"                         durée de cette commande. Des noms de mappage valables\n"
"                         sont « emacs », « emacs-standard », « emacs-meta », \n"
"                         « emacs-ctlx », « vi », « vi-move », « vi-command » et\n"
"                         « vi-insert ».\n"
"      -l                 Affiche les noms de fonctions.\n"
"      -P                 Affiche les noms et associations des fonctions.\n"
"      -p                 Affiche les fonctions et associations dans une forme qui\n"
"                         peut être réutilisée comme entrée.\n"
"      -S                 Affiche les séquences de touches qui invoquent des macros,\n"
"                         et leurs valeurs.\n"
"      -s                 Affiche les séquences de touches qui invoquent des macros,\n"
"                         et leurs valeurs sous une forme qui peut être utilisée comme entrée.\n"
"      -V                 Affiche les noms et valeurs des variables\n"
"      -v                 Affiche les noms et valeurs des variables dans une forme qui peut\n"
"                         être réutilisée comme entrée.\n"
"      -q  nom-fonction   Permet de savoir quelles touches appellent la fonction.\n"
"      -u  nom-fonction   Enlève toutes les associations de touches liée à la fonction.\n"
"      -r  seqtouche      Enlève l'association pour « seqtouche ».\n"
"      -f  nomfichier     Lit l'association de touches depuis NOMFICHIER.\n"
"      -x  seqtouche:commande-shell\tEntraîne l'exécution de la commande-shell\n"
"    \t\t\t\tlorsque « seqtouche » est entrée.\n"
"      -X                 Liste les séquences de touches liées à -x et les commandes associées\n"
"                         sous une forme qui peut être réutilisée comme entrée.\n"
"    \n"
"    Code de sortie :\n"
"    « bind » renvoie 0 à moins qu'une option non reconnue ne soit donnée ou qu'une erreur survienne."

#: builtins.c:330
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Sort des boucles for, while, ou until.\n"
"    \n"
"    Sort d'une boucle FOR, WHILE ou UNTIL.  Si N est spécifié, sort de N boucles\n"
"    imbriquées.\n"
"    \n"
"    Code de retour :\n"
"    Le code de retour est 0 à moins que N ne soit pas supérieur ou égal à 1."

#: builtins.c:342
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Reprend l'exécution des boucles for, while ou until.\n"
"    \n"
"    Reprend l'itération suivante de la boucle FOR, WHILE ou UNTIL de niveau supérieur.\n"
"    Si N est précisé, reprend à la N-ième boucle supérieure.\n"
"    \n"
"    Code de sortie :\n"
"    Le code de sortie est 0 à moins que N ne soit pas supérieur ou égale à 1."

#: builtins.c:354
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Exécute des commandes shell intégrées.\n"
"    \n"
"    Exécute SHELL-BUILTIN avec les arguments ARGs sans effectuer de recherche\n"
"    de commande.  Ceci est utile lorsque vous souhaitez remplacer une commande\n"
"    intégrée par une fonction shell, mais nécessite d'exécuter la commande intégrée\n"
"    dans la fonction.\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de retour de SHELL-BUILTIN, ou false si SHELL-BUILTIN n'est\n"
"    pas une commande intégrée."

#: builtins.c:369
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Renvoie le contexte de l'appel de sous-routine actuel.\n"
"    \n"
"    Sans EXPR, renvoie « $ligne $nomfichier ».  Avec EXPR,\n"
"    renvoie « $ligne $sousroutine $nomfichier »; ces informations supplémentaires\n"
"    peuvent être utilisées pour fournir une trace de la pile.\n"
"    \n"
"    La valeur de EXPR indique le nombre de cadres d'appels duquel il faut revenir en arrière\n"
"    avant le cadre actuel ; le cadre supérieur est le cadre 0.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie 0 à moins que le shell ne soit pas en train d'exécuter une fonction ou que EXPR\n"
"    ne soit pas valable."

#: builtins.c:387
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n"
"    A null directory name is the same as the current directory.  If DIR begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is set,\n"
"    the word is assumed to be  a variable name.  If that variable has a value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Change le répertoire de travail du shell.\n"
"    \n"
"    Change le répertoire actuel vers DIR.  Le répertoire DIR par défaut\n"
"    est donné par la variable « HOME » du shell.\n"
"    \n"
"    La variable CDPATH définit le chemin de recherche du répertoire contenant\n"
"    DIR. Les noms de répertoires alternatifs dans CDPATH sont séparés par un deux-point « : ».\n"
"    Un nom de répertoire vide est identique au répertoire actuel.  Si DIR commence\n"
"    avec une barre oblique « / », alors CDPATH n'est pas utilisé.\n"
"    \n"
"    Si le répertoire n'est pas trouvé et que l'option « cdable_vars » du shell est définie,\n"
"    alors le mot est supposé être un nom de variable. Si la variable possède une valeur,\n"
"    alors cette valeur est utilisée pour DIR.\n"
"    \n"
"    Options :\n"
"      -L\tforce le suivi des liens symboliques : résout les liens symboliques dans\n"
"    \t\tDIR après le traitement des instances de « .. »\n"
"      -P\tutilise la structure physique des répertoires sans suivre les liens\n"
"    \t\tsymboliques : résout les liens symboliques dans DIR avant le traitement des\n"
"    \t\tinstances de « .. »\n"
"      -e\tsi l'option -P est fournie et que le répertoire de travail actuel ne peut pas\n"
"    \t\têtre déterminé avec succès, alors sort avec un code de retour non nul\n"
"      -@  sur les systèmes qui le supporte, présente un fichier avec des attributs\n"
"    \t\tétendus comme un répertoire contenant les attributs du fichier\n"
"    \n"
"    Le comportement par défaut est de suivre les liens symboliques, comme si « -L » était précisé.\n"
"    « .. » est traité en retirant le composant immédiatement avant dans le chemin jusqu'à\n"
"    la barre oblique ou le début de DIR.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie 0 si le répertoire est changé et si $PWD est correctement défini\n"
"    quand -P est utilisé ; sinon autre chose que 0."

#: builtins.c:425
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Affiche le nom du répertoire de travail courant.\n"
"    \n"
"    Options :\n"
"      -L\taffiche la valeur de $PWD s'il nomme le répertoire de travail\n"
"    \t\tcourant\n"
"      -P\taffiche le répertoire physique, sans aucun lien symbolique\n"
"    \n"
"    Par défaut, « pwd » se comporte comme si « -L » était spécifié.\n"
"    \n"
"    Code de retour :\n"
"    Renvoie 0 à moins qu'une option non valable ne soit donnée ou que le\n"
"    répertoire courant ne peut pas être lu."

#: builtins.c:442
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Commande vide.\n"
"    \n"
"    Sans effet : la commande ne fait rien.\n"
"    \n"
"    Code de retour :\n"
"    Renvoie toujours le code de succès."

#: builtins.c:453
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Renvoie un résultat de succès.\n"
"    \n"
"    Code de retour :\n"
"    Succès."

#: builtins.c:462
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Renvoie un résultat d'échec.\n"
"    \n"
"    Code de sortie :\n"
"    Toujours l'échec."

#: builtins.c:471
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a description of COMMAND similar to the `type' builtin\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Exécute une simple commande ou affiche des informations sur les commandes.\n"
"    \n"
"    Lance la COMMANDE avec des ARGS en court-circuitant la recherche de commande,\n"
"    ou affiche des informations sur les COMMANDEs spécifiées.  Ceci peut être\n"
"    utilisé pour invoquer des commandes sur le disque lorsqu'il y a conflit\n"
"    avec une fonction portant le même nom.\n"
"    \n"
"    Options :\n"
"      -p    utilise une valeur par défaut pour CHEMIN qui garantit de trouver\n"
"            tous les utilitaires standards\n"
"      -v    affiche une description de la COMMANDE similaire à la commande intégrée\n"
"            « type »\n"
"      -V    affiche une description plus détaillée de chaque COMMANDE\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de sortie de la COMMANDE, ou le code d'échec si la COMMANDE est introuvable."

#: builtins.c:490
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the `local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Définit les valeurs et les attributs des variables.\n"
"    \n"
"    Déclare des variables et leur assigne des attributs.  Si aucun NOM n'est donné,\n"
"    affiche les attributs et les valeurs de toutes les variables.\n"
"    \n"
"    Options :\n"
"      -f\trestreint l'action ou l'affichage aux noms et définitions de fonctions\n"
"      -F\trestreint l'affichage aux noms des fonctions uniquement (avec le numéro de ligne\n"
"    \t\tet le fichier source lors du débogage)\n"
"      -g\tcrée des variables globales lorsqu'utilisée dans une fonction shell ; ignoré sinon\n"
"      -I\tlors de la création d'une variable, hérite des attributs et valeur d'une variable\n"
"    \t\tportant le même nom dans une portée précédente\n"
"      -p\taffiche les attributs et la valeur de chaque NOM\n"
"    \n"
"    Options qui définissent des attributs :\n"
"      -a\tpour faire de NOMs des tableaux indexés (si pris en charge)\n"
"      -A\tpour faire de NOMs des tableaux associatifs (si pris en charge)\n"
"      -i\tpour assigner l'attribut « integer » aux NOMs\n"
"      -l\tpour convertir la valeur de chaque NOM en minuscules lors de l'affectation\n"
"      -n\ttransforme NOM en une référence vers une variable nommée d'après sa valeur\n"
"      -r\tpour mettre les NOMs en lecture seule\n"
"      -t\tpour permettre aux NOMs d'avoir l'attribut « trace »\n"
"      -u\tpour convertir les NOMs en majuscules lors de l'affectation\n"
"      -x\tpour permettre aux NOMs de s'exporter\n"
"    \n"
"    Utiliser « + » au lieu de « - » pour désactiver l'attribut.\n"
"    \n"
"    Les variables avec l'attribut « integer » ont une évaluation arithmétique (voir\n"
"    la commande « let ») effectuée lorsqu'une valeur est affectée à la variable.\n"
"    \n"
"    Lorsqu'utilisée dans une fonction, « declare » permet aux NOMs d'être locaux,\n"
"    comme avec la commande « local ». L'option « -g » supprime ce comportement.\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de succès à moins qu'une option non valable soit fournie ou qu'une\n"
"    erreur survienne lors de l'assignation d'une variable."

#: builtins.c:532
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Définit des valeurs et des attributs de variables.\n"
"    \n"
"    Un synonyme de « déclare ».  Consultez « help declare »."

#: builtins.c:540
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Définit des variables locales.\n"
"    \n"
"    Crée une variable locale nommée NOM, avec une valeur VALEUR.  OPTION peut\n"
"    être n'importe quelle option acceptée par « declare ».\n"
"    \n"
"    Les variables locales peuvent seulement être utilisées à l'intérieur d'une\n"
"    fonction; elles ne sont visibles que dans les fonctions où elles ont été\n"
"    définies et dans leurs fonctions filles.\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de succès à moins qu'une option non valable ne soit fournie,\n"
"    qu'une erreur survienne lors de l'assignation d'une variable, ou que le shell\n"
"    n'exécute pas une fonction."

#: builtins.c:557
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Écrit les arguments sur la sortie standard.\n"
"    \n"
"    Affiche les ARGs, séparés par une espace, sur la sortie standard, suivis\n"
"    d'un retour à la ligne.\n"
"    \n"
"    Options :\n"
"      -n\tn'ajoute pas de saut de ligne\n"
"      -e\tactive l'interprétation des barres contre-obliques d'échappement ci-dessous\n"
"      -E\tsupprime explicitement l'interprétation des barres contre-obliques d'échappement\n"
"    \n"
"    « echo » interprète les caractères suivants comme des séquences d'échappement :\n"
"      \\a\talerte (cloche)\n"
"      \\b\tretour arrière\n"
"      \\c\tsupprime la suite de la sortie\n"
"      \\e\tcaractère échap.\n"
"      \\E\tcaractère échap.\n"
"      \\f\tsaut de page\n"
"      \\n\tsaut de ligne\n"
"      \\r\tretour chariot\n"
"      \\t\ttabulation horizontale\n"
"      \\v\ttabulation verticale\n"
"      \\\\\tbarre contre-oblique\n"
"      \\0nnn\tle caractère dont le code ASCII est NNN (en octal).  NNN peut être\n"
"    \t\tlong de 0 à 3 chiffres octaux\n"
"      \\xHH\tle caractère sur 8 bits dont la valeur est HH (hexadécimal).  HH\n"
"    \t\tpeut être composé de 1 ou 2 chiffres hexadécimaux\n"
"    \t\tHHHH peut être composé de un à quatre chiffres hexadécimaux.\n"
"      \\UHHHHHHHH le caractère Unicode dont la valeur est la valeur hexadécimale\n"
"    \t\tHHHHHHHH. HHHHHHHH peut avoir un à huit chiffres hexadécimaux.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins qu'une erreur d'écriture survienne."

#: builtins.c:597
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Écrit des arguments sur la sortie standard.\n"
"    \n"
"    Affiche les ARGs sur la sortie standard, suivis d'un retour à la ligne.\n"
"    \n"
"    Options :\n"
"      -n\tpas de retour à la ligne\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins qu'une erreur d'écriture survienne."

#: builtins.c:612
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Active et désactive les commandes intégrées.\n"
"    \n"
"    Active et désactive les commandes intégrées du shell.  Les désactiver vous permet\n"
"    d'exécuter une commande du disque ayant le même nom qu'une commande du shell\n"
"    sans utiliser le chemin complet vers le fichier.\n"
"    \n"
"    Options :\n"
"      -a\taffiche la liste des commandes intégrées et leur état d'activation\n"
"      -n\tdésactive chaque NOM ou affiche la liste des commandes désactivées\n"
"      -p\taffiche la liste des commandes dans un format réutilisable\n"
"      -s\taffiche seulement les noms des commandes Posix de type « special »\n"
"    \n"
"    Options contrôlant le chargement dynamique :\n"
"      -f\tCharge la commande intégrée NOM depuis la bibliothèque partagée FILENAME\n"
"      -d\tDécharge une commande chargée avec « -f »\n"
"    \n"
"    S'il n'y a pas d'option, chaque commande NOM est activée.\n"
"    \n"
"    Pour utiliser le « test » trouvé dans $PATH au lieu de celui intégré au shell,\n"
"    saisissez « enable -n test ».\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins que NOM ne soit pas une commande intégrée ou qu'une erreur ne survienne."

#: builtins.c:640
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Exécute des arguments comme s'ils étaient une commande du shell.\n"
"    \n"
"    Combine des ARGs en une chaîne unique, utilise le résultat comme entrée du shell,\n"
"    puis exécute la commande résultante.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le même code de sortie que la commande, ou le code de succès si la commande est vide."

#: builtins.c:652
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Analyse les options en arguments.\n"
"    \n"
"    « getopts » est utilisé par les procédures du shell pour analyser les \n"
"    paramètres de position.\n"
"    \n"
"    OPTSTRING contient les lettres d'options qui devront être reconnues ;\n"
"    si une lettre est suivie par un deux-points, elle devra posséder un\n"
"    argument séparé d'elle par une espace.\n"
"    \n"
"    À chaque fois qu'elle est appelée, « getopts » place l'option suivante\n"
"    dans la variable de shell « $nom », en l'initialisant si elle n'existe pas,\n"
"    et place l'index de l'argument suivant dans la variable de shell OPTIND.\n"
"    OPTIND est initialisé à 1 à chaque fois que le shell ou qu'un script shell\n"
"    est appelé.  Lorsqu'une option nécessite un argument, « getopts » place cet\n"
"    argument dans la variable de shell OPTARG.\n"
"    \n"
"    « getopts » signale les erreurs de deux manières.  Si le premier caractère\n"
"    d'OPTSTRING est un deux-points, « getopts » utilise un signalement d'erreur\n"
"    silencieux. Dans ce mode aucun message d'erreur n'est affiché. Si une option\n"
"    incorrecte est rencontrée, « getopts » place dans OPTARG le caractère d'option\n"
"    trouvé. Si un argument nécessaire n'est pas trouvé, « getopts » place un « : »\n"
"    dans NOM et place dans OPTARG le caractère d'option trouvé.  Si « getopts »\n"
"    n'est pas en mode silencieux et qu'une option incorrecte est rencontrée, il\n"
"    place « ? » dans NAME et efface OPTARG.  Si un argument nécessaire n'est pas\n"
"    trouvé, un « ? » est placé dans NAME, OPTARG est effacé et un message de\n"
"    diagnostic est affiché.\n"
"    \n"
"    Si la variable de shell OPTERR possède la valeur 0, « getopts » désactive\n"
"    l'affichage des messages d'erreur, même si le premier caractère d'OPTSTRING\n"
"    n'est pas un deux-points. OPTERR possède la valeur 1 par défaut.\n"
"    \n"
"    « getopts » analyse habituellement les paramètres de position, mais si des arguments\n"
"    sont fournis par des valeurs ARG, ils sont analysés à la place.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès si une option est trouvée, le code d'échec si la fin des options\n"
"    est rencontrée ou si une erreur survient."

#: builtins.c:694
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error occurs."
msgstr ""
"Remplace le shell par la commande fournie.\n"
"    \n"
"    Exécute la COMMANDE, en remplaçant ce shell par le programme spécifié.\n"
"    Les ARGUMENTS deviennent ceux de la COMMANDE. Si la COMMANDE n'est pas fournie,\n"
"    les redirections prennent effet dans le shell courant.\n"
"    \n"
"    Options :\n"
"      -a nom\tpasse NOM comme argument numéro 0 à la COMMANDE\n"
"      -c\texécute la COMMANDE avec un environnement vide\n"
"      -l\tplace un tiret comme argument numéro 0 de la COMMANDE\n"
"    \n"
"    Si la commande ne peut pas être exécutée, un shell non-interactif se termine,\n"
"    à moins que l'option « execfail » ne soit définie.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins que la COMMANDE ne soit pas trouvée ou\n"
"    qu'une erreur de redirection ne survienne."

#: builtins.c:715
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Termine le shell.\n"
"    \n"
"    Termine le shell avec le code de retour « N ».  Si N est omis, le code\n"
"    de retour est celui de la dernière commande exécutée."

#: builtins.c:724
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not executed\n"
"    in a login shell."
msgstr ""
"Termine un shell de connexion.\n"
"    \n"
"    Termine un shell de connexion avec le code de sortie N.  Renvoie une erreur\n"
"    s'il n'est pas exécuté dans un shell de connexion."

#: builtins.c:734
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error occurs."
msgstr ""
"Affiche ou exécute des commandes issues de l'historique.\n"
"    \n"
"    « fc » est utilisé pour afficher ou modifier puis ré-exécuter les commandes\n"
"    de l'historique des commandes. PREMIER et DERNIER peuvent être des nombres\n"
"    indiquant la plage ou PREMIER peut être une chaîne donnant le début de la\n"
"    commande la plus récente recherchée.\n"
"    \n"
"    Options :\n"
"       -e ENAME\tdéfinit quel éditeur utiliser. Par défaut il s'agit de « FCEDIT »\n"
"    \t\tpuis « EDITOR », puis « vi »\n"
"       -l\taffiche les lignes au lieu de les éditer\n"
"       -n\tn'affiche pas les numéros de ligne\n"
"       -r\tinverse l'ordre des lignes (les plus récentes en premier)\n"
"    \n"
"    En tapant « fc -s [motif=rempl ...] [commande] », la commande est ré-exécutée\n"
"    après avoir effectué le remplacement ANCIEN=NOUVEAU.\n"
"    \n"
"    Un alias utile est « r='fc -s' » de sorte qu'en tapant « r cc »,\n"
"    la dernière commande commençant par « cc » est ré-exécutée et avec « r », la\n"
"    dernière commande est ré-exécutée.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès ou le code de sortie de la commande exécutée ; autre\n"
"    chose que 0 si une erreur survient."

#: builtins.c:764
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Déplace une tâche au premier plan.\n"
"    \n"
"    Place JOB_SPEC au premier plan et en fait la tâche actuelle. Si\n"
"    JOB_SPEC n'est pas fourni, le shell utilise sa propre notion\n"
"    de tâche actuelle.\n"
"    \n"
"    Code de sortie :\n"
"    Celui de la commande placée au premier plan ou le code d'échec si une erreur survient."

#: builtins.c:779
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Déplace des tâches vers l'arrière plan.\n"
"    \n"
"    Place chaque JOB_SPEC en arrière plan comme s'il avait été démarré avec « & ».\n"
"    Si JOB_SPEC n'est pas fourni, le shell utilise sa propre notion\n"
"    de tâche actuelle.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins que le contrôle de tâche ne soit pas activé\n"
"    ou qu'une erreur ne survienne."

#: builtins.c:793
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Mémorise ou affiche l'emplacement des programmes.\n"
"    \n"
"    Détermine et mémorise le chemin complet de chaque commande NOM.  Si\n"
"    aucun argument n'est donné, une information sur les commandes mémorisées est\n"
"    affichée.\n"
"    \n"
"    Options :\n"
"      -d\toublie l'emplacement mémorisé de chaque NOM\n"
"      -l\taffiche dans un format qui peut être réutilisé comme entrée\n"
"      -p nomchemin\tutilise NOMCHEMIN comme le chemin complet de NOM\n"
"      -r\toublie tous les emplacements mémorisés\n"
"      -t\taffiche l'emplacement mémorisé de chaque NOM, en précédant\n"
"    \t\tchaque emplacement du NOM correspondant si plusieurs NOMS\n"
"    \t\tsont donnés\n"
"    Arguments :\n"
"      NOM\tChaque NOM est recherché dans $PATH et ajouté à la liste\n"
"    \t\tdes commandes mémorisée.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins que le NOM ne soit pas trouvé ou\n"
"    qu'une option non valable ne soit donnée."

#: builtins.c:818
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is given."
msgstr ""
"Affiche des informations sur les commandes intégrées.\n"
"    \n"
"    Affiche de courts résumés des commandes intégrées.  Si MOTIF est\n"
"    spécifié, une aide détaillée de toutes les commandes correspondantes\n"
"    au MOTIF est affichée, sinon la liste des sujets d'aide est affichée.\n"
"    \n"
"    Options :\n"
"      -d\taffiche une courte description pour chaque sujet\n"
"      -m\taffiche l'aide dans un format proche des pages de man(uel)\n"
"      -s\tn'affiche qu'une courte aide pour chaque sujet correspondant au\n"
"    \t\tMOTIF\n"
"    \n"
"    Arguments :\n"
"      MOTIF\tMotif spécifiant un sujet d'aide\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de succès à moins que le MOTIF ne soit pas trouvé ou qu'une\n"
"    option non valable ne soit donnée."

#: builtins.c:842
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Affiche ou manipule l'historique.\n"
"    \n"
"    Affiche l'historique avec les numéros de lignes en préfixant chaque élément\n"
"    modifié d'un « * ».  Un argument égal à N limite la liste aux N derniers éléments.\n"
"    \n"
"    Options :\n"
"      -c\tefface la liste d'historique en supprimant tous les éléments\n"
"      -d offset\tefface l'élément d'historique à l'emplacement OFFSET. Un offset négatif\n"
"    \t\tcompte à partir de la fin de la liste de l'historique\n"
"    \n"
"      -a\tajoute les lignes d'historique de cette session au fichier d'historique\n"
"      -n\tlit toutes les lignes d'historique non déjà lues depuis le fichier d'historique\n"
"    \t\tet les ajoute à la liste de l'historique\n"
"      -r\tlit le fichier d'historique et ajoute le contenu à la liste d'historique\n"
"      -w\técrit l'historique actuelle dans le fichier d'historique\n"
"    \n"
"      -p\teffectue un développement de l'historique sur chaque ARG et affiche le résultat\n"
"    \t\tsans le stocker dans la liste d'historique\n"
"      -s\tajoute les ARGs à la liste d'historique comme entrée unique\n"
"    \n"
"    Si NOMFICHIER est donné, il est utilisé comme fichier d'historique. Sinon,\n"
"    si HISTFILE contient une valeur, celle-ci est utilisée, sinon ~/.bash_history.\n"
"    \n"
"    Si la variable HISTTIMEFORMAT est définie et n'est pas vide, sa valeur est utilisée\n"
"    comme chaîne de format pour que strftime(3) affiche l'horodatage associé\n"
"    à chaque entrée d'historique.  Sinon, aucun horodatage n'est affiché.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins qu'une option non valable soit donnée ou\n"
"    qu'une erreur ne survienne."

#: builtins.c:879
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Affiche l'état des tâches.\n"
"    \n"
"    Affiche la liste des tâches actives.  JOBSPEC restreint l'affichage à\n"
"    cette tâche. S'il n'y a pas d'option, l'état de toutes les tâches actives\n"
"    est affiché.\n"
"    \n"
"    Options :\n"
"      -l\taffiche les IDs de processus en plus des informations normales\n"
"      -n\taffiche seulement les processus dont l'état a changé depuis la\n"
"    \t\tdernière notification\n"
"      -p\taffiche seulement les IDs de processus\n"
"      -r\trestreint l'affichage aux tâches en cours d'exécution\n"
"      -s\trestreint l'affichage aux tâches stoppées\n"
"    \n"
"    Si « -x » est fournie, la COMMANDE est lancée après que toutes les\n"
"    spécifications qui apparaissent dans ARGs ont été remplacées par l'ID de\n"
"    processus du leader de groupe de processus de cette tâche.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins qu'une option non valable ne soit donnée\n"
"    ou qu'une erreur ne survienne. Si « -x » est utilisée, le code de sortie de\n"
"    la COMMANDE est renvoyé."

#: builtins.c:906
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Retire des tâches du shell courant.\n"
"    \n"
"    Retire chaque argument JOBSPEC de la table des tâches actives.  Sans\n"
"    JOBSPEC, le shell utilise sa propre notion de tâche courante.\n"
"    \n"
"    Options :\n"
"      -a\tretire toutes les tâches si JOBSPEC n'est pas fourni\n"
"      -h\tmarque chaque JOBSPEC de façon que SIGHUP ne soit pas envoyé à la tâche\n"
"    \t\tsi le shell reçoit un SIGHUP\n"
"      -r\tretire seulement les tâches en cours de fonctionnement\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins qu'une option ou un JOBSPEC non\n"
"    valable ne soit donné."

#: builtins.c:925
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Envoie un signal à une tâche.\n"
"    \n"
"    Envoie le signal nommé par SIGSPEC ou SIGNUM au processus identifié par\n"
"    PID ou JOBSPEC. Si SIGSPEC et SIGNUM ne sont pas donnés, alors SIGTERM est\n"
"    envoyé.\n"
"    \n"
"    Options :\n"
"      -s sig\tSIG est un nom de signal\n"
"      -n sig\tSIG est un numéro de signal\n"
"      -l\taffiche la liste des noms de signaux ; si des arguments suivent « -l »,\n"
"    \t\tils sont supposés être des numéros de signaux pour lesquels les noms doivent\n"
"    \t\têtre affichés\n"
"      -L\tsynonyme de -l\n"
"    \n"
"    « kill » est une commande intégrée pour deux raisons : elle permet aux IDs de\n"
"    tâches d'être utilisés à la place des IDs de processus et elle permet aux\n"
"    processus d'être tués si la limite du nombre de processus que vous pouvez créer\n"
"    est atteinte.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins qu'une option non valable soit donnée ou qu'une\n"
"    erreur ne survienne."

#: builtins.c:949
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Évalue des expressions arithmétiques.\n"
"    \n"
"    Chaque ARG est une expression arithmétique à évaluer. L'évaluation\n"
"    est faite avec des entiers de largeur fixe sans vérification de\n"
"    dépassement, mais la division par zéro est interceptée et\n"
"    signalée comme une erreur. La liste suivante d'opérateurs\n"
"    est groupée par niveau d'égale priorité. Les niveaux sont listés\n"
"    par priorité décroissante.\n"
"    \n"
"    \tid++, id--\tpost-incrément ou post-décrément de variable\n"
"    \t++id, --id\tpré-incrément ou pré-décrément de variable\n"
"    \t-, +\t\tmoins unaire, plus unaire\n"
"    \t!, ~\t\tnégations logique et binaire\n"
"    \t**\t\tmise en exposant\n"
"    \t*, /, %\t\tmultiplication, division, reste de la division\n"
"    \t+, -\t\taddition, soustraction\n"
"    \t<<, >>\t\tdécalage binaire à gauche et à droite\n"
"    \t<=, >=, <, >\tcomparaison\n"
"    \t==, !=\t\tégalité, inégalité\n"
"    \t&\t\tET binaire\n"
"    \t^\t\tOU binaire exclusif\n"
"    \t|\t\tOU binaire\n"
"    \t&&\t\tET logique\n"
"    \t||\t\tOU logique\n"
"    \texpr ? expr : expr\n"
"    \t\t\topérateur de condition\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\taffectation\n"
"    \n"
"    Les variables de shell sont autorisées comme opérandes. Le nom de la\n"
"    variable est remplacé par sa valeur (contrainte à un entier de largeur\n"
"    fixe) à l'intérieur d'une expression. La variable n'a pas besoin d'avoir\n"
"    son attribut d'entier activé pour être utilisée dans une expression.\n"
"    \n"
"    Les opérateurs sont évalués dans leur ordre de priorité. Les sous-expressions\n"
"    entre parenthèses sont évaluées en premier et peuvent être prioritaires sur\n"
"    les règles ci-dessus.\n"
"    \n"
"    Code de sortie :\n"
"    Si le dernier ARG est évalué à 0, « let » renvoie 1, sinon 0 est renvoyé."

#: builtins.c:994
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as word\n"
"    delimiters. By default, the backslash character escapes delimiter characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times out\n"
"    (in which case it's greater than 128), a variable assignment error occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Lit une ligne depuis l'entrée standard et la découper en morceaux.\n"
"    \n"
"    Lit une simple ligne depuis l'entrée standard ou depuis le descripteur de\n"
"    fichier FD si l'option « -u » est fournie.  La ligne est découpée en morceaux\n"
"    comme des mots, et le premier mot est assigné au premier NOM, le deuxième mot\n"
"    au deuxième NOM, et ainsi de suite, le dernier NOM récupérant la liste des mots\n"
"    restants. Seuls les caractères trouvés dans $IFS sont reconnus comme délimiteurs\n"
"    de mots. Par défaut, la barre oblique inverse échappe les caractères délimiteurs\n"
"    et les sauts de ligne.\n"
"    \n"
"    Si aucun NOM n'est fourni, la ligne lue est stockée dans la variable REPLY.\n"
"    \n"
"    Options :\n"
"      -a tableau\taffecte les mots lus séquentiellement aux indices de la variable\n"
"    \t\ttableau ARRAY en commençant à 0\n"
"      -d délim\tcontinue jusqu'à ce que le premier caractère de DELIM soit lu,\n"
"    \t\tau lieu du retour à la ligne\n"
"      -e\t\tutilise « Readline » pour obtenir la ligne\n"
"      -i texte\tUtilise TEXTE comme texte initial pour « Readline »\n"
"      -n n\ttermine après avoir lu N caractères plutôt que d'attendre\n"
"    \t\tun retour à la ligne, mais obéi à un délimiteur si moins de N caractères\n"
"    \t\tsont lus avant le délimiteur\n"
"      -N n\ttermine seulement après avoir lu exactement N caractères, à moins\n"
"    \t\tque le caractère EOF soit rencontré ou que le délai de lecture n'expire.\n"
"    \t\tLes délimiteurs sont ignorés\n"
"      -p prompt\taffiche la chaîne PROMPT sans retour à la ligne final, avant de\n"
"    \t\ttenter une lecture\n"
"      -r\tne pas permettre aux barres obliques inverses de se comporter comme\n"
"    \t\tdes caractères d'échappement\n"
"      -s\tne pas répéter l'entrée provenant d'un terminal\n"
"      -t timeout\texpire et renvoie un code d'échec si une ligne d'entrée complète\n"
"    \t\tn'est pas lue en moins de TIMEOUT secondes.  La valeur de la variable TIMEOUT\n"
"    \t\test le délai d'expiration par défaut.  TIMEOUT peut être un nombre décimal.\n"
"    \t\tSi TIMEOUT est à zéro, la lecture se termine immédiatement sans essayer de\n"
"    \t\tlire la moindre donnée mais elle renvoie un code de succès seulement\n"
"    \t\tsi l'entrée est disponible sur le descripteur de fichier.  Le code\n"
"    \t\tde sortie est supérieur à 128 si le délai a expiré\n"
"      -u fd\tlit depuis le descripteur de fichier FD plutôt que l'entrée standard\n"
"    \n"
"    Code de sortie :\n"
"    Le code de retour est 0, à moins qu'une fin de fichier ne survienne, que le délai expire\n"
"    (auquel cas, il est plus grand que 128), une erreur d'affectation à une variable survient\n"
"    ou qu'un descripteur de fichier non valable ne soit fourni comme argument à « -u »."

#: builtins.c:1042
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Termine depuis une fonction du shell.\n"
"    \n"
"    Entraîne l'arrêt d'une fonction ou d'un script sourcé, avec le code\n"
"    de retour spécifié par N. Si N est omis, le code de retour est celui\n"
"    de la dernière commande exécutée à l'intérieur de la fonction ou du\n"
"    script\n"
"    \n"
"    Code de retour :\n"
"    Renvoie N ou le code d'échec si le shell n'est pas en train d'exécuter\n"
"    une fonction ou un script."

#: builtins.c:1055
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Définit ou invalide des valeurs d'options et des paramètres de position du shell.\n"
"    \n"
"    Change la valeur des attributs du shell et des paramètres de position, ou\n"
"    affiche les noms et valeurs des variables du shell.\n"
"    \n"
"    Options :\n"
"        -a  Marque pour l'export toutes les variables qui sont modifiées ou créées.\n"
"        -b  Averti immédiatement de la fin d'une tâche.\n"
"        -e  Termine immédiatement si une commande s'arrête avec un code de retour non nul.\n"
"        -f  Désactive la génération de nom de fichier (globbing).\n"
"        -h  Mémorise l'emplacement des commandes après leur recherche.\n"
"        -k  Place dans l'environnement tous les arguments d'affectation pour une commande,\n"
"            pas seulement ceux qui précèdent le nom de la commande.\n"
"        -m  Active le contrôle de tâche.\n"
"        -n  Lit les commandes, mais ne les exécute pas.\n"
"        -o nom-option\n"
"            Défini la variable correspondant à nom-option :\n"
"                allexport    identique à -a\n"
"                braceexpand  identique à -B\n"
"                emacs        utilise une édition de ligne façon « emacs »\n"
"                errexit      identique à -e\n"
"                errtrace     identique à -E\n"
"                functrace    identique à -T\n"
"                hashall      identique à -h\n"
"                histexpand   identique à -H\n"
"                history      active l'historique des commandes\n"
"                ignoreeof    ne termine pas le shell à la lecture d'un « EOF »\n"
"                interactive-comments\n"
"                             permet aux commentaires d'apparaître dans les commandes interactives\n"
"                keyword      identique à -k\n"
"                monitor      identique à -m\n"
"                noclobber    identique à -C\n"
"                noexec       identique à -n\n"
"                noglob       identique à -f\n"
"                nolog        actuellement accepté mais ignoré\n"
"                notify       identique à -b\n"
"                nounset      identique à -u\n"
"                onecmd       identique à -t\n"
"                physical     identique à -P\n"
"                pipefail     le code de retour d'un tube est celui de la dernière commande\n"
"                             qui s'est terminée avec un code non nul,\n"
"                             ou zéro si aucune commande ne s'est arrêtée avec un code non nul.\n"
"                posix        modifie le comportement de « bash » où les opérations par défaut\n"
"                             sont différentes du standard Posix de manière à correspondre au\n"
"                             standard\n"
"                privileged   identique à -p\n"
"                verbose      identique à -v\n"
"                vi           utiliser une édition de ligne façon « vi »\n"
"                xtrace       identique à -x\n"
"        -p  Option activée lorsque les n° d'identifiants utilisateurs réels et effectifs ne\n"
"            sont pas les mêmes. Désactive le traitement du fichier $ENV et l'importation des\n"
"            fonctions du shell. Désactiver cette option permet de définir les uid et gid\n"
"            effectifs aux valeurs des uid et gid réels.\n"
"        -t  Termine après la lecture et l'exécution d'une commande.\n"
"        -u  Traite les variables non définies comme des erreurs lors de la substitution.\n"
"        -v  Affiche les lignes d'entrée du shell à leur lecture.\n"
"        -x  Affiche les commandes et leurs arguments au moment de leur exécution.\n"
"        -B  Effectue l'expansion des accolades\n"
"        -C  Si défini, empêche les fichiers réguliers existants d'être écrasés par une\n"
"            redirection de la sortie.\n"
"        -E  Si défini, l'interception ERR est héritée par les fonctions du shell.\n"
"        -H  Active la substitution d'historique façon « ! ». Ceci est actif par défaut\n"
"            lorsque le shell est interactif.\n"
"        -P  Si défini, les liens symboliques ne sont pas suivis lors de l'exécution des\n"
"            commandes telles que « cd » qui changent le répertoire courant.\n"
"        -T  Si défini, l'interception de DEBUG et RETURN est héritée par les fonctions du shell.\n"
"        --  Affecte tous les arguments restants aux paramètres de position.\n"
"            S'il n'y a plus d'argument, les paramètres de position sont\n"
"            indéfinis.\n"
"        -   Affecter tous les arguments restants aux paramètres de position.\n"
"            Les options « -x » et « -v » sont désactivées.\n"
"    \n"
"    Ces indicateurs peuvent être désactivés en utilisant « + » plutôt que « - ». Ils peuvent\n"
"    être utilisés lors de l'appel au shell. Le jeu d'indicateurs actuel peut être trouvé\n"
"    dans « $- ».  Les n ARGs restants sont des paramètres de position et sont affectés,\n"
"    dans l'ordre, à $1, $2, .. $n.  Si aucun ARG n'est donné, toutes les variables du shell\n"
"    sont affichées.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins qu'une option non valable ne soit donnée."

#: builtins.c:1140
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Annule des valeurs ou des attributs de variables et de fonctions du shell.\n"
"    \n"
"    Pour chaque NOM, annule la variable ou fonction correspondante.\n"
"    \n"
"    Options :\n"
"      -f\ttraite chaque NOM comme une fonction du shell\n"
"      -v\ttraite chaque NOM comme une variable du shell\n"
"      -n\ttraite chaque NOM comme une référence nommée et annule la variable\n"
"    \t\telle-même plutôt que la variable à laquelle elle fait référence\n"
"    \n"
"    Sans option, « unset » essaye d'abord d'annuler une variable et, \n"
"    en cas d'échec, essaye d'annuler la fonction.\n"
"    \n"
"    Certaines variables ne peuvent pas être annulées ; consultez aussi « readonly ».\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de succès à moins qu'une option non valable ne soit\n"
"    donnée ou que NOM soit en lecture seule."

#: builtins.c:1162
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Définit l'attribut « export » pour des variables du shell.\n"
"    \n"
"    Marque chaque NOM pour exportation automatique vers l'environnement des\n"
"    commandes exécutées ultérieurement.  Si VALEUR est fournie, affecte la VALEUR\n"
"    avant l'exportation.\n"
"    \n"
"    Options :\n"
"      -f\tse référer aux fonctions du shell\n"
"      -n\tenlève la propriété d'exportation de chaque NOM\n"
"      -p\taffiche une liste de toutes les variables et fonctions exportées\n"
"    \n"
"    L'argument « -- » désactive tout traitement postérieur d'options.\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de succès à moins qu'une option non valable ne soit données\n"
"    ou que NOM ne soit pas valable."

#: builtins.c:1181
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Marque des variables du shell comme non modifiables.\n"
"    \n"
"    Marque chaque NOM comme étant en lecture seule ; les valeurs de ces NOMs\n"
"    ne peuvent plus être modifiées par des affectations ultérieures.  Si VALEUR\n"
"    est fournie, lui affecter la VALEUR avant le passage en lecture seule.\n"
"    \n"
"    Options :\n"
"      -a\tse réfère à des variables étant des tableaux indexés\n"
"      -A\tse réfère à des variables étant des tableaux associatifs\n"
"      -f\tse réfère à des fonctions du shell\n"
"      -p\taffiche une liste des toutes les fonctions et variables en lecture seule\n"
"    \t\tselon que l'option -f est fournie ou non\n"
"    \n"
"    Un argument « -- » désactive tout traitement postérieur d'options.\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de succès à moins qu'une option non valable ne soit\n"
"    donnée ou que NOM ne soit pas valable."

#: builtins.c:1203
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Décale des paramètres de position.\n"
"    \n"
"    Renomme les paramètres de position $N+1,$N+2 ... à $1,$2 ...  Si N n'est pas\n"
"    donné, il est supposé égal à 1.\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de succès à moins que N soit négatif ou supérieur à $#."

#: builtins.c:1215 builtins.c:1230
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Exécute des commandes depuis un fichier dans le shell actuel.\n"
"    \n"
"    Lit et exécute des commandes depuis NOMFICHIER dans le shell actuel.  Les\n"
"    éléments dans $PATH sont utilisés pour trouver le répertoire contenant NOMFICHIER.\n"
"    Si des ARGUMENTS sont fournis, ils deviennent les paramètres de position\n"
"    lorsque NOMFICHIER est exécuté.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de la dernière commande exécutée dans NOMFICHIER, ou le code\n"
"    d'échec si NOMFICHIER ne peut pas être lu."

#: builtins.c:1246
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Suspend l'exécution du shell.\n"
"    \n"
"    Suspend l'exécution de ce shell jusqu'à ce qu'il reçoive un signal SIGCONT.\n"
"    À moins que ce soit forcé, les shell de connexion ne peuvent pas être suspendus.\n"
"    \n"
"    Options :\n"
"      -f\tforce la suspension, même si le shell est un shell de connexion\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de succès à moins que le contrôle de tâche ne soit pas activé\n"
"    ou qu'une erreur survienne."

#: builtins.c:1262
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Évalue une expression conditionnelle.\n"
"    \n"
"    Se termine avec le code de retour 0 (vrai) ou 1 (faux) selon\n"
"    le résultat de l'évaluation de EXPR. Les expressions peuvent être\n"
"    unaires ou binaires. Les expressions unaires sont souvent utilisées\n"
"    pour examiner l'état d'un fichier. Il existe aussi des opérateurs de\n"
"    chaîne, ainsi que des opérateurs de comparaison numériques.\n"
"    \n"
"    Le comportement de test dépend du nombre d'arguments.  Consultez la page\n"
"    de manuel de bash pour connaître les spécifications complètes.\n"
"    \n"
"    Opérateurs sur des fichiers : \n"
"    \n"
"      -a FICHIER     Vrai si le fichier existe.\n"
"      -b FICHIER     Vrai si le fichier est un fichier spécial de bloc.\n"
"      -c FICHIER     Vrai si le fichier est un fichier spécial de caractères.\n"
"      -d FICHIER     Vrai si le fichier est un répertoire.\n"
"      -e FICHIER     Vrai si le fichier existe.\n"
"      -f FICHIER     Vrai si le fichier existe et est un fichier régulier.\n"
"      -g FICHIER     Vrai si le fichier est « set-group-id ».\n"
"      -h FICHIER     Vrai si le fichier est un lien symbolique.\n"
"      -L FICHIER     Vrai si le fichier est un lien symbolique.\n"
"      -k FICHIER     Vrai si le fichier a son bit « sticky » défini.\n"
"      -p FICHIER     Vrai si le fichier est un tube nommé.\n"
"      -r FICHIER     Vrai si le fichier est lisible par vous.\n"
"      -s FICHIER     Vrai si le fichier existe et n'est pas vide.\n"
"      -S FICHIER     Vrai si le fichier est un socket.\n"
"      -t FD          Vrai si FD est ouvert sur un terminal.\n"
"      -u FICHIER     Vrai si le fichier est « set-user-id ».\n"
"      -w FICHIER     Vrai si le fichier peut être écrit par vous.\n"
"      -x FICHIER     Vrai si le fichier est exécutable par vous.\n"
"      -O FICHIER     Vrai si le fichier est effectivement possédé par vous.\n"
"      -G FICHIER     Vrai si le fichier est effectivement possédé par votre groupe.\n"
"      -N FICHIER     Vrai si le fichier a été modifié depuis la dernière fois qu'il a été lu.\n"
"    \n"
"      FICHIER1 -nt FICHIER2 Vrai si le fichier1 est plus récent que le fichier2 (selon la date\n"
"                             de modification).\n"
"    \n"
"      FICHIER1 -ot FICHIER2 Vrai si le fichier1 est plus vieux que le fichier2.\n"
"    \n"
"      FICHIER1 -ef FICHIER2 Vrai si le fichier1 est un lien physique vers le fichier2.\n"
"    \n"
"    Opérateurs sur des chaînes :\n"
"    \n"
"      -z CHAÎNE      Vrai si la chaîne est vide.\n"
"    \n"
"      -n CHAÎNE\n"
"         CHAÎNE      Vrai si la chaîne n'est pas vide.\n"
"    \n"
"      CHAÎNE1 = CHAÎNE2\n"
"                     Vrai si les chaînes sont égales.\n"
"      CHAÎNE1 != CHAÎNE2\n"
"                     Vrai si les chaînes ne sont pas égales.\n"
"      CHAÎNE1 < CHAÎNE2\n"
"                     Vrai si le tri lexicographique place la chaîne1 en premier.\n"
"      CHAÎNE1 > CHAÎNE2\n"
"                     Vrai si le tri lexicographique place la chaîne1 en deuxième.\n"
"    \n"
"    Autres opérateurs :\n"
"    \n"
"      -o OPTION      Vrai si l'OPTION du shell est activée.\n"
"      -v VAR         Vrai si la variable de shell VAR est définie.\n"
"      -R VAR         Vrai is la variable VAR est définie est une référence nommée.\n"
"      ! EXPR         Vrai si l'EXPRession est fausse.\n"
"      EXPR1 -a EXPR2 Vrai si les deux expressions sont vraies.\n"
"      EXPR1 -o EXPR2 Vrai si l'une des deux expressions est vraie.\n"
"    \n"
"      arg1 OP arg2   Tests arithmétiques. OP peut être -eq, -ne,\n"
"                     -lt, -le, -gt ou -ge.\n"
"    \n"
"    Les opérateurs arithmétiques binaires renvoient « vrai » si ARG1 est égal,\n"
"    non-égal, inférieur, inférieur ou égal, supérieur, supérieur ou égal à ARG2.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès si EXPR est vraie, le code d'échec si EXPR est fausse ou si\n"
"    un argument non valable est donné."

#: builtins.c:1344
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Évalue une expression conditionnelle.\n"
"    \n"
"    Ceci est un synonyme de la primitive « test », mais le dernier argument\n"
"    doit être le caractère « ] », pour fermer le « [ » correspondant."

#: builtins.c:1353
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Affiche les temps des processus.\n"
"    \n"
"    Affiche le cumul des temps utilisateur et système pour le shell et\n"
"    tous ses processus fils.\n"
"    \n"
"    Code de retour :\n"
"    Toujours le code de succès."

#: builtins.c:1365
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  If\n"
"    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or a\n"
"    script run by the . or source builtins finishes executing.  A SIGNAL_SPEC\n"
"    of ERR means to execute ARG each time a command's failure would cause the\n"
"    shell to exit when the -e option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is given."
msgstr ""
"Intercepter des signaux et d'autres événements.\n"
"    \n"
"    Définit et active des gestionnaires à lancer lorsque le shell reçoit des signaux\n"
"    ou sous d'autres conditions.\n"
"    \n"
"    La commande ARG doit être lue et exécutée lorsque le shell reçoit le\n"
"    signal SIGNAL_SPEC. Si ARG est absent (et qu'un unique SIGNAL_SPEC\n"
"    est fourni) ou égal à « - », tous les signaux spécifiés sont remis\n"
"    à leur valeur d'origine. Si ARG est une chaîne vide, tous les SIGNAL_SPEC\n"
"    sont ignorés par le shell et les commandes qu'ils appellent.\n"
"    \n"
"    Si SIGNAL_SPEC est EXIT (0), la commande ARG est exécutée à la sortie du shell. Si un\n"
"    SIGNAL_SPEC est DEBUG, ARG est exécuté après chaque commande simple. Si\n"
"    un SIGNAL_SPEC est RETURN, ARG est exécuté à chaque fois qu'une fonction shell ou\n"
"    qu'un script lancé avec . ou source se termine.  Un SIGNAL_SPEC\n"
"    valant ERR permet d'exécuter ARG à chaque fois qu'un échec d'une commande engendrerait\n"
"    la sortie du shell lorsque l'option -e est activée.\n"
"    \n"
"    Si aucun argument n'est fourni, « trap » affiche la liste des commandes associées\n"
"    à chaque signal.\n"
"    \n"
"    Options :\n"
"      -l\taffiche la liste des noms de signaux et leur numéro correspondant\n"
"      -p\taffiche les commandes de « trap » associées à chaque SIGNAL_SPEC\n"
"    \n"
"    Chaque SIGNAL_SPEC est soit un nom de signal dans <signal.h>\n"
"    ou un numéro de signal. Les noms de signaux sont insensibles à la casse et\n"
"    le préfixe « SIG » est facultatif. Un signal peut être envoyé au\n"
"    shell avec « kill -signal $$ ».\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins que SIGSPEC ne soit pas valable ou qu'une\n"
"    option non valable ne soit donnée."

#: builtins.c:1401
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not found."
msgstr ""
"Affiche des informations sur le type de commande.\n"
"    \n"
"    Pour chaque NOM, indique comment il serait interprété s'il était\n"
"    utilisé comme un nom de commande.\n"
"    \n"
"    Options :\n"
"      -a\taffiche tous les emplacements contenant un exécutable nommé NOM;\n"
"    \t\ty compris les alias, les commandes intégrées et les fonctions si et seulement si\n"
"    \t\tl'option « -p » n'est pas utilisée\n"
"      -f\tdésactive la recherche de fonctions du shell\n"
"      -P\tforce une recherche de CHEMIN pour chaque NOM, même si c'est un alias,\n"
"    \t\tune commande intégrée ou une fonction et renvoie le nom du fichier du disque\n"
"    \t\tqui serait exécuté\n"
"      -p\trenvoie le nom du fichier du disque qui serait exécuté sauf si\n"
"    \t\t« type -t NOM » aurait renvoyé autre chose que « file » auquel cas, rien\n"
"    \t\tn'est renvoyé.\n"
"      -t\taffiche un mot unique parmi « alias », « keyword »,\n"
"    \t\t« function », « builtin », « file » or « », si NOM est respectivement un alias,\n"
"    \t\tun mot réservé du shell, une fonction du shell, une commande intégrée,\n"
"    \t\tun fichier du disque ou un nom inconnu\n"
"    \n"
"    Arguments :\n"
"      NOM\tNom de commande à interpréter.\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de succès si tous les NOMs sont trouvés, le code d'échec si l'un\n"
"    d'entre eux n'est pas trouvé."

#: builtins.c:1432
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Modifie les limites de ressources du shell.\n"
"    \n"
"    Fournit un contrôle sur les ressources disponibles au shell et aux processus\n"
"    qu'il crée, sur les systèmes qui permettent un tel contrôle. \n"
"    \n"
"    Options :\n"
"        -S\tutilise la limite de ressources « soft »\n"
"        -H\tutilise la limite de ressources « hard »\n"
"        -a\ttoutes les limites actuelles sont présentées\n"
"        -b\tla taille du tampon de socket\n"
"        -c\ttaille maximale des fichiers « core » créés\n"
"        -d\ttaille maximale du segment de données d'un processus\n"
"        -e\tla priorité maximale d'ordonnancement (« nice »)\n"
"        -f\tla taille maximale des fichiers écrits par le shell et ses fils\n"
"        -i\tle nombre maximal de signaux en attente\n"
"        -k\tle nombre maximal de kqueues allouées pour ce processus\n"
"        -l\tla taille maximale qu'un processus peut verrouiller en mémoire\n"
"        -m\tla taille maximale de « set » résident\n"
"        -n\tle nombre maximal de descripteurs de fichiers ouverts\n"
"        -p\tla taille du tampon pour les tubes\n"
"        -q\tle nombre maximal d'octets dans les queues de messages POSIX\n"
"        -r\tla priorité maximale pour l'ordonnancement temps-réel\n"
"        -s\tla taille maximale de la pile\n"
"        -t\tla quantité maximale de temps processeur en secondes\n"
"        -u\tle nombre maximal de processus utilisateurs\n"
"        -v\tla taille de la mémoire virtuelle\n"
"        -x\tle nombre maximal de verrous de fichiers\n"
"        -P\tle nombre maximal de pseudo terminaux\n"
"        -R\tle temps maximum qu'un processus en temps réel est autorisé à fonctionner\n"
"          \tavant d'être bloqué\n"
"        -T\tle nombre maximal de threads\n"
"        \n"
"    Toutes les options ne sont pas disponibles sur toutes les plates-formes.\n"
"    \n"
"    Si LIMIT est fournie, elle est utilisée comme nouvelle valeur de ressource.\n"
"    Les valeurs spéciales de LIMIT « soft », « hard » et « unlimited » correspondent\n"
"    respectivement aux valeurs actuelles de la limite souple, de la limite dure,\n"
"    ou à une absence de limite. Sinon la valeur actuelle de la limite est affichée\n"
"    Si aucune option n'est donnée, « -f » est supposée.\n"
"    \n"
"    Les valeurs sont des multiples de 1024 octets, sauf pour « -t » qui prend des\n"
"    secondes, « -p » qui prend un multiple de 512 octets et « -u » qui prend un nombre\n"
"    de processus sans unité.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins qu'une option non valable ne soit fournie ou\n"
"    qu'une erreur ne survienne."

#: builtins.c:1483
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Affiche ou définit le masque de mode de fichier.\n"
"    \n"
"    Définit le masque de création de fichier comme étant MODE.  Si MODE est omis,\n"
"    affiche la valeur courante du MASQUE.\n"
"    \n"
"    Si MODE commence par un chiffre, il est interprété comme un nombre octal ;\n"
"    sinon comme une chaîne de symboles de mode comme ceux acceptés par chmod(1).\n"
"    \n"
"    Options :\n"
"      -p\tsi MODE est omis, affiche sous une forme réutilisable en entrée\n"
"      -S\taffiche sous forme symbolique, sinon la sortie octale est utilisée\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de succès à moins que MODE ne soit pas valable ou qu'une\n"
"    option non valable ne soit donnée."

#: builtins.c:1503
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Attend la fin d'une tâche et renvoie le code de retour.\n"
"    \n"
"    Attend la fin du processus identifié par ID, qui peut être un ID de processus\n"
"    ou une spécification de tâche, et renvoie son code de retour.  Si ID n'est\n"
"    pas donné, la commande attend la fin de tous les processus actifs en cours et\n"
"    le code de retour est zéro.  Si ID est une spécification de tâche, la commande\n"
"    attend tous les processus dans le pipeline de la tâche.\n"
"    \n"
"    Si l'option -n est fournie, attend la fin d'une seule tâche de la liste des ID,\n"
"    ou, si aucun ID est fourni, attend la fin de la prochaine tâche et retourne\n"
"    son code de retour.\n"
"    \n"
"    Si l'option -p est fournie, l'identificateur du processus ou de la tâche de la\n"
"    tâche pour laquelle un code de statut est retourné est assigné à la variable VAR\n"
"    nommée par l'argument de l'option. La variable est purgée initialement avant\n"
"    \n"
"    Si l'option -f est fournie et que le contrôle de tâche est activé, attends que\n"
"    le ID spécifié soit terminé au lieu d'attendre qu'il change de statut.\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le même code que celui d'ID ; ou échoue si ID n'est pas valable\n"
"    ou si une option non valable et fournie ou si -n est employé et que le shell\n"
"    n'a aucun enfant sur lequel attendre."

#: builtins.c:1534
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an invalid\n"
"    option is given."
msgstr ""
"Attend la fin d'un processus et renvoie le code de sortie.\n"
"    \n"
"    Attend la fin de chaque processus spécifié par un PID et donne son code de\n"
"    retour. Si PID n'est pas mentionné, la fin de tous les processus fils\n"
"    actuellement actifs est attendue et le code de retour est zéro. PID doit être\n"
"    un ID de processus.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de retour du dernier PID. Échoue si PID n'est pas valable ou\n"
"    si une option non valable est donnée."

#: builtins.c:1549
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Exécute des commandes pour chaque membre d'une liste.\n"
"    \n"
"    La boucle « for » exécute une suite de commandes pour chaque membre d'une\n"
"    liste d'éléments. Si « in MOTS ...; » n'est pas fourni, « in \"$@\" » est\n"
"    utilisé. Pour chaque élément dans MOTS, NOM est défini à cet élément,\n"
"    et les COMMANDES sont exécutées.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de la dernière commande exécutée."

#: builtins.c:1563
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Boucle « for » arithmétique.\n"
"    \n"
"    Équivalent à\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 sont des expressions arithmétiques.  Si une expression\n"
"    est omise, elle se comporte comme si elle était évaluée à 1.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de la dernière commande exécutée."

#: builtins.c:1581
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Sélectionne des mots d'une liste et exécute des commandes.\n"
"    \n"
"    Les mots WORDS subissent une expansion et génèrent une liste de mots.\n"
"    L'ensemble de ces mots est affiché dans la sortie d'erreur, chacun\n"
"    étant précédé d'un nombre. Si « in WORDS » n'est pas fourni, \n"
"    « in \"$@\" » est utilisé. L'invite PS3 est ensuite affichée et une\n"
"    ligne est lue depuis l'entrée standard. Si la ligne consiste en\n"
"    le numéro d'un des mots affichés, alors ce mot est affecté à NAME.\n"
"    Si la ligne est vide, WORDS et l'invite sont réaffichés. Si un EOF\n"
"    est lu, la commande se termine. Toute autre valeur lue a pour effet\n"
"    de vider NAME. La ligne lue est conservée dans la variable REPLY.\n"
"    Les COMMANDS sont exécutées après chaque sélection jusqu'à ce qu'une\n"
"    commande « break » soit exécutée.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de la dernière commande exécutée."

#: builtins.c:1602
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Signale le temps passé pendant l'exécution d'un tube de commandes.\n"
"    \n"
"    Exécute PIPELINE et affiche un résumé du temps réel, du temps processeur\n"
"    utilisateur, et du temps processeur système passés à exécuter PIPELINE\n"
"    lorsque celui-ci se termine.\n"
"    \n"
"    Options :\n"
"      -p\taffiche le résumé dans le format portable Posix.\n"
"    \n"
"    La valeur de la variable TIMEFORMAT est utilisée comme format de sortie.\n"
"    \n"
"    Code de sortie :\n"
"    Le code de retour est celui du PIPELINE."

#: builtins.c:1619
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Exécute des commandes selon une correspondance de motif.\n"
"    \n"
"    Exécute de manière sélective les COMMANDES selon la correspondance du MOT\n"
"    au MOTIF. Le caractère « | » est utilisé pour séparer les différents motifs.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de la dernière commande exécutée."

#: builtins.c:1631
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of the\n"
"    entire construct is the exit status of the last command executed, or zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Exécute des commandes selon une condition.\n"
"    \n"
"    La liste « if COMMANDES » est exécutée. Si elle se termine avec le code zéro,\n"
"    alors la liste « then COMMANDES » est exécutée. Sinon, chaque liste\n"
"    « elif COMMANDES » est exécutée à son tour et si son code de retour est zéro,\n"
"    la liste « then COMMANDES » correspondante est exécutée et la commande « if »\n"
"    se termine. Sinon, la liste « else COMMANDES » est exécutée si elle existe.\n"
"    Le code de retour de l'ensemble est celui de la dernière commande exécutée\n"
"    ou zéro si aucune condition n'était vraie.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de la dernière commande exécutée."

#: builtins.c:1648
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Exécute des commandes aussi longtemps qu'elles réussissent.\n"
"    \n"
"    Effectue une expansion et exécute les COMMANDES-2 aussi longtemps\n"
"    que la commande finale de COMMANDES se termine avec un code de retour\n"
"    à zéro.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de la dernière commande exécutée."

#: builtins.c:1660
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Exécute des commandes aussi longtemps qu'un test échoue.\n"
"    \n"
"    Effectue une expansion et exécute les commandes COMMANDES-2\n"
"    aussi longtemps que la commande finale de COMMANDES se termine\n"
"    avec un code de retour différent de zéro.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de la dernière commande exécutée."

#: builtins.c:1672
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Crée un coprocessus nommé NOM.\n"
"    \n"
"    Exécute la COMMANDE de manière asynchrone, en connectant la sortie et\n"
"    l'entrée standard de la commande par un tube aux descripteurs de fichiers\n"
"    affectés aux indices 0 et 1 d'une variable tableau NOM dans le shell en\n"
"    cours d'exécution. Le NOM par défaut est « COPROC ».\n"
"    \n"
"    Code de retour :\n"
"    La commande coproc renvoie le code de sortie 0."

#: builtins.c:1686
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Définit une fonction du shell.\n"
"    \n"
"    Crée une fonction du shell nommée NOM.  Lorsqu'appelée comme une simple commande,\n"
"    NOM lance la COMMANDE dans le contexte du shell qui l'appelle.  Lorsque NOM est appelé,\n"
"    les arguments sont transmis à la fonction comme $1...$n, et le nom de la fonction\n"
"    est $FUNCNAME.\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de succès à moins que NOM ne soit en lecture seule."

#: builtins.c:1700
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Groupe plusieurs commandes en une seule.\n"
"    \n"
"    Lance un ensemble de commandes d'un groupe. Ceci est une façon de\n"
"    rediriger tout un ensemble de commandes.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de la dernière commande exécutée."

#: builtins.c:1712
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Reprend une tâche en arrière plan.\n"
"    \n"
"    Équivalent à l'argument JOB_SPEC de la commande « fg ». Reprend l'exécution\n"
"    d'une tâche stoppée ou en tâche de fond. JOB_SPEC peut spécifier soit\n"
"    un nom soit un numéro de tâche. Faire suivre JOB_SPEC de « & » permet de\n"
"    placer la tâche en arrière plan, comme si la spécification de tâche avait\n"
"    été fournie comme argument de « bg ».\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de la commande reprise."

#: builtins.c:1727
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Évalue une expression arithmétique.\n"
"    \n"
"    L'EXPRESSION est évaluée selon les règles d'évaluation arithmétique.\n"
"    C'est équivalent à « let \"EXPRESSION\" ».\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie 1 si EXPRESSION est évaluée à 0, sinon renvoie 0."

#: builtins.c:1739
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries used\n"
"    by the `test' builtin, and may be combined using the following operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Exécute une commande conditionnelle.\n"
"    \n"
"    Renvoie le code de retour 0 ou 1 dépendant de l'évaluation de l'EXPRESSION\n"
"    conditionnelle. Les expressions sont formées de la même façon que pour la\n"
"    primitive « test », et peuvent être combinées avec les opérateurs suivants :\n"
"    \n"
"    \t( EXPRESSION )\tRenvoie la valeur de l'EXPRESSION\n"
"    \t! EXPRESSION\tVrai si l'EXPRESSION est fausse, sinon vrai\n"
"    \tEXPR1 && EXPR2\tVrai si EXPR1 et EXPR2 sont vraies, faux sinon\n"
"    \tEXPR1 || EXPR2\tVrai si EXPR1 ou EXPR2 est vraie, faux sinon\n"
"    \n"
"    Lorsque les opérateurs « == » et « != » sont utilisés, la chaîne à droite de\n"
"    l'opérateur est utilisée comme motif, et une mise en correspondance est effectuée.\n"
"    Lorsque l'opérateur « =~ » est utilisé, la chaîne à droite de l'opérateur\n"
"    est mise en correspondance comme une expression rationnelle.\n"
"    \n"
"    Les opérateurs « && » et « || » n'évaluent pas EXPR2 si\n"
"    EXPR1 est suffisant pour déterminer la valeur de l'expression.\n"
"    \n"
"    Code de sortie :\n"
"    0 ou 1 selon la valeur de l'EXPRESSION."

#: builtins.c:1765
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Nom et usage de variable shell courantes.\n"
"    \n"
"    BASH_VERSION\tNuméro de version de ce Bash.\n"
"    CDPATH\tUne liste de répertoires, séparés par un deux-points, utilisés\n"
"    \t\tpar « cd » pour la recherche de répertoires.\n"
"    GLOBIGNORE\tUne liste de motifs séparés par un deux-points, décrivant les\n"
"    \t\tnoms de fichiers à ignorer lors de l'expansion des chemins.\n"
"    HISTFILE\tLe nom du fichier où votre historique des commandes est stocké.\n"
"    HISTFILESIZE\tLe nombre maximal de lignes que ce fichier peut contenir.\n"
"    HISTSIZE\tLe nombre maximal de lignes d'historique auquel un shell en\n"
"    \t\tfonctionnement peut accéder.\n"
"    HOME\tLe chemin complet vers votre répertoire de connexion.\n"
"    HOSTNAME\tLe nom de la machine actuelle.\n"
"    HOSTTYPE\tLe type de processeur sur lequel cette version de Bash fonctionne.\n"
"    IGNOREEOF\tContrôle l'action du shell à la réception d'un caractère « EOF »\n"
"    \t\tcomme seule entrée. Si défini, sa valeur est le nombre de caractères\n"
"    \t\t« EOF » qui peuvent être rencontrés à la suite sur une ligne vide\n"
"    \t\tavant que le shell ne se termine (10 par défaut).\n"
"    \t\tS'il n'est pas défini, « EOF » signifie la fin de l'entrée.\n"
"    MACHTYPE\tUne chaîne décrivant le système actuel sur lequel fonctionne Bash.\n"
"    MAILCHECK\tLe nombre de secondes séparant deux vérifications du courrier par Bash.\n"
"    MAILPATH\tUne liste de fichiers séparés par un deux-points, que Bash utilise\n"
"    \t\tpour vérifier les nouveaux courriers.\n"
"    OSTYPE\tLa version d'Unix sur laquelle cette version de Bash fonctionne.\n"
"    PATH\tUne liste de répertoires séparés par un deux-points, utilisés\n"
"    \t\tpour la recherche des commandes.\n"
"    PROMPT_COMMAND\tUne commande à exécuter avant d'afficher chaque invite\n"
"    \t\tde commande principale.\n"
"    PS1\t\tL'invite de commande principal.\n"
"    PS2\t\tL'invite secondaire.\n"
"    PWD\t\tLe chemin complet vers le répertoire actuel.\n"
"    SHELLOPTS\tLa liste des options activées du shell, séparées par un deux-points.\n"
"    TERM\tLe nom du type actuel du terminal.\n"
"    TIMEFORMAT\tLe format de sortie pour les statistiques de temps affichées\n"
"    \t\tpar le mot réservé « time ».\n"
"    auto_resume\tNon-vide signifie qu'un mot de commande apparaissant\n"
"    \t\tde lui-même sur une ligne est d'abord recherché dans la liste des\n"
"    \t\ttâches stoppées. Si elle est trouvée, la tâche est remise en avant-plan.\n"
"    \t\tLa valeur « exact » signifie que le mot de commande doit correspondre\n"
"    \t\texactement à la commande dans la liste des tâches stoppées.  La valeur\n"
"    \t\t« substring » signifie que le mot de commande doit correspondre à une\n"
"    \t\tsous-chaîne de la tâche. Une autre valeur signifie que la commande doit\n"
"    \t\têtre un préfixe d'une tâche stoppée.\n"
"    histchars\tCaractères contrôlant l'expansion d'historique et la substitution\n"
"    \t\trapide. Le premier caractère est le caractère de substitution d'historique,\n"
"    \t\thabituellement « ! ». Le deuxième est le caractère de substitution rapide,\n"
"    \t\thabituellement « ^ ». Le troisième est le caractère de commentaire\n"
"    \t\td'historique, habituellement « # ».\n"
"    HISTIGNORE\tUne liste de motifs séparés par un deux-points, utilisés pour\n"
"    \t\tdécider quelles commandes doivent être conservées dans la liste d'historique.\n"

#: builtins.c:1822
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Ajoute un répertoire à la pile.\n"
"    \n"
"    Ajoute un répertoire en haut de la pile des répertoires, ou permute\n"
"    la pile, de façon que le répertoire en haut de la pile devienne\n"
"    le nouveau répertoire de travail. S'il n'y a pas d'argument, les deux\n"
"    répertoires en haut de la pile sont échangés.\n"
"    \n"
"    Options :\n"
"      -n\tNe change pas de répertoire de travail lorsque des répertoires\n"
"    \t\tsont ajoutés à la pile, de façon que seule la pile soit manipulée\n"
"    \n"
"    Arguments :\n"
"      +N\tPermute la pile de façon que le Nième répertoire se place en haut,\n"
"    \t\ten comptant de zéro depuis la gauche de la liste fournie par « dirs ».\n"
"    \n"
"      -N\tPermute la pile de façon que le Nième répertoire se place en haut,\n"
"    \t\ten comptant de zéro depuis la droite de la liste fournie par « dirs ».\n"
"    \n"
"      dir\tAjoute le répertoire DIR en haut de la pile, et en fait le nouveau\n"
"    \t\trépertoire de travail.\n"
"    \n"
"    Vous pouvez voir la pile des répertoires avec la commande « dirs ».\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins qu'un argument non valable ne soit fourni\n"
"    ou que le changement de répertoire n'échoue."

#: builtins.c:1856
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Enlève des répertoires de la pile.\n"
"    \n"
"    Enlève des éléments de la pile des répertoires. S'il n'y a pas\n"
"    d'argument, le répertoire en haut de la pile est enlevé et le\n"
"    nouveau sommet de la pile devient le répertoire de travail.\n"
"    \n"
"    Options :\n"
"      -n\tNe change pas de répertoire de travail lorsque des répertoires\n"
"    \t\tsont enlevés de la pile, de façon que seule la pile soit manipulée\n"
"    \n"
"    Arguments :\n"
"      +N\tEnlève le Nième répertoire, en comptant de zéro depuis la gauche\n"
"    \t\tde la liste fournie par « dirs ». Par exemple : « popd +0 »\n"
"    \t\tenlève le premier répertoire, « popd +1 » le deuxième.\n"
"    \n"
"      -N\tEnlève le Nième répertoire, en comptant de zéro depuis la droite\n"
"    \t\tde la liste fournie par « dirs ». Par exemple : « popd -0 »\n"
"    \t\tenlève le dernier répertoire, « popd -1 » l'avant-dernier.\n"
"    \n"
"    Vous pouvez voir la pile des répertoires avec la commande « dirs ».\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins qu'un argument non valable ne soit donné\n"
"    ou que le changement de répertoire n'échoue."

#: builtins.c:1886
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Affiche la pile de répertoire.\n"
"    \n"
"    Affiche la liste des répertoires actuellement mémorisés. Les répertoires\n"
"    sont insérés dans la liste avec la commande « pushd ». Vous pouvez remonter\n"
"    dans la liste en enlevant des éléments avec la commande « popd ».\n"
"    \n"
"    Options:\n"
"      -c\tefface la pile des répertoires en effaçant tous les éléments\n"
"      -l\tn'affiche pas la version raccourcie (avec ~) des répertoires\n"
"    \t\trelativement à votre dossier personnel\n"
"      -p\taffiche la pile des répertoires avec un élément par ligne\n"
"      -v\taffiche la pile des répertoires avec un élément par ligne,\n"
"    \t\ten préfixant avec sa position dans la pile\n"
"    \n"
"    Arguments :\n"
"      +N\tAffiche le Nième élément en comptant de zéro depuis la gauche de la\n"
"    \t\tliste affichée par « dirs » lorsque celle-ci est appelée sans option.\n"
"    \n"
"      -N\tAffiche le Nième élément en comptant de zéro depuis la droite de la\n"
"    \t\tliste affichée par « dirs » lorsque celle-ci est appelée sans option.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins qu'une option non valable ne soit\n"
"    fournie ou qu'une erreur ne survienne."

#: builtins.c:1917
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Active ou désactive des options du shell.\n"
"    \n"
"    Change la valeur de chaque option du shell NOMOPT.  S'il n'y a pas d'argument\n"
"    à l'option, liste chaque NOMOPT fourni ou toutes les options du shell si aucun\n"
"    NOMOPT est donné, avec une indication montrant si chacun est actif ou non.\n"
"    \n"
"    Options :\n"
"      -o\trestreint les NOMOPT à ceux définis pour être utilisés avec « set -o »\n"
"      -p\taffiche chaque option du shell en indiquant son état\n"
"      -q\tsupprime l'affichage\n"
"      -s\tactive (set) chaque NOMOPT\n"
"      -u\tdésactive (unset) chaque NOMOPT\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de succès si NOMOPT est active ; échec si une option non valable\n"
"    est donnée ou si NOMOPT est inactive."

#: builtins.c:1938
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: plain\n"
"    characters, which are simply copied to standard output; character escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in printf(1),\n"
"    printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or assignment\n"
"    error occurs."
msgstr ""
"Formate et affiche des ARGUMENTS en contrôlant le FORMAT.\n"
"    \n"
"    Options :\n"
"      -v var\taffecte la sortie à la variable VAR du shell plutôt que de l'afficher\n"
"    \t\tsur la sortie standard\n"
"    \n"
"    Le FORMAT est une chaîne de caractères qui contient trois types d'objets : des caractères\n"
"    normaux qui sont simplement copiés vers la sortie standard ; des séquences d'échappement\n"
"    qui sont converties et copiées vers la sortie standard et des spécifications de\n"
"    format, chacun entraînant l'affichage de l'argument suivant.\n"
"    \n"
"    En plus des formats standards décrits dans printf(1), « printf » interprète :\n"
"    \n"
"      %b\tdéveloppe les séquences d'échappement à contre-oblique dans l'argument correspondant\n"
"      %q\tprotège les arguments avec des guillemets de façon qu'ils puissent être réutilisés\n"
"      comme entrée du shell.\n"
"      %Q\tcomme %q mais applique une éventuelle précision à l'argument sans guillemets avant\n"
"      d'ajouter les guillemets.\n"
"      %(fmt)T\trenvoie la chaîne date-heure résultant de l'utilisation de FMT comme\n"
"    \t        chaîne de format pour strftime(3)\n"
"    \n"
"    Le format est réutilisé si nécessaire pour consommer tous les arguments. S'il y a\n"
"    moins d'arguments qu'exigé par le format, les spécificateurs de format surnuméraires\n"
"    se comportent comme si la valeur zéro ou une chaîne nulle avait été fournies (selon\n"
"    ce qui est approprié).\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins qu'une option non valable ne soit donnée ou qu'une\n"
"    erreur d'écriture ou d'affectation ne survienne."

#: builtins.c:1974
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no options\n"
"    are supplied, existing completion specifications are printed in a way that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Spécifie la façon dont Readline complète les arguments.\n"
"    \n"
"    Pour chaque NOM, la commande spécifie la façon dont les arguments sont complétés\n"
"    S'il n'y a pas d'option, le réglage actuel est affiché d'une manière\n"
"    réutilisable comme une entrée.\n"
"    \n"
"    Options :\n"
"      -p\taffiche le réglage d'auto-complètement actuel dans un format réutilisable\n"
"      -r\tretire un réglage d'auto-complètement de chaque NOM ou, si aucun NOM\n"
"    \t\tn'est fourni, retire tous les réglages\n"
"      -D\tapplique les auto-complètements et actions comme valeurs par défaut aux\n"
"    \t\tcommandes ne possédant aucun auto-complètement spécifique\n"
"      -E\tapplique les auto-complètements et actions aux commandes vides\n"
"    \t\t(auto-complètement tenté sur une ligne vide)\n"
"      -I\tapplique les auto-complètements et actions au mot initial (habituellement\n"
"    \t\tla commande)\n"
"    \n"
"    Lorsqu'un auto-complètement est tenté, les actions sont appliquées dans l'ordre\n"
"    dans lequel les options en majuscule ci-dessus sont listées. Si plusieurs\n"
"    options sont fournies, l'option « -D » est prioritaire sur -E et les deux sont\n"
"    prioritaires sur -I.\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de succès à moins qu'une option non valable ne soit fournie ou\n"
"    qu'une erreur ne survienne."

#: builtins.c:2004
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Affiche les possibilités de complètement dépendant des options.\n"
"    \n"
"    Ceci est destiné à être utilisé depuis une fonction de shell générant\n"
"    des auto-complètements possibles. Si le MOT optionnel est fourni,\n"
"    des correspondances avec « MOT » sont générées.\n"
"    \n"
"    Code de sortie :\n"
"    Renvoie le code de succès à moins qu'une option non valable ne soit\n"
"    fournie ou qu'une erreur ne survienne."

#: builtins.c:2019
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, print\n"
"    the completion options for each NAME or the current completion specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Modifie ou affiche les options d'auto-complètement.\n"
"    \n"
"    Modifie les options d'auto-complètement pour chaque NOM ou, si aucun NOM n'est\n"
"    fourni, pour l'auto-complètement actuellement exécuté.  Si aucune OPTION n'est\n"
"    donnée, affiche les options d'auto-complètement de chaque NOM ou le réglage\n"
"    actuel d'auto-complètement.\n"
"    \n"
"    Options :\n"
"    \t-o option\tDéfini l'option d'auto-complètement OPTION pour chaque NOM\n"
"    \t-D\t\tChange les options pour l'auto-complètement de commande par défaut\n"
"    \t-E\t\tChange les options pour l'auto-complètement de commande vide\n"
"    \t-I\t\tChange les options pour l'auto-complètement du mot initial\n"
"    \n"
"    Utiliser « +o » au lieu de « -o » désactive l'option spécifiée.\n"
"    \n"
"    Arguments :\n"
"    \n"
"    Chaque NOM correspond à une commande pour laquelle un réglage d'auto-complètement\n"
"    doit déjà avoir été défini grâce à la commande intégrée « complete ».  Si aucun\n"
"    NOM n'est fourni, « compopt » doit être appelée par une fonction générant\n"
"    des auto-complètements ; ainsi les options de ce générateur d'auto-complètement\n"
"    en cours d'exécution seront modifiées.\n"
"    \n"
"    Code de retour :\n"
"    Renvoie le code de succès à moins qu'une option non valable ne soit fournie\n"
"    ou que NOM n'ait aucun réglage d'auto-complètement."

#: builtins.c:2050
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly or\n"
"    not an indexed array."
msgstr ""
"Lit des lignes depuis l'entrée standard vers une variable tableau indexé.\n"
"    \n"
"    Lit des lignes depuis l'entrée standard vers la variable tableau indexé TABLEAU ou\n"
"    depuis le descripteur de fichier FD si l'option « -u » est utilisée. La variable\n"
"    MAPFILE est le TABLEAU par défaut.\n"
"    \n"
"    Options :\n"
"      -d delim\tUtilise DELIM pour terminer les lignes au lieu du saut de ligne\n"
"      -n nombre\tCopie au maximum NOMBRE lignes.  Si NOMBRE est 0, toutes les lignes sont copiées.\n"
"      -O origine\tCommence l'affectation au TABLEAU à l'indice ORIGINE.  L'indice par défaut est 0.\n"
"      -s nombre\tSaute les NOMBRE premières lignes lues.\n"
"      -t\tRetire les retours à la ligne de chaque ligne lue.\n"
"      -u fd\tLit les lignes depuis le descripteur de fichier FD au lieu de l'entrée standard.\n"
"      -C callback\tÉvalue CALLBACK à chaque fois que QUANTUM lignes sont lues.\n"
"      -c quantum\tIndique le nombre de lignes lues entre chaque appel au CALLBACK.\n"
"    \n"
"    Arguments :\n"
"      TABLEAU\tNom de la variable tableau à utiliser pour les données.\n"
"    \n"
"    Si l'option « -C » est fournie sans option « -c », le quantum par défaut est 5000.\n"
"    Lorsque CALLBACK est évalué, l'indice du prochain élément de tableau qui sera affecté\n"
"    lui est transmis comme argument additionnel.\n"
"    \n"
"    Si la commande « mapfile » n'est pas appelée avec une origine explicite, le tableau est\n"
"    vidé avant affectation.\n"
"    \n"
"    code de retour :\n"
"    Renvoie le code de succès à moins qu'une option non valable ne soit donnée ou que\n"
"    le TABLEAU soit en lecture seule ou ne soit pas un tableau indexé."

#: builtins.c:2086
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Lit des lignes depuis un fichier vers une variable tableau.\n"
"    \n"
"    Synonyme de « mapfile »."

#~ msgid "%s: invalid associative array key"
#~ msgstr "%s : clé non valable pour le tableau associatif"

#~ msgid ""
#~ "Returns the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns "
#~ msgstr ""
#~ "Renvoie le contexte de l'appel de sous-routine actuel.\n"
#~ "    \n"
#~ "    Sans EXPR, renvoie"

#~ msgid "add_process: process %5ld (%s) in the_pipeline"
#~ msgstr "add_process : processus %5ld (%s) dans le_pipeline"

#~ msgid "Unknown Signal #"
#~ msgstr "N° de signal inconnu"

#~ msgid "Copyright (C) 2018 Free Software Foundation, Inc."
#~ msgstr "Copyright (C) 2018 Free Software Foundation, Inc."

#~ msgid "Copyright (C) 2014 Free Software Foundation, Inc."
#~ msgstr "Copyright (C) 2014 Free Software Foundation, Inc."

#~ msgid ":"
#~ msgstr ":"

#~ msgid "true"
#~ msgstr "true"

#~ msgid "false"
#~ msgstr "false"

#~ msgid "times"
#~ msgstr "times"

#~ msgid "Copyright (C) 2009 Free Software Foundation, Inc.\n"
#~ msgstr "Copyright (C) 2009 Free Software Foundation, Inc.\n"

#~ msgid "License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>\n"
#~ msgstr "Licence GPLv2+ : GNU GPL version 2 ou ultérieure <http://gnu.org/licenses/gpl.html>\n"

#~ msgid ""
#~ ".  With EXPR, returns\n"
#~ "    "
#~ msgstr ""
#~ ".  Avec EXPR, renvoie\n"
#~ "    "

#~ msgid ""
#~ "; this extra information can be used to\n"
#~ "    provide a stack trace.\n"
#~ "    \n"
#~ "    The value of EXPR indicates how many call frames to go back before the\n"
#~ "    current one; the top frame is frame 0."
#~ msgstr ""
#~ "; ces informations supplémentaires peuvent être utilisées pour\n"
#~ "    fournir une trace d'appels\n"
#~ "    \n"
#~ "    La valeur de EXPR indique le nombre de cadres d'appels duquel il faut revenir en arrière\n"
#~ "    avant le cadre actuel ; le cadre supérieur est le cadre 0."

#~ msgid " "
#~ msgstr " "

#~ msgid "Without EXPR, returns returns \"$line $filename\".  With EXPR,"
#~ msgstr "Sans « EXPR », renvoie « $ligne $nomfichier ».  Avec « EXPR »,"

#~ msgid "returns \"$line $subroutine $filename\"; this extra information"
#~ msgstr "renvoie « $ligne $sousroutine $nomfichier » ; cette information supplémentaire"

#~ msgid "can be used used to provide a stack trace."
#~ msgstr "peut être utilisée pour fournir une trace de la pile"

#~ msgid "The value of EXPR indicates how many call frames to go back before the"
#~ msgstr "La valeur de « EXPR » indique le nombre de cadres d'appel dont il faut reculer"

#~ msgid "current one; the top frame is frame 0."
#~ msgstr "par rapport à l'actuel ; le cadre supérieur est le cadre 0."

#~ msgid "%s: invalid number"
#~ msgstr "%s : nombre non valable"

#~ msgid "Shell commands matching keywords `"
#~ msgstr "Commandes du shell correspondant aux mots-clés « "

#~ msgid "Display the list of currently remembered directories.  Directories"
#~ msgstr "Affiche la liste des répertoires actuellement mémorisés. Les répertoires"

#~ msgid "find their way onto the list with the `pushd' command; you can get"
#~ msgstr "sont insérés dans la pile avec la commande « pushd » ; vous pouvez"

#~ msgid "back up through the list with the `popd' command."
#~ msgstr "remonter dans la pile en enlevant des éléments avec la commande « popd »."

#~ msgid "The -l flag specifies that `dirs' should not print shorthand versions"
#~ msgstr "L'option « -l » demande à « dirs » de ne pas afficher sous forme abrégée"

#~ msgid "of directories which are relative to your home directory.  This means"
#~ msgstr "les répertoires relatifs à votre répertoire personnel.  Cela signifie que"

#~ msgid "that `~/bin' might be displayed as `/homes/bfox/bin'.  The -v flag"
#~ msgstr "le répertoire « ~/bin » pourra être affiché « /homes/bfox/bin ». L'option « -v »"

#~ msgid "causes `dirs' to print the directory stack with one entry per line,"
#~ msgstr "demande à « dirs » d'afficher un répertoire de la pile par ligne,"

#~ msgid "prepending the directory name with its position in the stack.  The -p"
#~ msgstr "en le précédant de sa position dans la pile.  L'option « -p » fait la même chose"

#~ msgid "flag does the same thing, but the stack position is not prepended."
#~ msgstr "sans afficher le numéro d'emplacement dans la pile."

#~ msgid "The -c flag clears the directory stack by deleting all of the elements."
#~ msgstr "L'option « -c » vide la pile des répertoires en retirant tous ses éléments."

#~ msgid "+N   displays the Nth entry counting from the left of the list shown by"
#~ msgstr "+N   affiche la Nième entrée à partir de la gauche de la liste fournie par"

#~ msgid "     dirs when invoked without options, starting with zero."
#~ msgstr "     « dirs » lorsqu'elle est appelée sans option, la première entrée étant zéro."

#~ msgid "-N   displays the Nth entry counting from the right of the list shown by"
#~ msgstr "+N   affiche la Nième entrée à partir de la droite de la liste fournie par"

#~ msgid "Adds a directory to the top of the directory stack, or rotates"
#~ msgstr "Ajoute un répertoire au dessus de la pile des répertoires ou effectue une"

#~ msgid "the stack, making the new top of the stack the current working"
#~ msgstr "rotation de la pile en plaçant le répertoire supérieur comme répertoire courant."

#~ msgid "directory.  With no arguments, exchanges the top two directories."
#~ msgstr "Sans paramètre, les deux répertoires supérieurs de la pile sont échangés."

#~ msgid "+N   Rotates the stack so that the Nth directory (counting"
#~ msgstr "+N   effectue une rotation de la pile de façon que le Nième répertoire soit"

#~ msgid "     from the left of the list shown by `dirs', starting with"
#~ msgstr "placé au dessus (N commençant à zéro et en partant à gauche de la liste"

#~ msgid "     zero) is at the top."
#~ msgstr " fournie par « dirs »)."

#~ msgid "-N   Rotates the stack so that the Nth directory (counting"
#~ msgstr "+N   effectue une rotation de la pile de façon que le Nième répertoire soit"

#~ msgid "     from the right of the list shown by `dirs', starting with"
#~ msgstr "placé au dessus (N commençant à zéro et en partant à gauche de la liste"

#~ msgid "-n   suppress the normal change of directory when adding directories"
#~ msgstr "-n   inhibe le changement de répertoire lors d'un ajout de répertoire "

#~ msgid "     to the stack, so only the stack is manipulated."
#~ msgstr "     à la liste. Seule la pile est manipulée."

#~ msgid "dir  adds DIR to the directory stack at the top, making it the"
#~ msgstr "dir  ajoute « DIR » au dessus de la pile des répertoires, en faisant de lui"

#~ msgid "     new current working directory."
#~ msgstr "     le nouveau répertoire courant."

#~ msgid "You can see the directory stack with the `dirs' command."
#~ msgstr "Vous pouvez voir le contenu de la pile des répertoires avec la commande « dirs »."

#~ msgid "Removes entries from the directory stack.  With no arguments,"
#~ msgstr "Enlève des éléments de la pile des répertoires. Sans paramètre,"

#~ msgid "removes the top directory from the stack, and cd's to the new"
#~ msgstr "le répertoire supérieur de la pile est enlevé et un changement de"

#~ msgid "+N   removes the Nth entry counting from the left of the list"
#~ msgstr "+N   enlève le Nième élément en commençant à zéro à gauche"

#~ msgid "     shown by `dirs', starting with zero.  For example: `popd +0'"
#~ msgstr "de la liste affichée par « dirs ». Par exemple, « popd  +0 »"

#~ msgid "     removes the first directory, `popd +1' the second."
#~ msgstr "     enlève le premier répertoire, « popd  +1 » le second."

#~ msgid "-N   removes the Nth entry counting from the right of the list"
#~ msgstr "+N   enlève la Nième entrée en commençant à zéro à droite"

#~ msgid "     shown by `dirs', starting with zero.  For example: `popd -0'"
#~ msgstr "de la liste affichée par « dirs ». Par exemple, « popd  -0 »"

#~ msgid "     removes the last directory, `popd -1' the next to last."
#~ msgstr "     enlève le dernier répertoire, « popd  -1 » l'avant-dernier."

#~ msgid "-n   suppress the normal change of directory when removing directories"
#~ msgstr "-n   inhibe le changement de répertoire lors de l'enlèvement d'un répertoire"

#~ msgid "     from the stack, so only the stack is manipulated."
#~ msgstr "     de la liste. Seule la pile est manipulée."

#~ msgid "allocated"
#~ msgstr "alloué"

#~ msgid "freed"
#~ msgstr "libéré"

#~ msgid "requesting resize"
#~ msgstr "demande de redimensionnement"

#~ msgid "just resized"
#~ msgstr "redimensionné à l'instant"

#~ msgid "bug: unknown operation"
#~ msgstr "bogue : opération inconnue"

#~ msgid "malloc: watch alert: %p %s "
#~ msgstr "malloc : alerte de « watch » : %p %s "

#~ msgid "xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr "xrealloc : impossible de réallouer %lu octets (%lu octets alloués)"

#~ msgid "xrealloc: cannot allocate %lu bytes"
#~ msgstr "xrealloc : impossible d'allouer %lu octets"

#~ msgid "xrealloc: %s:%d: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr "xrealloc : %s:%d : impossible de réallouer %lu octets (%lu octets alloués)"

#~ msgid ""
#~ "Exit from within a FOR, WHILE or UNTIL loop.  If N is specified,\n"
#~ "    break N levels."
#~ msgstr ""
#~ "Permet de sortir d'une boucle FOR, WHILE ou UNTIL.  Si N est précisé,\n"
#~ "    la sortie de boucle se fait sur N niveaux."

#~ msgid ""
#~ "Run a shell builtin.  This is useful when you wish to rename a\n"
#~ "    shell builtin to be a function, but need the functionality of the\n"
#~ "    builtin within the function itself."
#~ msgstr ""
#~ "Lance une primitive du shell. Ceci est utile lorsque vous souhaitez nommer une fonction comme\n"
#~ "    une primitive, mais que vous avez besoin d'utiliser la primitive dans la fonction elle-même."

#~ msgid ""
#~ "Print the current working directory.  With the -P option, pwd prints\n"
#~ "    the physical directory, without any symbolic links; the -L option\n"
#~ "    makes pwd follow symbolic links."
#~ msgstr ""
#~ "Affiche le répertoire de travail actuel.  Avec l'option « -P », « pwd » affiche\n"
#~ "    le répertoire physique, sans lien symbolique ; l'option « -L »\n"
#~ "    demande à « pwd » de suivre les liens symboliques."

#~ msgid "Return a successful result."
#~ msgstr "Renvoie un résultat de succès"

#~ msgid ""
#~ "Runs COMMAND with ARGS ignoring shell functions.  If you have a shell\n"
#~ "    function called `ls', and you wish to call the command `ls', you can\n"
#~ "    say \"command ls\".  If the -p option is given, a default value is used\n"
#~ "    for PATH that is guaranteed to find all of the standard utilities.  If\n"
#~ "    the -V or -v option is given, a string is printed describing COMMAND.\n"
#~ "    The -V option produces a more verbose description."
#~ msgstr ""
#~ "Lance la commande COMMAND avec les ARGS en ignorant les fonctions du shell.  Si vous\n"
#~ "    avez défini une fonction de shell appelée « ls » et que vous voulez appeler\n"
#~ "    la commande « ls », vous pouvez faire « command ls ».  Si l'option « -p » est\n"
#~ "    donnée, une valeur par défaut est utilisée pour le PATH garantissant que tous\n"
#~ "    les utilitaires standards seront trouvés.  Si l'option « -V » ou « -v » est\n"
#~ "    donnée, une description de la commande s'affiche. L'option « -V » fournit plus\n"
#~ "    d'informations."

#~ msgid ""
#~ "Declare variables and/or give them attributes.  If no NAMEs are\n"
#~ "    given, then display the values of variables instead.  The -p option\n"
#~ "    will display the attributes and values of each NAME.\n"
#~ "    \n"
#~ "    The flags are:\n"
#~ "    \n"
#~ "      -a\tto make NAMEs arrays (if supported)\n"
#~ "      -f\tto select from among function names only\n"
#~ "      -F\tto display function names (and line number and source file name if\n"
#~ "    \tdebugging) without definitions\n"
#~ "      -i\tto make NAMEs have the `integer' attribute\n"
#~ "      -r\tto make NAMEs readonly\n"
#~ "      -t\tto make NAMEs have the `trace' attribute\n"
#~ "      -x\tto make NAMEs export\n"
#~ "    \n"
#~ "    Variables with the integer attribute have arithmetic evaluation (see\n"
#~ "    `let') done when the variable is assigned to.\n"
#~ "    \n"
#~ "    When displaying values of variables, -f displays a function's name\n"
#~ "    and definition.  The -F option restricts the display to function\n"
#~ "    name only.\n"
#~ "    \n"
#~ "    Using `+' instead of `-' turns off the given attribute instead.  When\n"
#~ "    used in a function, makes NAMEs local, as with the `local' command."
#~ msgstr ""
#~ "Déclare des variables ou ajoute des attributs aux variables.  Si aucun nom\n"
#~ "    n'est donné, affiche plutôt les valeurs des variables.  L'option « -p »\n"
#~ "    permet d'afficher les attributs et les valeurs de chaque NAME.\n"
#~ "    \n"
#~ "    Les options sont :\n"
#~ "    \n"
#~ "      -a\tpour faire des tableaux de NAME (si pris en charge)\n"
#~ "      -f\tpour choisir uniquement parmi les noms de fonctions\n"
#~ "      -F\tpour afficher les noms de fonctions (et les numéros de ligne et le\n"
#~ "       \tfichier source si le mode de débogage est activé\n"
#~ "      -i\tpour que les NAME aient l'attribut « integer »\n"
#~ "      -r\tpour que les NAME soient en lecture seule\n"
#~ "      -t\tpour que les NAME aient l'attribut « trace »\n"
#~ "      -x\tpour faire un export des NAME\n"
#~ "    \n"
#~ "    L'évaluation arithmétique des variables ayant l'attribut « integer » est\n"
#~ "    effectuée au moment de l'affectation (voir « let »).\n"
#~ "    \n"
#~ "    Lors de l'affichage des valeurs de variables, -f affiche le nom de la fonction\n"
#~ "    et sa définition.  L'option -F permet de n'afficher que le nom.\n"
#~ "    \n"
#~ "    Un attribut peut être désactivé en utilisant « + » au lieu de « - ».  Dans une\n"
#~ "    fonction, ceci a pour effet de rendre les NAME locaux, comme avec la commande «local »."

#~ msgid "Obsolete.  See `declare'."
#~ msgstr "Obsolète. Consulter « declare »."

#~ msgid ""
#~ "Create a local variable called NAME, and give it VALUE.  LOCAL\n"
#~ "    can only be used within a function; it makes the variable NAME\n"
#~ "    have a visible scope restricted to that function and its children."
#~ msgstr ""
#~ "Permet de créer une variable locale appelée NAME, et de lui affecter une VALUE.\n"
#~ "    LOCAL peut seulement être utilisé à l'intérieur d'une fonction ; il rend le nom de\n"
#~ "    variable NAME visible uniquement à l'intérieur de la fonction et de ses filles."

#~ msgid "Output the ARGs.  If -n is specified, the trailing newline is suppressed."
#~ msgstr "Affiche les ARGs. L'option « -n » supprime le saut de ligne final."

#~ msgid ""
#~ "Enable and disable builtin shell commands.  This allows\n"
#~ "    you to use a disk command which has the same name as a shell\n"
#~ "    builtin without specifying a full pathname.  If -n is used, the\n"
#~ "    NAMEs become disabled; otherwise NAMEs are enabled.  For example,\n"
#~ "    to use the `test' found in $PATH instead of the shell builtin\n"
#~ "    version, type `enable -n test'.  On systems supporting dynamic\n"
#~ "    loading, the -f option may be used to load new builtins from the\n"
#~ "    shared object FILENAME.  The -d option will delete a builtin\n"
#~ "    previously loaded with -f.  If no non-option names are given, or\n"
#~ "    the -p option is supplied, a list of builtins is printed.  The\n"
#~ "    -a option means to print every builtin with an indication of whether\n"
#~ "    or not it is enabled.  The -s option restricts the output to the POSIX.2\n"
#~ "    `special' builtins.  The -n option displays a list of all disabled builtins."
#~ msgstr ""
#~ "Active et désactive les primitives du shell.  Ceci permet\n"
#~ "    d'utiliser une commande du disque qui a le même nom qu'une commande intégrée\n"
#~ "    sans devoir spécifier un chemin complet.  Si « -n » est utilisé, les\n"
#~ "    noms NAME sont désactivés ; sinon, les noms NAME sont activés. Par exemple,\n"
#~ "    pour utiliser « test » trouvé dans $PATH au lieu de la primitive du\n"
#~ "    même nom, tapez « enable -n test ».  Sur les systèmes permettant le chargement\n"
#~ "    dynamique, l'option « -f » peut être utilisée pour charger de nouvelles primitives\n"
#~ "    depuis l'objet partagé FILENAME.  L'option « -d » efface une primitive précédemment\n"
#~ "    chargée avec « -f ».  Si aucun nom (n'étant pas une option) n'est donné, ou si l'option\n"
#~ "    « -p » est spécifiée, une liste de primitive est affichée.  L'option « -a » permet d'afficher\n"
#~ "    toutes les primitives en précisant si elles sont activées ou non. L'option « -s » restreint\n"
#~ "    la sortie aux primitives « special » POSIX.2. L'option « -n » affiche une liste de toutes les\n"
#~ "    primitives désactivées."

#~ msgid "Read ARGs as input to the shell and execute the resulting command(s)."
#~ msgstr "Lit les ARGs comme une entrée du shell et exécute les commandes résultantes."

#~ msgid ""
#~ "Exec FILE, replacing this shell with the specified program.\n"
#~ "    If FILE is not specified, the redirections take effect in this\n"
#~ "    shell.  If the first argument is `-l', then place a dash in the\n"
#~ "    zeroth arg passed to FILE, as login does.  If the `-c' option\n"
#~ "    is supplied, FILE is executed with a null environment.  The `-a'\n"
#~ "    option means to make set argv[0] of the executed process to NAME.\n"
#~ "    If the file cannot be executed and the shell is not interactive,\n"
#~ "    then the shell exits, unless the shell option `execfail' is set."
#~ msgstr ""
#~ "Exécute le fichier FILE en remplaçant ce shell par le programme spécifié.\n"
#~ "    Si FILE n'est pas spécifié, les redirections prennent effet dans\n"
#~ "    ce shell. Si le premier argument est « -l », un tiret est placé dans\n"
#~ "    l'argument n°0 transmis à FILE, comme le fait « login ». Si l'option\n"
#~ "    « -c » est fournie, FILE est exécuté avec un environnement vide.\n"
#~ "    L'option « -a » indique de définir « argv[0] » du processus exécuté\n"
#~ "    à NAME. Si le fichier ne peut pas être exécuté et que le shell n'est\n"
#~ "    pas interactif, alors le shell se termine, à moins que l'option « execfail »\n"
#~ "    ne soit définie."

#~ msgid "Logout of a login shell."
#~ msgstr "Fermer un shell de connexion"

#~ msgid ""
#~ "For each NAME, the full pathname of the command is determined and\n"
#~ "    remembered.  If the -p option is supplied, PATHNAME is used as the\n"
#~ "    full pathname of NAME, and no path search is performed.  The -r\n"
#~ "    option causes the shell to forget all remembered locations.  The -d\n"
#~ "    option causes the shell to forget the remembered location of each NAME.\n"
#~ "    If the -t option is supplied the full pathname to which each NAME\n"
#~ "    corresponds is printed.  If multiple NAME arguments are supplied with\n"
#~ "    -t, the NAME is printed before the hashed full pathname.  The -l option\n"
#~ "    causes output to be displayed in a format that may be reused as input.\n"
#~ "    If no arguments are given, information about remembered commands is displayed."
#~ msgstr ""
#~ "Pour chaque NAME, le chemin complet de la commande est déterminé puis mémorisé.\n"
#~ "    Si l'option « -p » est fournie, le CHEMIN est utilisé comme chemin complet\n"
#~ "    pour NAME, et aucune recherche n'est effectuée. L'option « -r » demande au shell\n"
#~ "    d'oublier tous les chemins mémorisés. L'option « -d » demande au shell d'oublier\n"
#~ "    les chemins mémorisés pour le NAME. Si l'option « -t » est fournie, le chemin\n"
#~ "    complet auquel correspond chaque NAME est affiché. Si plusieurs NAME sont fournis\n"
#~ "    à l'option « -t », le NAME est affiché avant chemin complet haché. L'option\n"
#~ "    « -l » permet d'utiliser un format de sortie qui peut être réutilisé comme entrée.\n"
#~ "    Si aucun argument n'est donné, des informations sur les commandes mémorisées sont\n"
#~ "    affichées."

#~ msgid ""
#~ "Display helpful information about builtin commands.  If PATTERN is\n"
#~ "    specified, gives detailed help on all commands matching PATTERN,\n"
#~ "    otherwise a list of the builtins is printed.  The -s option\n"
#~ "    restricts the output for each builtin command matching PATTERN to\n"
#~ "    a short usage synopsis."
#~ msgstr ""
#~ "Affiche des informations utiles sur les commandes intégrées. Si MOTIF\n"
#~ "    est précisé, une aide détaillée sur toutes les commandes correspondant\n"
#~ "    au MOTIF sont affichées, sinon une liste des commandes intégrées est\n"
#~ "    fournie. L'option « -s » restreint l'affichage de chaque commande\n"
#~ "    correspondant au MOTIF à une courte description sur l'utilisation."

#~ msgid ""
#~ "By default, removes each JOBSPEC argument from the table of active jobs.\n"
#~ "    If the -h option is given, the job is not removed from the table, but is\n"
#~ "    marked so that SIGHUP is not sent to the job if the shell receives a\n"
#~ "    SIGHUP.  The -a option, when JOBSPEC is not supplied, means to remove all\n"
#~ "    jobs from the job table; the -r option means to remove only running jobs."
#~ msgstr ""
#~ "Par défaut, enlève tous les arguments JOBSPEC de la table des tâches actives.\n"
#~ "    Si l'option « -h » est fournie, la tâche n'est pas retirée de la table mais\n"
#~ "    est marquée de telle sorte que le signal SIGHUP ne lui soit pas envoyé quand\n"
#~ "    le shell reçoit un SIGHUP. Lorsque JOBSPEC n'est pas fournie, l'option « -a »,\n"
#~ "    permet d'enlever toutes les tâches de la table des tâches. L'option « -r »\n"
#~ "    indique de ne retirer que les tâches en cours de fonctionnement."

#~ msgid ""
#~ "One line is read from the standard input, or from file descriptor FD if the\n"
#~ "    -u option is supplied, and the first word is assigned to the first NAME,\n"
#~ "    the second word to the second NAME, and so on, with leftover words assigned\n"
#~ "    to the last NAME.  Only the characters found in $IFS are recognized as word\n"
#~ "    delimiters.  If no NAMEs are supplied, the line read is stored in the REPLY\n"
#~ "    variable.  If the -r option is given, this signifies `raw' input, and\n"
#~ "    backslash escaping is disabled.  The -d option causes read to continue\n"
#~ "    until the first character of DELIM is read, rather than newline.  If the -p\n"
#~ "    option is supplied, the string PROMPT is output without a trailing newline\n"
#~ "    before attempting to read.  If -a is supplied, the words read are assigned\n"
#~ "    to sequential indices of ARRAY, starting at zero.  If -e is supplied and\n"
#~ "    the shell is interactive, readline is used to obtain the line.  If -n is\n"
#~ "    supplied with a non-zero NCHARS argument, read returns after NCHARS\n"
#~ "    characters have been read.  The -s option causes input coming from a\n"
#~ "    terminal to not be echoed.\n"
#~ "    \n"
#~ "    The -t option causes read to time out and return failure if a complete line\n"
#~ "    of input is not read within TIMEOUT seconds.  If the TMOUT variable is set,\n"
#~ "    its value is the default timeout.  The return code is zero, unless end-of-file\n"
#~ "    is encountered, read times out, or an invalid file descriptor is supplied as\n"
#~ "    the argument to -u."
#~ msgstr ""
#~ "Une ligne est lue depuis l'entrée standard ou depuis le descripteur de fichier\n"
#~ "    FD si l'option « -u » est fournie. Le premier mot est affecté au premier NAME,\n"
#~ "    le second mot au second NAME, et ainsi de suite, les mots restants étant affectés\n"
#~ "    au dernier NAME. Seuls les caractères situés dans « $IFS » sont reconnus comme\n"
#~ "    étant des délimiteurs de mots. Si aucun NAME n'est fourni, la ligne est conservée\n"
#~ "    dans la variable REPLY. L'option « -r » signifie « entrée brute » et la neutralisation \n"
#~ "    par barre oblique inverse est désactivée. L'option « -d » indique de continuer\"    la lecture jusqu'à ce que le premier caractère de DELIM soit lu plutôt que\n"
#~ "    le retour à la ligne. Si « -p » est fourni, la chaîne PROMPT est affichée\n"
#~ "    sans retour à la ligne final avant la tentative de lecture. Si « -a » est fourni,\n"
#~ "    les mots lus sont affectés en séquence aux indices du TABLEAU, en commençant\n"
#~ "    à zéro. Si « -e » est fourni et que le shell est interactif, « readline » est\n"
#~ "    utilisé pour obtenir la ligne. Si « -n » est fourni avec un argument NCHARS non nul,\n"
#~ "    « read » se termine après que NCHARS caractères ont été lus. L'option « -s »\n"
#~ "    permet aux données venant d'un terminal de ne pas être répétées.\n"
#~ "    \n"
#~ "    L'option « -t » permet à « read » de se terminer avec une erreur si une ligne\n"
#~ "    entière de données ne lui a pas été fournie avant le DÉLAI d'expiration. Si la\n"
#~ "    variable TMOUT est définie, sa valeur est le délai d'expiration par défaut. Le code\n"
#~ "    de retour est zéro à moins qu'une fin de fichier ne soit rencontrée, que « read »\n"
#~ "    atteigne le délai d'expiration ou qu'un descripteur de fichier incorrect ne soit\n"
#~ "    fourni pour l'argument « -u »."

#~ msgid ""
#~ "Causes a function to exit with the return value specified by N.  If N\n"
#~ "    is omitted, the return status is that of the last command."
#~ msgstr ""
#~ "Permet à une fonction de se terminer avec le code de retour spécifié par N.\n"
#~ "    Si N est omis, le code de retour est celui de la dernière commande."

#~ msgid ""
#~ "For each NAME, remove the corresponding variable or function.  Given\n"
#~ "    the `-v', unset will only act on variables.  Given the `-f' flag,\n"
#~ "    unset will only act on functions.  With neither flag, unset first\n"
#~ "    tries to unset a variable, and if that fails, then tries to unset a\n"
#~ "    function.  Some variables cannot be unset; also see readonly."
#~ msgstr ""
#~ "Pour chaque NAME, supprime la variable ou la fonction correspondante.\n"
#~ "    En spécifiant « -v », « unset » agira seulement sur les variables.\n"
#~ "    Avec l'option « -f », « unset » n'agit que sur les fonctions. Sans option,\n"
#~ "    « unset » essaye d'abord de supprimer une variable et, s'il échoue, essaye\n"
#~ "    de supprimer une fonction. Certaines variables ne peuvent pas être supprimées.\n"
#~ "    Consultez aussi « readonly ».    "

#~ msgid ""
#~ "NAMEs are marked for automatic export to the environment of\n"
#~ "    subsequently executed commands.  If the -f option is given,\n"
#~ "    the NAMEs refer to functions.  If no NAMEs are given, or if `-p'\n"
#~ "    is given, a list of all names that are exported in this shell is\n"
#~ "    printed.  An argument of `-n' says to remove the export property\n"
#~ "    from subsequent NAMEs.  An argument of `--' disables further option\n"
#~ "    processing."
#~ msgstr ""
#~ "Les NAME sont marqués pour export automatique vers l'environnement des\n"
#~ "    prochaines commandes exécutées. si l'option « -f » est donnée, les NAME\n"
#~ "    se rapportent à des fonctions. Si aucun NAME n'est donné ou si « -p »\n"
#~ "    est fourni, la liste de tous les NAME exportés dans ce shell s'affiche.\n"
#~ "    L'argument « -n » permet de supprimer la propriété d'export des NAME qui\n"
#~ "    suivent. L'argument « -- » désactive le traitement des options suivantes."

#~ msgid ""
#~ "The given NAMEs are marked readonly and the values of these NAMEs may\n"
#~ "    not be changed by subsequent assignment.  If the -f option is given,\n"
#~ "    then functions corresponding to the NAMEs are so marked.  If no\n"
#~ "    arguments are given, or if `-p' is given, a list of all readonly names\n"
#~ "    is printed.  The `-a' option means to treat each NAME as\n"
#~ "    an array variable.  An argument of `--' disables further option\n"
#~ "    processing."
#~ msgstr ""
#~ "Les NAME donnés sont marqués pour lecture seule et les valeurs de ces NAME\n"
#~ "    ne peuvent plus être changés par affection. Si l'option « -f » est donnée,\n"
#~ "    les fonctions correspondant aux NAME sont marquées de la sorte. Si aucun\n"
#~ "    argument n'est donné ou si « -p » est fourni, la liste de tous les noms\n"
#~ "    en lecture seule est affichée. L'option « -a » indique de traiter tous les\n"
#~ "    NAME comme des variables tableaux. L'argument « -- » désactive le traitement\n"
#~ "    des option suivantes."

#~ msgid ""
#~ "The positional parameters from $N+1 ... are renamed to $1 ...  If N is\n"
#~ "    not given, it is assumed to be 1."
#~ msgstr ""
#~ "Les paramètres de position depuis $N+1 ... sont renommés en $1 ...\n"
#~ "    Si N n'est pas fourni, il est supposé égal à 1."

#~ msgid ""
#~ "Suspend the execution of this shell until it receives a SIGCONT\n"
#~ "    signal.  The `-f' if specified says not to complain about this\n"
#~ "    being a login shell if it is; just suspend anyway."
#~ msgstr ""
#~ "Suspend l'exécution de ce shell jusqu'à ce qu'il reçoive le signal SIGCONT.\n"
#~ "    Si « -f » est spécifié, il indique de ne pas se plaindre s'il s'agit d'un \n"
#~ "    shell de connexion, mais de suspendre quand-même."

#~ msgid ""
#~ "Print the accumulated user and system times for processes run from\n"
#~ "    the shell."
#~ msgstr ""
#~ "Affiche les temps utilisateur et système accumulés pour les processus\n"
#~ "    lancés depuis le shell."

#~ msgid ""
#~ "For each NAME, indicate how it would be interpreted if used as a\n"
#~ "    command name.\n"
#~ "    \n"
#~ "    If the -t option is used, `type' outputs a single word which is one of\n"
#~ "    `alias', `keyword', `function', `builtin', `file' or `', if NAME is an\n"
#~ "    alias, shell reserved word, shell function, shell builtin, disk file,\n"
#~ "    or unfound, respectively.\n"
#~ "    \n"
#~ "    If the -p flag is used, `type' either returns the name of the disk\n"
#~ "    file that would be executed, or nothing if `type -t NAME' would not\n"
#~ "    return `file'.\n"
#~ "    \n"
#~ "    If the -a flag is used, `type' displays all of the places that contain\n"
#~ "    an executable named `file'.  This includes aliases, builtins, and\n"
#~ "    functions, if and only if the -p flag is not also used.\n"
#~ "    \n"
#~ "    The -f flag suppresses shell function lookup.\n"
#~ "    \n"
#~ "    The -P flag forces a PATH search for each NAME, even if it is an alias,\n"
#~ "    builtin, or function, and returns the name of the disk file that would\n"
#~ "    be executed."
#~ msgstr ""
#~ "Indique comment chaque NAME serait interprété s'il était utilisé comme un\n"
#~ "    nom de commande.\n"
#~ "    \n"
#~ "    Si l'option « -t » est utilisée, « type » affiche un simple mot parmi\n"
#~ "    « alias », « keyword », « function », « builtin », « file » ou « », si\n"
#~ "    NAME est respectivement un alias, un mot réservé du shell, une fonction\n"
#~ "    du shell, une primitive, un fichier du disque, ou s'il est inconnu.\n"
#~ "    \n"
#~ "    Si l'indicateur « -p » est utilisé, « type » renvoie soit le nom du fichier\n"
#~ "    du disque qui serait exécuté, soit rien si « type -t NAME » ne retourne pas\n"
#~ "    « file ».\n"
#~ "    \n"
#~ "    Si « -a » est utilisé, « type » affiche tous les emplacements qui contiennent\n"
#~ "    un exécutable nommé « file ». Ceci inclut les alias, les primitives et les\n"
#~ "    fonctions si, et seulement si « -p » n'est pas également utilisé.\n"
#~ "    \n"
#~ "    L'indicateur « -P » force une recherche dans PATH pour chaque NAME même\n"
#~ "    si c'est un alias, une primitive ou une fonction et renvoie le nom du\n"
#~ "    fichier du disque qui serait exécuté."

#~ msgid ""
#~ "The user file-creation mask is set to MODE.  If MODE is omitted, or if\n"
#~ "    `-S' is supplied, the current value of the mask is printed.  The `-S'\n"
#~ "    option makes the output symbolic; otherwise an octal number is output.\n"
#~ "    If `-p' is supplied, and MODE is omitted, the output is in a form\n"
#~ "    that may be used as input.  If MODE begins with a digit, it is\n"
#~ "    interpreted as an octal number, otherwise it is a symbolic mode string\n"
#~ "    like that accepted by chmod(1)."
#~ msgstr ""
#~ "Le masque de création des fichiers utilisateurs est réglé à MODE. Si MODE\n"
#~ "    est omis ou si « -S » est fourni, la valeur actuelle du masque est affichée\n"
#~ "    L'option « -S » rend la sortie symbolique, sinon une valeur octale est\n"
#~ "    est utilisée. Si « -p » est fourni et que MODE est omis, la sortie se fait\n"
#~ "    dans un format qui peut être réutilisé comme entrée. Si MODE commence par\n"
#~ "    un chiffre, il est interprété comme un nombre octal, sinon comme une chaîne\n"
#~ "    symbolique de mode comme celle utilisée par « chmod(1) »."

#~ msgid ""
#~ "Wait for the specified process and report its termination status.  If\n"
#~ "    N is not given, all currently active child processes are waited for,\n"
#~ "    and the return code is zero.  N is a process ID; if it is not given,\n"
#~ "    all child processes of the shell are waited for."
#~ msgstr ""
#~ "Attend le processus spécifié et donne son code de retour. Si N n'est\n"
#~ "    pas donné, tous les processus fils actuellement actifs sont attendus\n"
#~ "    et le code de retour est zéro. N est un n° de processus. S'il n'est\n"
#~ "    pas fourni, tous les processus du shell sont attendus."

#~ msgid ""
#~ "Create a simple command invoked by NAME which runs COMMANDS.\n"
#~ "    Arguments on the command line along with NAME are passed to the\n"
#~ "    function as $0 .. $n."
#~ msgstr ""
#~ "Crée une simple commande invoquée avec NAME, et qui lance les\n"
#~ "    commandes COMMANDS. Les arguments fournis avec NAME sur la\n"
#~ "    ligne de commande sont transmis à la fonction en tant que $0 .. $n."

#~ msgid ""
#~ "Toggle the values of variables controlling optional behavior.\n"
#~ "    The -s flag means to enable (set) each OPTNAME; the -u flag\n"
#~ "    unsets each OPTNAME.  The -q flag suppresses output; the exit\n"
#~ "    status indicates whether each OPTNAME is set or unset.  The -o\n"
#~ "    option restricts the OPTNAMEs to those defined for use with\n"
#~ "    `set -o'.  With no options, or with the -p option, a list of all\n"
#~ "    settable options is displayed, with an indication of whether or\n"
#~ "    not each is set."
#~ msgstr ""
#~ "Commute la valeur des variables qui contrôlent les comportements optionnels.\n"
#~ "    L'option « -s » indique d'activer chaque option nommée OPTNAME. L'option\n"
#~ "    « -u » désactive l'option OPTNAME. L'option « -q » rend la sortie silencieuse.\n"
#~ "    Le code de retour indique si chaque OPTNAME est activée ou désactivée.\n"
#~ "    L'option « -o » restreint les options OPTNAME à celles qui peuvent être utilisées avec\n"
#~ "    « set -o ». Sans option ou avec l'option « -p », une liste de toutes les\n"
#~ "    options modifiables est affichée, avec une indication sur l'état de chacune."

#~ msgid ""
#~ "For each NAME, specify how arguments are to be completed.\n"
#~ "    If the -p option is supplied, or if no options are supplied, existing\n"
#~ "    completion specifications are printed in a way that allows them to be\n"
#~ "    reused as input.  The -r option removes a completion specification for\n"
#~ "    each NAME, or, if no NAMEs are supplied, all completion specifications."
#~ msgstr ""
#~ "Pour chaque NAME, spécifie comment les arguments doivent être complétés.\n"
#~ "    Si l'option « -p » est fournie ou si aucune option n'est fournie, les spécifications\n"
#~ "    de complètement actuelles sont affichées de manière à pouvoir être réutilisées\n"
#~ "    comme entrée. L'option « -r » enlève la spécification de complètement pour chaque\n"
#~ "    NAME ou, si aucun NAME n'est fourni, toutes les spécifications de complètement."
