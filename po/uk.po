# Bash Ukrainian messages
# Copyright (C) 2009 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
#
# Myhailo Danylenko <isbear@ukrpost.net>, 2009.
# Maxim V. Dziumanenko <dziumanenko@gmail.com>, 2010.
# Yuri Chornoivan <yurchor@ukr.net>, 2011, 2013, 2014, 2015, 2016, 2018, 2019, 2020, 2022, 2025.
msgid ""
msgstr ""
"Project-Id-Version: bash 5.3-rc2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-22 09:37-0400\n"
"PO-Revision-Date: 2025-06-03 13:19+0300\n"
"Last-Translator: Yuri Chornoivan <yurchor@ukr.net>\n"
"Language-Team: Ukrainian <trans-uk@lists.fedoraproject.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
"X-Generator: Lokalize 23.04.3\n"

#: arrayfunc.c:63
msgid "bad array subscript"
msgstr "неправильний індекс масиву"

#: arrayfunc.c:466 builtins/declare.def:748 variables.c:2196 variables.c:2225
#: variables.c:3099
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: вилучаємо атрибут nameref"

#: arrayfunc.c:493 builtins/declare.def:920
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: неможливо перетворити індексований масив на асоціативний"

#: arrayfunc.c:789
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: означення нечислових елементів неможливе"

#: arrayfunc.c:841
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: при означенні асоціативних масивів слід вказувати ключ"

#: bashhist.c:464
msgid "cannot create"
msgstr "не вдалося створити"

#: bashline.c:4642
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: не вдалося знайти відповідне призначення для команди"

#: bashline.c:4813
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: перший непробільний символ не є «\"»"

# c-format
#: bashline.c:4842
#, c-format
msgid "no closing `%c' in %s"
msgstr "нема заключної «%c» у %s"

#: bashline.c:4873
#, c-format
msgid "%s: missing separator"
msgstr "%s: пропущено роздільник"

#: bashline.c:4920
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "«%s»: не вдалося зняти призначення у мапі ключів команди"

#: braces.c:340
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "розкриття дужок: не вдалося отримати пам’ять для %s"

#: braces.c:403
#, c-format
msgid "brace expansion: failed to allocate memory for %s elements"
msgstr "розкриття дужок: не вдалося отримати об’єм пам’яті для %s елементів"

#: braces.c:462
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "розкриття дужок: не вдалося отримати об’єм пам’яті для «%s»"

#: builtins/alias.def:131 variables.c:1789
#, c-format
msgid "`%s': invalid alias name"
msgstr "«%s»: некоректна назва замінника"

#: builtins/bind.def:123
msgid "line editing not enabled"
msgstr "редагування рядку не ввімкнено"

#: builtins/bind.def:208
#, c-format
msgid "`%s': invalid keymap name"
msgstr "«%s»: неправильна назва набору призначень клавіш"

#: builtins/bind.def:277
msgid "cannot read"
msgstr "не вдалося виконати читання"

#: builtins/bind.def:353 builtins/bind.def:382
#, c-format
msgid "`%s': unknown function name"
msgstr "«%s»: невідома назва функції"

#: builtins/bind.def:361
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s не призначено жодної клавіші.\n"

#: builtins/bind.def:365
#, c-format
msgid "%s can be invoked via "
msgstr "%s можна запустити за допомогою "

#: builtins/bind.def:401 builtins/bind.def:418
#, c-format
msgid "`%s': cannot unbind"
msgstr "«%s»: не вдалося зняти призначення"

#: builtins/break.def:80 builtins/break.def:125
msgid "loop count"
msgstr "кількість циклів"

#: builtins/break.def:145
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "має сенс лише усередині циклів `for', `while' та `until'"

#: builtins/caller.def:135
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Повертає контекст виконання поточної підпрограми.\n"
"    \n"
"    Якщо ВИРАЗ не вказано, виводить \"$line $filename\". Інакше виводить\n"
"    \"$line $subroutine $filename\"; цю додаткову інформацію можна\n"
"    використовувати для трасування стеку.\n"
"    \n"
"    Значення ВИРАЗУ визначає на скільки рівнів викликів піднятися від\n"
"    поточного; поточний рівень є нульовим.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо оболонка зараз не виконує функцію\n"
"    або якщо ВИРАЗ є неправильним."

#: builtins/cd.def:321
msgid "HOME not set"
msgstr "змінну HOME не встановлено"

#: builtins/cd.def:329 builtins/common.c:143 builtins/fc.def:293 test.c:946
msgid "too many arguments"
msgstr "забагато аргументів"

#: builtins/cd.def:335
msgid "null directory"
msgstr "порожній каталог"

#: builtins/cd.def:345
msgid "OLDPWD not set"
msgstr "змінну OLDPWD не встановлено"

#: builtins/common.c:91
#, c-format
msgid "line %d: "
msgstr "рядок %d: "

#: builtins/common.c:117 error.c:227
#, c-format
msgid "warning: "
msgstr "попередження: "

#: builtins/common.c:131
#, c-format
msgid "%s: usage: "
msgstr "%s: використовуйте: "

#: builtins/common.c:178 shell.c:524 shell.c:865
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: параметр потребує аргументу"

#: builtins/common.c:184
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: потрібен числовий аргумент"

#: builtins/common.c:190
#, c-format
msgid "%s: not found"
msgstr "%s: не знайдено"

#: builtins/common.c:198 shell.c:878
#, c-format
msgid "%s: invalid option"
msgstr "%s: неправильний параметр"

#: builtins/common.c:204
#, c-format
msgid "%s: invalid option name"
msgstr "%s: некоректна назва параметра"

#: builtins/common.c:210 error.c:461
#, c-format
msgid "`%s': not a valid identifier"
msgstr "«%s»: неправильний ідентифікатор"

#: builtins/common.c:219
msgid "invalid octal number"
msgstr "неправильне вісімкове число"

#: builtins/common.c:221
msgid "invalid hex number"
msgstr "неправильне шістнадцяткове число"

#: builtins/common.c:223 expr.c:1577 expr.c:1591
msgid "invalid number"
msgstr "неправильне число"

#: builtins/common.c:230
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: сигнал вказано з помилками"

#: builtins/common.c:236
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "«%s»: не є ідентифікатором процесу чи завдання"

#: builtins/common.c:242 error.c:455
#, c-format
msgid "%s: readonly variable"
msgstr "%s: змінна призначена лише для читання"

#: builtins/common.c:248
#, c-format
msgid "%s: cannot assign"
msgstr "%s: не вдалося встановити значення"

#: builtins/common.c:255
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s виходить за встановлені межі"

#: builtins/common.c:255 builtins/common.c:257
msgid "argument"
msgstr "аргумент"

#: builtins/common.c:257
#, c-format
msgid "%s out of range"
msgstr "%s виходить за встановлені межі"

#: builtins/common.c:264
#, c-format
msgid "%s: no such job"
msgstr "%s: нема такого завдання"

#: builtins/common.c:271
#, c-format
msgid "%s: no job control"
msgstr "%s: керування завданнями не ввімкнене"

#: builtins/common.c:273
msgid "no job control"
msgstr "керування завданнями не ввімкнене"

#: builtins/common.c:279
#, c-format
msgid "%s: invalid job specification"
msgstr "%s: некоректне визначення завдання"

#: builtins/common.c:289
#, c-format
msgid "%s: restricted"
msgstr "%s: заборонено обмеженнями"

#: builtins/common.c:291
msgid "restricted"
msgstr "заборонено обмеженнями"

#: builtins/common.c:298
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: не є вбудованою командою оболонки"

#: builtins/common.c:307
msgid "write error"
msgstr "помилка під час спроби запису"

#: builtins/common.c:314
msgid "error setting terminal attributes"
msgstr "помилка встановлення параметрів термінала"

#: builtins/common.c:316
msgid "error getting terminal attributes"
msgstr "помилка отримання параметрів термінала"

#: builtins/common.c:611
msgid "error retrieving current directory"
msgstr "помилка отримання поточного каталогу"

#: builtins/common.c:675 builtins/common.c:677
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: завдання вказано неоднозначно"

#: builtins/common.c:709
#, c-format
msgid "%s: job specification requires leading `%%'"
msgstr "%s: специфікація завдання має починатися з «%%»"

#: builtins/common.c:937
msgid "help not available in this version"
msgstr "у цій версії не можна скористатися довідкою"

#: builtins/common.c:1005
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: не є індексованим масивом"

#: builtins/common.c:1028 builtins/set.def:964 variables.c:3868
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: не вдалося знищити: %s лише для читання"

#: builtins/common.c:1033 builtins/set.def:930 variables.c:3873
#, c-format
msgid "%s: cannot unset"
msgstr "%s: не вдалося знищити"

#: builtins/complete.def:285
#, c-format
msgid "%s: invalid action name"
msgstr "%s: неправильна назва дії"

#: builtins/complete.def:501 builtins/complete.def:644
#: builtins/complete.def:899
#, c-format
msgid "%s: no completion specification"
msgstr "%s: не вказано специфікація завершення"

#: builtins/complete.def:703
msgid "warning: -F option may not work as you expect"
msgstr "попередження: можливо параметр -F працює не так, як ви очікуєте"

#: builtins/complete.def:705
msgid "warning: -C option may not work as you expect"
msgstr "попередження: можливо параметр -C працює не так, як ви очікуєте"

#: builtins/complete.def:872
msgid "not currently executing completion function"
msgstr "наразі функція завершення рядку не виконується"

#: builtins/declare.def:139
msgid "can only be used in a function"
msgstr "може використовуватися лише усередині функції"

#: builtins/declare.def:471
msgid "cannot use `-f' to make functions"
msgstr "`-f' не використовується для створення функцій"

#: builtins/declare.def:499 execute_cmd.c:6320
#, c-format
msgid "%s: readonly function"
msgstr "%s: незмінна функція"

#: builtins/declare.def:556 builtins/declare.def:843
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: еталонна змінна не може бути масивом"

#: builtins/declare.def:567 variables.c:3346
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s: не можна використовувати циклічне посилання у змінній посилання"

#: builtins/declare.def:572 variables.c:2035 variables.c:3343
#, c-format
msgid "%s: circular name reference"
msgstr "%s: циклічне посилання за назвою"

#: builtins/declare.def:576 builtins/declare.def:850 builtins/declare.def:859
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "«%s»: некоректна назва змінної для посилання за назвою"

#: builtins/declare.def:908
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: неможливо знищити масив таким чином"

#: builtins/declare.def:914
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: неможливо перетворити асоціативний масив на індексований"

#: builtins/declare.def:943
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s: встановлення значень для складеного масиву у лапках вважається застарілим"

#: builtins/enable.def:149 builtins/enable.def:157
msgid "dynamic loading not available"
msgstr "динамічне завантаження недоступне"

#: builtins/enable.def:389
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "не вдалося відкрити колективний об’єкт %s: %s"

#: builtins/enable.def:408
#, c-format
msgid "%s: builtin names may not contain slashes"
msgstr "%s: у вбудованих назвах не можна використовувати символи похилих рисок"

#: builtins/enable.def:423
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "не вдалося знайти %s у колективному об’єкті %s: %s"

#: builtins/enable.def:440
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: динамічне вбудовування вже завантажено"

#: builtins/enable.def:444
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "функцією завантаження для %s повернуто повідомлення щодо помилки (%d): не завантажено"

#: builtins/enable.def:565
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: завантажений не динамічно"

#: builtins/enable.def:591
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: не вдалося вилучити: %s"

#: builtins/evalfile.c:137 builtins/hash.def:190 execute_cmd.c:6140
#, c-format
msgid "%s: is a directory"
msgstr "%s: це каталог"

#: builtins/evalfile.c:143
#, c-format
msgid "%s: not a regular file"
msgstr "%s: не є звичайним файлом"

#: builtins/evalfile.c:152
#, c-format
msgid "%s: file is too large"
msgstr "%s: файл завеликий"

#: builtins/evalfile.c:189 builtins/evalfile.c:207 execute_cmd.c:6222
#: shell.c:1687
msgid "cannot execute binary file"
msgstr "не вдалося виконати бінарний файл"

#: builtins/evalstring.c:478
#, c-format
msgid "%s: ignoring function definition attempt"
msgstr "%s: ігноруємо спробу визначення функції"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:249
msgid "cannot execute"
msgstr "не вдалося виконати"

#: builtins/exit.def:61
#, c-format
msgid "logout\n"
msgstr "вихід\n"

#: builtins/exit.def:85
msgid "not login shell: use `exit'"
msgstr "це не оболонка сеансу: використовуйте `exit'"

#: builtins/exit.def:116
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Залишилися призупинені завдання.\n"

#: builtins/exit.def:118
#, c-format
msgid "There are running jobs.\n"
msgstr "Фонові завдання все ще виконуються.\n"

#: builtins/fc.def:284 builtins/fc.def:391 builtins/fc.def:435
msgid "no command found"
msgstr "команду не знайдено"

#: builtins/fc.def:381 builtins/fc.def:386 builtins/fc.def:425
#: builtins/fc.def:430
msgid "history specification"
msgstr "параметри журналу"

#: builtins/fc.def:462
msgid "cannot open temp file"
msgstr "не вдалося відкрити тимчасовий файл"

#: builtins/fg_bg.def:150 builtins/jobs.def:293
msgid "current"
msgstr "поточне"

#: builtins/fg_bg.def:159
#, c-format
msgid "job %d started without job control"
msgstr "завдання %d запущене без контролю завдань"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: неправильний параметр — %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: параметр потребує аргументу — %c\n"

#: builtins/hash.def:88
msgid "hashing disabled"
msgstr "кешування вимкнене"

#: builtins/hash.def:144
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: в кеші нічого немає\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "влучень\tкоманда\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Команди оболонки, що відповідають слову `"
msgstr[1] "Команди оболонки, що відповідають словам `"
msgstr[2] "Команди оболонки, що відповідають словам `"

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"'\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid "no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr "«%s» не відповідає жодний розділ довідки. Спробуйте `help help' чи `man -k %s' або `info %s'."

#: builtins/help.def:214
msgid "cannot open"
msgstr "не вдалося відкрити"

#: builtins/help.def:264 builtins/help.def:306 builtins/history.def:306
#: builtins/history.def:325 builtins/read.def:909
msgid "read error"
msgstr "помилка читання"

#: builtins/help.def:517
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Ці команди оболонки визначені внутрішньо. Введіть `help', щоб побачити їх список.\n"
"Введіть `help name', щоб дізнатися більше про функцію `name'.\n"
"Використовуйте `info bash', щоб отримати більше інформації про оболонку в цілому.\n"
"`man -k' чи `info' можуть стати в пригоді для отримання довідки з команд, яких немає\n"
"у цьому списку.\n"
"\n"
"Зірочка (*) поряд з назвою команди означає, що команда заборонена.\n"
"\n"

#: builtins/history.def:164
msgid "cannot use more than one of -anrw"
msgstr "-anrw можуть зустрічатися лише один раз"

#: builtins/history.def:197 builtins/history.def:209 builtins/history.def:220
#: builtins/history.def:245 builtins/history.def:252
msgid "history position"
msgstr "позиція у журналу команд"

#: builtins/history.def:280
msgid "empty filename"
msgstr "порожня назва файла"

#: builtins/history.def:282 subst.c:8226
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: параметр нульової довжини чи не вказаний"

#: builtins/history.def:362
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: некоректна часова позначка"

#: builtins/history.def:470
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: невдалий пошук по журналу команд"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "не можна використовувати інші параметри разом з `-x'"

#: builtins/kill.def:214
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: аргументи мають бути ідентифікаторами завдань чи процесів"

#: builtins/kill.def:280
msgid "Unknown error"
msgstr "Невідома помилка"

#: builtins/let.def:96 builtins/let.def:120 expr.c:647 expr.c:665
msgid "expression expected"
msgstr "очікувався вираз"

#: builtins/mapfile.def:249 builtins/read.def:373
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: неправильно вказаний дескриптор файла"

#: builtins/mapfile.def:257 builtins/read.def:380
msgid "invalid file descriptor"
msgstr "некоректний дескриптор файла"

#: builtins/mapfile.def:266 builtins/mapfile.def:304
#, c-format
msgid "%s: invalid line count"
msgstr "%s: неправильна кількість рядків"

#: builtins/mapfile.def:277
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: неправильний початковий індекс"

#: builtins/mapfile.def:294
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: неправильний крок виклику функції"

#: builtins/mapfile.def:327
msgid "empty array variable name"
msgstr "порожня назва змінної-масиву"

#: builtins/mapfile.def:347
msgid "array variable support required"
msgstr "змінні-масиви не підтримуються"

#: builtins/printf.def:483
#, c-format
msgid "`%s': missing format character"
msgstr "«%s»: пропущено символ у шаблоні"

#: builtins/printf.def:609
#, c-format
msgid "`%c': invalid time format specification"
msgstr "«%c»: помилкове визначення формату часу"

#: builtins/printf.def:711
msgid "string length"
msgstr "довжина рядка"

#: builtins/printf.def:811
#, c-format
msgid "`%c': invalid format character"
msgstr "«%c»: помилковий символ у шаблоні"

#: builtins/printf.def:928
#, c-format
msgid "format parsing problem: %s"
msgstr "проблема з обробкою форматування: %s"

#: builtins/printf.def:1113
msgid "missing hex digit for \\x"
msgstr "пропущено шістнадцяткову цифру у \\x"

#: builtins/printf.def:1128
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "пропущено цифру Unicode у \\%c"

#: builtins/pushd.def:198
msgid "no other directory"
msgstr "немає іншого каталогу"

#: builtins/pushd.def:358 builtins/pushd.def:383
#, c-format
msgid "%s: invalid argument"
msgstr "%s: некоректний аргумент"

#: builtins/pushd.def:501
msgid "<no current directory>"
msgstr "<немає поточного каталогу>"

#: builtins/pushd.def:543
msgid "directory stack empty"
msgstr "стек каталогів порожній"

#: builtins/pushd.def:545
msgid "directory stack index"
msgstr "рівень стеку каталогів"

#: builtins/pushd.def:708
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Показує список збережених каталогів. Каталоги\n"
"    додаються до цього списку командою `pushd'; ви можете повернутися\n"
"    назад по списку за допомогою команди `popd'.\n"
"    \n"
"    Параметри:\n"
"      -c\tочистити список каталогів, вилучивши усі його елементи\n"
"      -l\tне використовувати ~ для каталогів, що перебувають усередині\n"
"    \tвашого домашнього каталогу\n"
"      -p\tвиводити каталоги по одному на рядок\n"
"      -v\tвиводити каталоги по одному на рядок з зазначенням позиції у\n"
"    \tсписку\n"
"    \n"
"    Аргументи:\n"
"      +N\tПоказує N-ний зліва каталог у списку, що виводиться командою\n"
"    \tdirs без аргументів, відлік починається з нуля.\n"
"    \n"
"      -N\tПоказує N-ний з кінця каталог у списку, що виводиться командою\n"
"\tdirs без аргументів, відлік починається з нуля."

#: builtins/pushd.def:730
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Додає каталог на вершину стеку каталогів, чи циклічно обертає\n"
"    стек, встановлюючи поточний робочий каталог відповідно до його нової\n"
"    вершини. Без аргументів міняє місцями дві найвищих каталоги.\n"
"    \n"
"    Параметри:\n"
"      -n\tНе робити звичайного переходу у новий каталог при додаванні\n"
"    \tкаталогів до стеку, виконувати операції лише над стеком.\n"
"    \n"
"    Аргументи:\n"
"      +N\tЦиклічно обертає стек так, щоб N-ний каталог, рахуючи\n"
"    \tзліва (починаючи з нуля) у списку, що виводиться командою `dirs'\n"
"    \tопиниться на вершині стеку.\n"
"    \n"
"      -N\tЦиклічно обертає стек так, щоб N-ний каталог, рахуючи\n"
"    \tз кінця (починаючи з нуля) у списку, що виводиться командою `dirs'\n"
"    \tопиниться на вершині стеку.\n"
"    \n"
"      dir\tДодає DIR на вершину стеку, й робить його поточним робочим\n"
"    \tкаталогом.\n"
"    \n"
"    Вбудована команда `dirs' показує стек каталогів."

#: builtins/pushd.def:755
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Вилучає каталоги зі стеку збережених каталогів. Без аргументів, вилучає\n"
"    верхній каталог у стеку і змінює поточний каталог відповідно до нової\n"
"    вершини стеку.\n"
"    \n"
"    Параметри:\n"
"      -n\tНе робити звичайного переходу до нової каталоги при вилученні\n"
"    \tкаталогів зі стеку, проводити операції лише над стеком.\n"
"    \n"
"    Аргументи:\n"
"      +N\tВилучає N-ний зліва каталог у списку, що показується командою `dirs'\n"
"    \t(відлік починається з нуля). Наприклад: `popd +0' вилучає перший каталог,\n"
"    \t`popd +1' — другий.\n"
"    \n"
"      -N\tВилучає N-ний з кінця каталог у списку, що показується командою\n"
"    \t`dirs' (відлік починається з нуля). Наприклад: `popd -0' вилучає\n"
"    \tостанній каталог, `popd -1' — передостанній.\n"
"    \n"
"    Вбудована команда `dirs' показує стек каталогів."

#: builtins/read.def:346
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: некоректне визначення часу очікування"

#: builtins/return.def:73
msgid "can only `return' from a function or sourced script"
msgstr "`return' працює лише у функції чи скрипті, запущеному за допомогою `source'"

#: builtins/set.def:863
msgid "cannot simultaneously unset a function and a variable"
msgstr "не можна одночасно знищити і функцію і змінну"

#: builtins/set.def:981
#, c-format
msgid "%s: not an array variable"
msgstr "%s: не є масивом"

#: builtins/setattr.def:187
#, c-format
msgid "%s: not a function"
msgstr "%s: не є функцією"

#: builtins/setattr.def:192
#, c-format
msgid "%s: cannot export"
msgstr "%s: не вдалося експортувати"

#: builtins/shift.def:74 builtins/shift.def:86
msgid "shift count"
msgstr "кількість зсувів"

#: builtins/shopt.def:332
msgid "cannot set and unset shell options simultaneously"
msgstr "не можна одночасно встановлювати й скасовувати параметри оболонки"

#: builtins/shopt.def:457
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: неправильна назва параметра оболонки"

#: builtins/source.def:143
msgid "filename argument required"
msgstr "потрібна назва файла"

#: builtins/source.def:179
#, c-format
msgid "%s: file not found"
msgstr "%s: файл не знайдено"

#: builtins/suspend.def:105
msgid "cannot suspend"
msgstr "не вдалося призупинити"

#: builtins/suspend.def:111
msgid "cannot suspend a login shell"
msgstr "не можна призупинити оболонку сеансу"

#: builtins/test.def:146 test.c:926
msgid "missing `]'"
msgstr "відсутня `]'"

#: builtins/type.def:231
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s є псевдонімом до «%s»\n"

#: builtins/type.def:252
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s — це ключове слово оболонки\n"

#: builtins/type.def:270 builtins/type.def:314
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s є спеціальною вбудованою командою оболонки\n"

#: builtins/type.def:289
#, c-format
msgid "%s is a function\n"
msgstr "%s є функцією\n"

#: builtins/type.def:316
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s є вбудованою командою оболонки\n"

#: builtins/type.def:338 builtins/type.def:425
#, c-format
msgid "%s is %s\n"
msgstr "%s — це %s\n"

# I know the difference between hash and cache, but here,
# I think, this is more suitable...
#: builtins/type.def:358
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s знаходиться в кеші (%s)\n"

#: builtins/ulimit.def:403
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: помилковий аргумент обмеження"

#: builtins/ulimit.def:429
#, c-format
msgid "`%c': bad command"
msgstr "«%c»: неправильна команда"

#: builtins/ulimit.def:465 builtins/ulimit.def:748
msgid "cannot get limit"
msgstr "не вдалося отримати значення обмеження"

#: builtins/ulimit.def:498
msgid "limit"
msgstr "значення обмеження"

#: builtins/ulimit.def:511 builtins/ulimit.def:812
msgid "cannot modify limit"
msgstr "не вдалося змінити обмеження"

#: builtins/umask.def:114
msgid "octal number"
msgstr "вісімкове число"

#: builtins/umask.def:256
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "«%c»: помилковий оператор у символьному режимі"

#: builtins/umask.def:345
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "«%c»: помилковий символ у символьному режимі"

#: error.c:83 error.c:311 error.c:313 error.c:315
msgid " line "
msgstr " рядок "

#: error.c:151
#, c-format
msgid "last command: %s\n"
msgstr "остання команда: %s\n"

#: error.c:159
#, c-format
msgid "Aborting..."
msgstr "Припинення..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:244
#, c-format
msgid "INFORM: "
msgstr "ІНФОРМАЦІЯ: "

#: error.c:261
#, c-format
msgid "DEBUG warning: "
msgstr "Діагностичне попередження: "

#: error.c:413
msgid "unknown command error"
msgstr "невідома помилка команди"

#: error.c:414
msgid "bad command type"
msgstr "неправильний тип команди"

#: error.c:415
msgid "bad connector"
msgstr "неправильний з’єднувальний оператор"

#: error.c:416
msgid "bad jump"
msgstr "неправильний перехід"

#: error.c:449
#, c-format
msgid "%s: unbound variable"
msgstr "%s: неозначена змінна"

#: eval.c:260
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\aчас очікування вводу вичерпано: автоматичний вихід\n"

#: execute_cmd.c:606
msgid "cannot redirect standard input from /dev/null"
msgstr "не вдалося переспрямувати /dev/null на стандартний ввід"

#: execute_cmd.c:1412
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: «%c»: помилковий символ шаблону"

#: execute_cmd.c:2493
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr "execute_coproc: coproc [%d:%s] все ще існує"

#: execute_cmd.c:2647
msgid "pipe error"
msgstr "помилка каналу"

#: execute_cmd.c:4100
#, c-format
msgid "invalid regular expression `%s': %s"
msgstr "некоректний формальний вираз «%s»: %s"

#: execute_cmd.c:4102
#, c-format
msgid "invalid regular expression `%s'"
msgstr "некоректний формальний вираз: «%s»"

#: execute_cmd.c:5056
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: перевищено максимальний рівень вкладеності eval (%d)"

#: execute_cmd.c:5069
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: перевищено максимальний рівень вкладеності джерела (%d)"

#: execute_cmd.c:5198
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: перевищено максимальний рівень вкладеності функцій (%d)"

#: execute_cmd.c:5754
msgid "command not found"
msgstr "команди не знайдено"

#: execute_cmd.c:5783
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: обмеження: не можна вказувати `/' у назві команди"

#: execute_cmd.c:6176
msgid "bad interpreter"
msgstr "неправильний інтерпретатор"

#: execute_cmd.c:6185
#, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: не вдалося виконати: не знайдено потрібного файла"

#: execute_cmd.c:6361
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "не вдалося створити копію файлового дескриптору %d у %d"

#: expr.c:272
msgid "expression recursion level exceeded"
msgstr "рівень вкладення виразів перевищено"

#: expr.c:300
msgid "recursion stack underflow"
msgstr "нестача стеку рекурсії"

#: expr.c:485
msgid "arithmetic syntax error in expression"
msgstr "арифметична синтаксична помилка у виразі"

#: expr.c:529
msgid "attempted assignment to non-variable"
msgstr "спроба призначення не-змінної"

#: expr.c:538
msgid "arithmetic syntax error in variable assignment"
msgstr "арифметична синтаксична помилка при спробі надати змінній значення"

#: expr.c:552 expr.c:917
msgid "division by 0"
msgstr "ділення на 0"

#: expr.c:600
msgid "bug: bad expassign token"
msgstr "вада: неправильна лексема у виразі"

#: expr.c:654
msgid "`:' expected for conditional expression"
msgstr "очікувалася `:' умовного виразу"

#: expr.c:979
msgid "exponent less than 0"
msgstr "експонента менша за 0"

#: expr.c:1040
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "пре-інкремент чи пре-декремент потребують ідентифікатор"

#: expr.c:1067
msgid "missing `)'"
msgstr "відсутня `)'"

#: expr.c:1120 expr.c:1507
msgid "arithmetic syntax error: operand expected"
msgstr "арифметична синтаксична помилка: очікувався операнд"

#: expr.c:1468 expr.c:1489
msgid "--: assignment requires lvalue"
msgstr "--: надання значення потребує lvalue"

#: expr.c:1470 expr.c:1491
msgid "++: assignment requires lvalue"
msgstr "++: надання значення потребує lvalue"

#: expr.c:1509
msgid "arithmetic syntax error: invalid arithmetic operator"
msgstr "арифметична синтаксична помилка: помилковий арифметичний оператор"

#: expr.c:1532
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (позначка помилки \"%s\")"

#: expr.c:1595
msgid "invalid arithmetic base"
msgstr "некоректна арифметична основа"

#: expr.c:1604
msgid "invalid integer constant"
msgstr "некоректна ціла стала"

#: expr.c:1620
msgid "value too great for base"
msgstr "завелике значення основи"

#: expr.c:1671
#, c-format
msgid "%s: expression error\n"
msgstr "%s: помилка у виразі\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: не вдалося отримати доступ до каталогів вищого рівня"

#: general.c:459
#, c-format
msgid "`%s': is a special builtin"
msgstr "%s є спеціальною вбудованою командою оболонки"

#: input.c:98 subst.c:6542
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "не вдалося перевстановити режим без затримки файлового дескриптору %d"

#: input.c:254
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "не вдалося отримати новий файловий дескриптор для вводу bash з файлового дескриптору %d"

#: input.c:262
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: для нового файлового дескриптору %d вже існує буфер"

#: jobs.c:549
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pgrp pipe"

#: jobs.c:910
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:962
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:1380
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "ідентифікатор відгалуженого процесу %d знайдено у поточному завданні %d"

#: jobs.c:1496
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "вилучення зупиненого завдання %d, що має групу процесів %ld"

#: jobs.c:1620
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: ідентифікатор процесу %5ld (%s) вказує на його працездатність"

#: jobs.c:1949
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: ідентифікатор процесу не існує"

#: jobs.c:1963
#, c-format
msgid "Signal %d"
msgstr "Сигнал %d"

#: jobs.c:1974 jobs.c:2000
msgid "Done"
msgstr "Завершено"

#: jobs.c:1979 siglist.c:123
msgid "Stopped"
msgstr "Зупинено"

#: jobs.c:1983
#, c-format
msgid "Stopped(%s)"
msgstr "Зупинено(%s)"

#: jobs.c:1987
msgid "Running"
msgstr "Працює"

#: jobs.c:2004
#, c-format
msgid "Done(%d)"
msgstr "Зроблено(%d)"

#: jobs.c:2006
#, c-format
msgid "Exit %d"
msgstr "Вихід %d"

#: jobs.c:2009
msgid "Unknown status"
msgstr "Невідомий стан"

#: jobs.c:2105
#, c-format
msgid "(core dumped) "
msgstr "(збережено знімок оперативної пам’яті)"

#: jobs.c:2124
#, c-format
msgid "  (wd: %s)"
msgstr "  (РД: %s)"

#: jobs.c:2391
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "зміна групи дочірнього процесу (%ld на %ld)"

#: jobs.c:2754 nojobs.c:640
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: процес %ld не є відгалуженим від цієї оболонки"

#: jobs.c:3052
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: Нема запису для процесу %ld"

#: jobs.c:3410
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: завдання %d зупинене"

#: jobs.c:3838
#, c-format
msgid "%s: no current jobs"
msgstr "%s: немає поточних завдань"

#: jobs.c:3845
#, c-format
msgid "%s: job has terminated"
msgstr "%s: завдання завершилося"

#: jobs.c:3854
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: завдання %d вже працює в фоні"

#: jobs.c:4092
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld: увімкнути WNOHANG, щоб уникнути нескінченного блокування"

#: jobs.c:4641
#, c-format
msgid "%s: line %d: "
msgstr "%s: рядок %d: "

#: jobs.c:4657 nojobs.c:895
#, c-format
msgid " (core dumped)"
msgstr " (збережено знімок оперативної пам’яті)"

#: jobs.c:4677 jobs.c:4697
#, c-format
msgid "(wd now: %s)\n"
msgstr "(тепер РД: %s)\n"

#: jobs.c:4741
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: помилка getpgrp"

#: jobs.c:4797
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: немає керування завданнями у тлі"

#: jobs.c:4813
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: алгоритм реалізації рядків"

#: jobs.c:4823
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:4844 jobs.c:4853
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "не вдалося встановити групу процесу для термінала (%d)"

#: jobs.c:4858
msgid "no job control in this shell"
msgstr "ця оболонка не може керувати завданнями"

#: lib/malloc/malloc.c:364
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: умова не виконується: %s\n"

#: lib/malloc/malloc.c:375
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: потрібна умова не виконується\r\n"

#: lib/malloc/malloc.c:376 lib/malloc/malloc.c:925
msgid "unknown"
msgstr "невідомий"

#: lib/malloc/malloc.c:876
msgid "malloc: block on free list clobbered"
msgstr "malloc: зайнятий блок у списку вільних"

#: lib/malloc/malloc.c:961
msgid "free: called with already freed block argument"
msgstr "free: аргумент є вже звільненим блоком"

#: lib/malloc/malloc.c:964
msgid "free: called with unallocated block argument"
msgstr "free: блок ще не виділено"

#: lib/malloc/malloc.c:982
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: виявлено перехід за нижню границю блоку; mh_nbytes не вкладається у рамки"

#: lib/malloc/malloc.c:988
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: виявлено перехід за нижню границю блоку; magic8 пошкоджено"

#: lib/malloc/malloc.c:995
msgid "free: start and end chunk sizes differ"
msgstr "free: розмір у записах на початку та в кінці блоку відрізняється"

#: lib/malloc/malloc.c:1155
msgid "realloc: called with unallocated block argument"
msgstr "realloc: блок ще не виділено"

#: lib/malloc/malloc.c:1170
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: виявлено перехід за нижню границю блоку; mh_nbytes не вкладається у рамки"

#: lib/malloc/malloc.c:1176
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: виявлено перехід за нижню границю блоку; magic8 пошкоджено"

#: lib/malloc/malloc.c:1184
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: розмір у записах на початку та в кінці блоку відрізняється"

#: lib/malloc/table.c:179
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: таблицю виділення заповнено FIND_ALLOC?\n"

#: lib/malloc/table.c:188
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p вже позначений як виділений у таблиці?\n"

#: lib/malloc/table.c:237
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p вже позначений як вільний у таблиці?\n"

#: lib/sh/fmtulong.c:90
msgid "invalid base"
msgstr "неправильна основа"

#: lib/sh/netopen.c:161
#, c-format
msgid "%s: host unknown"
msgstr "%s: невідомий хост"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: invalid service"
msgstr "%s: неправильна служба"

#: lib/sh/netopen.c:294
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: неправильно вказаний мережевий шлях"

#: lib/sh/netopen.c:332
msgid "network operations not supported"
msgstr "мережеві операції не підтримуються"

#: locale.c:226 locale.c:228 locale.c:301 locale.c:303
msgid "cannot change locale"
msgstr "не вдалося змінити локаль"

#: mailcheck.c:435
msgid "You have mail in $_"
msgstr "Присутня пошта у $_"

#: mailcheck.c:460
msgid "You have new mail in $_"
msgstr "Нова пошта у $_"

#: mailcheck.c:476
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Пошту у %s прочитано\n"

#: make_cmd.c:286
msgid "syntax error: arithmetic expression required"
msgstr "синтаксична помилка: потрібен арифметичний вираз"

#: make_cmd.c:288
msgid "syntax error: `;' unexpected"
msgstr "синтаксична помилка: неочікувана `;'"

#: make_cmd.c:289
#, c-format
msgid "syntax error: `((%s))'"
msgstr "синтаксична помилка: `((%s))'"

#: make_cmd.c:523
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: неправильний тип інструкції %d"

#: make_cmd.c:627
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "here-document з рядка %d закінчено кінцем файла (очікувалося «%s»)"

#: make_cmd.c:722
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: інструкція переспрямування `%d' поза межами"

#: parse.y:2572
#, c-format
msgid "shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line truncated"
msgstr "shell_getc: shell_input_line_size (%zu) перевищує обмеження SIZE_MAX (%lu): рядок обрізано"

#: parse.y:2864
msgid "script file read error"
msgstr "помилка читання файла скрипту"

#: parse.y:3101
msgid "maximum here-document count exceeded"
msgstr "перевищено максимальну можливу кількість here-document"

#: parse.y:3901 parse.y:4799 parse.y:6859
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "файл скінчився раніше, ніж було знайдено відповідний «%c»"

#: parse.y:5006
msgid "unexpected EOF while looking for `]]'"
msgstr "файл скінчився раніше, ніж було знайдено `]]'"

#: parse.y:5011
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "синтаксична помилка в умовному виразі: неочікувана лексема «%s»"

#: parse.y:5015
msgid "syntax error in conditional expression"
msgstr "синтаксична помилка в умовному виразі"

#: parse.y:5093
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "неочікувана лексема «%s», очікувалася `)'"

#: parse.y:5097
msgid "expected `)'"
msgstr "очікувалася `)'"

#: parse.y:5127
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "неочікуваний аргумент унарного умовного оператора «%s»"

#: parse.y:5131
msgid "unexpected argument to conditional unary operator"
msgstr "неочікуваний аргумент унарного умовного оператора"

#: parse.y:5178
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "неочікувана лексема «%s», очікувався бінарний умовний оператор"

#: parse.y:5182
msgid "conditional binary operator expected"
msgstr "очікувався бінарний умовний оператор"

#: parse.y:5211
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "неочікуваний аргумент бінарного умовного оператора «%s»"

#: parse.y:5215
msgid "unexpected argument to conditional binary operator"
msgstr "неочікуваний аргумент бінарного умовного оператора"

#: parse.y:5226
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "неочікувана лексема «%c» в умовній команді"

#: parse.y:5229
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "неочікувана лексема «%s» в умовній команді"

#: parse.y:5233
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "неочікувана лексема %d в умовній команді"

#: parse.y:6827
#, c-format
msgid "syntax error near unexpected token `%s' while looking for matching `%c'"
msgstr "синтаксична помилка поряд із неочікуваним жетоном «%s» при пошуку відповідного «%c»"

#: parse.y:6829
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "синтаксична помилка коло неочікуваної лексеми «%s»"

#: parse.y:6848
#, c-format
msgid "syntax error near `%s'"
msgstr "синтаксична помилка коло «%s»"

#: parse.y:6867
#, c-format
msgid "syntax error: unexpected end of file from `%s' command on line %d"
msgstr "синтаксична помилка: раптово скінчився файл з команди «%s» у рядку %d"

#: parse.y:6869
#, c-format
msgid "syntax error: unexpected end of file from command on line %d"
msgstr "синтаксична помилка: раптово скінчився файл з команди у рядку %d"

#: parse.y:6873
msgid "syntax error: unexpected end of file"
msgstr "синтаксична помилка: раптово скінчився файл"

#: parse.y:6873
msgid "syntax error"
msgstr "синтаксична помилка"

#: parse.y:6922
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Використовуйте \"%s\", щоб вийти з оболонки.\n"

#: parse.y:7120
msgid "unexpected EOF while looking for matching `)'"
msgstr "файл скінчився, перш ніж було знайдено відповідну `)'"

#: pathexp.c:897
msgid "invalid glob sort type"
msgstr "некоректний тип упорядковування за замінником"

#: pcomplete.c:1070
#, c-format
msgid "completion: function `%s' not found"
msgstr "завершення: функцію «%s» не знайдено"

#: pcomplete.c:1654
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr "programmable_completion: %s: можливий цикл повторних спроб"

#: pcomplib.c:176
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: NULL COMPSPEC"

#: print_cmd.c:324
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: неправильний з’єднувальний оператор `%d'"

#: print_cmd.c:399
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: некоректний дескриптор файла"

#: print_cmd.c:404
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: нульовий вказівник на файл"

#: print_cmd.c:408
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "дескриптор файла xtrace (%d) не дорівнює номеру файла у вказівнику xtrace (%d)"

#: print_cmd.c:1597
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: «%c»: неправильний символ шаблону"

#: redir.c:146 redir.c:194
msgid "file descriptor out of range"
msgstr "дескриптор файла поза можливими межами"

#: redir.c:201
msgid "ambiguous redirect"
msgstr "неоднозначне переспрямування"

#: redir.c:205
msgid "cannot overwrite existing file"
msgstr "заборонено перезаписувати наявні файли"

#: redir.c:210
msgid "restricted: cannot redirect output"
msgstr "обмеження: переспрямування виводу заборонене"

#: redir.c:215
msgid "cannot create temp file for here-document"
msgstr "не вдалося створити тимчасовий файл для here-document"

#: redir.c:219
msgid "cannot assign fd to variable"
msgstr "не вдалося надати змінній значення дескриптора файла"

#: redir.c:639
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "/dev/(tcp|udp)/host/port не підтримується"

#: redir.c:945 redir.c:1062 redir.c:1124 redir.c:1291
msgid "redirection error: cannot duplicate fd"
msgstr "помилка переспрямування: не вдалося створити копію дескриптора файла"

#: shell.c:359
msgid "could not find /tmp, please create!"
msgstr "не вдалося знайти /tmp, будь ласка створіть його!"

#: shell.c:363
msgid "/tmp must be a valid directory name"
msgstr "/tmp має бути чинною назвою каталогу"

#: shell.c:827
msgid "pretty-printing mode ignored in interactive shells"
msgstr "режим форматованого виведення даних у інтерактивних оболонках буде проігноровано"

#: shell.c:969
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: помилковий параметр"

#: shell.c:1354
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "не вдалося встановити uid %d: ефективним є uid %d"

#: shell.c:1370
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "не вдалося встановити gid %d: ефективним є gid %d"

#: shell.c:1559
msgid "cannot start debugger; debugging mode disabled"
msgstr "не вдалося запустити засіб діагностики: режим діагностування вимкнено"

#: shell.c:1672
#, c-format
msgid "%s: Is a directory"
msgstr "%s: це каталог"

#: shell.c:1748 shell.c:1750
msgid "error creating buffered stream"
msgstr "помилка під час спроби створити буферизований потік даних"

#: shell.c:1899
msgid "I have no name!"
msgstr "У мене нема назви!"

#: shell.c:2063
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, версія %s-(%s)\n"

#: shell.c:2064
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Використовуйте:\t%s [довгий параметр GNU] [параметр] ...\n"
"\t%s [довгий параметр GNU] [параметр] файл_сценарію ...\n"

#: shell.c:2066
msgid "GNU long options:\n"
msgstr "Довгі параметри GNU:\n"

#: shell.c:2070
msgid "Shell options:\n"
msgstr "Параметри оболонки:\n"

#: shell.c:2071
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-ilrsD чи -c команда чи -O параметр_shopt\t\t(тільки на початку)\n"

#: shell.c:2090
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s чи -o параметр\n"

#: shell.c:2096
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "Введіть `%s -c \"help set\"', щоб отримати більше інформації про параметри оболонки.\n"

#: shell.c:2097
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "Введіть `%s -c help', щоб отримати більше інформації про вбудовані команди оболонки.\n"

#: shell.c:2098
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Щоб повідомити про помилку в програмі, використовуйте команду `bashbug'.\n"

#: shell.c:2100
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "Домашня сторінка bash: <http://www.gnu.org/software/bash>\n"

#: shell.c:2101
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Загальна довідкова інформація щодо використання програмного забезпечення GNU: <http://www.gnu.org/gethelp/>\n"

#: sig.c:809
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: некоректна операція"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Ненаявний сигнал"

#: siglist.c:51
msgid "Hangup"
msgstr "Зависання"

#: siglist.c:55
msgid "Interrupt"
msgstr "Переривання"

#: siglist.c:59
msgid "Quit"
msgstr "Вихід"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Помилкова інструкція"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "Точка зупину trace/trap"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Інструкція ABORT"

#: siglist.c:79
msgid "EMT instruction"
msgstr "Інструкція EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Помилка обчислень з рухомою комою"

#: siglist.c:87
msgid "Killed"
msgstr "Вбитий"

#: siglist.c:91
msgid "Bus error"
msgstr "Помилка шини"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Помилка адресування"

#: siglist.c:99
msgid "Bad system call"
msgstr "Помилковий системний виклик"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Зламаний канал"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Таймер"

#: siglist.c:111
msgid "Terminated"
msgstr "Припинено"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Невідкладні події В/В"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Зупинено (сигнал)"

#: siglist.c:127
msgid "Continue"
msgstr "Продовження"

#: siglist.c:135
msgid "Child death or stop"
msgstr "Зупинка чи припинення дочірнього процесу"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Зупинено (ввід з термінала)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Зупинено (вивід на термінал)"

#: siglist.c:147
msgid "I/O ready"
msgstr "В/В готовий"

#: siglist.c:151
msgid "CPU limit"
msgstr "Обмеження часу CPU"

#: siglist.c:155
msgid "File limit"
msgstr "Обмеження розміру файла"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Таймер (віртуальний)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Таймер (профілювання)"

#: siglist.c:167
msgid "Window changed"
msgstr "Зміна вікна"

#: siglist.c:171
msgid "Record lock"
msgstr "Блокування втрачено"

#: siglist.c:175
msgid "User signal 1"
msgstr "Сигнал користувача 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Сигнал користувача 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "Вхідні дані HFT очікують"

#: siglist.c:187
msgid "power failure imminent"
msgstr "наближається втрата живлення"

#: siglist.c:191
msgid "system crash imminent"
msgstr "наближається аварійна ситуація"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "перенесення процесу на інший CPU"

#: siglist.c:199
msgid "programming error"
msgstr "помилка програмування"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "Режим монітору HFT надано"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "Режим монітору HFT відкликано"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "Завершено звукову послідовність HFT"

#: siglist.c:215
msgid "Information request"
msgstr "Інформаційний запит"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Невідомий сигнал №%d"

#: subst.c:1503 subst.c:1795 subst.c:2001
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "неправильна заміна: немає заключної «%s» у %s"

#: subst.c:3601
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: неможливо означити елемент масиву списком"

#: subst.c:6381 subst.c:6397
msgid "cannot make pipe for process substitution"
msgstr "не вдалося створити канал для підставляння процесу"

#: subst.c:6457
msgid "cannot make child for process substitution"
msgstr "не вдалося створити дочірній процес для підставляння процесу"

#: subst.c:6532
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "не вдалося відкрити іменований канал %s для читання"

#: subst.c:6534
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "не вдалося відкрити іменований канал %s для запису"

#: subst.c:6557
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "не вдалося здублювати іменований канал %s як fd %d"

#: subst.c:6723
msgid "command substitution: ignored null byte in input"
msgstr "заміна команди: проігноровано порожній байт у вхідних даних"

#: subst.c:6962
msgid "function_substitute: cannot open anonymous file for output"
msgstr "function_substitute: не вдалося відкрити анонімний файл для виведення даних"

#: subst.c:7036
msgid "function_substitute: cannot duplicate anonymous file as standard output"
msgstr "function_substitute: не можна дублювати анонімний файл як стандартне виведення"

#: subst.c:7210 subst.c:7231
msgid "cannot make pipe for command substitution"
msgstr "не вдалося створити канал для підставляння команди"

#: subst.c:7282
msgid "cannot make child for command substitution"
msgstr "не вдалося створити дочірній процес для підставляння команди"

#: subst.c:7315
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: не вдалося створити копію каналу із файловим дескриптором 1"

#: subst.c:7813 subst.c:10989
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: некоректна назва змінної для посилання за назвою"

#: subst.c:7906 subst.c:7924 subst.c:8100
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: некоректне непряме розгортання"

#: subst.c:7940 subst.c:8108
#, c-format
msgid "%s: invalid variable name"
msgstr "%s: некоректна назва змінної"

#: subst.c:8125 subst.c:10271 subst.c:10298
#, c-format
msgid "%s: bad substitution"
msgstr "%s: неправильна заміна"

#: subst.c:8224
#, c-format
msgid "%s: parameter not set"
msgstr "%s: параметр не встановлено"

#: subst.c:8480 subst.c:8495
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: підрядок коротший за 0"

#: subst.c:10397
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: не можна призначити таким чином"

#: subst.c:10855
msgid "future versions of the shell will force evaluation as an arithmetic substitution"
msgstr "у наступних версіях оболонки буде виконуватися обчислення для заміни арифметичних виразів"

#: subst.c:11563
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "неправильна заміна: немає заключної \"`\" у %s"

#: subst.c:12636
#, c-format
msgid "no match: %s"
msgstr "нема відповідника: %s"

#: test.c:156
msgid "argument expected"
msgstr "очікувався аргумент"

#: test.c:164
#, c-format
msgid "%s: integer expected"
msgstr "%s: мало бути використано ціле значення"

#: test.c:292
msgid "`)' expected"
msgstr "очікувалася `)'"

#: test.c:294
#, c-format
msgid "`)' expected, found %s"
msgstr "очікувалася `)', отримано %s"

#: test.c:488 test.c:831
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: очікувався бінарний оператор"

#: test.c:792 test.c:795
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: очікувався унарний оператор"

#: test.c:944
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "синтаксична помилка: неочікуване `%s'"

#: trap.c:225
msgid "invalid signal number"
msgstr "неправильний номер сигналу"

#: trap.c:358
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "обробник пасток: досягнуто максимального рівня для обробника пасток (%d)"

#: trap.c:455
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: неправильне значення у trap_list[%d]: %p"

#: trap.c:459
#, c-format
msgid "run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr "run_pending_traps: обробник сигналу є SIG_DFL, %d (%s) повторно надсилається собі"

#: trap.c:592
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: неправильний сигнал %d"

#: unwind_prot.c:246 unwind_prot.c:292
msgid "frame not found"
msgstr "фрейм не знайдено"

#: variables.c:441
#, c-format
msgid "error importing function definition for `%s'"
msgstr "помилка імпортування означення функції «%s»"

#: variables.c:864
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "рівень оболонки (%d) занадто високий, перевстановлено у 1"

#: variables.c:2191 variables.c:2220 variables.c:2278 variables.c:2297
#: variables.c:2315 variables.c:2350 variables.c:2378 variables.c:2405
#: variables.c:2431 variables.c:3274 variables.c:3282 variables.c:3797
#: variables.c:3841
#, c-format
msgid "%s: maximum nameref depth (%d) exceeded"
msgstr "%s: перевищено максимальну глибину nameref (%d)"

#: variables.c:2641
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: немає контексту функції у поточній області"

#: variables.c:2660
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: змінною не може бути значення, яке приймають інші змінні"

#: variables.c:2831 variables.c:2884
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr "%s: неможливо успадкувати значення несумісного типу"

#: variables.c:3437
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: присвоєння цілого числа посиланню з назвою"

#: variables.c:4387
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: немає контексту функції у поточній області"

#: variables.c:4816
#, c-format
msgid "%s has null exportstr"
msgstr "%s має нульове значення рядка експортування"

#: variables.c:4821 variables.c:4830
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "Помилковий символ %d у рядку експорту для %s"

#: variables.c:4836
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "немає `=' у рядку експорту для %s"

#: variables.c:5354
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: перший елемент shell_variables не є контекстом функції"

#: variables.c:5367
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: немає контексту global_variables"

#: variables.c:5457
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: перший елемент shell_variables не є тимчасовим оточенням виконання"

#: variables.c:6448
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: не вдалося відкрити ФАЙЛ"

#: variables.c:6453
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: некоректне значення дескриптора файла трасування"

#: variables.c:6497
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: значення сумісності не належить припустимому діапазону значень"

#: version.c:50
msgid "Copyright (C) 2025 Free Software Foundation, Inc."
msgstr "© Free Software Foundation, Inc., 2025"

#: version.c:51
msgid "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
msgstr "Ліцензія GPLv3+: GNU GPL версія 3 чи новіша <http://gnu.org/licenses/gpl.html>\n"

#: version.c:90
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, версія %s (%s)\n"

#: version.c:95
msgid "This is free software; you are free to change and redistribute it."
msgstr "Це вільне програмне забезпечення; ви можете його змінювати та розповсюджувати."

#: version.c:96
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "Не надається НІЯКИХ ГАРАНТІЙ у межах, передбачених законом."

#: xmalloc.c:84
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: не вдалося виділити %lu байтів (виділено %lu байтів)"

#: xmalloc.c:86
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: не вдалося виділити %lu байтів"

#: xmalloc.c:164
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: не вдалося виділити %lu байтів (виділено %lu байтів)"

#: xmalloc.c:166
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: не вдалося виділити %lu байтів"

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-3] [назва[=значення] ...]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] назва [назва ...]"

#: builtins.c:53
msgid "bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr "bind [-lpsvPSVX] [-m keymap] [-f файл] [-q назва] [-u назва] [-r послідовність-клавіш] [-x послідовність-клавіш:команда-оболонки] [послідовність-клавіш:функція-readline чи команда-readline]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [вбудована-команда [аргумент ...]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [вираз]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]]] [-@] [dir]"
msgstr "cd [-L|[-P [-e]]] [-@] [каталог]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] команда [аргумент ...]"

#: builtins.c:78
msgid "declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] [name ...]"
msgstr "declare [-aAfFgiIlnrtux] [назва[=значення] ...] або declare -p [-aAfFilnrtux] [назва ...]"

#: builtins.c:80
msgid "typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] [name ...]"
msgstr "typeset [-aAfFgiIlnrtux] назва[=значення] ... або typeset -p [-aAfFilnrtux] [назва ...]"

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [параметр] назва[=значення] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [аргумент ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [аргумент ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f файл] [назва ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [аргумент ...]"

#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts рядок-параметрів назва [аргумент ...]"

#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a назва] [команда [аргумент ...]] [переспрямування ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e редактор] [-lnr] [перший] [останній] чи fc -s [шаблон=заміна] [команда]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [завдання]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [завдання ...]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p шлях] [-dt] [назва ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [шаблон ...]"

#: builtins.c:123
msgid "history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]"
msgstr "history [-c] [-d позиція] [n] чи history -anrw [файл] чи history -ps аргумент [аргумент ...]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [завдання ...] чи jobs -x команда [аргументи]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [специфікація завдання ... | pid ...]"

#: builtins.c:134
msgid "kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]"
msgstr "kill [-s сигнал | -n номер-сигналу | -сигнал] pid | завдання ... чи kill -l [сигнал]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let аргумент [аргумент ...]"

#: builtins.c:138
msgid "read [-Eers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]"
msgstr "read [-Eers] [-a масив] [-d роздільник] [-i текст] [-n кількість-символів] [-N кількість-символів][-p запрошення] [-t ліміт-часу] [-u дескриптор-файла] [назва ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCEHPT] [-o назва-параметра] [--] [-] [аргумент ...]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [назва ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p [-f]"
msgstr "export [-fn] [назва[=значення] ...] чи export -p [-f]"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonli [-af [назва[=значення] ...] чи readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source [-p path] filename [arguments]"
msgstr "source [-p шлях] файл [аргументи]"

#: builtins.c:154
msgid ". [-p path] filename [arguments]"
msgstr ". [-p шлях] файл [аргументи]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [вираз]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ аргумент... ]"

#: builtins.c:166
msgid "trap [-Plp] [[action] signal_spec ...]"
msgstr "trap [-Plp] [[дія] сигнал ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] назва [назва ...]"

#: builtins.c:171
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPRT] [обмеження]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [режим-доступу]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p змінна] [ідентифікатор]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [ідентифікатор-процесу ...]"

#: builtins.c:184
msgid "! PIPELINE"
msgstr "! КАНАЛ_ОБРОБКИ"

#: builtins.c:186
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for НАЗВА [in СЛОВА ... ] ; do КОМАНДИ; done"

#: builtins.c:188
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( вираз1; вираз2; вираз3 )); do КОМАНДИ; done"

#: builtins.c:190
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select НАЗВА [in СЛОВА ...;] do КОМАНДИ; done"

#: builtins.c:192
msgid "time [-p] pipeline"
msgstr "time [-p] канал"

#: builtins.c:194
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case СЛОВО in [ШАБЛОН [| ШАБЛОН]...) КОМАНДИ ;;]... esac"

#: builtins.c:196
msgid "if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi"
msgstr "if КОМАНДИ; then КОМАНДИ; [ elif КОМАНДИ; then КОМАНДИ; ]... [ else КОМАНДИ; ] fi"

#: builtins.c:198
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while КОМАНДИ; do КОМАНДИ-2; done"

#: builtins.c:200
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until КОМАНДИ; do КОМАНДИ-2; done"

#: builtins.c:202
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [НАЗВА] команда [переспрямування]"

#: builtins.c:204
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function НАЗВА { КОМАНДИ ; } чи НАЗВА () { КОМАНДИ ; }"

#: builtins.c:206
msgid "{ COMMANDS ; }"
msgstr "{ КОМАНДИ ; }"

#: builtins.c:208
msgid "job_spec [&]"
msgstr "завдання [&]"

#: builtins.c:210
msgid "(( expression ))"
msgstr "(( вираз ))"

#: builtins.c:212
msgid "[[ expression ]]"
msgstr "[[ вираз ]]"

#: builtins.c:214
msgid "variables - Names and meanings of some shell variables"
msgstr "variables - назви та значення деяких змінних оболонки"

#: builtins.c:217
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | каталог]"

#: builtins.c:221
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:225
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:228
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [назва-параметра ...]"

#: builtins.c:230
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v змінна] шаблон-форматування [аргументи]"

#: builtins.c:233
msgid "complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]"
msgstr "complete [-abcdefgjksuv] [-pr] [-DEI] [-o параметр] [-A дія] [-G шаблон-оболонки] [-W список-слів] [-F функція] [-C команда] [-X шаблон-фільтрування] [-P префікс] [-S суфікс] [назва ...]"

#: builtins.c:237
msgid "compgen [-V varname] [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr "compgen [-V змінна] [-abcdefgjksuv] [-o параметр] [-A дія] [-G шаблон-оболонки] [-W список-слів] [-F функція] [-C команда] [-X шаблон-фільтрування] [-P префікс] [-S суфікс] [слово]"

#: builtins.c:241
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o параметр] [-DEI] [назва ...]"

#: builtins.c:244
msgid "mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "mapfile [-d роздільник] [-n кількість] [-O початок-відліку] [-s кількість] [-t] [-u дескриптор] [-C обробник] [-c крок] [масив]"

#: builtins.c:246
msgid "readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "readarray [-d роздільник] [-n кількість] [-O початок-відліку] [-s кількість] [-t] [-u дескриптор] [-C обробник] [-c крок] [масив]"

#: builtins.c:258
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has been\n"
"    defined."
msgstr ""
"Додає чи показує псевдоніми для команд.\n"
"    \n"
"    Викликана без аргументів, команда `alias' друкує список псевдонімів у\n"
"    придатній до подальшого виконання формі `alias НАЗВА=ЗНАЧЕННЯ'.\n"
"    \n"
"    Інакше вона додає псевдоніми для кожної вказаної НАЗВИ, для якої надане\n"
"    ЗНАЧЕННЯ. Пробіли в кінці ЗНАЧЕННЯ дозволяють увімкнути подальше розкриття\n"
"    псевдонімів усередині цього псевдоніму під час його підставляння.\n"
"    \n"
"    Параметри:\n"
"      -p\tвивести усі визначені псевдоніми у придатній до виконання формі.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо було вказано НАЗВУ, для якої немає\n"
"    псевдоніма."

#: builtins.c:280
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Вилучає усі вказані НАЗВИ зі списку визначених псевдонімів.\n"
"    \n"
"    Параметри:\n"
"      -a\tВилучити визначення усіх псевдонімів.\n"
"    \n"
"    Код завершення:\n"
"    Завершується невдало, якщо НАЗВА не є визначеним псевдонімом."

#: builtins.c:293
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their values\n"
"      -s                 List key sequences that invoke macros and their values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    If arguments remain after option processing, the -p and -P options treat\n"
"    them as readline command names and restrict output to those names.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Встановлює призначення клавіш та змінні readline.\n"
"    \n"
"    Призначає функції чи макровизначенню readline послідовність клавіш чи\n"
"    встановлює змінну readline. Аргумент, що не відносяться до параметрів\n"
"    має синтаксис такий же як у ~/.inputrc, але мають бути вказані як один\n"
"    аргумент, наприклад, bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Параметри:\n"
"      -m  набір          Використовувати НАБІР призначень клавіш на час\n"
"                         виконання цієї команди. Назви наявних наборів: emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command та vi-insert.\n"
"      -l                 Вивести назви функцій.\n"
"      -P                 Вивести назви функцій та які послідовності клавіш їм\n"
"                         призначено.\n"
"      -p                 Вивести функції та призначення у формі, придатній для\n"
"                         подальшого використання як ввід.\n"
"      -S                 Вивести послідовності клавіш, які запускають\n"
"                         макровизначення.\n"
"      -s                 Вивести послідовності клавіш, які запускають\n"
"                         макровизначення у формі, придатній для подальшого\n"
"                         використання як ввід.\n"
"      -V                 Вивести назви та значення змінних.\n"
"      -v                 Вивести назви та значення змінних у формі, що може\n"
"                         бути надалі використана як ввід.\n"
"      -q  функція        Показати, які послідовності клавіш запускають цю\n"
"                         функцію.\n"
"      -u  функція        Скасувати усі призначені цій функції послідовності.\n"
"      -r  послідовність  Скасувати призначення ПОСЛІДОВНОСТІ.\n"
"      -f  файл           Прочитати призначення клавіш з ФАЙЛУ.\n"
"      -x  послідовність:команда-оболонки\tПри введенні ПОСЛІДОВНОСТІ буде\n"
"    \t\t\t\tзапускатися КОМАНДА-ОБОЛОНКИ.\n"
"      -X                 Показати список послідовностей клавіш, пов'язаних з -x та відповідні\n"
"                         команди у форматі, яким можна скористатися як вхідними даними\n"
"                         для іншої програми.\n"
"    \n"
"    Якщо після обробки параметрів лишаться аргументи, параметри -p і -P розроблятимуть\n"
"    їх як назви команд readline і обмежуватиме виведення до цих назв.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо вказані правильні параметри та не\n"
"    виникло помилки під час виконання."

#: builtins.c:335
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Виходить з циклів for, while чи until.\n"
"    \n"
"    Перериває цикли FOR, WHILE чи UNTIL. Якщо вказано N, перериває\n"
"    N вкладених циклів.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо N менше за 1."

#: builtins.c:347
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Переходить до наступної ітерації циклів for, while чи until.\n"
"    \n"
"    Переходить до наступної ітерації циклу for, while чи until.\n"
"    Якщо вказане N, перехід відбувається у N-ному зовнішньому циклі.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо N менше 1."

#: builtins.c:359
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Виконує вбудовану команду оболонки.\n"
"    \n"
"    Запускає ВБУДОВАНУ-КОМАНДУ з вказаними АРГУМЕНТАМИ, пошук команди не\n"
"    робиться. Це може стати в нагоді, якщо ви хочете замінити вбудовану\n"
"    команду функцією оболонки, але вам треба запускати вбудовану команду\n"
"    зсередини цієї функції.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає код завершення ВБУДОВАНОЇ-КОМАНДИ або помилку, якщо\n"
"    ВБУДОВАНА-КОМАНДА не є вбудованою командою оболонки."

#: builtins.c:374
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Повертає контекст виконання поточної підпрограми.\n"
"    \n"
"    Якщо ВИРАЗ не вказано, виводить \"$line $filename\". Інакше виводить\n"
"    \"$line $subroutine $filename\"; цю додаткову інформацію можна\n"
"    використовувати для трасування стеку.\n"
"    \n"
"    Значення ВИРАЗУ визначає на скільки рівнів викликів піднятися від\n"
"    поточного; поточний рівень є нульовим.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо оболонка зараз не виконує функцію\n"
"    або якщо ВИРАЗ є неправильним."

#: builtins.c:392
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of the\n"
"    HOME shell variable. If DIR is \"-\", it is converted to $OLDPWD.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n"
"    A null directory name is the same as the current directory.  If DIR begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is set,\n"
"    the word is assumed to be  a variable name.  If that variable has a value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Змінює робочий каталог оболонки.\n"
"    \n"
"    Змінює поточний каталог на КАТАЛОГ. Якщо КАТАЛОГ не вказано,\n"
"    значення буде взято зі значення змінної середовища HOME.\n"
"    Якщо замість КАТАЛОГ вказано «-», його буде перетворено на $OLDPWD.\n"
"    \n"
"    Змінна CDPATH визначає набір каталогів, в яких слід шукати КАТАЛОГ.\n"
"    Каталоги у цій змінній розділяються двокрапкою (:).\n"
"    Порожня назва каталогу означає поточний каталог. Якщо КАТАЛОГ\n"
"    починається з похилої риски (/), CDPATH не використовується.\n"
"    \n"
"    Якщо каталог не буде знайдено, у разі визначеного параметра оболонки\n"
"    `cdable_vars', КАТАЛОГ вважатиметься назвою змінної. Якщо змінна з\n"
"    такою назвою існуватиме, її значення буде використане замість КАТАЛОГУ.\n"
"    \n"
"    Параметри:\n"
"      -L\tПримусово переходити за символічними посиланнями: визначати\n"
"    \tджерело символічних посилань як КАТАЛОГ після обробки записів `..'.\n"
"      -P\tВикористовувати фізичну структуру каталогів, не переходити за\n"
"    \tсимволічними посиланнями: визначати джерело символічних посилань як\n"
"    \tКАТАЛОГ до обробки записів `..'.\n"
"      -e\tякщо вказано параметр -P і програмі не вдасться визначити поточний\n"
"    \tробочий каталог, вийти з ненульовим значенням стану.\n"
"      -@  у системах, де передбачено таку підтримку, показати файл з розширеними\n"
"            атрибутами як каталог, що містить атрибути файла\n"
"    \n"
"    Зазвичай команда переходитиме за символічними посиланнями, неначе було\n"
"    вказано параметр `-L'.\n"
"    `..' обробляється шляхом вилучення компонентів шляху до символу\n"
"    похилої риски або за початковим компонентом каталогу КАТАЛОГ.\n"
"    \n"
"    Код завершення:\n"
"    Повертає 0, якщо каталог було змінено і якщо було успішно встановлено значення\n"
"    $PWD у разі використання -P. За інших результатів повертає ненульове значення."

#: builtins.c:430
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Виводить назву поточного робочого каталогу.\n"
"    \n"
"    Параметри:\n"
"      -L\tВивести значення $PWD, якщо вона вказує поточний робочий каталог.\n"
"      -P\tВивести фізичне розташування каталогу, без символічних посилань.\n"
"    \n"
"    Зазвичай `pwd' працює як ніби вказано `-L'.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо вказано неправильний параметр чи\n"
"    не вдалося отримати доступ до поточного робочого каталогу."

#: builtins.c:447
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Нічого не робить.\n"
"    \n"
"    Не має жодного ефекту; ця команда нічого не робить.\n"
"    \n"
"    Код завершення:\n"
"    Команда завжди успішна."

#: builtins.c:458
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Завершується успішно.\n"
"    \n"
"    Код завершення:\n"
"    Команда завжди успішна."

#: builtins.c:467
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Завершується помилково.\n"
"    \n"
"    Код завершення:\n"
"    Команда завжди завершується невдало."

#: builtins.c:476
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a single word indicating the command or filename that\n"
"            invokes COMMAND\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Запускає звичайну команду чи показує інформацію про команди.\n"
"    \n"
"    Запускає КОМАНДУ з АРГУМЕНТАМИ, не роблячи пошуку серед функцій оболонки,\n"
"    чи показує інформацію про вказані КОМАНДИ. Може використовуватися для\n"
"    запуску команд з диску, коли існує функція з такою ж назвою.\n"
"    \n"
"    Параметри:\n"
"      -p   Використовувати стандартне значення PATH, яке забезпечує\n"
"           знаходження усіх стандартних утиліт.\n"
"      -v   Вивести одне слово команди або назви файла,\n"
"            яким викликано КОМАНДУ\n"
"      -V   Вивести більш багатослівний опис кожної з КОМАНД.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає код завершення КОМАНДИ або помилку, якщо КОМАНДУ не буде\n"
"    знайдено."

#: builtins.c:496
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute, except for a,\n"
"    A, and r.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the `local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Встановлює значення та властивості змінних.\n"
"    \n"
"    Описує змінні та встановлює їх властивості. Якщо НАЗВИ не вказано,\n"
"    показує властивості та значення усіх змінних.\n"
"    \n"
"    Параметри:\n"
"      -f\tОбмежити поле дії лише назвами та визначеннями функцій.\n"
"      -F\tОбмежити показ лише назвами функцій (плюс номер рядку та\n"
"    \t\tфайл, звідки походить функція, якщо виконується діагностика).\n"
"      -g\tстворити загальні змінні, якщо використано у функції оболонки,\n"
"    \t\tякщо це не функція оболонки, буде проігноровано.\n"
"      -I\tпри створення локальної змінної успадкувати атрибути і значення\n"
"    \t\tзмінної із тією самою назвою у попередньому просторі назв\n"
"      -p\tПоказати властивості та значення кожної з НАЗВ.\n"
"    \n"
"    Параметри, що встановлюють властивості:\n"
"      -a\tЗробити НАЗВИ індексованими масивами (якщо підтримується).\n"
"      -A\tЗробити НАЗВИ асоціативними масивами (якщо підтримується).\n"
"      -i\tНадати НАЗВА властивість `ціле число'.\n"
"      -n\tЗробити НАЗВУ посиланням на змінну, вказану як значення\n"
"      -l\tПеретворити значення кожної НАЗВИ до нижнього регістру, якщо НАЗВИ визначено.\n"
"      -r\tЗробити НАЗВИ незмінними (лише для читання).\n"
"      -t\tНадати НАЗВАМ властивість `trace'.\n"
"      -u\tПеретворити значення кожної НАЗВИ до верхнього регістру, якщо НАЗВИ визначено.\n"
"      -x\tЕкспортувати НАЗВИ.\n"
"    \n"
"    Замінивши `+' на `-' можна вимкнути відповідну властивість, окрім a,\n"
"    A і r.\n"
".\n"
"    \n"
"    При означенні змінні з властивістю цілого числа виконується арифметичне\n"
"    обчислення (див. команду `let') значення.\n"
"    \n"
"    При використанні всередині функції `declare' робить НАЗВИ локальними\n"
"    змінними, як команда `local'. Параметр `-g' вимикає таку поведінку.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо вказані правильні параметри і не виникло\n"
"    помилки під час виконання."

#: builtins.c:539
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Встановлює значення та властивості змінних.\n"
"    \n"
"    Синонім `declare'. Дивіться `help declare'."

#: builtins.c:547
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    If any NAME is \"-\", local saves the set of shell options and restores\n"
"    them when the function returns.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Описує локальні змінні.\n"
"    \n"
"    Створює локальну змінну НАЗВА та призначає їй ЗНАЧЕННЯ. ПАРАМЕТР може бути\n"
"    будь-яким параметром, що приймається командою `declare'.\n"
"    \n"
"    Якщо якась з НАЗВ є «-», local зберігатиме набір параметрів оболонки і\n"
"    відновлюватиме їх при поверненні з функції.\n"
"    \n"
"    Локальні змінні можуть використовуватися лише усередині функції; їх видно\n"
"    лише у функції, де їх визначено та її нащадках.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо вказано помилкові параметри, стається\n"
"    помилка під час надання змінній значення або якщо оболонка не виконує функцію."

#: builtins.c:567
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Друкує аргументи до стандартного виводу.\n"
"    \n"
"    Виводить АРГУМЕНТИ, відокремлені один від одного одинарним символом пробілу, із\n"
"    завершальним символом розриву рядка до стандартного виводу.\n"
"    \n"
"    Параметри:\n"
"      -n\tНе додавати символ нового рядку в кінці.\n"
"      -e\tУвімкнути інтерпретацію нижченаведених послідовностей.\n"
"      -E\tЯвно заборонити інтерпретацію послідовностей.\n"
"    \n"
"    `echo' інтерпретує наступні послідовності, що починаються зі зворотньої\n"
"    похилої риски:\n"
"      \\a\tсигнал (дзвінок)\n"
"      \\b\tповернення курсору\n"
"      \\c\tне виводити все, що далі\n"
"      \\e\tсимвол escape\n"
"      \\E\tсимвол escape\n"
"      \\f\tперехід на рядок нижче\n"
"      \\n\tпочаток нового рядку\n"
"      \\r\tповернення до початку рядку\n"
"      \\t\tгоризонтальна табуляція\n"
"      \\v\tвертикальна табуляція\n"
"      \\\\\tзворотня похила риска\n"
"      \\0nnn\tсимвол з вісімковим ASCII-кодом NNN. NNN може мати від\n"
"    \t\tнуля до трьох вісімкових цифр\n"
"      \\xHH\tвосьмибітовий символ із шістнадцятковим кодом HH. HH\n"
"    \t\tможе бути одною чи двома шістнадцятковими цифрами\n"
"      \\uHHHH\tсимвол Unicode, чиє значення є шістнадцятковим числом HHHH.\n"
"    \t\tHHHH може складатися з одної, двох, трьох або чотирьох шістнадцяткових цифр.\n"
"      \\UHHHHHHHH символ Unicode, чиє значення є шістнадцятковим числом\n"
"    \t\tHHHHHHHH. HHHHHHHH може містити від однією до восьми шістнадцяткових цифр.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо виникне помилка запису."

#: builtins.c:607
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Друкує аргументи до стандартного виводу.\n"
"    \n"
"    Виводить АРГУМЕНТИ до стандартного виводу з переходом на новий рядок.\n"
"    \n"
"    Параметри:\n"
"      -n\tНе додавати символ нового рядку в кінці.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо трапиться помилка запису."

#: builtins.c:622
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    On systems with dynamic loading, the shell variable BASH_LOADABLES_PATH\n"
"    defines a search path for the directory containing FILENAMEs that do\n"
"    not contain a slash. It may include \".\" to force a search of the current\n"
"    directory.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Вмикає та вимикає вбудовані команди оболонки.\n"
"    \n"
"    Вмикає та вимикає вбудовані команди оболонки. Вимкнення команди дозволяє\n"
"    вам запускати команду з диску, що має таку ж назву, як і вбудована команда\n"
"    оболонки, без потреби вказувати повний шлях до команди.\n"
"    \n"
"    Параметри:\n"
"      -a\tНадрукувати список вбудованих команд, вказуючи чи вони ввімкнені.\n"
"      -n\tВимкнути кожну з НАЗВ або надрукувати список вимкнених команд.\n"
"      -p\tНадрукувати список вбудованих команд у придатній для подальшого\n"
"    \tвиконання формі.\n"
"      -s\tДрукувати лише назви `спеціальних' команд Posix.\n"
"    \n"
"    Параметри, що контролюють динамічне завантаження:\n"
"      -f\tЗавантажити вбудовану команду НАЗВА з колективного об’єктного ФАЙЛУ.\n"
"      -d\tВилучити вбудовану команду, завантажену за допомогою -f.\n"
"    \n"
"    Без параметрів вмикає кожну з НАЗВ.\n"
"    \n"
"    У системах із динамічним завантаженням, змінна оболонки BASH_LOADABLES_PATH\n"
"    визначає шлях пошуку каталогу, що містить ФАЙЛИ, який не містить символу\n"
"    похилої риски. Він може містити «.» для примусового пошуку поточного\n"
"    каталогу.\n"
"    \n"
"    Щоб використовувати `test', що знаходиться десь у $PATH замість\n"
"    вбудованої у оболонку версії, введіть `enable -n test'.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо НАЗВА не є вбудованою командою\n"
"    оболонки або якщо трапиться помилка під час виконання."

#: builtins.c:655
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Виконує аргументи як команду оболонки.\n"
"    \n"
"    Об’єднує АРГУМЕНТИ в один рядок та виконує результат як команди, введені\n"
"    до оболонки.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає результат виконання команди. Якщо отриманий рядок команди\n"
"    є порожнім рядком, команда завершується успішно."

#: builtins.c:667
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Аналізує рядок параметрів.\n"
"    \n"
"    Getopts використовується підпрограмами оболонки для аналізу позиційних\n"
"    аргументів як параметрів командного рядку.\n"
"    \n"
"    РЯДОК-ПАРАМЕТРІВ містить літери параметрів, які можуть бути вказані; якщо\n"
"    за літерою іде двокрапка, цей параметр очікує аргументу, відокремленого\n"
"    від нього пробілом.\n"
"    \n"
"    Після кожного запуску getopts кладе наступний параметр до змінної оболонки\n"
"    $name, створюючи її, якщо треба. Номер наступного неопрацьованого\n"
"    аргументу кладеться до змінної оболонки OPTIND. OPTIND встановлюється у 1\n"
"    кожного разу, як запускається оболонка чи скрипт. Якщо параметр очікує\n"
"    аргументу, getopts кладе аргумент до змінної оболонки OPTARG.\n"
"    \n"
"    Getopts може повідомляти про помилки двома способами. Якщо першим символом\n"
"    РЯДКУ-ПАРАМЕТРІВ є двокрапка, getopts використовує `тихе' повідомлення про\n"
"    помилки. В такому режимі повідомлення про помилки не виводяться. Якщо буде\n"
"    знайдено неправильний параметр, getopts покладе його до OPTARG. Якщо не\n"
"    буде вказано очікуваний аргумент, getopts покладе ':' до НАЗВА, а символ\n"
"    параметра — до OPTARG. У `гучному' режимі, при з помилками у параметрі у NAME\n"
"    кладеться '?', а OPTARG скидається. Якщо потрібний аргумент не вказано, у\n"
"    NAME кладеться '?', OPTARG скидається і друкується діагностичне\n"
"    повідомлення.\n"
"    \n"
"    Якщо змінна оболонки OPTERR встановлена у 0, getopts не друкуватиме\n"
"    повідомлення про помилки навіть у `гучному режимі'. Стандартне значення\n"
"    OPTERR — 1.\n"
"    \n"
"    Зазвичай getopts обробляє позиційні параметри, але якщо надано\n"
"    аргументи як значення ARG, замість цього буде оброблено аргументи.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо знайдено параметр; помилково, якщо\n"
"    параметри скінчилися або трапилася помилка."

#: builtins.c:709
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error occurs."
msgstr ""
"Заміщує оболонку вказаною командою.\n"
"    \n"
"    Запускає КОМАНДУ, заміщаючи поточну оболонку вказаною програмою.\n"
"    АРГУМЕНТИ передаються КОМАНДІ. Якщо КОМАНДУ не вказано, будь-які\n"
"    переспрямування застосовуються до поточної оболонки.\n"
"    \n"
"    Параметри:\n"
"      -a назва\tПередати НАЗВУ як нульовий аргумент КОМАНДИ.\n"
"      -c\tЗапустити КОМАНДУ з порожнім оточенням.\n"
"      -l\tПокласти риску до нульового аргументу КОМАНДИ.\n"
"    \n"
"    Якщо команду не вдасться запустити, неінтерактивна оболонка завершується,\n"
"    якщо тільки не встановлено параметр оболонки `execfail'.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо команду не буде знайдено або якщо\n"
"    трапиться помилка переспрямування."

#: builtins.c:730
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Виходить з оболонки.\n"
"    \n"
"    Виходить з оболонки, повертаючи статус N. Якщо N не вказано, береться\n"
"    статус останньої запущеної команди."

#: builtins.c:739
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not executed\n"
"    in a login shell."
msgstr ""
"Виходить з оболонки сеансу.\n"
"    \n"
"    Виходить з оболонки сеансу зі статусом N. Повертає помилку, якщо команду\n"
"    запущено не у оболонці сеансу."

#: builtins.c:749
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    The history builtin also operates on the history list.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error occurs."
msgstr ""
"Показує чи запускає команди зі списку попередньо запущених.\n"
"    \n"
"    Fc використовується для показу чи редагування та подальшого повторного\n"
"    запуску команд з журналу. ПЕРШИЙ та ОСТАННІЙ можуть вказувати діапазон\n"
"    або ПЕРШИЙ може бути рядком, тоді він означатиме останню команду, що\n"
"    починалася з цього рядка.\n"
"    \n"
"    Параметри:\n"
"      -e РЕДАКТОР\tВказує редактор. Зазвичай це FCEDIT, EDITOR чи vi,\n"
"    \t\tщо перше буде знайдене.\n"
"      -l\tПоказати рядки журналу, замість редагування.\n"
"      -n\tНе виводити номери рядків у списку.\n"
"      -r\tПоказувати у зворотньому порядку (найновіші першими).\n"
"    \n"
"    У форматі `fc -s [шаблон=заміна ...] [команда]', КОМАНДА запускається\n"
"    після заміни ШАБЛОН=ЗАМІНА.\n"
"    \n"
"    При використанні цієї команди може бути зручним псевдонім r='fc -s' — тоді\n"
"    `r cc' запустить останню команду, що починається з `cc', а `r' повторно\n"
"    виконає останню команду.\n"
"    \n"
"    Вбудоване значення history працює зі списком журналу.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується зі статусом запущених команд, або помилкою, якщо\n"
"    трапиться помилка."

#: builtins.c:781
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Переводить завдання у пріоритетний режим.\n"
"    \n"
"    Переводить ЗАВДАННЯ у пріоритетний режим виконання і робить його поточним\n"
"    завданням. Якщо ЗАВДАННЯ не вказане, береться завдання, яке оболонка\n"
"    вважає поточним.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується зі статусом завершення завдання, що переведене\n"
"    у пріоритетний режим, або помилкою, якщо трапиться помилка."

#: builtins.c:796
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Переводить завдання у фоновий режим.\n"
"    \n"
"    Переводить кожне з ЗАВДАНЬ у фоновий режим виконання, як ніби їх запущено\n"
"    із `&'. Якщо ЗАВДАННЯ не вказані, береться завдання, що оболонка вважає\n"
"    поточним.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо контроль завдань не ввімкнено або якщо\n"
"    трапиться помилка."

#: builtins.c:810
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Запам’ятовує чи показує розміщення програм.\n"
"    \n"
"    Визначає та запам’ятовує повний шлях до кожної з вказаних програм. Якщо\n"
"    НАЗВИ не вказані, показує інформацію про збережені команди.\n"
"    \n"
"    Параметри:\n"
"      -d\tВилучити з кешу розміщення НАЗВ.\n"
"      -l\tПоказувати у форматі, що можна потім виконати.\n"
"      -p шлях\tвикористовувати ШЛЯХ як повний шлях до НАЗВИ.\n"
"      -r\tСпорожнити кеш.\n"
"      -t\tВивести збережені розташування НАЗВ, вказуючи перед розташуванням\n"
"    \t\tвідповідну НАЗВУ, якщо вказано декілька НАЗВ.\n"
"    Аргументи:\n"
"      НАЗВА\tКожна з НАЗВ шукається у $PATH та додається до списку збережених\n"
"    \t\tкоманд.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо НАЗВУ не вдалося знайти або якщо\n"
"    вказано помилковий параметр."

#: builtins.c:835
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is given."
msgstr ""
"Показує інформацію про вбудовані команди.\n"
"    \n"
"    Показує коротку довідку з вбудованих команд. Якщо вказано ШАБЛОН, надає\n"
"    детальну довідку з усіх команд, що відповідають цьому ШАБЛОНУ. Якщо його\n"
"    не вказано, друкує список пунктів довідки.\n"
"    \n"
"    Параметри:\n"
"      -d\tВивести короткий опис кожного з пунктів.\n"
"      -m\tПоказати довідку у форматі, подібному до man(1).\n"
"      -s\tВивести лише короткий опис синтаксису використання кожної з команд,\n"
"    \tщо відповідають ШАБЛОНУ\n"
"    \n"
"    Аргументи:\n"
"      ШАБЛОН\tШаблон, що визначає тему довідки.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало якщо ШАБЛОН не знайдено або якщо вказано\n"
"    помилковий параметр."

# WTF??? history list += history + history file ???
#: builtins.c:859
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"      -d start-end\tdelete the history entries beginning at position START\n"
"    \t\tthrough position END.\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used. If FILENAME is not supplied\n"
"    and HISTFILE is unset or null, the -a, -n, -r, and -w options have\n"
"    no effect and return success.\n"
"    \n"
"    The fc builtin also operates on the history list.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Показує чи змінює список попередніх команд.\n"
"    \n"
"    Показує список журналу команд з номерами рядків, вказуючи `*' перед кожним\n"
"    зміненим рядком. Якщо вказано аргумент N, показує лише N останніх рядків.\n"
"    \n"
"    Параметри:\n"
"      -c\tВилучити зі списку усі збережені команди.\n"
"      -d позиція\tВилучити рядок у ПОЗИЦІЇ (відносній). Відлік від'ємних значень\n"
"    \t\tпозиції ведеться від кінця списку журналу\n"
"      -d початок-кінець\tвилучити запису журналу, починаючи з позиції ПОЧАТОК\n"
"    \t\tдо позиції КІНЕЦЬ.\n"
"    \n"
"\n"
"    \n"
"      -a\tДодати записи з поточного сеансу до файла журналу.\n"
"      -n\tДодати записи, яких ще немає у списку з файла журналу, і\n"
"      \t\tдописати їх до файла журналу.\n"
"      -r\tПрочитати файл журналу та додати його вміст до кінця списку.\n"
"      -w\tЗаписати поточний журнал команд до файла журналу.\n"
"    \n"
"      -p\tЗробити розкриття журналу команд на кожному з АРГУМЕНТІВ та\n"
"    \tпоказати результат (без збереження у списку журналу команд).\n"
"      -s\tДодати АРГУМЕНТИ до списку журналу як один запис.\n"
"    \n"
"    Якщо вказаний ФАЙЛ, його буде використано як файл журналу команд. Інакше,\n"
"    якщо визначено $HISTFILE, береться її значення. Якщо ФАЙЛ не вказано,\n"
"    і не встановлено значення HISTFILE або значення є порожнім, параметри\n"
"    -a, -n, -r і -w не працюватимуть, а команда повертатиме значення\n"
"    успіху виконання.\n"
"    \n"
"    Крім того, вбудована команда fc працює зі списком журналу.\n"
"    \n"
"    Якщо змінна $HISTTIMEFORMAT має значення, відмінне від порожнього рядку,\n"
"    її буде використано як шаблон strftime(3) для показу часових позначок.\n"
"    Інакше часові позначки не виводяться.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо вказано вірні параметри та не виникло\n"
"    помилки під час виконання."

#: builtins.c:902
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Виводить стан завдань.\n"
"    \n"
"    Показує список активних завдань. ЗАВДАННЯ обмежує вивід цим завданням.\n"
"    Без параметрів показує стан усіх активних завдань.\n"
"    \n"
"    Параметри:\n"
"      -l\tДодатково виводити ідентифікатори процесів.\n"
"      -n\tПоказувати лише процеси, стан яких змінився з часу останнього\n"
"    \tзвідомлення.\n"
"      -p\tПоказувати лише ідентифікатори процесів.\n"
"      -r\tОбмежити вивід поточними завданнями.\n"
"      -s\tОбмежити вивід зупиненими завданнями.\n"
"    \n"
"    Якщо вказано -x, КОМАНДУ буде виконано після заміни усіх згадок про\n"
"    завдання у АРГУМЕНТАХ на ідентифікатори головних процесів відповідних\n"
"    завдань.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо вказано правильні параметри та не\n"
"    виникло помилки під час виконання. При використанні -x команда\n"
"    завершується зі статусом завершення КОМАНДИ."

#: builtins.c:929
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Вилучає завдання з поточної оболонки.\n"
"    \n"
"    Вилучає кожне з ЗАВДАНЬ з таблиці активних завдань. Якщо ЗАВДАННЯ не\n"
"    вказано, береться завдання, яке оболонка вважає поточним.\n"
"    \n"
"    Параметри:\n"
"      -a\tВилучити усі завдання, якщо ЗАВДАННЯ не вказані.\n"
"      -h\tПозначити ЗАВДАННЯ так, щоб вони не отримали SIGHUP, якщо оболонка\n"
"    \t\tотримає SIGHUP.\n"
"      -r\tВилучати лише поточні завдання.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо вказано неправильний параметр чи\n"
"    ЗАВДАННЯ."

#: builtins.c:948
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Надіслати сигнал до завдання.\n"
"    \n"
"    Надіслати процесу, вказаному за ідентифікатором процесу чи завдання\n"
"    сигнал, вказаний за його номером чи назвою. Якщо не вказано ані першого,\n"
"    ані другого, буде надіслано SIGTERM.\n"
"    \n"
"    Параметри:\n"
"      -s сигнал\tСИГНАЛ є назвою сигналу.\n"
"      -n сигнал\tСИГНАЛ є номером сигналу.\n"
"      -l\tПерелічити назви сигналів; якщо за -l ідуть іще аргументи, вони\n"
"    \t\tвважаються номерами сигналів, які треба показати.\n"
"      -L\tсинонім до -l\n"
"    \n"
"    Kill є вбудованою командою з двох причин: це дозволяє вказувати\n"
"    ідентифікатори завдань замість ідентифікаторів процесів та дозволяє\n"
"    вбивати процеси, навіть якщо ви вичерпали ліміт процесів.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо вказані правильні аргументи та не\n"
"    трапилося помилки під час виконання."

#: builtins.c:972
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Обчислює арифметичні вирази.\n"
"    \n"
"    Обчислює кожен АРГУМЕНТ як арифметичний вираз. Обчислення виконується у\n"
"    цілих числах фіксованої довжини без перевірки переповнення, але все ж\n"
"    ділення на 0 визначається і вважається помилкою. Нижченаведений список\n"
"    операторів згруповано за рівнями пріоритету. Їх перелічено у порядку\n"
"    спадання пріоритету.\n"
"    \n"
"    \tid++, id--\tпост-інкремент та пост-декремент змінної\n"
"    \t++id, --id\tпре-інкремент та пре-декремент змінної\n"
"    \t-, +\t\tунарний мінус та плюс\n"
"    \t!, ~\t\tлогічна та побітова інверсія\n"
"    \t**\t\tпіднесення до степеня\n"
"    \t*, /, %\t\tмноження, ділення, залишок\n"
"    \t+, -\t\tдодавання, віднімання\n"
"    \t<<, >>\t\tпобітовий зсув вправо та вліво\n"
"    \t<=, >=, <, >\tпорівняння\n"
"    \t==, !=\t\tрівність, нерівність\n"
"    \t&\t\tпобітове AND\n"
"    \t^\t\tпобітове XOR\n"
"    \t|\t\tпобітове OR\n"
"    \t&&\t\tлогічне AND\n"
"    \t||\t\tлогічне OR\n"
"    \tвираз ? вираз : вираз\n"
"    \t\t\tумовний оператор\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tприсвоєння\n"
"    \n"
"    Змінні оболонки можуть виступати операндами. Назву змінної буде замінено\n"
"    її значенням (приведеним до цілого числа фіксованої довжини) у виразі.\n"
"    Для цього не потрібно встановлювати властивість змінної `ціле число'.\n"
"    \n"
"    Оператори обчислюються за пріоритетами. Вкладені вирази у дужках\n"
"    обчислюються першими та можуть змінювати правила пріоритетів, наведені\n"
"    вище.\n"
"    \n"
"    Код завершення:\n"
"    Якщо результатом обчислення останнього АРГУМЕНТУ є 0, let повертає 1,\n"
"    інакше — 0."

#: builtins.c:1017
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as word\n"
"    delimiters. By default, the backslash character escapes delimiter characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -E\tuse Readline to obtain the line and use the bash default\n"
"    \t\tcompletion instead of Readline's default completion\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times out\n"
"    (in which case it's greater than 128), a variable assignment error occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Читає рядок зі стандартного вводу та розбиває його на поля.\n"
"    \n"
"    Зчитує один рядок зі стандартного вводу чи з ФАЙЛОВОГО-ДЕСКРИПТОРА, якщо\n"
"    вказано параметр -u. Рядок розбивається на поля по словах, перше слово\n"
"    призначується першій НАЗВІ, друге слово — другій НАЗВІ тощо, якщо\n"
"    залишаться непризначені слова, їх буде призначено останній НАЗВІ. Як\n"
"    роздільники полів розпізнаються символи, вказані у змінній $IFS.\n"
"    Типово, символ зворотної похилої риски екранує символи роздільника\n"
"    та розриву рядка.\n"
"    \n"
"    Якщо НАЗВ не вказано, рядок цілком буде збережено у змінній REPLY.\n"
"    \n"
"    Параметри:\n"
"      -a масив\tПризначити прочитані слова послідовним елементам МАСИВУ,\n"
"    \t\tпочинаючи з нульового.\n"
"      -d роздільник\tЧитати ввід доки не знайдеться символ РОЗДІЛЬНИК\n"
"    \t\t(замість кінця рядка, як звичайно).\n"
"      -e\t\tВикористовувати Readline для отримання рядка.\n"
"      -E\tВикористовувати Readline для отримання рядка і використовувати\n"
"    \t\tтипове доповнення оболонки замість типового доповнення Readline\n"
"      -i текст\tВказати початковий ТЕКСТ для Readline.\n"
"      -n кількість\tПрипинити після зчитування КІЛЬКОСТІ символів, замість\n"
"    \t\tтого, щоб чекати на кінець рядка.\n"
"      -N кількість\tПрипинити, лише після читання КІЛЬКОСТІ символів, якщо\n"
"    \t\tсеред них не виявиться символі кінця файла або не буде перевищено\n"
"    \t\tчас очікування, ігнорувати роздільники.\n"
"      -p запрошення\tВивести рядок ЗАПРОШЕННЯ (без переведення рядка в кінці)\n"
"    \t\tперед читанням.\n"
"      -r\t\tНе обробляти зворотню похилу риску для екранування символів.\n"
"      -s\t\tНе виводити отриманий ввід на термінал.\n"
"      -t ліміт-часу\tПрипинити читання та вийти з помилкою якщо за вказаний\n"
"    \t\tпроміжок часу (в секундах) не було прочитано рядок цілком. Значення\n"
"    \t\tзмінної TMOUT є стандартним значенням обмеження за часом. ЛІМІТ-ЧАСУ\n"
"    \t\tможе бути дробовим числом. Якщо ЛІМІТ-ЧАСУ 0, read завершується\n"
"    \t\tуспішно, лише якщо ввід вже наявний на вказаному файловому\n"
"    \t\tдескрипторі. Якщо перевищено термін очікування, код завершення буде\n"
"    \t\tбільшим за 128.\n"
"       -u файловий-дескриптор\tЧитати ввід з ФАЙЛОВОГО-ДЕСКРИПТОРУ замість\n"
"    \t\tстандартного вводу.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає помилку, якщо знайдено кінець файла, якщо вичерпано час\n"
"    очікування (значення, більше за 128), якщо сталася помилка під час\n"
"    встановлення значення змінної, або якщо із -u вказано неправильний файловий дескриптор."

#: builtins.c:1067
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Повертається з функції оболонки.\n"
"    \n"
"    Виходить з функції чи сценарію, виконаного за допомогою source зі вказаним\n"
"    кодом завершення N. Якщо N не вказане, return повертає статус останньої\n"
"    виконаної всередині сценарію чи функції команди.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає N, або помилку, якщо викликана не у функції чи сценарії."

#: builtins.c:1080
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    If -o is supplied with no option-name, set prints the current shell\n"
"    option settings. If +o is supplied with no option-name, set prints a\n"
"    series of set commands to recreate the current option settings.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Встановлює та скидає параметри оболонки та позиційні параметри.\n"
"    \n"
"    Змінює значення властивостей оболонки та позиційних параметрів чи показує\n"
"    назви та значення змінних оболонки.\n"
"    \n"
"    Параметри:\n"
"      -a  Експортувати змінні, які будуть змінюватися чи створюватися.\n"
"      -b  Сповіщати про припинення завдань негайно.\n"
"      -e  Завершити роботу, якщо одна з команд завершиться помилкою.\n"
"      -f  Вимкнути розкриття шаблонів назв файлів (globbing).\n"
"      -h  Запам’ятовувати розміщення команд по мірі використання.\n"
"      -k  Переносити усі аргументи-присвоєння до оточення команди, не лише ті,\n"
"          що йдуть перед назвою команди.\n"
"      -m  Ввімкнути контроль завдань.\n"
"      -n  Читати команди, але не виконувати їх.\n"
"      -o параметр\n"
"          Встановити параметр оболонки:\n"
"              allexport    те саме, що й -a\n"
"              braceexpand  те саме, що й -B\n"
"              emacs        використовувати подібний до emacs інтерфейс\n"
"                           редагування\n"
"              errexit      те саме, що й -e\n"
"              errtrace     те саме, що й -E\n"
"              functrace    те саме, що й -T\n"
"              hashall      те саме, що й -h\n"
"              histexpand   те саме, що й -H\n"
"              history      ввімкнути збереження журналу команд\n"
"              ignoreeof    не виходити з оболонки після зчитування кінця файла\n"
"              interactive-comments\n"
"                           дозволити коментарі у інтерактивній оболонці\n"
"              keyword      те саме, що й -k\n"
"              monitor      те саме, що й -m\n"
"              noclobber    те саме, що й -C\n"
"              noexec       те саме, що й -n\n"
"              noglob       те саме, що й -f\n"
"              nolog        наразі приймається, але ігнорується\n"
"              notify       те саме, що й -b\n"
"              nounset      те саме, що й -u\n"
"              onecmd       те саме, що й -t\n"
"              physical     те саме, що й -P\n"
"              pipefail     кодом завершення ланцюжка команд є код завершення\n"
"                           останньої команди, що завершилася невдало, або\n"
"                           нуль, якщо усі команди завершилися успішно\n"
"              posix        змінити поведінку bash у ситуаціях, де її поведінка\n"
"                           зазвичай відхиляється від стандарту Posix так, щоб\n"
"                           вона відповідала стандарту\n"
"              privileged   те саме, що й -p\n"
"              verbose      те саме, що й -v\n"
"              vi           використовувати подібний до vi інтерфейс\n"
"                           редагування рядку\n"
"              xtrace       те саме, що й -x\n"
"      -p  Ввімкнений, якщо дійсний та ефективний ідентифікатори користувача не\n"
"          збігаються. Вимикає обробку файла $ENV та імпортування функцій\n"
"          оболонки. Вимикання цього параметра встановлює ефективні\n"
"          ідентифікатори користувача та групи у реальні.\n"
"      -t  Завершити роботу після зчитування та виконання однієї команди.\n"
"      -u  Обробляти неозначені змінні як помилку під час їх підставляння.\n"
"      -v  Друкувати рядки вводу по мірі їх читання.\n"
"      -x  Друкувати команди та їх аргументи при їх виконанні.\n"
"      -B  Виконувати розкриття дужок.\n"
"      -C  Вмикання параметра забороняє перезапис наявних звичайних файлів\n"
"          переспрямуванням виводу.\n"
"      -E  Якщо ввімкнений, пастка ERR успадковується функціями оболонки.\n"
"      -H  Ввімкнути підставляння журналу за допомогою !. Цей параметр зазвичай\n"
"          ввімкнено у інтерактивних оболонках.\n"
"      -P  Не переходити за символічними посиланнями при запуску команд,\n"
"          таких як cd, яка змінює поточний каталог.\n"
"      -T  Якщо ввімкнений, пастки DEBUG і RETURN будуть успадковуватися функціями\n"
"          оболонки.\n"
"      --  Призначити всі аргументи, які ще не призначено до позиційних параметрів.\n"
"          Якщо всі аргументи вже призначено, позиційні параметри вважатимуться\n"
"          невстановленими.\n"
"      -   Призначити аргументи, що залишилися позиційним параметрам.\n"
"          Параметри -x та -v вимикаються.\n"
"    \n"
"    \n"
"    Якщо -o вказано без назви параметра, set виводить поточні параметри\n"
"    оболонки. Якщо +o вказано без назви параметра, set виводить\n"
"    послідовність команд set для відтворення поточних параметрів.\n"
"    \n"
"    Вимкнути параметр можна вказавши + замість -. Параметри можна змінювати\n"
"    й після запуску оболонки. Наразі ввімкнені параметри можна побачити у\n"
"    змінній $-. Залишкові аргументи вважаються позиційними параметрами\n"
"    та призначаються по порядку відповідно до $1 $2, .. $n. Якщо АРГУМЕНТИ не\n"
"    вказані, виводиться список усіх змінних оболонки.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо вказані правильні параметри."

#: builtins.c:1169
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Скидає значення та параметри змінних та функцій оболонки.\n"
"    \n"
"    Вилучає змінні чи функції, вказані за НАЗВАМИ.\n"
"    \n"
"    Параметри:\n"
"      -f\tНАЗВИ є функціями оболонки.\n"
"      -v\tНАЗВИ є змінними оболонки.\n"
"      -n\tНАЗВИ є посиланнями на назви, визначення самих змінних скасовується.\n"
"    \n"
"    Без параметрів, unset спочатку намагається скинути змінну, якщо це не\n"
"    вдасться, тоді функцію.\n"
"    \n"
"    Деякі змінні не можуть бути скинутими; див. `readonly'.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо вказано неправильний параметр чи НАЗВА\n"
"    доступна лише для читання."

#: builtins.c:1191
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables or functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Вмикає властивість експортування змінних оболонки.\n"
"    \n"
"    Позначає кожну з НАЗВ для експорту до середовища запущених надалі команд.\n"
"    Якщо вказане ЗНАЧЕННЯ, призначає ЗНАЧЕННЯ перед тим, як експортувати.\n"
"    \n"
"    Параметри:\n"
"      -f\tПрацювати з функціями оболонки.\n"
"      -n\tВимкнути властивість експортування для усіх НАЗВ.\n"
"      -p\tВивести список усіх експортованих змінних або функцій.\n"
"    \n"
"    Аргумент `--' вимикає подальший аналіз параметрів.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо вказано правильні параметри та НАЗВИ."

#: builtins.c:1210
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Робить змінні оболонки незмінними.\n"
"    \n"
"    Позначає кожну з НАЗВ як незмінну; після цього значення НАЗВИ не можуть\n"
"    бути змінені призначенням. Якщо вказане ЗНАЧЕННЯ, воно призначається, перш\n"
"    ніж змінну буде позначено незмінною.\n"
"    \n"
"    Параметри:\n"
"      -a\tПрацювати з індексованими масивами.\n"
"      -A\tПрацювати з асоціативними масивами.\n"
"      -f\tПрацювати з функціями оболонки.\n"
"      -p\tВивести список всіх незмінних змінних та функцій, залежно від\n"
"            того, чи вказано параметр -f.\n"
"    \n"
"    Аргумент `--' вимикає подальший аналіз параметрів.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо вказано правильні параметри та НАЗВИ."

#: builtins.c:1232
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Зсуває позиційні параметри.\n"
"    \n"
"    Перейменовує позиційні параметри $N+1,$N+2 ... у $1,$2 ... Якщо N не\n"
"    вказане, береться 1.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо N менше за нуль чи більше за $#."

#: builtins.c:1244 builtins.c:1260
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell. If the\n"
"    -p option is supplied, the PATH argument is treated as a colon-\n"
"    separated list of directories to search for FILENAME. If -p is not\n"
"    supplied, $PATH is searched to find FILENAME. If any ARGUMENTS are\n"
"    supplied, they become the positional parameters when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Виконує команди з файла у поточній оболонці.\n"
"    \n"
"    Читає та виконує команди з ФАЙЛА у поточній оболонці. Якщо вказано\n"
"    параметр -p, аргумент ШЛЯХ буде оброблено як список відокремлених\n"
"    двокрапками каталогів, де слід шукати ФАЙЛ. Якщо -p не вказано, пошук\n"
"    ФАЙЛА відбуватимуться на основі змінної $PATH. Якщо вказані АРГУМЕНТИ,\n"
"    вони стають позиційними параметрами при запуску ФАЙЛА.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає код завершення останньої команди, виконаної у ФАЙЛІ, або\n"
"    помилку, якщо ФАЙЛ не вдалося прочитати."

#: builtins.c:1277
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells and shells without job control cannot be\n"
"    suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell or job\n"
"    \t\tcontrol is not enabled.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Призупиняє виконання оболонки.\n"
"    \n"
"    Призупиняє виконання оболонки до отримання сигналу SIGCONT. Зазвичай,\n"
"    оболонки сеансу і оболонки без керування завданнями не можуть бути\n"
"    призупинені.\n"
"    \n"
"    Параметри:\n"
"      -f\tПризупинити, навіть якщо це оболонка сеансу або керування\n"
"    \t\tзавданнями не увімкнено.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо не ввімкнене керування завданнями чи\n"
"    якщо трапиться помилка."

#: builtins.c:1295
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Перевіряє умовний вираз.\n"
"    \n"
"    Завершується з кодом 0 (істинний) чи 1 (хибний), залежно від\n"
"    результату обчислення ВИРАЗУ. Вирази можуть бути унарними чи бінарними.\n"
"    Унарні вирази часто використовуються для визначення властивостей файлів.\n"
"    Також є оператори для рядків та для порівняння чисел.\n"
"    \n"
"    Файлові оператори:\n"
"    \n"
"      -a файл        Істинний, якщо файл існує.\n"
"      -b файл        Істинний, якщо файл є блоковим пристроєм.\n"
"      -c файл        Істинний, якщо файл є символьним пристроєм.\n"
"      -d файл        Істинний, якщо файл є каталогом.\n"
"      -e файл        Істинний, якщо файл існує.\n"
"      -f файл        Істинний, якщо файл існує та є звичайним файлом.\n"
"      -g файл        Істинний, якщо файл має встановлений біт `set-group-id'.\n"
"      -h файл        Істинний, якщо файл є символічним посиланням.\n"
"      -L файл        Істинний, якщо файл є символічним посиланням.\n"
"      -k файл        Істинний, якщо файл має встановленим біт `sticky'.\n"
"      -p файл        Істинний, якщо файл є іменованим каналом.\n"
"      -r файл        Істинний, якщо ви можете читати файл.\n"
"      -s файл        Істинний, якщо файл існує і не є порожнім.\n"
"      -S файл        Істинний, якщо файл є сокетом.\n"
"      -t дескриптор  Істинний, якщо дескриптор відкритий у терміналі.\n"
"      -u файл        Істинний, якщо файл має встановлений біт `set-user-id'.\n"
"      -w файл        Істинний, якщо ви можете записувати до файла.\n"
"      -x файл        Істинний, якщо ви можете виконати файл.\n"
"      -O файл        Істинний, якщо ви є власником файла.\n"
"      -G файл        Істинний, якщо ваша група є власником файла.\n"
"      -N файл        Істинний, якщо файл був змінений після останнього\n"
"                     читання\n"
"    \n"
"      файл1 -nt файл2  Істинний, якщо файл1 новіший за файл2 (за датою зміни).\n"
"    \n"
"      файл1 -ot файл2  Істинний, якщо файл1 старіший за файл2.\n"
"    \n"
"      файл1 -ef файл2  Істинний, якщо файл1 є жорстким посиланням на файл2.\n"
"    \n"
"    Оператори з рядками:\n"
"    \n"
"      -z рядок       Істинний, якщо рядок порожній.\n"
"    \n"
"      -n рядок\n"
"         рядок       Істинний, якщо рядок не порожній.\n"
"    \n"
"      рядок1 = рядок2\n"
"                     Істинний, якщо рядки однакові.\n"
"      рядок1 != рядок2\n"
"                     Істинний, якщо рядки не однакові.\n"
"      рядок1 < рядок2\n"
"                     Істинний, якщо при лексикографічному сортуванні рядок1\n"
"                     буде іти перед рядком\n"
"      рядок1 > рядок2\n"
"                     Істинний, якщо при лексикографічному сортуванні рядок1\n"
"                     ітиме після рядка2.\n"
"    \n"
"    Інші оператори:\n"
"    \n"
"      -o параметр    Істинний, якщо параметр оболонки ввімкнено.\n"
"      -v ЗМІННА\t Істинний, якщо встановлено змінну середовища ЗМІННА\n"
"      -R ЗМІННА\t Істинний, якщо встановлено змінну середовища ЗМІННА і ця змінна є посиланням на назву.\n"
"      ! вираз        Істинний, якщо вираз хибний.\n"
"      вираз1 -a вираз2  Істинний, якщо обидва вирази істинні.\n"
"      вираз1 -o вираз2  Істинний, якщо хоч один з виразів істинний.\n"
"    \n"
"      аргумент1 ОПЕРАТОР аргумент2\n"
"                     Арифметичне порівняння. ОПЕРАТОР може бути: -eq, -ne,\n"
"                     -lt, -le, -gt, чи -ge.\n"
"    \n"
"    Арифметичні бінарні оператори істинні, якщо аргумент1 рівний, не рівний,\n"
"    менший, менший чи рівний, більший, чи більший чи рівний аргументу2.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо ВИРАЗ істинний; невдало, якщо вказано\n"
"    помилковий аргумент чи ВИРАЗ хибний."

#: builtins.c:1377
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Перевіряє умовний вираз.\n"
"    \n"
"    Це синонім до вбудованої команди \"test\", але на відміну від неї останнім\n"
"    аргументом має бути `]'."

#: builtins.c:1386
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Показує час виконання процесу.\n"
"    \n"
"    Виводить збірний час виконання оболонки та всіх її нащадків на рівні\n"
"    користувача та на рівні системи.\n"
"    \n"
"    Код завершення:\n"
"    Команда завжди успішна."

#: builtins.c:1398
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives signals\n"
"    or other conditions.\n"
"    \n"
"    ACTION is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ACTION is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ACTION is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ACTION is executed on exit from the shell.\n"
"    If a SIGNAL_SPEC is DEBUG, ACTION is executed before every simple command\n"
"    and selected other commands. If a SIGNAL_SPEC is RETURN, ACTION is\n"
"    executed each time a shell function or a script run by the . or source\n"
"    builtins finishes executing.  A SIGNAL_SPEC of ERR means to execute ACTION\n"
"    each time a command's failure would cause the shell to exit when the -e\n"
"    option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands associated\n"
"    with each trapped signal in a form that may be reused as shell input to\n"
"    restore the same signal dispositions.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC in a\n"
"    \t\tform that may be reused as shell input; or for all trapped\n"
"    \t\tsignals if no arguments are supplied\n"
"      -P\tdisplay the trap commands associated with each SIGNAL_SPEC. At least\n"
"    \t\tone SIGNAL_SPEC must be supplied. -P and -p cannot be used\n"
"    \t\ttogether.\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is given."
msgstr ""
"Перехоплює сигнали чи інші події.\n"
"    \n"
"    Визначає та активує обробники для отриманих оболонкою сигналів чи інших\n"
"    подій.\n"
"    \n"
"    ДІЯ є командою, яку буде запущено оболонкою при отриманні\n"
"    СИГНАЛУ(ІВ). Якщо ДІЮ не вказано (а СИГНАЛ вказано) або вказано\n"
"    `-' як АРГУМЕНТ, кожен вказаний СИГНАЛ встановлюється у його\n"
"    початковий стан. Якщо ДІЯ є порожнім рядком, СИГНАЛ(И) буде\n"
"    ігноруватися оболонкою та запущеними з неї командами.\n"
"    \n"
"    Якщо СИГНАЛ є EXIT (0), ДІЮ буде виконано при виході з оболонки. Якщо\n"
"    СИГНАЛ є DEBUG, ДІЯ буде виконуватися перед кожною простою командою і\n"
"    вибраними іншими командами. Якщо СИГНАЛОМ є RETURN, ДІЮ буде виконано\n"
"    кожного разу, коли функцію або скрипт оболонки буде запущено . або\n"
"    завершиться виконання вбудованих функції source. СИГНАЛ ERR означає\n"
"    виконання ДІЇ кожного разу, коли аварія команди спричиняла б вихід з\n"
"    оболонки, якщо увімкнено параметр -e.\n"
"    \n"
"    Якщо ДІЮ взагалі не вказано, trap покаже список команд,\n"
"    призначених до сигналів.\n"
"    \n"
"    Параметри:\n"
"      -l\tвивести список сигналів та їх номерів.\n"
"      -p\tвивести команди trap, які пов'язано з кожним з СИГНАЛІВ, у\n"
"    \t\tформі, якою можна скористатися як вхідною для оболонки; або усіх\n"
"    \t\tзахоплених сигналів, якщо аргументів не вказано\n"
"      -P\tвивести команди trap, які пов'язано із кожним з СИГНАЛІВ. Має\n"
"    \t\tбути вказано принаймні один СИГНАЛ. -P і -p не можна використовувати\n"
"    \t\tодночасно.\n"
"    \n"
"    Кожен з СИГНАЛІВ має бути або назвою сигналу з <signal.h> або номером\n"
"    номером сигналу. Назви сигналів нечутливі до регістру літер, префікс SIG\n"
"    необов’язковий. Сигнал можна надіслати оболонці за допомогою\n"
"    \"kill -signal $$\".\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо вказані правильні параметри та СИГНАЛИ."

#: builtins.c:1441
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not found."
msgstr ""
"Показує тип команди.\n"
"    \n"
"    Для кожної НАЗВИ показує, як її буде оброблено як назву команди.\n"
"    \n"
"    Параметри:\n"
"      -a\tПоказати усі можливі інтерпретації НАЗВИ; якщо не вказано\n"
"    \tпараметр `-p', охоплює також псевдоніми, вбудовані команди, функції.\n"
"      -f\tНе шукати серед функцій оболонки.\n"
"      -P\tВиводити лише дискові команди, знайдені за PATH.\n"
"      -p\tВивести лише назву файла на диску, або нічого.\n"
"      -t\tВивести одне слово, що вказує тип — `alias', `keyword',\n"
"    \t`function', `builtin', `file' чи `', якщо НАЗВА, відповідно, є\n"
"    \tпсевдонімом, зарезервованим словом оболонки, функцією оболонки\n"
"    \tвбудованою командою оболонки, файлом на диску чи не знайдене.\n"
"    \n"
"    Аргументи:\n"
"      НАЗВА\tназва команди для інтерпретації.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо буде знайдено усі НАЗВИ; невдало, якщо\n"
"    хоч одне з них не вдасться знайти."

#: builtins.c:1472
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds;\n"
"    -p, which is in increments of 512 bytes; -R, which is in microseconds;\n"
"    -b, which is in bytes; and -e, -i, -k, -n, -q, -r, -u, -x, and -P,\n"
"    which accept unscaled values.\n"
"    \n"
"    When in posix mode, values supplied with -c and -f are in 512-byte\n"
"    increments.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Змінює обмеження ресурсів оболонки.\n"
"    \n"
"    Дозволяє керувати доступними оболонці та створеним нею процесам ресурсами,\n"
"    якщо це підтримується системою.\n"
"    \n"
"    Параметри:\n"
"      -S\tВикористовувати `soft' обмеження.\n"
"      -H\tВикористовувати `hard' обмеження.\n"
"      -a\tНадати звіт про поточні обмеження.\n"
"      -b\tРозмір буфера сокетів.\n"
"      -c\tМаксимальний розмір файла дампу пам’яті.\n"
"      -d\tМаксимальний розмір сегменту даних процесу.\n"
"      -e\tМаксимальний пріоритет виконання (`nice').\n"
"      -f\tМаксимальний розмір файлів, записаних оболонкою та нащадками.\n"
"      -i\tМаксимальна кількість сигналів, що очікують обробки.\n"
"      -k\tМаксимальна кількість k-черг, визначених для цього процесу\n"
"      -l\tМаксимальний розмір, який процес може заблокувати в пам’яті.\n"
"      -m\tМаксимальний розмір резидентного набору.\n"
"      -n\tМаксимальна кількість відкритих файлових дескрипторів.\n"
"      -p\tРозмір буфера каналу.\n"
"      -q\tМаксимальний розмір повідомлення у чергах повідомлень POSIX\n"
"    \t(у байтах).\n"
"      -r\tМаксимальний пріоритет виконання у реальному часі.\n"
"      -s\tМаксимальний розмір стеку.\n"
"      -t\tМаксимальний час використання процесору (у секундах).\n"
"      -u\tМаксимальна кількість процесів користувача.\n"
"      -v\tРозмір віртуальної пам’яті.\n"
"      -x\tМаксимальна кількість блокувань файлів.\n"
"      -R\tмаксимальний період роботи процесу реального часу до блокування\n"
"      -T\tмаксимальна кількість потоків обробки\n"
"    \n"
"    Перелік доступних параметрів залежить від програмної платформи.\n"
"    \n"
"    Якщо вказане ОБМЕЖЕННЯ, воно встановлюється як нове значення обмеження\n"
"    використання вказаного ресурсу; спеціальні значення ОБМЕЖЕННЯ `soft',\n"
"    `hard', та `unlimited' означають, відповідно, поточне м’яке обмеження,\n"
"    поточне жорстке обмеження та відсутність обмежень. Якщо ОБМЕЖЕННЯ не\n"
"    вказане, виводиться поточне значення вказаного ресурсу. Якщо не вказано\n"
"    жодного параметра, береться -f.\n"
"    \n"
"    Значення можуть змінюватися із кроком у 1024 байти, за винятком -t,\n"
"    що вказується в секундах, -p, яке має крок 512 байтів; -R, у мікросекундах;\n"
"    -b, у байтах; і -e, -i, -k, -n, -q, -r, -u, -x і -P,\n"
"    який приймає немасштабовані значення.\n"
"    \n"
"    У режимі posix значення, які вказано з -c і -f є 512-байтовими\n"
"    приростами.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо вказано неправильний параметр чи\n"
"    трапилася помилка під час виконання."

#: builtins.c:1527
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Встановлює чи показує маску дозволів для файлів.\n"
"    \n"
"    Встановлює МАСКУ дозволів для створених файлів. Якщо МАСКУ не вказано,\n"
"    виводить поточне значення маски.\n"
"    \n"
"    Якщо МАСКА починається з цифри, вона вважається вісімковим числом;\n"
"    якщо ні — вона має бути рядком символьного режиму, подібним до того, що\n"
"    використовується chmod(1).\n"
"    \n"
"    Параметри:\n"
"      -p\tЯкщо МАСКУ не вказано, вивести її у формі, придатній для виконання.\n"
"      -S\tВиводити у символьному режимі; інакше виводиться вісімкове число.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо вказано правильну МАСКУ та параметри."

#: builtins.c:1547
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Чекає завершення виконання завдання та повертає його код завершення.\n"
"    \n"
"    Очікує завершення роботи процесу, вказаного за ІДЕНТИФІКАТОРОМ, що може\n"
"    бути ідентифікатором процесу чи завдання, та повертає його код завершення.\n"
"    Якщо ІДЕНТИФІКАТОР не вказано, очікує завершення усіх активних дочірніх\n"
"    процесів та повертає код 0. Якщо ІДЕНТИФІКАТОР є завданням, очікує на\n"
"    завершення усіх процесів у ланцюжку завдання.\n"
"    \n"
"    Якщо вказано параметр -n, очікує на завершення якогось завдання зі списку\n"
"    ідентифікаторів або, якщо не вказано жодного ідентифікатора, на завершення\n"
"    наступного завдання і повертає його стан завершення.\n"
"    \n"
"    Якщо вказано параметр -p, процес або ідентифікатор завдання, для якого\n"
"    повернуто стан завершення, пов'язується із змінною VAR, назва якої\n"
"    визначається аргументом параметра. Спочатку змінна лишатиметься\n"
"    невизначеною. Це корисно, лише якщо вказано параметр -n.\n"
"    \n"
"    Якщо вказано параметр -f і увімкнено керування завданнями, очікує на\n"
"    вказаний ідентифікатор для переривання, замість очікування на зміну\n"
"    його стану.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає код завершення вказаного завдання; помилку, якщо вказано\n"
"    неправильні параметри чи ІДЕНТИФІКАТОР або якщо вказано -n і оболонка не\n"
"    має неочікуваних дочірніх процесів."

#: builtins.c:1578
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an invalid\n"
"    option is given."
msgstr ""
"Очікує на завершення роботи процесу та повертає його код завершення.\n"
"    \n"
"    Очікує, поки завершиться вказаний процес, та доповідає про його успішність.\n"
"    Якщо ІДЕНТИФІКАТОР-ПРОЦЕСУ не вказаний, очікує завершення усіх дочірніх\n"
"    процесів й завершується з кодом 0. ІДЕНТИФІКАТОР має бути ідентифікатором\n"
"    процесу.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає код завершення процесу з останнім вказаним ідентифікатором.\n"
"    Повертає код помилки, якщо вказано неправильний ІДЕНТИФІКАТОР чи параметр."

#: builtins.c:1593
msgid ""
"Execute PIPELINE, which can be a simple command, and negate PIPELINE's\n"
"    return status.\n"
"    \n"
"    Exit Status:\n"
"    The logical negation of PIPELINE's return status."
msgstr ""
"Виконати КАНАЛ_ОБРОБКИ, який може бути простою командою і інвертувати стан\n"
"    виходу КАНАЛ_ОБРОБКИ.\n"
"    \n"
"    Стан виходу:\n"
"    Логічне заперечення стану повернення КАНАЛ_ОБРОБКИ."

#: builtins.c:1603
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Виконати команди для кожного з пунктів списку.\n"
"    \n"
"    Цикл `for' виконує послідовність команд для кожного елементу списку.\n"
"    Якщо `in СЛОВА ...;' не вказано, тоді береться `in \"$@\"'. НАЗВА\n"
"    послідовно встановлюється у кожне зі СЛІВ, потім виконуються КОМАНДИ.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає код завершення останньої виконаної команди."

#: builtins.c:1617
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Арифметичний цикл.\n"
"    \n"
"    Те ж саме, що й\n"
"    \t(( ВИРАЗ1 ))\n"
"    \twhile (( ВИРАЗ2 )); do\n"
"    \t\tКОМАНДИ\n"
"    \t\t(( ВИРАЗ3 ))\n"
"    \tdone\n"
"    ВИРАЗИ мають бути арифметичними виразами. Якщо будь-який з них не\n"
"    вказаний, цикл поводиться, як ніби його результатом є 1.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає код завершення останньої виконаної команди."

#: builtins.c:1635
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Пропонує вибрати слово та виконує відповідні команди.\n"
"    \n"
"    СЛОВА розгортаються, утворюючи список слів. Отриманий список слів\n"
"    виводиться пронумерованим до стандартного виводу помилок. Якщо `in СЛОВА'\n"
"    не вказано, береться `in \"$@\"'. Тоді виводиться запрошення PS3 та зі\n"
"    стандартного вводу зчитується рядок. Якщо цей рядок є числом, що вказує\n"
"    номер одного зі слів, НАЗВА встановлюється у це слово. Якщо рядок порожній,\n"
"    СЛОВА та запрошення виводяться знов. Якщо прочитано кінець файла, команда\n"
"    завершується. Якщо рядок містить щось інше, НАЗВІ призначається порожній\n"
"    рядок. Прочитаний рядок зберігається у змінній REPLY. Після кожного\n"
"    зчитування виконуються КОМАНДИ. Команда продовжує виконання доки не\n"
"    буде викликано команду break.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає код завершення останньої виконаної команди."

#: builtins.c:1656
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Доповідає про час виконання ланцюжка команд.\n"
"    \n"
"    Виконує ЛАНЦЮЖОК та, по його завершенні, друкує звіт про час процесора,\n"
"    витрачений користувачем, системою та сумарно на виконання ЛАНЦЮЖКА.\n"
"    \n"
"    Параметри:\n"
"      -p\tДрукує звіт у форматі, що відповідає стандарту POSIX.\n"
"    \n"
"    Час виводиться у форматі, вказаному у змінній TIMEFORMAT.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає код завершення ЛАНЦЮЖКА-КОМАНД."

#: builtins.c:1673
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Вибірково виконує команди відповідно до шаблону.\n"
"    \n"
"    Вибірково виконує КОМАНДИ, залежно від відповідності СЛОВА ШАБЛОНУ.\n"
"    Декілька шаблонів можуть бути вказані через `|'.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає код завершення останньої виконаної команди."

#: builtins.c:1685
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of the\n"
"    entire construct is the exit status of the last command executed, or zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Виконує команди відповідно до умови.\n"
"    \n"
"    КОМАНДИ з `if КОМАНДИ' виконуються, і якщо їх код завершення нульовий,\n"
"    виконуються КОМАНДИ з `then КОМАНДИ'. Інакше в свою чергу виконуються\n"
"    команди з `elif КОМАНДИ', і якщо їх код завершення нульовий, виконуються\n"
"    КОМАНДИ з відповідного `then КОМАНДИ'. Інакше виконуються КОМАНДИ з\n"
"    `else КОМАНДИ'. Блоки elif та else не обов’язкові.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає код завершення останньої виконаної команди або нуль,\n"
"    якщо жодна з перевірених умов не була істинною."

#: builtins.c:1702
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Циклічно виконує команди поки виконується умова.\n"
"    \n"
"    Виконуватиме КОМАНДИ-2, поки остання команда з КОМАНД\n"
"    не завершиться невдало.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає код завершення останньої виконаної команди."

#: builtins.c:1714
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Виконує команди доки умову не буде виконано.\n"
"    \n"
"    Виконуватиме КОМАНДИ-2, поки остання команда з КОМАНД\n"
"    не завершиться успішно.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає код завершення останньої виконаної команди."

# WTF? How can it return exit code of _asynchronous_ process...
#: builtins.c:1726
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Створює співпроцес з назвою НАЗВА.\n"
"    \n"
"    Починає асинхронне виконання КОМАНДИ, під’єднавши її стандартний ввід та\n"
"    вивід через канали до файлових дескрипторів, які присвоюються елементам 0\n"
"    та 1 змінної-масиву НАЗВА.\n"
"    Стандартна назва змінної — \"COPROC\".\n"
"    \n"
"    Код завершення:\n"
"    Команда coproc повертає стан виходу 0."

#: builtins.c:1740
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Описує функцію оболонки.\n"
"    \n"
"    Створює функцію оболонки з назвою НАЗВА. Функція запускається як звичайна\n"
"    команда з назвою НАЗВА та послідовно виконує КОМАНДИ. Аргументи до команди\n"
"    призначаються на час виконання змінним $1...$n, а назва функції — змінній\n"
"    $FUNCNAME.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо НАЗВА є незмінною."

#: builtins.c:1754
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Групує команди в один блок.\n"
"    \n"
"    Виконує згрупований набір команд. Це один з методів перенаправлення виводу\n"
"    групи команд.\n"
"    \n"
"    Код завершення:\n"
"    Конструкція повертає код завершення останньої виконаної команди."

#: builtins.c:1766
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Продовжує виконання завдання на передньому плані.\n"
"    \n"
"    Продовжує на передньому плані виконання призупиненого чи фонового\n"
"    завдання, як це робить команда `fg'. ЗАВДАННЯ може бути назвою чи номером\n"
"    завдання. Якщо після ЗАВДАННЯ вказано `&', завдання продовжує виконання у\n"
"    фоні, тобто команда має ефект команди `bg'.\n"
"    \n"
"    Код завершення:\n"
"    Команда повертає статус продовженого завдання."

#: builtins.c:1781
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Обчислює арифметичний вираз.\n"
"    \n"
"    Обчислює ВИРАЗ відповідно до правил арифметичного розкриття. Те ж саме,\n"
"    що й «let \"ВИРАЗ\"».\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо результат обчислення ненульовий."

#: builtins.c:1793
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries used\n"
"    by the `test' builtin, and may be combined using the following operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Виконує умовну команду.\n"
"    \n"
"    Повертає статус 0 чи 1, в залежності від результату обчислення умовного\n"
"    ВИРАЗУ. Вирази складаються з тих самих складових, що використовуються у\n"
"    вбудованій команді `test', але можуть також комбінуватися за допомогою:\n"
"    \n"
"      ( ВИРАЗ )\t\tПовертає значення ВИРАЗУ.\n"
"      ! ВИРАЗ\t\tІстинний, якщо ВИРАЗ хибний.\n"
"      ВИРАЗ1 && ВИРАЗ2\tІстинний, якщо обидва ВИРАЗИ істинні.\n"
"      ВИРАЗ1 || ВИРАЗ2\tІстинний, якщо хоч один з ВИРАЗІВ істинний.\n"
"    \n"
"    Якщо застосовуються оператори `==' та `!=', рядок з правої сторони\n"
"    вважається шаблоном, й проводиться перевірка на відповідність цьому\n"
"    шаблону. При застосуванні `=~' рядок зліва вважається регулярним\n"
"    виразом, відносно якого перевіряється правий рядок.\n"
"    \n"
"    Оператори && та || не обчислюють ВИРАЗ2, якщо ВИРАЗУ1 достатньо для\n"
"    визначення результату.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо ВИРАЗ істинний."

#: builtins.c:1819
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Загальні назви змінних оболонки та їхнє використання.\n"
"    \n"
"    BASH_VERSION\tІнформація щодо версії Bash.\n"
"    CDPATH\tРозділений двокрапкою список каталогів, у яких оболонка буде\n"
"    \t\tшукати каталоги, вказані команді `cd'.\n"
"    GLOBIGNORE\tРозділений двокрапкою список шаблонів назв файлів, які будуть\n"
"    \t\tігноруватися під час розкриття шляхів.\n"
"    HISTFILE\tНазва файла, де зберігається історія команд.\n"
"    HISTFILESIZE\tНайбільша дозволена кількість записів у файлі журналу.\n"
"    HISTSIZE\tНайбільша кількість записів, які може використовувати\n"
"    \t\tпоточна оболонка.\n"
"    HOME\tПовний шлях до вашої домівки.\n"
"    HOSTNAME\tНазва поточної машини.\n"
"    HOSTTYPE\tТип процесора, на якому виконується оболонка.\n"
"    IGNOREEOF\tВизначає реакцію оболонки на символ кінця файла на вводі.\n"
"    \t\tЯкщо змінна визначена, її значення є кількістю таких символів,\n"
"    \t\tщо можуть бути отримані під ряд й бути проігнорованими. Звичайне\n"
"    \t\tзначення — 10. Якщо змінна не визначена, символ кінця файла\n"
"    \t\tозначатиме кінець вводу.\n"
"    MACHTYPE\tРядок, що описує поточну систему, на якій виконується Bash.\n"
"    MAILCHECK\tВизначає частоту перевірки пошти оболонкою.\n"
"    MAILPATH\tРозділений двокрапкою список файлів, які оболонка буде\n"
"    \t\tперевіряти на наявність нової пошти.\n"
"    OSTYPE\tВаріант Unix, на якому виконується оболонка.\n"
"    PATH\tРозділений двокрапкою список каталогів, де оболонка шукатиме\n"
"    \t\tвиконувані файли команд.\n"
"    PROMPT_COMMAND\tКоманда, яку оболонка буде виконувати перш ніж вивести\n"
"    \t\tосновне запрошення вводу.\n"
"    PS1\t\tРядок основного запрошення вводу.\n"
"    PS2\t\tРядок вторинного запрошення вводу.\n"
"    PWD\t\tПовний шлях до поточного каталогу.\n"
"    SHELLOPTS\tРозділений двокрапкою список увімкнених параметрів оболонки.\n"
"    TERM\tТип поточного термінала.\n"
"    TIMEFORMAT\tФормат виводу часу командою `time'.\n"
"    auto_resume\tЯкщо встановлена, введені команди, що складаються з\n"
"    \t\tодного слова, спочатку будуть шукатися у списку поточних\n"
"    \t\tпризупинених завдань. Якщо таке завдання буде знайдене, йому буде\n"
"    \t\tнадано пріоритет. Значення цієї змінної `exact' означає,\n"
"    \t\tщо слово має точно відповідати команді у списку завдань. Значення\n"
"    \t\t`substring' означає, що слово має міститися у команді завдання.\n"
"    \t\tБудь-яке інше значення означає, що команда завдання має\n"
"    \t\tпочинатися з вказаного слова.\n"
"    histchars\tСимволи, що використовуються для розкриття журналу та\n"
"    \t\tшвидкої заміни. Перший символ є символом підставляння журналу,\n"
"    \t\tзазвичай це `!'.  Другий — символ «швидкої заміни», зазичай `^'.\n"
"    \t\tТретій — символ «коментаря журналу», зазвичай це `#'.\n"
"    HISTIGNORE\tРозділений двокрапкою список шаблонів, що використовуються\n"
"    \t\tпри визначенні, чи зберігати команду у списку журналу.\n"

#: builtins.c:1876
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Додає каталоги до списку збережених каталогів.\n"
"    \n"
"    Додає каталог на вершину стеку каталогів, чи циклічно обертає\n"
"    стек, встановлюючи поточний робочий каталог відповідно до його нової\n"
"    вершини. Без аргументів міняє місцями дві найвищих каталоги.\n"
"    \n"
"    Параметри:\n"
"      -n\tНе робити звичайного переходу у новий каталог при додаванні\n"
"    \t\tкаталогів до стеку, проводити операції лише над стеком.\n"
"    \n"
"    Аргументи:\n"
"      +N\tЦиклічно обертає стек так, щоб N-ний каталог, рахуючи\n"
"    \t\tзліва (починаючи з нуля) у списку, що виводиться командою `dirs'\n"
"    \t\tопинилася на вершині стеку.\n"
"    \n"
"      -N\tЦиклічно обертає стек так, щоб N-ний каталог, рахуючи\n"
"    \t\tз кінця (починаючи з нуля) у списку, що виводиться командою `dirs'\n"
"    \t\tопинився на вершині стеку.\n"
"    \n"
"      КАТАЛОГ\tДодає КАТАЛОГ на вершину стеку і робить його поточним\n"
"    \t\t\tробочим каталогом.\n"
"    \n"
"    Вбудована команда `dirs' показує стек каталогів.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо вказаний неправильний аргумент чи\n"
"    якщо не вдалося змінити поточну каталог."

#: builtins.c:1910
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Вилучає каталоги зі списку збережених каталогів.\n"
"    \n"
"    Вилучає каталоги зі стеку збережених каталогів. Якщо аргументи не\n"
"    вказані, вилучає верхній каталог стеку і змінює поточний каталог\n"
"    відповідно до нової вершини стеку.\n"
"    \n"
"    Параметри:\n"
"      -n\tНе виконувати звичайного переходу до нового каталогу при вилученні\n"
"    \t\tкаталогів зі стеку, проводити операції лише над стеком.\n"
"    \n"
"    Аргументи:\n"
"      +N\tВилучає N-ний зліва каталог у списку, що показується командою\n"
"    \t\t`dirs' (відлік починається з нуля). Приклад: `popd +0' вилучає\n"
"    \t\tперший каталог, `popd +1' — другий.\n"
"    \n"
"      -N\tВилучає N-ний з кінця каталог у списку, що показується\n"
"    \t\tкомандою `dirs' (відлік починається з нуля). Приклад: `popd -0'\n"
"    \t\tвилучає останній каталог, `popd -1' — передостанній.\n"
"    \n"
"    Вбудована команда `dirs' показує список збережених каталогів.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо вказано помилковий аргумент чи якщо\n"
"    не вдалося змінити поточний каталог."

#: builtins.c:1940
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Показує список збережених каталогів.\n"
"    \n"
"    Показує список збережених каталогів. Каталоги додаються до цього списку\n"
"    командою `pushd'; ви можете повернутися назад по цьому списку за допомогою\n"
"    команди `popd'.\n"
"    \n"
"    Параметри:\n"
"      -c\tСпорожнити список каталогів, вилучивши усі його елементи.\n"
"      -l\tНе використовувати ~ при виводі каталогів, що знаходяться\n"
"    \t\tусередині вашої домівки.\n"
"      -p\tВиводити каталоги по одній на рядок.\n"
"      -v\tВиводити каталоги по одній на рядок із вказанням позиції у\n"
"    \t\tсписку.\n"
"    \n"
"    Аргументи:\n"
"      +N\tПоказує N-ний зліва каталог у списку, що виводиться командою\n"
"    \t\tdirs без аргументів, відлік починається з нуля.\n"
"    \n"
"      -N\tПоказує N-ний з кінця каталог у списку, що виводиться\n"
"    \t\tкомандою dirs без аргументів, відлік починається з нуля.    \n"
"    Код завершення:\n"
"    Команда завершується невдало, якщо вказано неправильний параметр чи якщо\n"
"    трапиться помилка."

#: builtins.c:1971
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Встановлює та скидає параметри оболонки.\n"
"    \n"
"    Змінює значення ПАРАМЕТРІВ. Якщо аргументи ПАРАМЕТРИ не вказані, виводить\n"
"    список усіх вказаних параметрів оболонки. Якщо ж параметрів не вказано,\n"
"    виводить список усіх параметрів, вказуючи, чи параметр ввімкнений, чи ні.\n"
"    \n"
"    Параметри:\n"
"      -o\tПриймати лише ПАРАМЕТРИ, з якими працює `set -o'.\n"
"      -p\tВивести список параметрів оболонки та їх поточний стан.\n"
"      -q\tНе виводити нічого.\n"
"      -s\tВвімкнути (встановити) кожен з ПАРАМЕТРІВ.\n"
"      -u\tВимкнути (скинути) кожен з ПАРАМЕТРІВ.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо ПАРАМЕТР ввімкнено; невдало, якщо\n"
"    вказано неправильні параметри чи ПАРАМЕТР вимкнено."

#: builtins.c:1992
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: plain\n"
"    characters, which are simply copied to standard output; character escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format characters csndiouxXeEfFgGaA described\n"
"    in printf(3), printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or assignment\n"
"    error occurs."
msgstr ""
"Форматує та виводить аргументи відповідно до шаблону ФОРМАТ.\n"
"    \n"
"    Параметри:\n"
"      -v змінна\tПризначити результат змінній оболонки, замість\n"
"    \t\tвиведення його до стандартного виводу.\n"
"    \n"
"    ШАБЛОН складається з символів, які можуть належати до трьох типів:\n"
"    звичайні символи, які просто копіюються у вивід; спеціальні\n"
"    послідовності, які інтерпретуються, а потім копіюються у вивід; та\n"
"    вказівки форматування, замість кожної з яких підставляється відповідний\n"
"    аргумент.\n"
"    \n"
"    Окрім стандартних вказівок форматування csndiouxXeEfFgGaA, описаних у printf(3),\n"
"    printf також розуміє:\n"
"    \n"
"      %b\tІнтерпретувати спеціальні послідовності (що починаються зі\n"
"    \t\tзворотної похилої риски) у відповідному аргументі.\n"
"      %q\tВзяти аргумент в лапки так, щоб його можна було використати як\n"
"    \t\tввід оболонки\n"
"      %Q\tподібна до %q, але буде застосовано довільну точність до аргументу\n"
"    \t\tбез лапок до застосування лапок\n"
"       %(формат)T – вивести рядок дати і часу з використанням ФОРМАТУ\n"
"            для форматування даних strftime(3)\n"
"    \n"
"    Визначене форматування використовується так, щоб було оброблено усі аргументи.\n"
"    Якщо аргументів виявиться менше за кількість визначених форматів, для зайвих\n"
"    специфікаторів форматів буде використано нульові значення або порожні рядки,\n"
"    залежно від типу форматування.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало лише якщо вказано неправильний параметр або\n"
"    якщо трапиться помилка запису чи присвоєння."

#: builtins.c:2028
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no options\n"
"    or NAMEs are supplied, display existing completion specifications in a way\n"
"    that allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Вказує, як буде завершувати аргументи readline.\n"
"    \n"
"    Визначає як завершувати аргументи для НАЗВ. Якщо параметрів або НАЗВ\n"
"    не вказано,\n"
"    буде виведено поточні вказівки завершення аргументів у формі,\n"
"    придатній для подальшого виконання.\n"
"    \n"
"    Параметри:\n"
"      -p\tВивести вказівки доповнення у формі, придатній до виконання.\n"
"      -r\tВилучити вказівки доповнення аргументів для НАЗВ (або, якщо\n"
"    \t\tНАЗВ не вказано, усі вказівки завершення).\n"
"      -D\tзастосувати доповнення та дії як типові для команд\n"
"    \tбез визначених вказівок щодо доповнення.\n"
"      -E\tзастосувати доповнення та дії до «порожніх» команд, спроби --\n"
"    \tзавершення на порожньому рядку.\n"
"      -I\tзастосовувати доповнення та дій до початкового слова\n"
"    \t\t(зазвичай, команди)\n"
"    \n"
"    Якщо виконується спроба доповнення, дії виконуються у порядку, в якому\n"
"    вказані наведені вище параметри у верхньому регістрі. Якщо вказано\n"
"    декілька параметрів, параметр -D має пріоритет над параметром -E,\n"
"    а обидва ці параметри мають пріоритет над параметром -I.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо вказано правильні параметри та не\n"
"    трапиться помилки під час виконання."

#: builtins.c:2058
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is present, generate matches\n"
"    against WORD.\n"
"    \n"
"    If the -V option is supplied, store the possible completions in the indexed\n"
"    array VARNAME instead of printing them to the standard output.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Показати можливі завершення залежно від параметрів.\n"
"    \n"
"    Команда призначена для використання зсередини функції для генерації\n"
"    можливих завершень. Якщо вказано необов’язковий аргумент СЛОВО,\n"
"    генеруються завершення, що відповідають цьому слову.\n"
"    \n"
"    Якщо вказано параметр -V, можливі завершення зберігатимуться у\n"
"    індексованому масиві ЗМІННА, а не виводитимуться до стандартного виведення.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо вказано правильні параметри і не\n"
"    трапиться помилки під час виконання."

#: builtins.c:2076
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, print\n"
"    the completion options for each NAME or the current completion specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Змінює чи показує параметри завершення аргументів.\n"
"    \n"
"    Змінює параметри завершення аргументів для НАЗВ (якщо НАЗВИ не вказано,\n"
"    для завершення, що наразі виконується). Якщо ПАРАМЕТРИ не вказані,\n"
"    виводить параметри завершення для кожної з НАЗВ (чи завершення, що\n"
"    наразі виконується).\n"
"    \n"
"    Параметри:\n"
"    \t-o параметр\tУвімкнути параметр завершення для всіх НАЗВ.\n"
"    \t-D\t\tЗмінити параметри для доповнення \"типових\" команд\n"
"    \t-E\t\tЗмінити параметри для доповнення \"порожніх\" команд\n"
"    \t-I\t\tЗмінити параметри для доповнення за початковим словом\n"
"    \n"
"    Параметри можна вимикати, використовуючи `+o' замість `-o'.\n"
"    \n"
"    Аргументи:\n"
"    \n"
"    Кожна з НАЗВ відповідає команді, для якої попередньо має бути вказано,\n"
"    як завершувати її аргументи за допомогою вбудованої команди `complete'.\n"
"    Якщо НАЗВ не вказано, compopt має виконуватися усередині функції, що\n"
"    генерує список завершень, тоді змінюються параметрі вказівки завершень,\n"
"    що відповідає цій функції.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується успішно, якщо вказано правильні параметри та\n"
"    вказівки завершень для НАЗВ існують."

#: builtins.c:2107
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly or\n"
"    not an indexed array."
msgstr ""
"Читає рядки зі стандартного вводу й заносить їх до масиву.\n"
"    \n"
"    Читає рядки зі стандартного вводу чи з ФАЙЛОВОГО-ДЕСКРИПТОРА, якщо вказано\n"
"    параметр -u, і вставляє їх до вказаної змінної-масиву. Якщо назву змінної\n"
"    не вказано, використовується змінна MAPFILE.\n"
"    \n"
"    Параметри:\n"
"      -d роздільник\tВикористати для поділу на рядки вказаний роздільник, а не\n"
"         символ розриву рядка\n"
"      -n кількість\tПрочитати вказану кількість рядків. Нуль означає\n"
"    \t\t\t«без обмежень».\n"
"      -O початок\tПочати вставляти до масиву з вказаного\n"
"    \t\t\tелемента масиву. Зазвичай відлік починається з нуля.\n"
"      -s кількість\tПропустити вказану кількість рядків на початку\n"
"    \t\t\tфайла.\n"
"      -t\t\tПрибирати символ переведення рядку в кінці прочитаних\n"
"    \t\t\tз файла рядків.\n"
"      -u дескриптор\tЧитати рядки з вказаного дескриптора замість\n"
"    \t\t\tстандартного вводу\n"
"      -C обробник\tВиконувати вказаний обробник після прочитання рядка.\n"
"      -c крок\t\tВикликати обробник лише після того, як буде прочитано\n"
"    \t\t\tвказану кількість рядків.\n"
"    \n"
"    Аргументи:\n"
"      МАСИВ\t\tНазва змінної-масиву для збереження даних з файла.\n"
"    \n"
"    Якщо вказано лише -C, без -c, обробник викликатиметься із кроком 5000.\n"
"    Обробник викликається із параметром, що вказує наступний елемент масиву,\n"
"    якому буде призначено значення.\n"
"    \n"
"    Якщо початковий елемент не вказано, mapfile спорожнить МАСИВ, перш ніж\n"
"    починати присвоєння.\n"
"    \n"
"    Код завершення:\n"
"    Команда завершується невдало лише якщо вказано неправильний параметр або\n"
"    якщо МАСИВ є незмінним."

#: builtins.c:2143
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Читає рядки з файла до масиву.\n"
"    \n"
"    Синонім до `mapfile'."

#~ msgid ""
#~ "Returns the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
#~ "    \"$line $subroutine $filename\"; this extra information can be used to\n"
#~ "    provide a stack trace.\n"
#~ "    \n"
#~ "    The value of EXPR indicates how many call frames to go back before the\n"
#~ "    current one; the top frame is frame 0."
#~ msgstr ""
#~ "Повертає контекст виконання поточної підпрограми.\n"
#~ "    \n"
#~ "    Якщо ВИРАЗ не вказано, виводить \"$line $filename\". Інакше виводить\n"
#~ "    \"$line $subroutine $filename\"; цю додаткову інформацію можна\n"
#~ "    використовувати для трасування стеку.\n"
#~ "    \n"
#~ "    Значення ВИРАЗУ визначає на скільки рівнів викликів піднятися від\n"
#~ "    поточного; поточний рівень є нульовим."

#, c-format
#~ msgid "%s: cannot open: %s"
#~ msgstr "%s: не вдалося відкрити: %s"

#, c-format
#~ msgid "%s: inlib failed"
#~ msgstr "%s: помилка inlib"

#, c-format
#~ msgid "warning: %s: %s"
#~ msgstr "попередження: %s: %s"

#, c-format
#~ msgid "%s: %s"
#~ msgstr "%s: %s"

#, c-format
#~ msgid "%s: cannot execute binary file: %s"
#~ msgstr "%s: не вдалося виконати бінарний файл: %s"

#, c-format
#~ msgid "setlocale: LC_ALL: cannot change locale (%s)"
#~ msgstr "setlocale: LC_ALL: не вдалося змінити локаль (%s)"

#, c-format
#~ msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
#~ msgstr "setlocale: LC_ALL: не вдалося змінити локаль (%s): %s"

#, c-format
#~ msgid "setlocale: %s: cannot change locale (%s): %s"
#~ msgstr "setlocale: %s: не вдалося змінити локаль (%s): %s"

#~ msgid "%s: invalid associative array key"
#~ msgstr "%s: неправильний ключ асоціативного масиву"

#~ msgid ""
#~ "Returns the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns "
#~ msgstr ""
#~ "Повертає контекст поточної підпрограми.\n"
#~ "    \n"
#~ "    Якщо EXPR не вказано, повертає "

#~ msgid "add_process: process %5ld (%s) in the_pipeline"
#~ msgstr "add_process: процес %5ld (%s) у the_pipeline"

#~ msgid "Unknown Signal #"
#~ msgstr "Невідомий сигнал №"

#~ msgid "Copyright (C) 2018 Free Software Foundation, Inc."
#~ msgstr "© Free Software Foundation, Inc., 2018"

#~ msgid "Copyright (C) 2014 Free Software Foundation, Inc."
#~ msgstr "© Free Software Foundation, Inc., 2014"

#~ msgid ":"
#~ msgstr ":"

#~ msgid "true"
#~ msgstr "true"

#~ msgid "false"
#~ msgstr "false"

#~ msgid "times"
#~ msgstr "times"

#~ msgid "Copyright (C) 2009 Free Software Foundation, Inc.\n"
#~ msgstr "© Free Software Foundation, Inc., 2009\n"

#~ msgid "License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>\n"
#~ msgstr "Ліцензія GPLv2+: GNU GPL версія 2 чи новіша <http://gnu.org/licenses/gpl.html>\n"

#~ msgid "xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr "xrealloc: не вдається змінити розмір виділеного блоку до %lu байтів (виділено %lu байтів)"

#~ msgid "xrealloc: cannot allocate %lu bytes"
#~ msgstr "xrealloc: не вдається виділити %lu байтів"

#~ msgid "xrealloc: %s:%d: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr "xrealloc: %s:%d: не вдається змінити розмір виділеного блоку до %lu байтів (виділено %lu байтів)"
