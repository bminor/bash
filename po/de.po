# qerman language file for GNU Bash 5.3-rc2
# Copyright (C) 2025 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Roland Illig <roland.illig@gmx.de> 2019
# Nils Naumann <nau@gmx.net>, 1996-2025.
#
msgid ""
msgstr ""
"Project-Id-Version: bash 5.3-rc2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-22 09:37-0400\n"
"PO-Revision-Date: 2025-06-07 21:16+0200\n"
"Last-Translator: Nils Naumann <nau@gmx.net>\n"
"Language-Team: German <translation-team-de@lists.sourceforge.net>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"

#: arrayfunc.c:63
msgid "bad array subscript"
msgstr "Falscher Feldindex."

#: arrayfunc.c:466 builtins/declare.def:748 variables.c:2196 variables.c:2225
#: variables.c:3099
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: Entferne das Nameref Attribut."

#: arrayfunc.c:493 builtins/declare.def:920
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: Das indizierte Array kann in kein assoziatives Array umgewandelt werden."

#: arrayfunc.c:789
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: Das Zuweisen auf einen nicht-numerischen Index ist nicht möglich."

#: arrayfunc.c:841
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: Ein Feldindex wird zum Zuweisen eines assoziativen Arrays benötigt."

#: bashhist.c:464
msgid "cannot create"
msgstr "Kann nicht erstellen"

#: bashline.c:4642
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: Kann nicht die Tastenzuordnung für das Kommando finden."

#: bashline.c:4813
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr " %s: Das erste Zeichen ist nicht `\"'"

#: bashline.c:4842
#, c-format
msgid "no closing `%c' in %s"
msgstr "fehlende schließende `%c' in %s."

#: bashline.c:4873
#, c-format
msgid "%s: missing separator"
msgstr "%s: Fehlendes Trennzeichen"

#: bashline.c:4920
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "»%s«: Kommandozurdnung kann nicht aufgehoben werden. "

#: braces.c:340
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "Klammererweiterung: Konnte keinen Speicher für %s zuweisen."

#: braces.c:403
#, c-format
msgid "brace expansion: failed to allocate memory for %s elements"
msgstr "Klammererweiterung: Konnte keinen Speicher für %s Elemente zuweisen."

#: braces.c:462
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "Klammererweiterung: Konnte keinen Speicher für »%s« zuweisen."

#: builtins/alias.def:131 variables.c:1789
#, c-format
msgid "`%s': invalid alias name"
msgstr "»%s«: Ungültiger Aliasname."

#: builtins/bind.def:123
msgid "line editing not enabled"
msgstr "Zeileneditierung ist nicht aktiviert."

#: builtins/bind.def:208
#, c-format
msgid "`%s': invalid keymap name"
msgstr "»%s«: Ungültiger Tastenzuordnungs-Name."

#: builtins/bind.def:277
msgid "cannot read"
msgstr "Nicht lesbar"

#: builtins/bind.def:353 builtins/bind.def:382
#, c-format
msgid "`%s': unknown function name"
msgstr "%s: Unbekannter Funktionsname."

#: builtins/bind.def:361
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s ist keiner Taste zugeordnet.\n"

#: builtins/bind.def:365
#, c-format
msgid "%s can be invoked via "
msgstr "%s kann aufgerufen werden durch "

#: builtins/bind.def:401 builtins/bind.def:418
#, c-format
msgid "`%s': cannot unbind"
msgstr "»%s«: Bindung kann nicht gelöst werden."

#: builtins/break.def:80 builtins/break.def:125
msgid "loop count"
msgstr "Schleifenzähler"

#: builtins/break.def:145
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "nur in einer for-, while- oder until-Schleife sinnvoll."

# caller
#: builtins/caller.def:135
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Gibt Informationen zum aktuellen Subroutinenaufruf aus.\n"
"\n"
"    Ohne Argument wird \\\"$line $filename\\\" angezeigt. Mit Argument\n"
"    werden Zeilennummer, Subroutinenname und Dateiname ausgegeben.\n"
"    Mit diesen Informationen kann ein Stacktrace erzeugt werden.\n"
"\n"
"    Das Argument gibt die angezeigte Position im Funktionsaufrufstapel an,\n"
"    wobei 0 der aktuelle Funktionsaufruf ist.\n"
"\n"
"    Rückgabewert:\n"
"    Ist ungleich 0 wenn keine Shellfunktion ausgeführt wird oder das Argument\n"
"    ungültig ist, sonst 0."

#: builtins/cd.def:321
msgid "HOME not set"
msgstr "HOME ist nicht zugewiesen."

#: builtins/cd.def:329 builtins/common.c:143 builtins/fc.def:293 test.c:946
msgid "too many arguments"
msgstr "Zu viele Argumente."

#: builtins/cd.def:335
msgid "null directory"
msgstr "NULL Verzeichnis"

#: builtins/cd.def:345
msgid "OLDPWD not set"
msgstr "OLDPWD ist nicht zugewiesen."

# Debug Ausgabe
#: builtins/common.c:91
#, c-format
msgid "line %d: "
msgstr "Zeile %d: "

#: builtins/common.c:117 error.c:227
#, c-format
msgid "warning: "
msgstr "Warnung: "

#: builtins/common.c:131
#, c-format
msgid "%s: usage: "
msgstr "%s: Aufruf: "

#: builtins/common.c:178 shell.c:524 shell.c:865
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: Die Option erfordert ein Argument."

#: builtins/common.c:184
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: Ein numerischer Parameter ist erforderlich."

#: builtins/common.c:190
#, c-format
msgid "%s: not found"
msgstr "%s: Nicht gefunden."

#: builtins/common.c:198 shell.c:878
#, c-format
msgid "%s: invalid option"
msgstr "%s: Ungültige Option."

#: builtins/common.c:204
#, c-format
msgid "%s: invalid option name"
msgstr "%s: Ungültiger Optionsname."

#: builtins/common.c:210 error.c:461
#, c-format
msgid "`%s': not a valid identifier"
msgstr "»%s«: Ist kein gültiger Bezeichner."

#: builtins/common.c:219
msgid "invalid octal number"
msgstr "Ungültige Oktalzahl."

#: builtins/common.c:221
msgid "invalid hex number"
msgstr "Ungültige hexadezimale Zahl."

#: builtins/common.c:223 expr.c:1577 expr.c:1591
msgid "invalid number"
msgstr "Ungültige Zahl."

#: builtins/common.c:230
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: Ungültige Signalbezeichnung."

#: builtins/common.c:236
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "»%s«: Ist keine gültige Prozess-ID oder Jobbezeichnung."

#: builtins/common.c:242 error.c:455
#, c-format
msgid "%s: readonly variable"
msgstr "%s: Schreibgeschützte Variable."

#: builtins/common.c:248
#, c-format
msgid "%s: cannot assign"
msgstr "%s: Zuweisung nicht möglich."

#: builtins/common.c:255
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s ist außerhalb des Gültigkeitsbereiches."

#: builtins/common.c:255 builtins/common.c:257
msgid "argument"
msgstr "Argument"

#: builtins/common.c:257
#, c-format
msgid "%s out of range"
msgstr "%s ist außerhalb des Gültigkeitsbereiches."

#: builtins/common.c:264
#, c-format
msgid "%s: no such job"
msgstr "%s: Kein solcher Job."

#: builtins/common.c:271
#, c-format
msgid "%s: no job control"
msgstr "%s: Keine Jobsteuerung in dieser Shell."

#: builtins/common.c:273
msgid "no job control"
msgstr "Keine Jobsteuerung in dieser Shell."

#: builtins/common.c:279
#, c-format
msgid "%s: invalid job specification"
msgstr "%s: Ungültige Jobbezeichnung"

#: builtins/common.c:289
#, c-format
msgid "%s: restricted"
msgstr "%s: eingeschränkt"

#: builtins/common.c:291
msgid "restricted"
msgstr "eingeschränkt"

#: builtins/common.c:298
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: Ist kein eingebautes Shellkommando."

#: builtins/common.c:307
msgid "write error"
msgstr "Schreibfehler"

#: builtins/common.c:314
msgid "error setting terminal attributes"
msgstr "Fehler beim Einstellen der Terminalattribute"

#: builtins/common.c:316
msgid "error getting terminal attributes"
msgstr "Fehler beim Ermitteln der Terminalattribute"

#: builtins/common.c:611
msgid "error retrieving current directory"
msgstr "Fehler bei Abrufen des aktuellen Verzeichnisses"

#: builtins/common.c:675 builtins/common.c:677
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: Mehrdeutige Jobbezeichnung."

#: builtins/common.c:709
#, c-format
msgid "%s: job specification requires leading `%%'"
msgstr "%s: Der Jobbezeichnung muss ein `%%' vorangestellt sein"

#: builtins/common.c:937
msgid "help not available in this version"
msgstr "In dieser Version ist keine Hilfe verfügbar."

#: builtins/common.c:1005
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: Ist kein indiziertes Array."

#: builtins/common.c:1028 builtins/set.def:964 variables.c:3868
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: »unset« nicht möglich: %s ist schreibgeschützt"

#: builtins/common.c:1033 builtins/set.def:930 variables.c:3873
#, c-format
msgid "%s: cannot unset"
msgstr "%s: »unset« nicht möglich."

#: builtins/complete.def:285
#, c-format
msgid "%s: invalid action name"
msgstr "%s: Ungültiger Aktionsname."

#: builtins/complete.def:501 builtins/complete.def:644
#: builtins/complete.def:899
#, c-format
msgid "%s: no completion specification"
msgstr "%s: Keine Komplettierung angegeben."

#: builtins/complete.def:703
msgid "warning: -F option may not work as you expect"
msgstr "Warnung: Die Option -F könnte unerwartete Ergebnisse liefern."

#: builtins/complete.def:705
msgid "warning: -C option may not work as you expect"
msgstr "Warnung: Die Option -C könnte unerwartete Ergebnisse liefern."

#: builtins/complete.def:872
msgid "not currently executing completion function"
msgstr "Gegenwärtig wird keine Komplettierungsfunktion ausgeführt."

#: builtins/declare.def:139
msgid "can only be used in a function"
msgstr "Kann nur innerhalb einer Funktion benutzt werden."

#: builtins/declare.def:471
msgid "cannot use `-f' to make functions"
msgstr "Mit »-f« können keine Funktionen erzeugt werden."

#: builtins/declare.def:499 execute_cmd.c:6320
#, c-format
msgid "%s: readonly function"
msgstr "%s: Schreibgeschützte Funktion."

#: builtins/declare.def:556 builtins/declare.def:843
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: Referenzvariable darf kein Array sein."

#: builtins/declare.def:567 variables.c:3346
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s: Selbstreferenz der Nameref Variable ist nicht erlaubt."

#: builtins/declare.def:572 variables.c:2035 variables.c:3343
#, c-format
msgid "%s: circular name reference"
msgstr "%s: Zirkularbezug auf indirekte Variable."

#: builtins/declare.def:576 builtins/declare.def:850 builtins/declare.def:859
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "»%s«: Ungültiger Name für indirekte Variablenreferenz."

#: builtins/declare.def:908
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: Kann Feldvariablen nicht auf diese Art löschen."

#: builtins/declare.def:914
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: Konvertieren von assoziativen in indizierte Arrays ist nicht möglich."

#: builtins/declare.def:943
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s: Ausführungszeichen um zusammengesetzte Array-Zuweisungen veraltet"

#: builtins/enable.def:149 builtins/enable.def:157
msgid "dynamic loading not available"
msgstr "Dynamisches Laden ist nicht verfügbar."

#: builtins/enable.def:389
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "Kann die dynamische Bibliothek nicht laden %s: %s"

#: builtins/enable.def:408
#, c-format
msgid "%s: builtin names may not contain slashes"
msgstr "%s: Namen eingebauter Funktionen sollen keine Schrägstriche enthalten"

#: builtins/enable.def:423
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "Kann %s nicht in der dynamischen Bibliothek finden %s: %s"

#: builtins/enable.def:440
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: Ist bereits geladen."

#: builtins/enable.def:444
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "Die Ladefunktion von %s lieferte einen Fehler (%d), daher nicht geladen."

#: builtins/enable.def:565
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: Ist nicht dynamisch geladen."

#: builtins/enable.def:591
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: Kann nicht löschen: %s"

#: builtins/evalfile.c:137 builtins/hash.def:190 execute_cmd.c:6140
#, c-format
msgid "%s: is a directory"
msgstr "%s: ist ein Verzeichnis."

#: builtins/evalfile.c:143
#, c-format
msgid "%s: not a regular file"
msgstr "%s: Ist keine normale Datei."

#: builtins/evalfile.c:152
#, c-format
msgid "%s: file is too large"
msgstr "%s: Die Datei ist zu groß."

#: builtins/evalfile.c:189 builtins/evalfile.c:207 execute_cmd.c:6222
#: shell.c:1687
msgid "cannot execute binary file"
msgstr "Binärdatei kann nicht ausgeführt werden"

#: builtins/evalstring.c:478
#, c-format
msgid "%s: ignoring function definition attempt"
msgstr "%s: Versuch einer Funktionsdefinition wird ignoriert"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:249
msgid "cannot execute"
msgstr "Kann nicht ausgeführt werden"

#: builtins/exit.def:61
#, c-format
msgid "logout\n"
msgstr "Abgemeldet\n"

#: builtins/exit.def:85
msgid "not login shell: use `exit'"
msgstr "Keine Loginshell: Mit »exit« abmelden!"

#: builtins/exit.def:116
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Es gibt noch angehaltene Prozesse.\n"

#: builtins/exit.def:118
#, c-format
msgid "There are running jobs.\n"
msgstr "Es gibt noch laufende Prozesse.\n"

#: builtins/fc.def:284 builtins/fc.def:391 builtins/fc.def:435
msgid "no command found"
msgstr "Kein Kommando gefunden."

#: builtins/fc.def:381 builtins/fc.def:386 builtins/fc.def:425
#: builtins/fc.def:430
msgid "history specification"
msgstr "Verlaufsspezifikation"

#: builtins/fc.def:462
msgid "cannot open temp file"
msgstr "Kann die temporäre Datei nicht öffnen"

#: builtins/fg_bg.def:150 builtins/jobs.def:293
msgid "current"
msgstr "gegenwärtig"

#: builtins/fg_bg.def:159
#, c-format
msgid "job %d started without job control"
msgstr "Job %d wurde ohne Jobsteuerung gestartet."

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: Ungültige Option -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: Diese Option erfordert ein Argument -- %c\n"

#: builtins/hash.def:88
msgid "hashing disabled"
msgstr "Hashing deaktiviert."

#: builtins/hash.def:144
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: Die Hashtabelle ist leer.\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "Treffer\tBefehl\n"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00022.html
#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Shellkommando, auf das das Schlüsselwort zutrifft `"
msgstr[1] "Shell Kommandos auf die die Schlüsselwörter zutreffen `"

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"'\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid "no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr "Kein passendes Hilfethema für »%s«. Probieren Sie »help help«, »man -k %s« oder »info %s«."

#: builtins/help.def:214
msgid "cannot open"
msgstr "Kann nicht geöffnet werden"

#: builtins/help.def:264 builtins/help.def:306 builtins/history.def:306
#: builtins/history.def:325 builtins/read.def:909
msgid "read error"
msgstr "Lesefehler"

#: builtins/help.def:517
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Diese Shellkommandos sind intern definiert. Geben Sie »help« ein, um diese\n"
"Liste zu sehen. Geben Sie »help Name« ein, um die Beschreibung der Funktion\n"
"»Name« zu sehen. Geben Sie »info bash« ein, um die vollständige Dokumentation\n"
"zu sehen. Geben Sie »man -k« oder »info« ein, um detaillierte Beschreibungen\n"
"der Shellkommandos zu sehen.\n"
"\n"
"Ein Stern (*) neben dem Namen kennzeichnet deaktivierte Kommandos.\n"
"\n"

#: builtins/history.def:164
msgid "cannot use more than one of -anrw"
msgstr "Es darf höchstens eine Option aus -anrw angegeben werden."

#: builtins/history.def:197 builtins/history.def:209 builtins/history.def:220
#: builtins/history.def:245 builtins/history.def:252
msgid "history position"
msgstr "Kommandostapelposition."

#: builtins/history.def:280
msgid "empty filename"
msgstr "Leerer Dateiname"

#: builtins/history.def:282 subst.c:8226
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: Parameter ist leer oder nicht gesetzt."

#: builtins/history.def:362
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: Ungültiger Zeitstempel."

#: builtins/history.def:470
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: Kommandoersetzung gescheitert."

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "Keine weiteren Optionen mit `-x' erlaubt."

#: builtins/kill.def:214
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: Die Argumente müssen Prozess- oder Job-IDs sein."

#: builtins/kill.def:280
msgid "Unknown error"
msgstr "Unbekannter Fehler."

#: builtins/let.def:96 builtins/let.def:120 expr.c:647 expr.c:665
msgid "expression expected"
msgstr "Ausdruck erwartet."

#: builtins/mapfile.def:249 builtins/read.def:373
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: Ungültige Dateideskriptor-Angabe."

#: builtins/mapfile.def:257 builtins/read.def:380
msgid "invalid file descriptor"
msgstr "Ungültiger Dateideskriptor"

#: builtins/mapfile.def:266 builtins/mapfile.def:304
#, c-format
msgid "%s: invalid line count"
msgstr "%s: Ungültige Zeilenanzahlangabe."

#: builtins/mapfile.def:277
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: Ungültiger Arrayanfang."

#: builtins/mapfile.def:294
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: ungültige Callback Anzahl"

#: builtins/mapfile.def:327
msgid "empty array variable name"
msgstr "Fehlender Name für die Arrayvariable."

#: builtins/mapfile.def:347
msgid "array variable support required"
msgstr "Die Unterstützung für Arrayvariablen ist in dieser Shell nicht vorhanden."

#: builtins/printf.def:483
#, c-format
msgid "`%s': missing format character"
msgstr "»%s«: Fehlendes Formatierungszeichen."

#: builtins/printf.def:609
#, c-format
msgid "`%c': invalid time format specification"
msgstr "»%c«: Ungültige Zeitformatangabe."

#: builtins/printf.def:711
msgid "string length"
msgstr "Zeichenkettenlänge"

#: builtins/printf.def:811
#, c-format
msgid "`%c': invalid format character"
msgstr "»%c«: Ungültiges Formatierungszeichen."

#: builtins/printf.def:928
#, c-format
msgid "format parsing problem: %s"
msgstr "Formatleseproblem: %s"

#: builtins/printf.def:1113
msgid "missing hex digit for \\x"
msgstr "Fehlende hexadezimale Ziffer nach \\x."

#: builtins/printf.def:1128
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "Fehlende Unicode-Ziffer für \\%c."

#: builtins/pushd.def:198
msgid "no other directory"
msgstr "kein anderes Verzeichnis"

#: builtins/pushd.def:358 builtins/pushd.def:383
#, c-format
msgid "%s: invalid argument"
msgstr "%s: Ungültiges Argument."

#: builtins/pushd.def:501
msgid "<no current directory>"
msgstr "<kein aktuelles Verzeichnis>"

#: builtins/pushd.def:543
msgid "directory stack empty"
msgstr "Der Verzeichnisstapel ist leer."

#: builtins/pushd.def:545
msgid "directory stack index"
msgstr "Verzeichnisstapelindex"

#: builtins/pushd.def:708
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Zeigt die Liste der gegenwärtig gespeicherten Verzeichnisse an.  Durch\n"
"    das Kommando »pushd« werden die Verzeichnisse auf den Stapel gelegt\n"
"    und können durch das Kommando »popd« wieder vom Stapel entfernt\n"
"    werden.\n"
"\n"
"    Optionen:\n"
"\t-c\tVerzeichnisstapel durch Löschen aller Einträge bereinigen.\n"
"\t-l\tDas Heimatverzeichnis wird nicht mit vorangestellter Tilde\n"
"\tausgegeben\n"
"\t-p\tDen Verzeichnisstapel zeilenweise ausgeben.\n"
"\t-v\tDen Verzeichnisstapel zeilenweise mit vorangestellter\n"
"\tPositionsnummer auseben.\n"
"\n"
"    Argumente:\n"
"\t+N\tZeigt den N'ten Eintrag von links an, der von »dirs« ausgegeben\n"
"\twird, wenn es ohne Optionen aufgerufen wird, beginnend mit Null.\n"
"\t-N\tZeigt den N'ten Eintrag von rechts an, der von »dirs« ausgegeben\n"
"\twird, wenn es ohne Optionen aufgerufen wird, beginnend mit Null."

#: builtins/pushd.def:730
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Legt einen Verzeichniseintrag auf den Verzeichnisstapel ab oder rotiert\n"
"den Stapel so, dass das aktuelle Verzeichnis oben liegt. Ohne Argumente\n"
"werden die beiden oberen Einträge vertauscht.\n"
"\n"
"    Optionen: \n"
"       -n\tVermeidet das Wechseln des Verzeichnisses, so dass\n"
"\tnur der Verzeichnisstapel geändert wird.\n"
"\n"
"    Argumente:\n"
"      +N\tRotiert den Verzeichnisstapel, dass das N-te Verzeichnis\n"
"\tvon links, das von »dirs« angezeigt wird, nach oben kommt. Die Zählung\n"
"\tbeginnt dabei mit Null.\n"
"\n"
"      -N\tRotiert den Verzeichnisstapel, dass das N-te Verzeichnis\n"
"\tvon rechts, das von »dirs« angezeigt wird, nach oben kommt. Die \n"
"\tZählung beginnt dabei mit Null.\n"
"\n"
"      dir\tLegt DIR auf den Verzeichnisstapel und wechselt in dieses\n"
"      Verzeichnis.\n"
"    \n"
"    Das Kommando »dirs« Kommando zeigt den Verzeichnisstapel an."

#: builtins/pushd.def:755
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Entfernt Einträge vom Stapel.  Ohne Argumente wird der oberste Eintrag\n"
"    gelöscht und anschließend in das das neue oben liegende Verzeichnis\n"
"    gewechselt.\n"
"    \n"
"    Optionen:\n"
"      -n\tVermeidet das Wechseln des Verzeichnisses, so dass\n"
"\tnur der Verzeichnisstapel geändert wird.\n"
"    \n"
"    Argumente:\n"
"      +N\tEntfernt den N-ten Eintrag von links, der von `dirs'\n"
"\tangezeigt wird.  Dabei beginnt die Zählung von Null.  So\n"
"\tentfernt z.B. »popd +0« den ersten und »popd +1« den zweiten\n"
"\tEintrag.\n"
"    \n"
"      -N\tEntfernt den N-ten Eintrag von rechts, der von `dirs'\n"
"\tangezeigt wird.  Dabei beginnt die Zählung von Null.  So\n"
"\tentfernt z.B. »popd -0« den letzten und »popd +1« den vorletzten\n"
"\tEintrag.\n"
"    \n"
"    Das Kommando »dirs« zeigt den Verzeichnisstapel an."

#: builtins/read.def:346
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: Ungültige Wartezeitangebe."

#: builtins/return.def:73
msgid "can only `return' from a function or sourced script"
msgstr "»Return« ist nur aus einer Funktion oder einem mit »source« ausgeführten Skript möglich."

#: builtins/set.def:863
msgid "cannot simultaneously unset a function and a variable"
msgstr "Gleichzeitiges »unset« einer Funktion und einer Variable ist nicht möglich."

#: builtins/set.def:981
#, c-format
msgid "%s: not an array variable"
msgstr "%s: Ist keine Feldvariable."

#: builtins/setattr.def:187
#, c-format
msgid "%s: not a function"
msgstr "%s: Ist keine Funktion."

#: builtins/setattr.def:192
#, c-format
msgid "%s: cannot export"
msgstr "%s: Exportieren nicht möglich."

#: builtins/shift.def:74 builtins/shift.def:86
msgid "shift count"
msgstr "Verschiebeanzahl"

#: builtins/shopt.def:332
msgid "cannot set and unset shell options simultaneously"
msgstr "Kann nicht Shelloptionen gleichzeitig aktivieren und deaktivieren."

#: builtins/shopt.def:457
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: Ungültiger Name für Shelloption."

#: builtins/source.def:143
msgid "filename argument required"
msgstr "Ein Dateiname wird als Argument benötigt."

#: builtins/source.def:179
#, c-format
msgid "%s: file not found"
msgstr "%s: Datei nicht gefunden."

#: builtins/suspend.def:105
msgid "cannot suspend"
msgstr "Kann die Shell nicht unterbrechen."

# logout
#: builtins/suspend.def:111
msgid "cannot suspend a login shell"
msgstr "Kann die Loginshell nicht unterbrechen."

#: builtins/test.def:146 test.c:926
msgid "missing `]'"
msgstr "Fehlende »]«"

#: builtins/type.def:231
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s ist ein Alias von »%s«.\n"

#: builtins/type.def:252
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s Ist ein reserviertes Schlüsselwort der Shell.\n"

#: builtins/type.def:270 builtins/type.def:314
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s ist eine spezielle eingebaute Funktion.\n"

#: builtins/type.def:289
#, c-format
msgid "%s is a function\n"
msgstr "%s ist eine Funktion.\n"

#: builtins/type.def:316
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s ist eine von der Shell mitgelieferte Funktion.\n"

#: builtins/type.def:338 builtins/type.def:425
#, c-format
msgid "%s is %s\n"
msgstr "%s ist %s\n"

#: builtins/type.def:358
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s ist gehasht (%s)\n"

#: builtins/ulimit.def:403
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: Ungültiges Argument für das Limit"

#: builtins/ulimit.def:429
#, c-format
msgid "`%c': bad command"
msgstr "`%c': Falsches Kommando."

#: builtins/ulimit.def:465 builtins/ulimit.def:748
msgid "cannot get limit"
msgstr "Kann das Limit nicht ermitteln"

#: builtins/ulimit.def:498
msgid "limit"
msgstr "Limit"

#: builtins/ulimit.def:511 builtins/ulimit.def:812
msgid "cannot modify limit"
msgstr "Kann das Limit nicht ändern"

#: builtins/umask.def:114
msgid "octal number"
msgstr "Oktalzahl"

#: builtins/umask.def:256
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "`%c': Ungültiger Operator für den symbolischen Modus."

#: builtins/umask.def:345
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "`%c': Ungültiges Zeichen im symbolischen Modus."

#: error.c:83 error.c:311 error.c:313 error.c:315
msgid " line "
msgstr " Zeile "

#: error.c:151
#, c-format
msgid "last command: %s\n"
msgstr "Letztes Kommando: %s\n"

#: error.c:159
#, c-format
msgid "Aborting..."
msgstr "Abbruch..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:244
#, c-format
msgid "INFORM: "
msgstr "INFO: "

#: error.c:261
#, c-format
msgid "DEBUG warning: "
msgstr "DEBUG Warnung: "

#: error.c:413
msgid "unknown command error"
msgstr "Unbekanntes Kommando"

#: error.c:414
msgid "bad command type"
msgstr "Falscher Kommandotyp"

# Programmierfehler
#: error.c:415
msgid "bad connector"
msgstr ""

#: error.c:416
msgid "bad jump"
msgstr "Falscher Sprung"

#: error.c:449
#, c-format
msgid "%s: unbound variable"
msgstr "%s ist nicht gesetzt."

#: eval.c:260
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\aZu lange keine Eingabe: Automatisch ausgeloggt.\n"

#: execute_cmd.c:606
msgid "cannot redirect standard input from /dev/null"
msgstr "Kann die Standardeingabe nicht von /dev/null umleiten"

#: execute_cmd.c:1412
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: »%c«: Ungültiges Formatzeichen."

#: execute_cmd.c:2493
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr ""

#: execute_cmd.c:2647
msgid "pipe error"
msgstr "Pipe-Fehler"

#: execute_cmd.c:4100
#, c-format
msgid "invalid regular expression `%s': %s"
msgstr "ungültiger regulärer Ausdruck `%si': %s"

#: execute_cmd.c:4102
#, c-format
msgid "invalid regular expression `%s'"
msgstr "ungültiger regulärer Ausdruck `%s'"

#: execute_cmd.c:5056
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: Maximale Schachtelungstiefe überschritten (%d)"

#: execute_cmd.c:5069
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: Maximale Quellcode-Schachtelungstiefe überschritten (%d)"

#: execute_cmd.c:5198
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: maximale Schachtelungstiefe für Funktionen überschritten (%d)"

#: execute_cmd.c:5754
msgid "command not found"
msgstr "Kommando nicht gefunden"

#: execute_cmd.c:5783
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: eingeschränkt: `/' ist in Kommandonamen unzulässig."

#: execute_cmd.c:6176
msgid "bad interpreter"
msgstr "Defekter Interpreter"

#: execute_cmd.c:6185
#, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: Kann nicht ausführen. Datei nicht gefunden."

#: execute_cmd.c:6361
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "Kann fd %d nicht auf fd %d verdoppeln."

#: expr.c:272
msgid "expression recursion level exceeded"
msgstr "Zu viele Rekursionen in Ausdruck."

#: expr.c:300
msgid "recursion stack underflow"
msgstr "Rekursionsstapel leer."

#: expr.c:485
msgid "arithmetic syntax error in expression"
msgstr "Arithmetischer Syntaxfehler im Ausdruck"

#: expr.c:529
msgid "attempted assignment to non-variable"
msgstr "Versuchte Zuweisung zu etwas, das keine Variable ist."

#: expr.c:538
msgid "arithmetic syntax error in variable assignment"
msgstr "Arithmetischer Syntaxfehler in der Variablenzuweisung"

#: expr.c:552 expr.c:917
msgid "division by 0"
msgstr "Division durch 0."

#: expr.c:600
msgid "bug: bad expassign token"
msgstr "Fehler: Falscher Zuweisungsoperator."

#: expr.c:654
msgid "`:' expected for conditional expression"
msgstr "»:« für ein bedingten Ausdruck erwartet."

#: expr.c:979
msgid "exponent less than 0"
msgstr "Der Exponent ist kleiner als 0."

#: expr.c:1040
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "Nach einem Präinkrement oder Prädekrement wird ein Bezeichner erwartet."

#: expr.c:1067
msgid "missing `)'"
msgstr "Fehlende »)«"

#: expr.c:1120 expr.c:1507
msgid "arithmetic syntax error: operand expected"
msgstr "Arithmetischer Syntaxfehler: Operand erwartet"

#: expr.c:1468 expr.c:1489
msgid "--: assignment requires lvalue"
msgstr "--: Die Zuweisung erfordert ein Lvalue"

#: expr.c:1470 expr.c:1491
msgid "++: assignment requires lvalue"
msgstr "++: Die Zuweisung erfordert ein Lvalue"

#: expr.c:1509
msgid "arithmetic syntax error: invalid arithmetic operator"
msgstr "Arithmetischer Syntaxfehler: Ungültiger arithmetischer Operator"

#: expr.c:1532
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (Fehlerverursachendes Zeichen ist \"%s\")."

#: expr.c:1595
msgid "invalid arithmetic base"
msgstr "Ungültige arithmetische Basis."

#: expr.c:1604
msgid "invalid integer constant"
msgstr "Ungültige Ganzzahlenkonstante."

#: expr.c:1620
msgid "value too great for base"
msgstr "Der Wert ist für die aktuelle Basis zu groß."

#: expr.c:1671
#, c-format
msgid "%s: expression error\n"
msgstr "%s: Fehler im Ausdruck.\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: Kann auf die übergeordneten Verzeichnisse nicht zugreifen."

#: general.c:459
#, c-format
msgid "`%s': is a special builtin"
msgstr "»%s« ist eine spezielle eingebaute Funktion."

#: input.c:98 subst.c:6542
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "Konnte den No-Delay-Modus für fd %d nicht wiederherstellen."

#: input.c:254
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "Kann keinen neuen Dateideskriptor für die Eingabe von fd %d zuweisen."

# Debug Ausgabe
#: input.c:262
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: Es existiert bereits ein Puffer für den neuen fd %d."

#: jobs.c:549
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pgrp pipe"

#: jobs.c:910
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr ""

#: jobs.c:962
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr ""

#: jobs.c:1380
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "Die geforkte PID %d erscheint im laufenden Prozess %d."

#: jobs.c:1496
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "Lösche den gestoppten Prozess %d der Prozessgruppe %ld."

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00024.html
#: jobs.c:1620
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr ""

# Programmierfehler
#: jobs.c:1949
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: Prozessnummer existiert nicht."

#: jobs.c:1963
#, c-format
msgid "Signal %d"
msgstr "Signal %d"

#: jobs.c:1974 jobs.c:2000
msgid "Done"
msgstr "Fertig"

#: jobs.c:1979 siglist.c:123
msgid "Stopped"
msgstr "Angehalten"

#: jobs.c:1983
#, c-format
msgid "Stopped(%s)"
msgstr "Angehalten(%s)"

#: jobs.c:1987
msgid "Running"
msgstr "Läuft"

#: jobs.c:2004
#, c-format
msgid "Done(%d)"
msgstr "Fertig(%d)"

#: jobs.c:2006
#, c-format
msgid "Exit %d"
msgstr "Exit %d"

#: jobs.c:2009
msgid "Unknown status"
msgstr "Unbekannter Status"

#: jobs.c:2105
#, c-format
msgid "(core dumped) "
msgstr "(Speicherabzug geschrieben) "

#: jobs.c:2124
#, c-format
msgid "  (wd: %s)"
msgstr "  (Verz.: %s)"

# interner Fehler
#: jobs.c:2391
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr ""

#: jobs.c:2754 nojobs.c:640
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: Prozess %ld wurde nicht von dieser Shell gestartet."

#: jobs.c:3052
#, c-format
msgid "wait_for: No record of process %ld"
msgstr ""

#: jobs.c:3410
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: Der Job %d ist gestoppt."

#: jobs.c:3838
#, c-format
msgid "%s: no current jobs"
msgstr "%s: Kein aktueller Job."

#: jobs.c:3845
#, c-format
msgid "%s: job has terminated"
msgstr "%s: Der Job ist beendet."

#: jobs.c:3854
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: Der Job %d läuft bereits im Hintergrund."

#: jobs.c:4092
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr ""

# Debug Ausgabe
#: jobs.c:4641
#, c-format
msgid "%s: line %d: "
msgstr "%s: Zeile %d: "

#: jobs.c:4657 nojobs.c:895
#, c-format
msgid " (core dumped)"
msgstr " (Speicherabzug geschrieben)"

#: jobs.c:4677 jobs.c:4697
#, c-format
msgid "(wd now: %s)\n"
msgstr "(gegenwärtiges Arbeitsverzeichnis ist: %s)\n"

# interner Fehler
#: jobs.c:4741
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp war nicht erfolgreich."

# interner Fehler
#: jobs.c:4797
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: Keine Jobsteuerung im Hintergrund."

# interner Fehler
#: jobs.c:4813
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: line discipline"

# interner Fehler
#: jobs.c:4823
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:4844 jobs.c:4853
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "Kann die Prozessgruppe des Terminals nicht setzen (%d)."

#: jobs.c:4858
msgid "no job control in this shell"
msgstr "Keine Jobsteuerung in dieser Shell."

#: lib/malloc/malloc.c:364
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: Zusicherung gescheitert: %s.\n"

#: lib/malloc/malloc.c:375
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: Zusicherung verpfuscht\\r\n"

#: lib/malloc/malloc.c:376 lib/malloc/malloc.c:925
msgid "unknown"
msgstr "Unbekannt"

#: lib/malloc/malloc.c:876
msgid "malloc: block on free list clobbered"
msgstr "Malloc: Ein internet Speicherbereich (free list) wurde überschrieben."

#: lib/malloc/malloc.c:961
msgid "free: called with already freed block argument"
msgstr "free: Wurde für bereits freigegebenen Speicherbereich aufgerufen."

#: lib/malloc/malloc.c:964
msgid "free: called with unallocated block argument"
msgstr "free: Wurde für nicht zugeordneten Speicherbereich aufgerufen."

#: lib/malloc/malloc.c:982
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: Underflow erkannt; mh_nbytes außerhalb des Gültigkeitsbereichs."

#: lib/malloc/malloc.c:988
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: Underflow erkannt; magic8 beschädigt."

#: lib/malloc/malloc.c:995
msgid "free: start and end chunk sizes differ"
msgstr "free: Beginn und Ende Segmentgrößen sind unterschiedlich."

#: lib/malloc/malloc.c:1155
msgid "realloc: called with unallocated block argument"
msgstr "realloc: Mit nicht zugewiesenen Argument aufgerufen."

#: lib/malloc/malloc.c:1170
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: Underflow erkannt; mh_nbytes außerhalb des Gültigkeitsbereichs."

#: lib/malloc/malloc.c:1176
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: Underflow erkannt; magic8 beschädigt."

#: lib/malloc/malloc.c:1184
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: Beginn und Ende Segmentgrößen sind unterschiedlich.<"

#: lib/malloc/table.c:179
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: Speicherzuordnungstabelle ist mit FIND_ALLOC gefüllt?\n"

#: lib/malloc/table.c:188
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p ist bereits in der Speicherzuordnungstabelle als belegt gekennzeichnet?\n"

#: lib/malloc/table.c:237
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p ist bereits in der Speicherzuordnungstabelle als frei gekennzeichnet?\n"

#: lib/sh/fmtulong.c:90
msgid "invalid base"
msgstr "Ungültige Basis"

#: lib/sh/netopen.c:161
#, c-format
msgid "%s: host unknown"
msgstr "%s: Unbekannter Host."

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: invalid service"
msgstr "%s: unbekannter Dienst."

#: lib/sh/netopen.c:294
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: Fehlerhafte Netzwerkspfadangabe."

#: lib/sh/netopen.c:332
msgid "network operations not supported"
msgstr "Der Netzwerkbetrieb ist nicht unterstützt."

#: locale.c:226 locale.c:228 locale.c:301 locale.c:303
msgid "cannot change locale"
msgstr "Kann die Regionaleinstellungen nicht ändern"

# Du oder Sie?
#: mailcheck.c:435
msgid "You have mail in $_"
msgstr "Sie haben Post in $_."

#: mailcheck.c:460
msgid "You have new mail in $_"
msgstr "Sie haben neue Post in $_."

#: mailcheck.c:476
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Die Post in %s wurde bereits gelesen.\n"

#: make_cmd.c:286
msgid "syntax error: arithmetic expression required"
msgstr "Syntaxfehler: Es wird ein arithmetischer Ausdruck benötigt."

#: make_cmd.c:288
msgid "syntax error: `;' unexpected"
msgstr "Syntax Fehler: unerwartetes `;'."

#: make_cmd.c:289
#, c-format
msgid "syntax error: `((%s))'"
msgstr "Syntaxfehler: »((%s))«."

# interner Fehler
#: make_cmd.c:523
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: Falscher Befehlstyp %d."

#: make_cmd.c:627
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "Das in der Zeile %d beginnende Here-Dokument geht bis zum Dateiende (erwartet wird »%s«)."

#: make_cmd.c:722
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr ""

#: parse.y:2572
#, c-format
msgid "shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line truncated"
msgstr ""

#: parse.y:2864
msgid "script file read error"
msgstr ""

#: parse.y:3101
msgid "maximum here-document count exceeded"
msgstr ""

#: parse.y:3901 parse.y:4799 parse.y:6859
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "Dateiende beim Suchen nach »%c« erreicht."

#: parse.y:5006
msgid "unexpected EOF while looking for `]]'"
msgstr "Dateiende beim Suchen nach »]]« erreicht."

#: parse.y:5011
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "Syntaxfehler im bedingten Ausdruck: Unerwartetes Symbol »%s«."

#: parse.y:5015
msgid "syntax error in conditional expression"
msgstr "Syntaxfehler im bedingten Ausdruck."

#: parse.y:5093
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "Unerwartetes Zeichen: »%s« anstatt von »)«"

#: parse.y:5097
msgid "expected `)'"
msgstr "»)« erwartet."

#: parse.y:5127
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr ""

#: parse.y:5131
msgid "unexpected argument to conditional unary operator"
msgstr ""

#: parse.y:5178
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr ""

#: parse.y:5182
msgid "conditional binary operator expected"
msgstr ""

#: parse.y:5211
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr ""

#: parse.y:5215
msgid "unexpected argument to conditional binary operator"
msgstr ""

#: parse.y:5226
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr ""

#: parse.y:5229
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr ""

#: parse.y:5233
#, c-format
msgid "unexpected token %d in conditional command"
msgstr ""

#: parse.y:6827
#, c-format
msgid "syntax error near unexpected token `%s' while looking for matching `%c'"
msgstr "Syntaxfehler beim unerwarteten Token `%s' während dem Suchen nach `%c«'"

#: parse.y:6829
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "Syntaxfehler beim unerwarteten Symbol »%s«"

#: parse.y:6848
#, c-format
msgid "syntax error near `%s'"
msgstr "Syntaxfehler bei »%s«"

#: parse.y:6867
#, c-format
msgid "syntax error: unexpected end of file from `%s' command on line %d"
msgstr "Syntaxfehler: Unerwartetes Dateiende vom Kommando `%s' in Zeile %d."

#: parse.y:6869
#, c-format
msgid "syntax error: unexpected end of file from command on line %d"
msgstr "Syntaxfehler: Unerwartetes Dateiende vom Kommando in Zeile %d"

#: parse.y:6873
msgid "syntax error: unexpected end of file"
msgstr "Syntaxfehler: Unerwartetes Dateiende."

#: parse.y:6873
msgid "syntax error"
msgstr "Syntaxfehler"

# Du oder Sie?
#: parse.y:6922
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Verwenden Sie »%s«, um die Shell zu verlassen.\n"

#: parse.y:7120
msgid "unexpected EOF while looking for matching `)'"
msgstr "Dateiende beim Suchen nach zugehöriger »)« erreicht."

#: pathexp.c:897
msgid "invalid glob sort type"
msgstr "Ungültiger Sortiertyp für Globbing"

#: pcomplete.c:1070
#, c-format
msgid "completion: function `%s' not found"
msgstr "completion: Funktion »%s« nicht gefunden."

#: pcomplete.c:1654
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr ""

#: pcomplib.c:176
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr ""

#: print_cmd.c:324
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: Falsches Verbindungszeichen »%d«."

#: print_cmd.c:399
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: Ungültiger Dateideskriptor."

#: print_cmd.c:404
msgid "xtrace_set: NULL file pointer"
msgstr ""

#: print_cmd.c:408
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr ""

#: print_cmd.c:1597
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: »%c«: Ungültiges Formatsymbol."

#: redir.c:146 redir.c:194
msgid "file descriptor out of range"
msgstr "Dateideskriptor außerhalb des gültigen Bereichs."

#: redir.c:201
msgid "ambiguous redirect"
msgstr "Mehrdeutige Umlenkung"

#: redir.c:205
msgid "cannot overwrite existing file"
msgstr "Kann existierende Datei nicht überschreiben"

#: redir.c:210
msgid "restricted: cannot redirect output"
msgstr "Eingeschränkt: Die Ausgabe kann nicht umgeleitet werden"

#: redir.c:215
msgid "cannot create temp file for here-document"
msgstr "Kann die temporäre Datei für das Hier-Dokument nicht anlegen"

#: redir.c:219
msgid "cannot assign fd to variable"
msgstr "Kann fd keiner Variable zuweisen"

#: redir.c:639
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "Dateinamen der Form /dev/(tcp|udp)/host/port werden ohne Netzwerk nicht unterstützt"

#: redir.c:945 redir.c:1062 redir.c:1124 redir.c:1291
msgid "redirection error: cannot duplicate fd"
msgstr "Umleitungsfehler: Verdoppeln des Dateibezeichners nicht möglich."

#: shell.c:359
msgid "could not find /tmp, please create!"
msgstr "Konnte das Verzeichnis »/tmp« nicht finden, bitte anlegen."

#: shell.c:363
msgid "/tmp must be a valid directory name"
msgstr "/tmp muss ein Verzeichnis sein."

#: shell.c:827
msgid "pretty-printing mode ignored in interactive shells"
msgstr "Der hübsche Druckmodus wird in interaktiven Schells ignoriert."

#: shell.c:969
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: Ungültige Option"

#: shell.c:1354
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "Konnte die UID nicht in %d ändern: Die effektive UID ist %d"

#: shell.c:1370
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "Konnte die GID nicht in %d ändern: Die effektive GID ist %d"

#: shell.c:1559
msgid "cannot start debugger; debugging mode disabled"
msgstr "Kann keinen Debugger starten. Der Debugmodus ist gesperrt."

#: shell.c:1672
#, c-format
msgid "%s: Is a directory"
msgstr "%s: Ist ein Verzeichnis."

#: shell.c:1748 shell.c:1750
msgid "error creating buffered stream"
msgstr ""

#: shell.c:1899
msgid "I have no name!"
msgstr "Ich habe keinen Benutzernamen!"

#: shell.c:2063
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, Version %s-(%s)\n"

#: shell.c:2064
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Aufruf:\t%s [Lange GNU-Option] [Option] ...\n"
"\t%s [Lange GNU-Option] [Option] Script-Datei ...\n"

#: shell.c:2066
msgid "GNU long options:\n"
msgstr "Lange GNU-Optionen:\n"

#: shell.c:2070
msgid "Shell options:\n"
msgstr "Shell-Optionen:\n"

#: shell.c:2071
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-ilrsD oder -c Kommando oder -O shopt_option\t\t(Nur Aufruf)\n"

#: shell.c:2090
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s oder Option -o\n"

#: shell.c:2096
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr ""
"Mehr Informationen über Shell-Optionen sind mit »%s -c \"help set\"«\n"
"verfügbar.\n"

#: shell.c:2097
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "Eingebaute Shell-Kommandos werden durch »%s -c help« beschrieben.\n"

#: shell.c:2098
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Fehler bitte mit dem Kommando »bashbug« melden.\n"

#: shell.c:2100
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "Bash-Homepage: <https://www.gnu.org/software/bash>\n"

#: shell.c:2101
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Allgemeine Hilfe für GNU-Software: <https://www.gnu.org/gethelp/>\n"

#: sig.c:809
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: Ungültige Operation"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Falsches Signal."

#: siglist.c:51
msgid "Hangup"
msgstr "Aufgelegt"

#: siglist.c:55
msgid "Interrupt"
msgstr "Unterbrochen (Interrupt)"

#: siglist.c:59
msgid "Quit"
msgstr "Quit"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Ungültige Anweisung."

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "Verfolgen/anhalten abfangen (Trace/breakpoint trap)"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Abbruchkommando"

#: siglist.c:79
msgid "EMT instruction"
msgstr "EMT abfangen (EMT trap)"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Gleitkommafehler"

#: siglist.c:87
msgid "Killed"
msgstr "Abgebrochen (Killed)"

#: siglist.c:91
msgid "Bus error"
msgstr "Bus-Fehler"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Adressierungsfehler"

#: siglist.c:99
msgid "Bad system call"
msgstr "Falscher Systemaufruf"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Unterbrochene Pipe"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Wecker"

#: siglist.c:111
msgid "Terminated"
msgstr "Abgebrochen (Terminated)"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Dringende IO-Bedingung"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Angehalten (Signal)"

#: siglist.c:127
msgid "Continue"
msgstr "Prozessbearbeitung wieder aufgenommen."

#: siglist.c:135
msgid "Child death or stop"
msgstr "Kindprozess abgebrochen oder gestoppt."

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Angehalten (Terminaleingabe)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Angehalten (Terminalausgabe)"

#: siglist.c:147
msgid "I/O ready"
msgstr "E/A fertig"

#: siglist.c:151
msgid "CPU limit"
msgstr "Rechenzeitgrenze"

#: siglist.c:155
msgid "File limit"
msgstr "Grenze für Dateigröße"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Alarm (Virtuell)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Alarm (Profil)"

#: siglist.c:167
msgid "Window changed"
msgstr "Fenster geändert"

#: siglist.c:171
msgid "Record lock"
msgstr "Datei blockiert"

#: siglist.c:175
msgid "User signal 1"
msgstr "Nutzersignal 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Nutzersignal 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "HFT Eingabedaten ausstehend"

#: siglist.c:187
msgid "power failure imminent"
msgstr "Spannungsausfall steht bevor"

#: siglist.c:191
msgid "system crash imminent"
msgstr "Systemausfall steht bevor"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "Verlege den Prozess auf einen anderen Prozessor"

#: siglist.c:199
msgid "programming error"
msgstr "Programmierfehler"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "HFT-Monitormodus erlaubt"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "HFT-Monitormodus abgeschaltet"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "HFT-Tonfolge beendet"

#: siglist.c:215
msgid "Information request"
msgstr "Informationsanforderung"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00025.html
#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Unbekanntes Signal Nr.: %d."

#: subst.c:1503 subst.c:1795 subst.c:2001
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "Falsche Ersetzung: Kein schließendes »%s« in »%s« enthalten."

#: subst.c:3601
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: Kann einem Feldelement keine Liste zuweisen."

#: subst.c:6381 subst.c:6397
msgid "cannot make pipe for process substitution"
msgstr "Kann keine Pipe für die Prozessersetzung erzeugen."

#: subst.c:6457
msgid "cannot make child for process substitution"
msgstr "Kann den Kindsprozess für die Prozessersetzung nicht erzeugen."

#: subst.c:6532
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "Kann nicht die benannte Pipe %s zum Lesen öffnen."

#: subst.c:6534
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "Kann nicht die benannte Pipe %s zum Schreiben öffnen."

#: subst.c:6557
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "Kann die benannte Pipe %s nicht auf fd %d duplizieren."

#: subst.c:6723
msgid "command substitution: ignored null byte in input"
msgstr "Kommandoersetzung: NULL-Byte in der Eingabe ignoriert."

#: subst.c:6962
msgid "function_substitute: cannot open anonymous file for output"
msgstr ""

# interner Fehler
#: subst.c:7036
msgid "function_substitute: cannot duplicate anonymous file as standard output"
msgstr "function_substitute: Kann die Standardausgabe nicht in einen anonyme Datei umlenken"

#: subst.c:7210 subst.c:7231
msgid "cannot make pipe for command substitution"
msgstr "Kann keine Pipes für Kommandoersetzung erzeugen."

#: subst.c:7282
msgid "cannot make child for command substitution"
msgstr "Kann keinen Unterprozess für die Kommandoersetzung erzeugen."

# interner Fehler
#: subst.c:7315
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: Kann Pipe nicht als Dateideskriptor 1 duplizieren."

#: subst.c:7813 subst.c:10989
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: Ungültiger Variablenname für Namensreferenz."

#: subst.c:7906 subst.c:7924 subst.c:8100
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: Ungültige indirekte Expansion."

#: subst.c:7940 subst.c:8108
#, c-format
msgid "%s: invalid variable name"
msgstr "%s: Ungültiger Variablenname."

#: subst.c:8125 subst.c:10271 subst.c:10298
#, c-format
msgid "%s: bad substitution"
msgstr "%s: Falsche Substitution."

#: subst.c:8224
#, c-format
msgid "%s: parameter not set"
msgstr "%s: Der Parameter ist nicht gesetzt."

# interner Fehler
#: subst.c:8480 subst.c:8495
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: Teilstring-Ausdruck < 0."

#: subst.c:10397
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: Kann so nicht zuweisen."

#: subst.c:10855
msgid "future versions of the shell will force evaluation as an arithmetic substitution"
msgstr "Zukünftige Versionen dieser Shell werden das Auswerten arithmetischer Ersetzungen erzwingen."

#: subst.c:11563
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "Falsche Ersetzung: Kein schließendes »`« in %s."

#: subst.c:12636
#, c-format
msgid "no match: %s"
msgstr "Keine Entsprechung: %s"

#: test.c:156
msgid "argument expected"
msgstr "Argument erwartet."

#: test.c:164
#, c-format
msgid "%s: integer expected"
msgstr "%s: Ganzzahl erwartet"

#: test.c:292
msgid "`)' expected"
msgstr "»)« erwartet."

#: test.c:294
#, c-format
msgid "`)' expected, found %s"
msgstr "»)« erwartet, %s gefunden."

#: test.c:488 test.c:831
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: Zweistelliger (binärer) Operator erwartet."

#: test.c:792 test.c:795
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: Einstelliger (unärer) Operator erwartet."

#: test.c:944
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "Syntax Fehler: »%s« unerwartet."

#: trap.c:225
msgid "invalid signal number"
msgstr "Ungültige Signalnummer."

#: trap.c:358
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "Traphandler: Maximale Traphandler-Ebene überschritten (%d)"

#: trap.c:455
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: Ungültiger Wert in trap_list[%d]: %p"

#: trap.c:459
#, c-format
msgid "run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr ""

# Programmierfehler
#: trap.c:592
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: Falsches Signal %d."

#: unwind_prot.c:246 unwind_prot.c:292
msgid "frame not found"
msgstr "Frame nicht gefunden"

#: variables.c:441
#, c-format
msgid "error importing function definition for `%s'"
msgstr "Fehler beim Importieren der Funktionsdefinition für »%s«."

#: variables.c:864
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "Der Shell-Level (%d) ist zu hoch und wird auf 1 zurückgesetzt."

#: variables.c:2191 variables.c:2220 variables.c:2278 variables.c:2297
#: variables.c:2315 variables.c:2350 variables.c:2378 variables.c:2405
#: variables.c:2431 variables.c:3274 variables.c:3282 variables.c:3797
#: variables.c:3841
#, c-format
msgid "%s: maximum nameref depth (%d) exceeded"
msgstr "%s: Maximale Namereftiefe (%d)überschritten"

#: variables.c:2641
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: no function context at current scope"

#: variables.c:2660
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: Der Variable darf kein Wert zugewiesen werden."

#: variables.c:2831 variables.c:2884
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr ""

# Interner Fehler
#: variables.c:3437
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: assigning integer to name reference"

# Interner Fehler
#: variables.c:4387
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: no function context at current scope"

# Interner Fehler
#: variables.c:4816
#, c-format
msgid "%s has null exportstr"
msgstr "%s has null exportstr"

# Interner Fehler
#: variables.c:4821 variables.c:4830
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "invalid character %d in exportstr for %s"

# Interner Fehler
#: variables.c:4836
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "no `=' in exportstr for %s"

# Interner Fehler
#: variables.c:5354
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: head of shell_variables not a function context"

# Interner Fehler
#: variables.c:5367
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: no global_variables context"

# Interner Fehler
#: variables.c:5457
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: head of shell_variables not a temporary environment scope"

# Interner Fehler
#: variables.c:6448
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: cannot open as FILE"

# Interner Fehler
#: variables.c:6453
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: invalid value for trace file descriptor"

# Interner Fehler
#: variables.c:6497
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: compatibility value out of range"

#: version.c:50
msgid "Copyright (C) 2025 Free Software Foundation, Inc."
msgstr "Copyright (C) 2025 Free Software Foundation, Inc."

#: version.c:51
msgid "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
msgstr "Lizenz GPLv3+: GNU GPL Version 3 oder jünger <http://gnu.org/licenses/gpl.html>\n"

#: version.c:90
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, Version %s (%s)\n"

#: version.c:95
msgid "This is free software; you are free to change and redistribute it."
msgstr "Dies ist freie Software. Sie darf verändert und weitergegeben werden."

#: version.c:96
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "Es wird keinerlei Garantie gewährt, soweit es das Gesetz zulässt."

#: xmalloc.c:84
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: Konnte keine %lu Bytes reservieren (%lu bytes reserviert)."

#: xmalloc.c:86
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: Konnte keine %lu Bytes reservieren."

#: xmalloc.c:164
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: Konnte keine %lu Bytes reservieren (%lu bytes reserviert)."

#: xmalloc.c:166
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: Konnte keine %lu Bytes reservieren."

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [Name[=Wert] ... ]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] Name [Name ...]"

#: builtins.c:53
msgid "bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpsvPSVX] [-m Tastaturtabelle] [-f Dateiname] [-q Name] [-u Name]\n"
"\t[-r Tastenfolge] [-x Tastenfolge:Shell Kommando]\n"
"\t[Tastenfolge:readline-Funktion oder -Kommando]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [Shellkommando [Argument ...]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [Ausdruck]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]]] [-@] [dir]"
msgstr "cd [-L|[-P [-e]]] [-@] [Verzeichnis]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] Kommando [Argument ...]"

#: builtins.c:78
msgid "declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] [name ...]"
msgstr "declare [-aAfFgiIlnrtux] [Name[=Wert] ...] oder declare -p [-aAfFilnrtux] [Name ...]"

#
#: builtins.c:80
msgid "typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] [name ...]"
msgstr "typeset [-aAfFgiIlnrtux] name[=Wert] ... oder typeset -p [-aAfFilnrtux] [Name ...]"

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [Option] Name[=Wert] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [Argument ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [Argument ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f Dateiname] [Name ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [Argument ...]"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00026.html
#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts Optionen [Argumente ...]"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00026.html
#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a Name] [Kommando [Argument ...]] [Umleitung ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e Editor] [-lnr] [Anfang] [Ende] oder fc -s [Muster=Ersetzung] [Kommando]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [Jobbezeichnung]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [Jobbezeichnung ...]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p Pfadname] [-dt] [Name ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [Muster ...]"

#: builtins.c:123
msgid "history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]"
msgstr "history [-c] [-d Offset] [n] oder history -anrw [Dateiname] oder history -ps Argument [Argument...]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [Jobbez. ...] or jobs -x Kommando [Arg]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [Jobbezeichnung ... | pid ...]"

#: builtins.c:134
msgid "kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]"
msgstr "kill [-s Signalname | -n Signalnummer | -Signalname] pid | jobspec ... oder kill -l [Signalname]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let Argument [Argument ...]"

#: builtins.c:138
msgid "read [-Eers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]"
msgstr "read [-Eers] [-a Feld] [-d Begrenzer] [-i Text] [-n Zeichenanzahl] [-N Zeichenanzahl] [-p Prompt] [-t Zeitlimit] [-u fd] [Name ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCEHPT] [-o Optionsname] [--] [-] [Argument ...]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [NAME ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p [-f]"
msgstr "export [-fn] [Name[=Wert] ...] oder export -p [-f]"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [Name[=Wert] ...] oder readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source [-p path] filename [arguments]"
msgstr "source [-p Pfad] Dateiname [Argumente]"

#: builtins.c:154
msgid ". [-p path] filename [arguments]"
msgstr ". [-p Pfad] Dateiname [Argumente]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [Ausdruck]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ Argument... ]"

#: builtins.c:166
msgid "trap [-Plp] [[action] signal_spec ...]"
msgstr "trap [-Plp] [[Argument] Signalbezeichnung ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] Name [Name ...]"

#: builtins.c:171
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPRT] [Grenze]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [Modus]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p Variable] [id ...]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [PID ...]"

#: builtins.c:184
msgid "! PIPELINE"
msgstr "! Pipeline"

#: builtins.c:186
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for Name [in Wort ... ] ; do Kommandos; done"

#: builtins.c:188
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( Ausdr1; Ausdr2; Ausdr3 )); do Kommandos; done"

#: builtins.c:190
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select Wort [in Wörter ... ;] do Kommandos; done"

#: builtins.c:192
msgid "time [-p] pipeline"
msgstr "time [-p] Pipeline"

#: builtins.c:194
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case Wort in [Muster [| Muster]...) Kommandos ;;]... esac"

#: builtins.c:196
msgid "if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi"
msgstr "if Kommandos; then Kommandos; [ elif Kommandos; then Kommandos; ]... [ else Kommandos; ] fi"

#: builtins.c:198
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while Test; do Kommandos; done"

#: builtins.c:200
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until Test; do Kommandos; done"

#: builtins.c:202
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [Name] Kommando [Umleitungen]"

#: builtins.c:204
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function Name { Kommandos ; } oder Name () { Kommandos ; }"

#: builtins.c:206
msgid "{ COMMANDS ; }"
msgstr "{ Kommandos ; }"

#: builtins.c:208
msgid "job_spec [&]"
msgstr "Jobbezeichnung [&]"

#: builtins.c:210
msgid "(( expression ))"
msgstr "(( Ausdruck ))"

#: builtins.c:212
msgid "[[ expression ]]"
msgstr "[[ Ausdruck ]]"

#: builtins.c:214
msgid "variables - Names and meanings of some shell variables"
msgstr "variables - Namen und Bedeutung einiger Shellvariablen"

#: builtins.c:217
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | Verzeichnis]"

#: builtins.c:221
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:225
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:228
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [Optionsname ...]"

#: builtins.c:230
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] Format [Argumente]"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00027.html
#: builtins.c:233
msgid "complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-DEI] [-o Option] [-A Aktion] [-G Suchmuster] [-W Wortliste]  [-F Funktion] [-C Kommando] [-X Filtermuster] [-P Prefix] [-S Suffix] [Name \n"
"...]"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00027.html
#: builtins.c:237
msgid "compgen [-V varname] [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr "compgen [-V Variablenname] [-abcdefgjksuv] [-o Option] [-A Aktion][-G Suchmuster] [-W Wortliste] [-F Funktion] [-C Kommando] [-X Filtermuster] [-P Prefix] [-S Suffix] [Wort]"

#: builtins.c:241
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o Option] [-DEI] [Name ...]"

#: builtins.c:244
msgid "mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr ""
"mapfile [-d Begrenzer] [-n Anzahl] [-O Index] [-s Anzahl] [-t] [-u fd]\n"
"        [-C Callback] [-c Anzahl] [Feldvariable]"

#: builtins.c:246
msgid "readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr ""
"readarray [-d Begrenzer] [-n Anzahl] [-O Quelle] [-s Anzahl] [-t]\n"
"          [-u fd] [-C Callback] [-c Anzahl ] [Feldvariable]"

# alias
#: builtins.c:258
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has been\n"
"    defined."
msgstr ""
"Definiert Aliase oder zeigt sie an.\n"
"\n"
"    Ohne Argumente wird die Liste der Aliase (Synonyme) in der Form\n"
"    »alias Name=Wert« auf die Standardausgabe ausgegeben.\n"
"\n"
"    Sonst wird ein Alias für jeden angegebenen Namen definiert, wenn\n"
"    für diesen auch ein »Wert« angegeben wurde. Wenn »Wert« mit einem\n"
"    Leerzeichen endet, dann wird auch das nächste Wort auf Aliase\n"
"    überprüft.\n"
"\n"
"    Optionen:\n"
"      -p\tGibt alle definierten Aliase aus.\n"
"\n"
"    Rückgabewert:\n"
"    Meldet Erfolg, außer wenn ein »Name« angegeben worden ist, für den\n"
"    kein Alias definiert wurde."

# unalias
#: builtins.c:280
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Entfernt jeden angegebenen Namen von der Aliasliste.\n"
"\n"
"    Optionen:\n"
"      -a\tEnfernt alle Alias-Definitionen.\n"
"\n"
"    Gibt immer Erfolg zurück, außer wenn der Alias nicht existiert."

# bind
#: builtins.c:293
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their values\n"
"      -s                 List key sequences that invoke macros and their values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    If arguments remain after option processing, the -p and -P options treat\n"
"    them as readline command names and restrict output to those names.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Bestimmt Readline Tastenzuordnungen und Variablen.\n"
"    \n"
"    Weist eine Tastensequenz einer Readlinefunktion oder -makro zu\n"
"    oder setzt eine Readlinevariable.  Die Argumentsyntax ist zu\n"
"    den Einträgen in ~/.inputrc äquivalent, aber sie müssen als\n"
"    einzelnes Argument übergeben werden.  Z.B: bind '\"\\C-x\\C-r\":\n"
"    re-read-init-file'.\n"
"    \n"
"    Optionen:\n"
"      -m  Keymap         Benutzt KEYMAP as Tastaturbelegung für die Laufzeit\n"
"                         dieses Kommandos.  Gültige Keymapnamen sind: emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command und vi-insert.\n"
"      -l                 Listet Funktionsnamen auf.\n"
"      -P                 Listet Funktionsnamen und Tastenzuordnungen auf.\n"
"      -p                 Listet Funktionsnamen und Tastenzuordnungen so auf,\n"
"                         dass sie direkt als Eingabe verwendet werden können.\n"
"      -S                 Listet Tastenfolgen und deren Werte auf, die Makros \n"
"                         aufrufen.\n"
"      -s                 Listet Tastenfolgen und deren Werte auf, die Makros \n"
"                         aufrufen, dass sie als Eingabe wiederverwendet werden\n"
"                         können.\n"
"      -V                 Listet Variablennamen und Werte auf.\n"
"      -v                 Listet Variablennamen und Werte so auf, dass sie als\n"
"                         Eingabe verwendet werden können.\n"
"      -q  Funktionsname  Sucht die Tastenfolgen, welche die angegebene\n"
"                         Funktion aufrufen.\n"
"      -u  Funktionsname  Entfernt alle der Funktion zugeordneten Tastenfolgen.\n"
"      -r  Tastenfolge    Entfernt die Zuweisungen der angegebeben Tastenfolge.\n"
"      -f  Dateiname      Liest die Tastenzuordnungen aus der angegebenen Datei.\n"
"      -x  Tastenfolge:Shellkommando\tWeist der Tastenfolge das Shellkommando\n"
"    \t\t\t\t\tzu.\n"
"      -X                                Listet mit -x erzeugte\n"
"                                        Tastenfolgen und deren Werte\n"
"                                        auf, die Makros aufrufen, dass\n"
"                                        sie als Eingabe wiederverwendet werden\n"
"                                        können.\n"
"    \n"
"    Argumente, die zu keiner Option gehören, werden von der -p und -P\n"
"    Option als Readline-Kommando betrachtet und die Ausgabe auf diese\n"
"    Kommandos beschränkt.\n"
"    \n"
"    Rückgabewert: \n"
"    Bind gibt 0 zurück, wenn keine unerkannte Option angegeben wurde\n"
"    oder ein Fehler eintrat."

# break
#: builtins.c:335
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Verlässt for-, while- oder until-Schleifen.\n"
"\n"
"    Break beendet eine »for«-, »while«- oder »until«- Schleife. Wenn »n«\n"
"    angegeben ist, werden entsprechend viele geschachtelte Schleifen beendet.\n"
"\n"
"    Rückgabewert:\n"
"    Der Rückgabewert ist 0, außer »n« ist nicht größer oder gleich 1."

# continue
#: builtins.c:347
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Springt zum Schleifenanfang von for, while, oder until Schleifen.\n"
"\n"
"    Springt zum Schleifenanfang der aktuellen »for«, »while« oder »until«\n"
"    Schleife. Wenn »n« angegeben ist, wird zum Beginn der »n«-ten\n"
"    übergeordneten Schleife gesprungen.\n"
"\n"
"    Rückgabewert:\n"
"    Der Rückgabewert ist 0, außer wenn »n« nicht größer oder gleich 1 ist."

# builtin
#: builtins.c:359
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Führt ein in der Shell definiertes Kommando aus.\n"
"\n"
"    Führt ein in der Shell definiertes Kommando ohne vorherige\n"
"    Befehlssuche aus. Dies ist dann nützlich, wenn das Kommando als\n"
"    Shell-Funktion reimplementiert werden soll, aber das Kommando\n"
"    innerhalb der neuen Funktion aufgerufen wird.\n"
"\n"
"    Rückgabewert: \n"
"    Der Rückgabewert des aufgerufenen Kommandos oder »falsch«, wenn\n"
"    dieses nicht existiert."

# caller
#: builtins.c:374
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Gibt Informationen zum aktuellen Subroutinenaufruf aus.\n"
"\n"
"    Ohne Argument wird die Zeilennummer und der Dateiname angezeigt. Mit\n"
"    Argument werden Zeilennummer, Subroutinenname und Dateiname ausgegeben.\n"
"    Mit diesen Informationen kann ein Stacktrace erzeugt werden.\n"
"\n"
"    Das Argument gibt die angezeigte Position im Funktionsaufrufstapel an,\n"
"    wobei 0 der aktuelle Funktionsaufruf ist.\n"
"\n"
"    Rückgabewert:\n"
"    Ist ungleich 0 wenn keine Shellfunktion ausgeführt wird oder das Argument\n"
"    ungültig ist, sonst 0."

# cd
#: builtins.c:392
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of the\n"
"    HOME shell variable. If DIR is \"-\", it is converted to $OLDPWD.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n"
"    A null directory name is the same as the current directory.  If DIR begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is set,\n"
"    the word is assumed to be  a variable name.  If that variable has a value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Wechselt das Arbeitsverzeichnis.\n"
"\n"
"    Wechselt in das angegebene Arbeitsverzeichnis. Ohne Angabe eines\n"
"    Verzeichnisses wird in das in der Variable HOME definierte\n"
"    Verzeichnis gewechselt. Wenn stattdessen \"-\" angegeben ist, wird\n"
"    $OLDPWD verwendet.\n"
"\n"
"    Die Variable CDPATH definiert den Suchpfad, in dem nach dem\n"
"    angegebenen Verzeichnisnamen gesucht wird. Mehrere Pfade werden\n"
"    durch Doppelpunkte »:« getrennt. Ein leerer Pfadname entspricht\n"
"    dem aktuellen Verzeichnis. Mit einem vollständigen Pfadnamen wird\n"
"    CDPATH nicht benutzt.\n"
"\n"
"    Wird kein entsprechendes Verzeichnis gefunden und die Shelloption\n"
"    »cdable_vars« ist gesetzt, dann wird der `Wert' als Variable\n"
"    interpretiert. Dessen Inhalt wird dann als Verzeichnisname\n"
"    verwendet.\n"
"\n"
"    Optionen:\n"
"      -L        Erzwingt, dass symbolischen Links gefolgt wird.\n"
"                Symbolische Links im aktuellen Verzeichnis werden nach\n"
"                dem übergeordneten Verzeichnis aufgelöst.\n"
"      -P        Symbolische Links werden ignoriert. Symbolische\n"
"                Links im aktuellen Verzeichnis werden vor dem\n"
"                übergeordneten Verzeichnis aufgelöst.\n"
"      -e        Wenn mit der Option »-P« das aktuelle Arbeitsverzeichnis\n"
"                nicht ermittelt werden kann, wird mit einem Rückgabewert\n"
"                ungleich 0 abgebrochen.\n"
"      -@        Wenn es das System unterstützt, wird eine Datei mit\n"
"                erweiterten Attributen als ein Verzeichnis angezeigt,\n"
"                welches die erweiterten Attribute enthält.\n"
"\n"
"    Standardmäßig wird symbolischen Links gefolgt (Option -L).\n"
"    Das übergeordnete Verzeichnis wird ermittelt, indem der\n"
"    Dateiname am letzten Schrägstrich gekürzt wird, oder es wird der\n"
"    Anfang von DIR verwendet.\n"
"\n"
"    Rückgabewert:\n"
"    Der Rückgabewert ist 0, wenn das Verzeichnis erfolgreich\n"
"    gewechselt wurde, oder wenn die Option -P angegeben und $PWD\n"
"    erfolgreich gesetzt werden konnte. Sonst ist er ungleich 0."

# pwd
#: builtins.c:430
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Gibt den Namen des aktuellen Arbeitsverzeichnisses aus.\n"
"\n"
"    Optionen:\n"
"      -L        Gibt den Inhalt der Variable $PWD aus, wenn sie das aktuelle\n"
"                Arbeitsverzeichnis enthält.\n"
"      -P        Gibt den physischen Verzeichnispfad aus, ohne symbolische\n"
"                Links.\n"
"\n"
"    Standardmäßig wird immer die Option »-L« gesetzt.\n"
"\n"
"    Rückgabewert:\n"
"    Ist 0, außer wenn eine ungültige Option angegeben oder das aktuelle\n"
"    Verzeichnis nicht lesbar ist."

# colon
#: builtins.c:447
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Leeranweisung.\n"
"\n"
"    Leeranweisung; das Kommando hat keine Wirkung.\n"
"\n"
"    Rückgabewert:\n"
"    Das Kommando ist immer »wahr«."

# true
#: builtins.c:458
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Gibt »wahr« zurück.\n"
"    \n"
"    Rückgabewert:\n"
"    Immer »wahr«."

#: builtins.c:467
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Gibt »falsch« zurück.\n"
"    \n"
"    Rückgabewert:\n"
"    Immer »falsch«."

# command
#: builtins.c:476
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a single word indicating the command or filename that\n"
"            invokes COMMAND\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Führt ein einfaches Kommando aus oder zeigt Informationen über Kommandos an.\n"
"\n"
"    Führt das Kommando mit den angegebenen Argumenten aus, ohne\n"
"    Shell-Funktion nachzuschlagen oder zeigt Informationen über die\n"
"    Kommandos an. Dadurch können auch dann Kommandos ausgeführt\n"
"    werden, wenn eine Shell-Funktion gleichen Namens existiert.\n"
"\n"
"    Optionen:\n"
"      -p        Es wird ein Standardwert für PATH verwendet, der garantiert,\n"
"                dass alle Standard-Dienstprogramme gefunden werden.\n"
"      -v        Ausgabe eines einzelnen Worts, welches das Kommando oder\n"
"                den Dateinamen des aufrufenden Kommandos angibt.\n"
"                Ähnlich dem eingebauten Kommando »type«.\n"
"      -V        Eine ausführlichere Beschreibung jedes Kommandos ausgeben.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt den Rückgabewert des Kommandos zurück, oder eine Fehlermeldung, wenn\n"
"    das Kommando nicht gefunden worden ist."

# declare
#: builtins.c:496
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute, except for a,\n"
"    A, and r.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the `local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Setzt Variablenwerte und deren Attribute.\n"
"\n"
"    Deklariert Variablen und weist ihnen Attribute zu. Wenn keine Namen\n"
"    angegeben sind, werden die Attribute und Werte aller Variablen ausgegeben.\n"
"    \n"
"    Optionen:\n"
"      -f        Schränkt Aktionen oder Anzeigen auf Funktionsnamen\n"
"                und Definitionen ein.\n"
"      -F        Zeigt nur Funktionsnamen an (inklusive Zeilennummer\n"
"                und Quelldatei beim Debuggen).\n"
"      -g        Deklariert globale Varieblen innerhalb einer\n"
"                Shellfunktion; wird ansonsten ignoriert.\n"
"      -I        Eine neue lokale Variable erhält die Attribute und Werte der\n"
"                Variable mit gleichen Namen im vorherigen Gültigkeitsbereich. \n"
"      -p        Zeigt die Attribute und Werte jeder angegebenen\n"
"                Variable an.\n"
"\n"
"    Attribute setzen:\n"
"      -a\tDeklariert ein indiziertes Array (wenn unterstützt).\n"
"      -A\tDeklariert ein assoziatives Array (wenn unterstützt).\n"
"      -i\tDeklariert eine ganzzahlige Variable.\n"
"      -l\tKonvertiert die übergebenen Werte zu Kleinbuchstaben.\n"
"      -n\tDer Name wird als Variable interpretiert. \n"
"      -r\tDeklariert nur lesbare Variablen.\n"
"      -t\tWeist das Attribut `trace' zu.\n"
"      -u\tKonvertiert die übergebenen Werte in Großbuchstaben.\n"
"      -x\tExportiert die Variablen.\n"
"\n"
"    Das Voranstellen von `+' anstelle von `-' schaltet die angegebenen\n"
"    Attribute ab, außer für -a, -A und -r.\n"
"\n"
"    Für ganzzahlige Variablen werden bei der Zuweisung arithmetische\n"
"    Berechnungen durchgeführt (siehe `help let').\n"
"\n"
"    Innerhalb einer Funktion werden lokale Variablen erzeugt. Die\n"
"    Option `-g' unterdrückt dieses Verhalten.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt `Erfolg' zurück, außer wenn eine ungültige Option angegeben,\n"
"    wurde oder ein Fehler auftrat."

#: builtins.c:539
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Setzt Variablen Werte und Eigenschaften\n"
"\n"
"    Synonym für »declare«. Siehe »help declare«."

#  local
#: builtins.c:547
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    If any NAME is \"-\", local saves the set of shell options and restores\n"
"    them when the function returns.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Definiert lokale Variablen.\n"
"\n"
"    Erzeugt eine lokale Variable Name und weist ihr den Wert Wert zu.\n"
"    Option kann eine beliebige von »declare« akzeptierte Option sein.\n"
"\n"
"    Wenn ein angagebeber Name \"-\" ist, dann speichert local den Satz\n"
"    der Shell-Optionen, und stellt sie wieder her, wenn die Funktion\n"
"    zurückkehrt.\n"
"    \n"
"    Lokale Variablen können nur innerhalb einer Funktion benutzt\n"
"    werden. Sie sind nur in der sie erzeugenden Funktion und ihren\n"
"    Kindern sichtbar.\n"
"\n"
"    Rückgabewert: \n"
"    Liefert 0 außer bei Angabe einer ungültigen Option, einer\n"
"    fehlerhaften Variablenzuweisung oder dem Aufruf außerhalb einer\n"
"    Funktion."

# echo
#: builtins.c:567
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Ausgabe der Argumente auf die Standardausgabe.\n"
"\n"
"    Zeigt die angegebenen Argumente auf der Standardausgabe an. Diese\n"
"    sind jeweils durch ein Leerzeichen getrennt und mit einem\n"
"    Zeilenumbruch abgeschlossen.\n"
"\n"
"    Optionen:\n"
"      -n\tKeinen Zeilenumbruch anfügen\n"
"      -e\tInterpretation der folgenden Escape-Sequenzen zulassen\n"
"      -E\tKeine Interpretation der Escape-Sequenzen.\n"
"\n"
"    `echo' interpretiert die folgenden Escape-Sequenzen:\n"
"      \a\tAlarm (Glocke)\n"
"      \\b\tRücktaste (Backspace)\n"
"      \\c\tweitere Ausgabe unterdrücken\n"
"      \\e\tEscape-Zeichen\n"
"      \\E\tEscape-Zeichen\n"
"      \\f\tSeitenvorschub\n"
"      \\n\tZeilenumbruch\n"
"      \\r\tWagenrücklauf\n"
"      \\t\tHorizontaler Tabulator\n"
"      \\v\tVertikaler Tabulator\n"
"      \\\\  umgekehrter Schrägstrich (Backslash)\n"
"      \\0nnn\tZeichen mit dem ASCII-Code »NNN« (oktal). »NNN« kann\n"
"    \t\t  aus bis zu drei oktalen Ziffern bestehen.\n"
"      \\xHH\tAcht-Bit-Zeichen mit dem Wert »HH« (hexadezimal). »HH«\n"
"    \t\tkann aus ein oder zwei hexadezimalen Ziffern bestehen.\n"
"      \\uHHHH ein Unicode-Zeichen mit dem Hexadezimalwert HHHH. HHHH kann\n"
"          ein bis vier Zeichen lang sein.\n"
"      \\UHHHHHHHH ein Unicode-Zeichen mit dem Hexadezimalwert HHHHHHHH.\n"
"          HHHHHHHH kann ein bis acht Zeichen lang sein.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt `Erfolg' zurück, außer ein Ausgabefehler tritt auf."

#: builtins.c:607
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Ausgabe der Argumente auf die Standardausgabe.\n"
"\n"
"    Zeigt die Argumente auf der Standardausgabe an, gefolgt von einem\n"
"    Zeilenumbruch.\n"
"\n"
"    Option:\n"
"      -n\tkeinen Zeilenumbruch anfügen.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt »Erfolg« zurück, außer nach einem Schreibfehler."

# enable
#: builtins.c:622
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    On systems with dynamic loading, the shell variable BASH_LOADABLES_PATH\n"
"    defines a search path for the directory containing FILENAMEs that do\n"
"    not contain a slash. It may include \".\" to force a search of the current\n"
"    directory.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Eingebaute Shell-Kommandos aktivieren und deaktivieren.\n"
"\n"
"    Aktiviert und deaktiviert eingebaute Shell-Kommandos. Die Deaktivierung\n"
"    erlaubt Ihnen, eigene Kommandos mit demselben Namen wie die eingebauten\n"
"    Kommandos zu nutzen, ohne den kompletten Pfad angeben zu müssen.\n"
"\n"
"    Optionen:\n"
"      -a\tGibt eine Liste der eingebauten Kommandos aus inklusive der\n"
"        \tInformation, ob sie aktiv sind oder nicht.\n"
"\n"
"      -n\tdeaktiviert jedes angegebene Kommando oder gibt eine\n"
"        \tListe der deaktivierten eingebauten Kommandos aus.\n"
"      -p\tGibt eine Liste der eingebauten Kommandos in einem\n"
"        \twiederverwendbaren Format aus.\n"
"      -s\tGibt nur die Namen der »speziellen« in POSIX eingebauten\n"
"        \tKommandos aus.\n"
"\n"
"    Optionen zum Beeinflussen des dynamischen Ladens:\n"
"      -f\tLädt ein eingebautes Kommando aus der angegebenen Datei.\n"
"      -d\tEntfernt ein mit »-f« geladenes Kommando.\n"
"\n"
"    Ohne Optionen wird jedes angegebene Kommando aktiviert.\n"
"\n"
"    In Systemen, die in der Lage sind, Bibilioteken dynamisch zu laden,\n"
"    enthält die Shell Variable BASH_LOADABLES_PATH den Suchpfad für das\n"
"    Verzeichnis der `Dateinamen', wenn kein absoluter Pfad angegeben ist.\n"
"    Durch Voanstellen eines \".\" wird im aktuellen Verzeichnis gesucht.\n"
"\n"
"    Um das unter $PATH liegende Kommando `test' anstelle der eingebauten\n"
"    Version zu nutzen, muss `enable -n test' eingegeben werden.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt `Erfolg' zurück, außer Name ist kein eingebautes Kommando\n"
"    oder ein Fehler ist aufgetreten."

#: builtins.c:655
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Führt die Argumente als Shellkommando aus.\n"
"\n"
"    Fügt die Argumente zu einer Zeichenkette zusammen und verwendet\n"
"    das Ergebnis als Eingebe in eine Shell, welche die enthaltenen\n"
"    Kommandos ausführt.\n"
"\n"
"    Rückgabewert:\n"
"    Der Status des Kommandos oder Erfolg, wenn das Kommando leer war."

# getopts
#: builtins.c:667
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Verarbeitet Optionsargumente.\n"
"\n"
"    Getopts wird von Shellprozeduren verwendet, um die\n"
"    Kommandozeilenoptionen auszuwerten.\n"
"\n"
"    \"Optionen\" enthält die auszuwertenden Buchstaben. Ein Doppelpunkt\n"
"    nach dem Buchstaben zeigt an, dass ein Argument erwartet wird,\n"
"    welches durch ein Leerzeichen von der Option getrennt ist.\n"
"\n"
"    Bei jedem Aufruf von »getopts« wird die nächste Option der\n"
"    $Variable zugewiesen. Diese wird angelegt, falls sie noch\n"
"    nicht existiert. Weiterhin wird der Index des nächsten zu\n"
"    verarbeitenden Arguments der Shell-Variablen OPTIND\n"
"    zugewiesen. OPTIND wird bei jedem Aufruf einer Shell oder eines\n"
"    Shell-Skripts mit 1 initialisiert. Wenn eine Option ein Argument\n"
"    benötigt, wird dieses OPTARG zugewiesen.\n"
"\n"
"    Für Fehlermeldungen gibt es zwei Varianten. Wenn das erste\n"
"    Zeichen des Optionsstrings ein Doppelpunkt ist, wird der stille\n"
"    Fehlermodus von »getopts« verwendet. In diesem Modus wird keine\n"
"    Fehlermeldung ausgegeben. Wenn eine ungültige Option erkannt wird,\n"
"    wird das gefundene Optionenzeichen OPTARG zugewiesen. Wenn ein\n"
"    benötigtes Argument fehlt, wird ein »:« der Variable zugewiesen\n"
"    und OPTARG auf das gefundene Optionenzeichen gesetzt. Im anderen\n"
"    Fehlermodus wird ein »?« der Variable zugewiesen, OPTARG geleert\n"
"    und eine Fehlermeldung ausgegeben.\n"
"\n"
"    Wenn die Shell-Variable OPTERR den Wert »0« hat, werden durch getopts\n"
"    keine Fehlermeldungen ausgegeben, auch wenn das erste Zeichen\n"
"    von OPTSTRING kein Doppelpunkt ist. OPTERR hat den Vorgabewert »1«.\n"
"\n"
"    Wenn im Aufruf von »getops« die »Argumente« angegeben sind, werden diese\n"
"    verarbeitet. Ansonsten werden die von der Position abhängigen\n"
"    Parameter ($1, $2, etc.) verarbeitet.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt »Erfolg« zurück wenn eine Option gefunden wird und\n"
"    »gescheitert«, wenn das Ende der Optionen erreicht oder ein Fehler\n"
"    aufgetreten ist."

# exec
#: builtins.c:709
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error occurs."
msgstr ""
"Ersetzt die Shell durch das angegebene Kommando.\n"
"\n"
"    Führt das angegebene Kommando einschließlich dessen Optionen an\n"
"    Stelle der Shell aus. Wenn kein Kommando angegeben ist, wirken\n"
"    alle Weiterleitungen für die aktuellen Shell.\n"
"\n"
"    Optionen:\n"
"      -a Name\tSetzt den Namen als nulltes Argument für das Kommando.\n"
"      -c\tFührt das Kommando in einer leeren Umgebung aus.\n"
"      -l\tSetzt einen Strich in das nullte Argument für das Kommando.\n"
"\n"
"    Wenn das Kommando nicht ausgeführt werden kann, wird eine nicht\n"
"    interaktive Shell beendet, außer die Shell-Option »execfail« ist\n"
"    gesetzt.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt »Erfolg« zurück, außer das Kommando wurde nicht gefunden oder\n"
"    ein Weiterleitungsfehler trat auf."

# exit
#: builtins.c:730
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Beendet die aktuelle Shell.\n"
"\n"
"    Beendet die aktuelle Shell mit dem Rückgabewert N. Wenn N nicht angegeben\n"
"    ist, wird der Rückgabewert des letzten ausgeführten Kommandos übernommen."

# logout
#: builtins.c:739
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not executed\n"
"    in a login shell."
msgstr ""
"Beendet eine Login-Shell.\n"
"\n"
"    Beendet eine Login-Shell mit dem Rückgabewert »n«. Wenn logout\n"
"    nicht von einer Login-Shell aus ausgeführt wurde, wird ein Fehler\n"
"    zurückgegeben."

# fc
#: builtins.c:749
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    The history builtin also operates on the history list.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error occurs."
msgstr ""
"Anzeigen oder Ausführen von Befehlen aus der History-Liste.\n"
"    \n"
"    fc wird verwendet, um Befehle aus der History-Liste aufzulisten,\n"
"    zu bearbeiten und erneut auszuführen.  `Anfang' und `Ende' können\n"
"    Zahlen sein, die den Bereich angeben. `Anfang' kann auch eine\n"
"    Zeichenkette sein, welche den letzten Befehl, der mit dieser\n"
"    Zeichenfolge beginnt, bezeichnet.\n"
"    \n"
"    Optionen:\n"
"      -e `Editor' Der zu verwendende Editor.  Standard sind FCEDIT,\n"
"         dann EDITOR, dann vi.\n"
"      -l Zeilen auflisten statt bearbeiten.\n"
"      -n Zeilennummern beim Auflisten weglassen.\n"
"      -r kehrt die Reihenfolge der Zeilen um (die neuesten Zeilen zuerst).\n"
"    \n"
"    Mit `fc -s [Muster=Ersetzung ...] [Kommando]' wird das `Kommando' erneut\n"
"    ausgeführt, nachdem die Ersetzung Alt=Neu durchgeführt wurde.\n"
"    \n"
"    Ein nützlicher Alias ist r='fc -s', so dass die Eingabe von `r cc'\n"
"    den letzten Befehl ausführt, der mit \"cc\" beginnt, und damit die\n"
"    Eingabe von \"r\" den letzten Befehl erneut ausführt.\n"
"    \n"
"    Die `history' Funktion wirkt ebenfalls auf die History-Liste.\n"
"    \n"
"    Exit-Status:\n"
"    Gibt den Erfolg oder den Status des ausgeführten Befehls zurück;\n"
"    ungleich Null, wenn ein Fehler auftritt."

#: builtins.c:781
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Bringt einen Job in den Vordergrund.\n"
"\n"
"    Bringt den mit JOB_SPEC bezeichneten Prozess als aktuellen Job in den\n"
"    Vordergrund. Wenn JOB_SPEC nicht angegeben ist, wird der zuletzt\n"
"    angehaltene Job verwendet.\n"
"\n"
"    Rückgabewert:\n"
"    Status des in den Vordergrund geholten Jobs oder Fehler."

#: builtins.c:796
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Bringt einen Job in den Hintergrund.\n"
"\n"
"    Bringt den mit JOB_SPEC bezeichneten Job in den Hintergrund,\n"
"    als ob er mit »&« gestartet wurde.\n"
"\n"
"    Rückgabewert:\n"
"    Immer Erfolg, außer wenn die Jobsteuerung nicht verfügbar ist\n"
"    oder ein Fehler auftritt."

# hash
#: builtins.c:810
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Programpfade merken oder anzeigen.\n"
"    \n"
"    Ermittelt und speichert den vollständigen Pfadnamen jedes\n"
"    Kommandos NAME.  Wenn keine Argumente angegeben werden, werden\n"
"    Informationen über gespeicherte Kommandod angezeigt.\n"
"    \n"
"    Optionen:\n"
"      -d Vergessen des Speicherortes für jeden NAME\n"
"      -l Anzeige in einem Format, das als Eingabe wiederverwendet werden kann\n"
"      -p Pfadname verwendet PATHNAME als den vollständigen Pfadnamen von NAME\n"
"      -r vergisst alle gespeicherten Pfade\n"
"      \n"
"      -t gibt den Speicherort jedes NAMENS aus, wobei jedem\n"
"         Speicherort der entsprechende NAME vorangestellt wird,\n"
"         wenn mehrere NAMEs angegeben sind\n"
"                \n"
"    Argumente:\n"
"        NAME    Jeder NAME wird in $PATH gesucht und in die Liste\n"
"        der gespeicherten Befehle hinzugefügt.\n"
"    \n"
"    Exit-Status:\n"
"    Gibt Erfolg zurück, es sei denn, NAME wird nicht gefunden oder es\n"
"    wird eine ungültige Option angegeben."

# help
#: builtins.c:835
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is given."
msgstr ""
"Informationen zu eingebauten Kommandos.\n"
"\n"
"    Zeigt kurze Informationen zu eingebauten Kommandos an. Wenn ein\n"
"    Muster angegeben ist, dann wird eine ausführliche Anleitung zu\n"
"    allen Kommandos mit zutreffendem Muster angezeigt. Sonst wird die\n"
"    Liste der Hilfethemen ausgegeben.\n"
"\n"
"    Optionen:\n"
"      -d\tKurzbeschreibung für jedes Thema\n"
"      -m\tAnzeige im Manpage-Format.\n"
"      -s\tGibt eine kurze Zusammenfassung für jedes angegebene\n"
"        \tangegebene Thema aus\n"
"\n"
"    Argumente:\n"
"      Muster\tDas gesuchte Hilfetheme\n"
"\n"
"    Rückgabestatus:\n"
"    Erfolg, außer wenn das Muster nicht gefunden oder eine ungültige Option\n"
"    angegeben wurde."

# history
#: builtins.c:859
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"      -d start-end\tdelete the history entries beginning at position START\n"
"    \t\tthrough position END.\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used. If FILENAME is not supplied\n"
"    and HISTFILE is unset or null, the -a, -n, -r, and -w options have\n"
"    no effect and return success.\n"
"    \n"
"    The fc builtin also operates on the history list.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Zeigt oder bearbeitet die History-Liste.\n"
"    \n"
"    Zeigt die History-Liste mit Zeilennummern an und stellt jedem\n"
"    geänderten Eintrag ein `*' voran.  Ein Argument `n'\n"
"    listet nur die letzten N Einträge auf.\n"
"    \n"
"    Optionen:\n"
"      -c Bereinigt die History-Liste, indem alle Einträge gelöscht werden.\n"
"      -d Offset löscht den Eintrag an der angegebenen Position.\n"
"         Negative Offsets zählen vom Listenende.\n"
"      -d Beginn-Ende\tLöscht die Listeneinträge von Beginn bis Ende.\n"
"      -a Anhängen des Verlaufs dieser Sitzung an die History-Datei.\n"
"      -n alle nicht bereits aus der History-Datei gelesenen Einträge\n"
"         an die History-Liste anhängen.\n"
"      -r Inhalt der History-Datei an die History-Liste anhängen.\n"
"      -w Schreibt den aktuellen Verlauf in die History-Datei.\n"
"      -p Führt eine History-Erweiterung für jedes `Argument' durch und zeigt\n"
"         das Ergebnis an, ohne es in die History-Liste einzutragen.\n"
"      -s Das `Argument' einzelnen Eintrag an die History-Liste anhängen.\n"
"    \n"
"    Wenn ein `Dateiname' angegeben ist, wird dieser als History-Datei verwendet.\n"
"    Sonst wird der Wert aus HISTFILE verwendet. Wenn weder ein `Dateiname'\n"
"    angegeben ist und HISTFILE nicht zugewiesen worde oder null ist, dann\n"
"    habe die -a, -n, -r und -w Optionen keinen Effekt und liefern `Erfolg'\n"
"    zurück.\n"
"    \n"
"    Die `fc' Funktion wirkt ebenfalls suf die History-Liste.\n"
"    \n"
"    Wenn die Variable HISTTIMEFORMAT gesetzt und nicht null ist, wird\n"
"    ihr Wert als Formatierungszeichenfolge für strftime(3) verwendet,\n"
"    um einen Zeitstempel für jeden angezeigten History-Eintrag zu drucken.\n"
"    Sonst wird kein Zeitstempel ausgegeben.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt `Erfolg' zurück, es sei denn, es wurde eine ungültige\n"
"    Option angegeben oder es ist ein Fehler aufgetreten."

# jobs
#: builtins.c:902
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Auftragstatus anzeigen.\n"
"    \n"
"    Listet die aktiven Aufträge auf.  JOBSPEC schränkt die Ausgabe auf\n"
"    diesen Auftrag ein.  Ohne Optionen werden die Status der aktiven\n"
"    Aufträge angezeigt.\n"
"    \n"
"    Optionen:\n"
"      -l zeigt zusätzlich auch die Prozessnummern an.\n"
"      -n zeigt nur die Prozesse an, deren Status sich seit der letzten\n"
"         Benachrichtigung geändert haben.\n"
"      -p zeigt nur Prozessnummern an.\n"
"      -r zeigt nur laufende Aufträge an.\n"
"      -s zeigt nur gestoppte Aufträge an\n"
"    \n"
"    Mit der Option -x wird COMMAND ausgeführt, nachdem alle in ARGS\n"
"    enthaltenen Auftragsspezifikationen durch die zugehörigen\n"
"    Prozesnummern ersetzt worden sind.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt einen Erfolg zurück, es sei denn, es wurde eine ungültige\n"
"    Option angegeben oder es ist ein Fehler aufgetreten.  Wenn -x\n"
"    verwendet wird, wird der Rückgebewert von COMMAND zurückgegeben."

# disown
#: builtins.c:929
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Entfernt Aufträge aus der aktuellen Shell.\n"
"    \n"
"    Entfernt jedes JOBSPEC-Argument aus der Tabelle der aktiven\n"
"    Aufträge. Ohne JOBSPECs verwendet die Shell ihre Vorstellung vom\n"
"    aktuellen Auftrag.\n"
"    \n"
"    Optionen:\n"
"      -a entfernt alle Aufträge, wenn JOBSPEC nicht angegeben wird.\n"
"      -h JOBSPEC maskieren, so dass der Auftrag kein SIGHUP erhält,\n"
"         wenn die Shell ein SIGHUP empfängt.\n"
"      -r entfernt nur laufende Aufträge.\n"
"    \n"
"    Beenden Status:\n"
"    Gibt Erfolg zurück, außer wenn eine ungültige Option oder\n"
"    JOBSPEC angegeben wurde."

# kill
#: builtins.c:948
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Sendet ein Signal an einen Auftrag.\n"
"    \n"
"    Sendet den durch PID oder JOBSPEC identifizierten Prozessen das\n"
"    mit SIGSPEC oder SIGNUM anggebene Signal. Wenn weder SIGSPEC\n"
"    noch SIGNUM angegeben sind, dann wird wird SIGTERM gesendet.\n"
"    \n"
"    Optionen:\n"
"      -s sig SIG ist ein Signalname.\n"
"      -n sig SIG ist eine Signalnummer.\n"
"      -l listet die Signalnamen auf. Wenn Argumente auf `-l' folgen,\n"
"         werden für diese Signalnummern die Namen aufgelistet.\n"
"      -L Synonym für -l.\n"
"    \n"
"    Kill ist ein in die Shell eingebaute Funktion, da diese erlaubt,\n"
"    Auftrags- statt Prozessnummern anzugeben. Weierhin kann Kill\n"
"    Prozesse auch dann beenden, wenn die maximal erlaubte\n"
"    Prozessanzahl erreicht ist.\n"
"    \n"
"    Exit-Status:\n"
"    Gibt Erfolg zurück, es sei denn, es wurde eine ungültige Option\n"
"    angegeben oder es ist ein Fehler aufgetreten."

#: builtins.c:972
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Auswerten arithmetischer Ausdrücke.\n"
"    \n"
"    Jedes ARG wird als arithmetischer Ausdruck ausgewertet.  Die\n"
"    Auswertung erfolgt in Ganzzahlen mit fester Breite ohne\n"
"    Überprüfung auf Überlauf. Division durch 0 wird abgefangen und als\n"
"    Fehler gekennzeichnet.  Die folgende Liste von Operatoren ist in\n"
"    abnehmender Präferenz nach gleichrangigen Operatoren gruppiert.\n"
"    \n"
"    \tid++, id-- Variable post-increment, post-decrement\n"
"    \t++id, --id Variable pre-increment, pre-decrement\n"
"    \t-, + unäres Minus, Plus\n"
"    \t!, ~ logische und bitweise Negation\n"
"    \t** Potenzierung\n"
"    \t*, /, % Multiplikation, Division, Rest\n"
"    \t+, - Addition, Subtraktion\n"
"    \t<<, >> bitweise Links- und Rechtsverschiebung\n"
"    \t<=, >=, <, > Vergleich\n"
"    \t==, != Gleichheit, Ungleichheit\n"
"    \t& bitweises UND\n"
"    \t^ bitweises XOR\n"
"    \t| bitweises ODER\n"
"    \t&& logisches UND\n"
"    \t|| logisches OR\n"
"    \texpr ? expr : expr\n"
"               Bedingte Ausführung\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |= Zuweisung\n"
"    \n"
"    Shell-Variablen sind als Operanden zulässig. Der Variablenname\n"
"    wird innerhalb eines Ausdrucks durch seinen Wert (der in eine\n"
"    Ganzzahl mit fester Breite umgewandelt wird) ersetzt.  Das\n"
"    Integer-Attribut der Variablen muss nicht eingeschaltet sein, um\n"
"    in einem Ausdruck verwendet zu werden.\n"
"    \n"
"    Die Operatoren werden in der Reihenfolge ihres Vorrangs\n"
"    ausgewertet. Unterausdrücke in Klammern werden zuerst ausgewertet\n"
"    und können die obigen Rangfolge Regeln außer Kraft setzen.\n"
"    \n"
"    Rückgabewert:\n"
"    Wenn der letzte ARG 0 ergibt, gibt let 1 zurück; andernfalls gibt let 0 zurück."

# read
#: builtins.c:1017
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as word\n"
"    delimiters. By default, the backslash character escapes delimiter characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -E\tuse Readline to obtain the line and use the bash default\n"
"    \t\tcompletion instead of Readline's default completion\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times out\n"
"    (in which case it's greater than 128), a variable assignment error occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Liest eine Zeile von der Standardeingabe und teilt sie in Felder auf.\n"
"    \n"
"    Liest eine Zeile von der Standardeingabe oder, mit der Option -u, dem\n"
"    Dateideskriptor FD. Die Zeile wird ähnlich der Wortaufteilung in Felder\n"
"    geteilt, und in der angegebenen Reihenfolge den Namen zugewiesen.\n"
"    Überzählige Felder werden dem letzten Namen zugewiesen. Die in $IFS\n"
"    enthaltenen Zeichen werden als Trennzeichen verwendet.\n"
"    \n"
"    Wenn keine NAMEn angegeben werden, wird die gelesene Zeile in der\n"
"    REPLY-Variablen gespeichert.\n"
"    \n"
"    Optionen:\n"
"      -a Feld\tWeist die gelesenen Wörter mit aufeinanderfolgenden\n"
"      \t\tIndizes mit Null beginnend der Array-Variable `Array' zu.\n"
"      -d Begrenzer\tBis zum ersten Zeichen von `Begrenzer' lesen, statt\n"
"      \t\tstatt bis zum Zeilenende.\n"
"      -e\tReadline verwenden, um die Zeile zu lesen.\n"
"      -E\tReadline verwenden die Zeile zu lesen, aber die Vervollständigung\n"
"    \t\tder Bash anstatt der von Readline benutzen.\n"
"      -i Text\t`Text' als Anfangstext für Readline verwenden.\n"
"      -n Zeichenenzahl\tLiest maximal so viele Zeichen bis zu einem, ohne ein Zeilenumbruch\n"
"    \t\tzu berücksichtigen. Worttrennzeichen werden ausgewertet.\n"
"      -N nchars Liest genau NCHARS Zeichen, bis EOF oder einer\n"
"    \t\tZeitüberschreitung. Worttrennzeichen werden ignoriert.\n"
"      -p prompt Gibt vor dem Lesen die Zeichenkette PROMPT ohne einen\n"
"    \t\tabschließenden Zeilenumbruch aus.\n"
"      -r        lässt keine Backslashes als Escape-Zeichen zu\n"
"      -s        keine Echo-Eingabe von einem Terminal\n"
"      -t timeout\n"
"                Zeitüberschreitung und Rückgabe eines Fehlers, wenn\n"
"    \t\teine vollständige Eingabezeile nicht innerhalb von\n"
"    \t\tTIMEOUT Sekunden gelesen wird. Die TMOUT Variable\n"
"    \t\tenthält das Standard-Timeout.  TIMEOUT kann als\n"
"    \t\tBruchteil angegeben werden.  Wenn TIMEOUT gleich 0\n"
"    \t\tist, werden keine daten geleden und gibt Erfolg\n"
"    \t\tzurück, wenn Daten dem angegebenen Dateideskriptor\n"
"    \t\tverfügbar sind.  Der Rückgabewert ist größer als 128,\n"
"    \t\twenn die Zeitüberschreitung abgelaufen ist.\n"
"      -u fd Lesen von Dateideskriptor FD statt von der Standardeingabe\n"
"    \n"
"    Rückgabewert: \n"
"    Der Rückgabewert ist Null. Es sei denn, das Dateiende wurde\n"
"    erreicht, die Lesezeit überschritten (in diesem Fall ist er größer\n"
"    als 128), ein Variablenzuweisungsfehler tritt auf oder ein\n"
"    ungültiger Dateideskriptor wurde als Argument von -u übergeben."

#: builtins.c:1067
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Rückkehr aus einer Shell-Funktion.\n"
"    \n"
"    Bewirkt, dass eine Funktion oder ein geladenes Skript mit dem\n"
"    durch N angegebenen Rückgabewert beendet wird.  Wenn N weggelassen\n"
"    wird, wird als Rückgabewert der des zuletzt ausgeführten Befehls\n"
"    verwendet.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt N zurück, oder einen Fehler, wenn return außerhalb einer Funktion\n"
"    oder Skript aufgerufen wird."

# set
#: builtins.c:1080
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    If -o is supplied with no option-name, set prints the current shell\n"
"    option settings. If +o is supplied with no option-name, set prints a\n"
"    series of set commands to recreate the current option settings.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Setzen oder Aufheben von Shell-Optionen und Positionsparametern.\n"
"    \n"
"    Den Wert von Shell-Attributen und Positionsparametern ändern, oder\n"
"    die Namen und Werte von Shell-Variablen anzeigen.\n"
"    \n"
"    Optionen:\n"
"      -a Markieren von Variablen die geändert oder erstellt wurden, für den Export.\n"
"      -b Sofortige Benachrichtigung über das Auftragsende.\n"
"      -e Sofortiger Abbruch, wenn ein Befehl mit einem Status ungleich Null beendet wird.\n"
"      -f Deaktiviert das Generieren von Dateinamen (globbing).\n"
"      -h Merkt sich den Speicherort von Befehlen, wenn sie nachgeschlagen werden.\n"
"      -k Alle Zuweisungsargumente werden in die Umgebung für einen\n"
"         Befehl in die Umgebung aufgenommen, nicht nur diejenigen,\n"
"         die dem Befehl vorangestellt sind.\n"
"      -m Die Auftragskontrolle ist aktiviert.\n"
"      -n Befehle lesen, aber nicht ausführen.\n"
"      -o Optionsname\n"
"          Setzt die Variable, die dem Optionsname entspricht:\n"
"              allexport wie -a\n"
"              braceexpand wie -B\n"
"              emacs verwendet eine emacsähnliche Schnittstelle zur Zeilenbearbeitung\n"
"              errexit gleich wie -e\n"
"              errtrace dasselbe wie -E\n"
"              functrace dasselbe wie -T\n"
"              hashall dasselbe wie -h\n"
"              histexpand gleich wie -H\n"
"              history Befehlshistorie aktivieren\n"
"              ignoreeof die Shell wird beim Lesen von EOF nicht beendet\n"
"              interaktive-Kommentare\n"
"                           erlaubt das Erscheinen von Kommentaren in interaktiven Befehlen\n"
"              keyword dasselbe wie -k\n"
"              monitor gleich wie -m\n"
"              noclobber dasselbe wie -C\n"
"              noexec gleich wie -n\n"
"              noglob gleich wie -f\n"
"              nolog wird derzeit akzeptiert, aber ignoriert\n"
"              notify gleich wie -b\n"
"              nounset dasselbe wie -u\n"
"              onecmd dasselbe wie -t\n"
"              physical wie -P\n"
"              pipefail der Rückgabewert einer Pipeline ist der Status\n"
"                       des des letzten Befehls, der mit einem Status\n"
"                       ungleich Null beendet wurde, oder Null, wenn\n"
"                       kein Befehl mit einem Status ungleich Null\n"
"                       beendet wurde.\n"
"             posix     Ändert das Verhalten der Bash, wo sie vom\n"
"                       Posix-Standard abweicht, dass sie mit dem\n"
"                       Standard übereinstimmt.\n"
"              privilegiert gleich wie -p\n"
"              verbose dasselbe wie -v\n"
"              vi eine vi-ähnliche Schnittstelle zur Zeilenbearbeitung verwenden\n"
"              xtrace dasselbe wie -x\n"
"      -p Wird eingeschaltet, wenn die realen und effektiven\n"
"         Benutzerkennungen nicht übereinstimmen.  Deaktiviert die\n"
"         Verarbeitung der $ENV-Datei und das Importieren von Shell\n"
"         Funktionen.  Wenn diese Option ausgeschalten ist, werden die\n"
"         effektive uid und gid auf die reale uid und gid gesetzt. \n"
"      -t Beenden nach dem Lesen und Ausführen eines Befehls.\n"
"      -u Nicht gesetzte Variablen beim Substituieren als Fehler behandeln.\n"
"      -v Shell-Eingabezeilen ausgeben, wenn sie gelesen werden.\n"
"      -x Befehle und ihre Argumente ausgeben, wenn sie ausgeführt werden.\n"
"      -B Die Shell führt eine Klammererweiterung durch\n"
"      -C Dateien werden bei Ausgabeumleitung nicht überschrieben.\n"
"      -E Wenn gesetzt, wird die Fehlerfalle (trap) an Shell-Funktionen vererbt.\n"
"      -H Aktiviert die !-Stil Verlaufsersetzung.  Diese Option ist\n"
"         bei einer interaktiven Shell standardmäßig aktiviert.\n"
"      -P Symbolische Links werden nicht aufgelöst, wenn Befehle wie\n"
"         z.B. cd, das aktuelle Verzeichnis ändern.\n"
"      -T DEBUG und RETURN Fallen (trap) werden an Shellfunktionen vererbt.\n"
"      -- Weist alle verbleibenden Argumente den Positionsparametern\n"
"         zu.  Sind keine Argumente verblieben, werden die\n"
"         Positionsparameter nicht gesetzt.\n"
"      - Weist alle verbleibenden Argumente den Positionsparametern zu.\n"
"        Die Optionen -x und -v sind ausgeschaltet.\n"
"    \n"
"    Wenn -o ohne Optionsname angegeben ist, werden die gegenwärtig aktiven\n"
"    Einstellungen der Shell ausgegeben. Wenn +o ohne Optionsname angegeben\n"
"    ist, wird eine Serie von Kommandos ausgegeben, mit der die gegenwärtig\n"
"    aktiven Optionseinstellungen wiederhergestellt werden können.\n"
"    \n"
"    Durch Verwenden von + anstelle von - werden Option ausgeschaltet.\n"
"    Die Optionen können auch beim Shellaufruf verwendet werden.  Die\n"
"    aktuelle aktiven Optionen sind in $- gespeichert.  Die restlichen\n"
"    n ARGs sind positionale Parameter und werden der Reihe nach $1,\n"
"    $2, ... $n zugewiesen.  Wenn keine ARGs angegeben werden, werden\n"
"    alle Shell-Variablen ausgegeben.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt Erfolg zurück, es sei denn, eine ungültige Option wurde angegeben."

# unset
#: builtins.c:1169
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Zurücksetzen der Werte und Attribute von Variablen und Funktionen.\n"
"    \n"
"     Entfernt für jeden NAMEN die entsprechende Variable oder Funktion.\n"
"    \n"
"     Optionen:\n"
"       -f behandelt jeden NAMEN als Shell-Funktion\n"
"       -v behandelt jeden NAMEN als Shell-Variable\n"
"       -n behandelt jeden NAMEN als Namensreferenz und setzt diese\n"
"          Variable zurück, statt der Variable, auf die es verweist\n"
"    \n"
"     Ohne Angabe einer Optionen versucht unset zunächst, eine Variable\n"
"     zu deaktivieren. Wenn dies fehlschlägt, versucht, eine Funktion zu\n"
"     deaktivieren.\n"
"    \n"
"     Einige Variablen können nicht deaktiviert werden. Siehe auch\n"
"     „schreibgeschützt“.\n"
"    \n"
"     Rückgabewert:\n"
"     Gibt Erfolg zurück, wenn keine ungültige Option oder ein\n"
"     schreibgeschützter NAME angegeben worden ist."

# export
#: builtins.c:1191
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables or functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Exportattribut für Variablen setzen.\n"
"    \n"
"     Markiert jeden Namen für den Export in die Umgebung der später\n"
"     ausgeführte Befehle. Wenn ein Wert angegeben ist, wird dieser der\n"
"     Variablen vor den Exportieren zugewiesen.\n"
"    \n"
"     Optionen:\n"
"       -f\tBezieht sich auf Shellfunktionen.\n"
"       -n\tEntfernt die Exporteigenschaft für jeden Namen.\n"
"       -p\tZeigt die exportierten Variablen und Funktionen an.\n"
"    \n"
"     Das Argument „--“ beendet die weitere Optionsverarbeitung.\n"
"    \n"
"     Rückgabewert:\n"
"     Gibt Erfolg zurück, wenn keine ungültige Option oder Name angegeben\n"
"     worden ist."

# readonly
#: builtins.c:1210
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Markiert Shellvariablen als unveränderlich.\n"
"    \n"
"     Mariert jeden angegebenen Namen als schreibgeschützt. Deren Werte\n"
"     können nicht mehr geändert werden. Wenn ein Wert angegeben ist,\n"
"     wird er den Variablen vor dem Schreibschützen zugewiesen.\n"
"    \n"
"     Optionen:\n"
"       -a bezieht sich auf indizierte Arrayvariablen\n"
"       -A bezieht sich auf assoziative Arrayvariablen\n"
"       -f bezieht sich auf Shellfunktionen\n"
"       -p zeigt eine Liste aller schreibgeschützten Variablen oder\n"
"          Funktionen an, abhängig davon, ob die Option -f angegeben ist\n"
"          oder nicht\n"
"    \n"
"     Das Argument „--“ beendet die weitere Optionsverarbeitung.\n"
"    \n"
"     Rückgabewert:\n"
"     Gibt Erfolg zurück, wenn keine ungültige Option angegeben und\n"
"     der Name gültig ist."

# shift
#: builtins.c:1232
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Verschiebt Positionsparameter.\n"
"    \n"
"    Benennt die Positionsparameter $N+1,$N+2 ... in $1,$2 ... um. Wenn N\n"
"    nicht angegeben ist, wird 1 verwendet.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt Erfolg zurück, wenn N positiv und kleiner gleich $# ist."

#: builtins.c:1244 builtins.c:1260
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell. If the\n"
"    -p option is supplied, the PATH argument is treated as a colon-\n"
"    separated list of directories to search for FILENAME. If -p is not\n"
"    supplied, $PATH is searched to find FILENAME. If any ARGUMENTS are\n"
"    supplied, they become the positional parameters when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Führt Befehle einer Datei in der aktuellen Shell aus.\n"
"\n"
"    Führt die Befehle in der angegebenen Datei in der aktuellen Shell aus.\n"
"    Mit der `-p' Option wird dessen Argument als mit Doppelpunkten\n"
"    getrennte Verzeichnisliste behandelt, in denen nach der Datei gesucht\n"
"    werden soll. Sonst wird der Standardsuchpfad durchsucht. Eventuell\n"
"    angegebene Argumente werden als Positionsparameter an die Datei\n"
"    übergeben.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt den Status des letzten in ausgeführten Befehls zurück, oder\n"
"    `Fehler', wenn die Datei nicht gelesen werden konnte."

# suspend
#: builtins.c:1277
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells and shells without job control cannot be\n"
"    suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell or job\n"
"    \t\tcontrol is not enabled.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Shell-Ausführung  aussetzen.\n"
"    \n"
"     Hält die die Shell so lange an, bis sie wieder ein SIGCONT-Signal empfängt.\n"
"     Anmelde-Shells und Shells ohne Jobsteuerung können nur ausgesetzt\n"
"     werden, wenn dies erzwungen wird.\n"
"    \n"
"     Optionen:\n"
"       -f erzwingt das Anhalten für eine Loginshell.\n"
"    \n"
"     Exit-Status:\n"
"     Gibt Erfolg zurück, außer bei inaktiver Jobsteuerung oder einem anderen\n"
"     Fehler."

# test
#: builtins.c:1295
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Bedingten Ausdruck auswerten.\n"
"    \n"
"     Gibt den Status 0 (wahr) oder 1 (falsch) abhängig vom Ergebnis des\n"
"     Ausdrucks zurück. Die Ausdrücke können unär oder binär sein. Unäre\n"
"     Ausdrücke werden häufig verwendet, um den Dateistatus zu ermitteln.\n"
"     Es gibt weiterhin Zeichenketten und numerische Vergeichsoperatoren.\n"
"    \n"
"     Das Verhalten hängt von der Argumentanzahl ab. Die bash\n"
"     Handbuchseite enthält deren vollständige Beschreibung.\n"
"    \n"
"     Dateioperatoren:\n"
"    \n"
"       -a Datei Wahr, wenn die Datei vorhanden ist.\n"
"       -b Datei Wahr, wenn die Datei ein Blockgerät ist.\n"
"       -c Datei Wahr, wenn die Datei ein zeichenorientiertes Gerät ist.\n"
"       -d Datei Wahr, wenn die Datei ein Verzeichnis ist.\n"
"       -e Datei Wahr, wenn die Datei vorhanden ist.\n"
"       -f Datei Wahr, wenn die Datei existiert und eine reguläre Datei ist.\n"
"       -g Datei Wahr, wenn das SetGID-Bit der Datei gesetzt ist.\n"
"       -h Datei Wahr, wenn die Datei ein symbolischer Link ist.\n"
"       -L Datei Wahr, wenn die Datei ein symbolischer Link ist.\n"
"       -k Datei Wahr, wenn für die Datei das „Sticky“-Bit gesetzt ist.\n"
"       -p Datei Wahr, wenn die Datei eine Named Pipe ist.\n"
"       -r Datei Wahr, wenn die Datei für den aktuellen Nutzer lesbar ist.\n"
"       -s Datei Wahr, wenn die Datei existiert und nicht leer ist.\n"
"       -S Datei Wahr, wenn die Datei ein Socket ist.\n"
"       -t FD    Wahr, wenn FD auf einem Terminal geöffnet ist.\n"
"       -u Datei Wahr, wenn das SetUID-Bit der Datei gesetzt ist.\n"
"       -w Datei Wahr, wenn die Datei für den aktuellen Nutzer schreibbar ist.\n"
"       -x Datei Wahr, wenn die Datei vom aktuellen Nutzer ausführbar ist.\n"
"       -O Datei Wahr, wenn die Datei dem aktuellen Nutzer gehört.\n"
"       -G Datei Wahr, wenn die Datei der aktuellen Gruppe gehört.\n"
"       -N Datei Wahr, wenn die Datei seit dem letzten Lesen geändert wurde.\n"
"    \n"
"       Datei1 -nt Datei2 Wahr, wenn Datei1 neuer als Datei2 ist (gemäß\n"
"                      Änderungsdatum).\n"
"    \n"
"       Datei1 -ot Datei2 Wahr, wenn Datei1 älter als Datei2 ist.\n"
"    \n"
"       Datei1 -ef Datei2 Wahr, wenn Datei1 ein harter Link zu Datei2 ist.\n"
"    \n"
"     Zeichenkettenoperatoren:\n"
"    \n"
"       -z STRING Wahr, wenn die Zeichenkette leer ist.\n"
"    \n"
"       -n STRING\n"
"          STRING Wahr, wenn die Zeichenkette nicht leer ist.\n"
"    \n"
"       STRING1 = STRING2\n"
"                      Wahr, wenn die Zeichenketten gleich sind.\n"
"       STRING1 != STRING2\n"
"                      Wahr, wenn die Zeichenketten nicht gleich sind.\n"
"       STRING1 < STRING2\n"
"                      Wahr, wenn STRING1 lexikografisch vor STRING2\n"
"                      sortiert wird.\n"
"       STRING1 > STRING2\n"
"                      Wahr, wenn STRING1 lexikografisch nach STRING2\n"
"                      sortiert wird.\n"
"    \n"
"     Andere Operatoren:\n"
"    \n"
"       -o OPTION Wahr, wenn die Shell-Option OPTION aktiviert ist.\n"
"       -v VAR    Wahr, wenn die Shell-Variable VAR gesetzt ist.\n"
"       -R VAR    Wahr, wenn die Variable gesetzt ist und ein Nameref ist.\n"
"       ! EXPR    Wahr, wenn Ausdruck falsch ist.\n"
"       EXPR1 -a EXPR2 Wahr, wenn sowohl expr1 als auch expr2 wahr sind.\n"
"       EXPR1 -o EXPR2 Wahr, wenn entweder expr1 ODER expr2 wahr ist.\n"
"    \n"
"       arg1 OP arg2 Arithmetische Tests. OP ist eines von -eq, -ne,\n"
"                      -lt, -le, -gt oder -ge.\n"
"    \n"
"     Arithmetische binäre Operatoren geben „Wahr“ zurück, wenn ARG1\n"
"     gleich, ungleich oder kleiner als, kleiner als oder gleich,\n"
"     größer als oder größer als oder gleich als ARG2 ist.\n"
"    \n"
"     Rückgabewert:\n"
"     Gibt Erfolg zurück, wenn der Ausdruck als wahr ausgewertet wird.\n"
"     Er gibt Falsch zurück, wenn der Ausdruck zu Falsch ausgewertet\n"
"     oder ein ungültiges Argument angegeben wird."

# [
#: builtins.c:1377
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Wertet einen bedingten Ausdruck aus.\n"
"\n"
"    Dieses Kommando entspricht dem Kommando »test«. Jedoch muss das\n"
"    letzte Argument ein »]« sein, welches die öffnende Klammer »[«\n"
"    schließt."

# times
#: builtins.c:1386
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Zeigt den Zeitverbrauch an.\n"
"\n"
"    Gibt den kumulierte Nutzer- und Systemzeitverbrauch der Shell und\n"
"    aller von ihr gestarteten Prozesse aus.\n"
"\n"
"    Rückgabewert:\n"
"    Immer 0."

#: builtins.c:1398
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives signals\n"
"    or other conditions.\n"
"    \n"
"    ACTION is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ACTION is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ACTION is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ACTION is executed on exit from the shell.\n"
"    If a SIGNAL_SPEC is DEBUG, ACTION is executed before every simple command\n"
"    and selected other commands. If a SIGNAL_SPEC is RETURN, ACTION is\n"
"    executed each time a shell function or a script run by the . or source\n"
"    builtins finishes executing.  A SIGNAL_SPEC of ERR means to execute ACTION\n"
"    each time a command's failure would cause the shell to exit when the -e\n"
"    option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands associated\n"
"    with each trapped signal in a form that may be reused as shell input to\n"
"    restore the same signal dispositions.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC in a\n"
"    \t\tform that may be reused as shell input; or for all trapped\n"
"    \t\tsignals if no arguments are supplied\n"
"      -P\tdisplay the trap commands associated with each SIGNAL_SPEC. At least\n"
"    \t\tone SIGNAL_SPEC must be supplied. -P and -p cannot be used\n"
"    \t\ttogether.\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is given."
msgstr ""
"Verarbeitet Signale und andere Ereignisse.\n"
"\n"
"    Definiert und aktiviert Handler für Signale oder andere Bedingungen,\n"
"    welche die Shell empfängt.\n"
"\n"
"    Das Argument ist ein Befehl, der gelesen und ausgeführt wird, wenn die\n"
"    Shell eins der angegebenen Signale empfängt. Fehlt das Argument,\n"
"    und ist nur ein einzelnes Signal angegeben oder die Signalbezeichnung\n"
"    „-“ angegeben, wird jedes Signal auf seinen ursprünglichen Wert\n"
"    zurückgesetzt. Wenn das Argument eine leere Zeichenkette ist, wird\n"
"    jedes angegebene Signal von der Shell und den von ihr aufgerufenen\n"
"    Befehlen ignoriert.\n"
"\n"
"    Wenn das angegebene Signal EXIT (0) ist, wird das Argument unmittelbar\n"
"    vor Beenden der Shell ausgeführt. Mit der Signalangabe DEBUG wird das\n"
"    Argument vor jedem einfachen Befehl und ausgewählten anderen Befehlen\n"
"    ausgeführt. Ist das Signal RETURN, wird das Argument jedes Mal\n"
"    ausgeführt, wenn eine Shellfunktion oder ein vom . oder source-\n"
"    Builtin ausgeführtes Skript endet. Eine Signalangabe ERR bedeutet,\n"
"    dass das Argument dann ausgeführt wird, sobald ein Fehler zum Beenden\n"
"    der Shell führen würde und die Shelloption -e aktiviert ist.\n"
"\n"
"    Ohne Argumente gibt trap die Liste der mit jedem abgefangenen Signal\n"
"    verknüpften Befehle in einer Form aus, die als Shell-Eingabe\n"
"    wiederverwendet werden kann, um die gleichen Signaldispositionen\n"
"    wiederherzustellen.\n"
"\n"
"    Optionen:\n"
"    -l\tGibt eine Liste der Signalnamen und der zugehörigen Nummern aus.\n"
"    -p\tZeigt die mit jedem Signal verknüpften Befehle in einer Form an,\n"
"    \t\tdie als Shell-Eingabe wiederverwendet werden kann oder für alle\n"
"        abgefangenen Signale, wenn keine Argumente angegeben werden.\n"
"    -P\tZeigt die mit jedem Signal verknüpften Befehle an. Mindestens\n"
"    \t\tein Signal muss angegeben werden. -P und -p schließen sich gegen-\n"
"        seitig aus.\n"
"\n"
"    Jedes angegebene Signal ist entweder ein Signalname aus <signal.h>\n"
"    oder eine Signalnummer.\n"
"    Signalnamen berücksichtigen keine Groß- und Kleinschreibung und das\n"
"    Präfix SIG ist optional. Ein Signal kann mit „kill -signal $$“ an\n"
"    die Shell gesendet werden.\n"
"\n"
"    Rückgabewert:\n"
"    Erfolg, sofern keine ungültige Signalspezifikation oder eine\n"
"    ungültige Option angegeben wurden."

# type
#: builtins.c:1441
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not found."
msgstr ""
"Informationen zum Befehlstyp anzeigen.\n"
"\n"
"    Gibt für jeden `Namen' an, wie er interpretiert würde, wenn er als\n"
"    Befehlsname verwendet würde.\n"
"\n"
"    Optionen:\n"
"      -a\tZeigt alle Orte an, die eine ausführbare Datei mit dem\n"
"    \t\tabgegebenen `Namen' enthalten. Aliase, eingebaute\n"
"    \t\tBefehle und Funktionen werden nur dann angezeigt, wenn\n"
"    \t\tdie -p Option nicht verwendet  wird.\n"
"      -f\tUnterdrückt die Shell-Funktionssuche\n"
"    \t-P\tErzwingt eine PATH-Suche für jeden `Namen', auch wenn es sich um\n"
"      \t\teinen Alias, integriertes Element oder eine Funktion handelt,\n"
"      \t\tund gibt den Namen der Datenträgerdatei zurück, die\n"
"      \t\tausgeführt werden würde\n"
"      -p\tGibt den Namen der ausgeführten Datei zurück, wenn\n"
"      \t\t`type -t NAME' `file' ausgeben würde. Sonst wird nichts\n"
"      \t\tausgegeben.\n"
"      -t\tGibt den Befehlstyp aus: `alias', `keywoard', `funktion',\n"
"      \t\t`builtin', `file' oder `', wenn `Name' ein Alias, reserviertes\n"
"      \t\tWort, Shell-Funktion, Shell-integriertes Element, Datei\n"
"      \t\tbzw. nicht gefunden worden ist\n"
"\n"
"    Argumente:\n"
"      Name\tZu interpretierender Befehlsname.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt `Erfolg' zurück, wenn alle `Namen' gefunden werden; schlägt fehl, wenn     nicht alle `Namen' gefunden worden sind."

# ulimit
#: builtins.c:1472
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds;\n"
"    -p, which is in increments of 512 bytes; -R, which is in microseconds;\n"
"    -b, which is in bytes; and -e, -i, -k, -n, -q, -r, -u, -x, and -P,\n"
"    which accept unscaled values.\n"
"    \n"
"    When in posix mode, values supplied with -c and -f are in 512-byte\n"
"    increments.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Shell-Ressourcenlimits einstellen.\n"
"\n"
"    Ermöglicht die Kontrolle der Shell-Ressourcen und den von ihr\n"
"    gestarteten Prozesse, für Systeme, die eine solche Kontrolle\n"
"    ermöglichen.\n"
"\n"
"    Optionen:\n"
"    -S\tVerwendet das „weiche“ Ressourcenlimit.\n"
"    -H\tVerwendet das „harte“ Ressourcenlimit.\n"
"    -a\tAnzeige der aktuellen Limits.\n"
"    -b\tDie Socket-Puffergröße.\n"
"    -c\tDie maximale Größe der erstellten Speicherabzüge.\n"
"    -d\tDie maximale Größe des Prozess-Datensegments.\n"
"    -e\tDie maximale Scheduling-Priorität („nice“).\n"
"    -f\tDie maximale Größe der von der Shell und ihren Kindern\n"
"    \t\tgeschriebenen Dateien.\n"
"    -i\tDie maximale Anzahl ausstehender Signale.\n"
"    -k\tDie maximale Anzahl der diesem Prozess zugewiesenen Kqueues.\n"
"    -l\tDie maximale Größe, die ein Prozess in den Speicher sperren kann.\n"
"    -m\tDie maximale Größe der „Resident Set Size (RSS)“.\n"
"    -n\tDie maximale Anzahl geöffneter Dateideskriptoren.\n"
"    -p\tDie Pipe-Puffergröße.\n"
"    -q\tDie maximale Anzahl von Bytes in POSIX-Nachrichtenwarteschlangen.\n"
"    -r\tDie maximale Echtzeit-Scheduling-Priorität.\n"
"    -s\tDie maximale Stack-Größe.\n"
"    -t\tDie maximale CPU-Zeit in Sekunden.\n"
"    -u\tDie maximale Anzahl von Benutzerprozessen.\n"
"    -v\tDie Größe des virtuellen Speichers.\n"
"    -x\tDie maximale Anzahl von Dateisperren.\n"
"    -P\tDie maximale Anzahl von Pseudoterminals.\n"
"    -R\tDie maximale Zeit für einen Echtzeitprozess vor dessen Blockieren.\n"
"    -T\tDie maximale Threadanzahl.\n"
"\n"
"    Nicht alle Optionen sind auf allen Plattformen verfügbar.\n"
"\n"
"    Wenn eine Grenze angegeben ist, wird diese der neuen Wert der\n"
"    angegebenen Ressource. Die speziellen Grenzwerte „weich“, „hart“ und\n"
"    „unbegrenzt“ stehen jeweils für das aktuelle Soft-Limit, das aktuelle\n"
"    Hard-Limit bzw. unlimitiert.\n"
"    Andernfalls wird der aktuelle Wert der angegebenen Ressource\n"
"    ausgegeben. Wenn keine Option angegeben ist, wird -f angenommen.\n"
"\n"
"    Werte werden in 1024-Byte-Schritten angegeben, mit Ausnahme von -t\n"
"    (in Sekunden), -p (in 512-Byte-Schritten), -R (in Mikrosekunden),\n"
"    -b (in Bytes) und -e, -i, -k, -n, -q, -r, -u, -x und -P, die\n"
"    unskalierte Werte akzeptieren.\n"
"\n"
"    Im POSIX-Modus werden die mit -c und -f angegebenen Werte in\n"
"    512-Byte-Schritten angegeben.\n"
"\n"
"    Rückabewert:\n"
"    Gibt Erfolg zurück, sofern keine ungültige Option angegeben wurde\n"
"    oder ein Fehler auftrat."

# umask
#: builtins.c:1527
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Dateimodusmaske anzeigen oder festlegen.\n"
"\n"
"    Setzt die Maske der Benutzerrechte für die Dateierstellung auf\n"
"    den angegebenen Modus. Ohne Argument wird der aktuelle Maskenwert\n"
"    ausgegeben.\n"
"\n"
"    Beginnt das Argument mit einer Ziffer an, wird diese als Oktalzahl\n"
"    interpretiert. Sonst wird eine symbolische Maske erwartet, wie sie\n"
"    von chmod(1) akzeptiert wird.\n"
"\n"
"Optionen:\n"
"    -p:\tOhne Argument wird die Ausgabe in einem Format ausgegeben, das\n"
"    \tals Eingabe wiederverwendet werden kann.\n"
"    -S:\tGibt die aktuelle Maske symbolisch aus. Standardmäßig wird eine\n"
"    \tOktalzahl ausgegeben.\n"
"\n"
"Rückgabewert:\n"
"    Gibt `Erfolg' zurück, wenn eine gültige Maske oder eine gültige\n"
"    Option angegeben wurde."

# wait with job control
#: builtins.c:1547
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Wartet auf das Ende des angegebenen Prozesses und meldet dessen\n"
"    Rückgabewert.\n"
"\n"
"    Wartet auf alle durch eine Prozess-ID oder Jobspezifikation\n"
"    angegebenen Prozesse und meldet deren Rückgabewert. Fehlt die\n"
"    Angabe wird auf alle aktuell aktiven Kindprozesse gewartet. Dann ist\n"
"    der Rückgabestatus Null. Ist eine Jobspezifikation angegeben, wird\n"
"    auf alle Prozesse der Jobpipeline gewartet.\n"
"\n"
"    Mit der Option -n wird nur auf das Ende des ersten angegebenen Jobs\n"
"    gewartet. Ohne Angabe einer Prozess- oder Jobbezeichnung wird auf\n"
"    den Abschluss des nächsten Jobs gewartet und dessen Rückgabewert\n"
"    gemeldet.\n"
"\n"
"    Mit der Option -p wird die Prozess- oder Jobbezeichnung des\n"
"    beendeten Jobs, der angegebenen Variable zugewiesen. Die Variable\n"
"    wird vor jeder Zuweisung gelöscht. Diese Option ist nur in\n"
"    Verbindung mit -n sinnvoll.\n"
"\n"
"    Die Option -f bei aktivierter Jobsteuerung bewirkt, dass auf das\n"
"    Ende der angegebenen Prozesse gewartet wird, statt auf deren\n"
"    Statusänderung.\n"
"\n"
"Rückgabewert:\n"
"    Gibt den Status der letzten Prozesses zurück. Der Befehl schlägt fehl,\n"
"    wenn die ID oder eine Option ungültig sind oder wenn -n angegeben ist\n"
"    und die Shell keine laufenden Kindsprozesse hat."

# wait without job control
#: builtins.c:1578
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an invalid\n"
"    option is given."
msgstr ""
"Wartet auf das Prozessende und gibt dessen Rückgabewert aus.\n"
"\n"
"    Wartet auf jeden durch eine PID angegebenen Prozess und meldet\n"
"    dessen Rückgabwert. Wenn keine PID angegeben ist, wird auf alle\n"
"    aktiven Kindsprozesse gewartet und der Rückgabestatus ist Null.\n"
"    Die PID muss eine Prozess-ID sein.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt den Status der letzten PID zurück; schlägt fehl, wenn die PID\n"
"    ungültig ist oder eine ungültige Option angegeben ist."

# ! Bang Operator
#: builtins.c:1593
msgid ""
"Execute PIPELINE, which can be a simple command, and negate PIPELINE's\n"
"    return status.\n"
"    \n"
"    Exit Status:\n"
"    The logical negation of PIPELINE's return status."
msgstr ""
"Führt die Pipelie aus (die auch ein einzelnes Kommando sein kann) und\n"
"    negiert deren Rückgabewert.\n"
"    \n"
"    Rückgabewert:\n"
"    Die logische Negation des Rückgabewerts der Pipeline."

# for
#: builtins.c:1603
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Führt Befehle für jeden Listeneintrag aus.\n"
"    \n"
"    Die `for' Schleife führt eine Befehlsfolge für jeden Listeneintrag aus. Wenn\n"
"    das Schlüsselwort `in Wort ...;' fehlt, wird `in \"$@\"' angenommen. Für jeden\n"
"    Eintrag in \"Wort\" wird die Variable \"Name\" gesetzt und die angegebenen\n"
"    Kommandos ausgeführt.\n"
"    \n"
"    Rückgabewert:\n"
"    Der Status des zuletzt ausgeführten Kommandos."

# for (( 
#: builtins.c:1617
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Arithmetische For Schleife.\n"
"\n"
"    Äquivalent zu:\n"
"    \t(( Ausdr1 ))\n"
"    \twhile (( Ausdr2 )); do\n"
"    \t\tKommandos\n"
"    \t\t(( Ausdr3 ))\n"
"    \tdone\n"
"    Ausdr1-3 sind arithmethische Ausdrücke. Für fehlende Ausdrücke wird 1\n"
"    angenommen.\n"
"\n"
"    Rückgabewert:\n"
"    Status des zuletzt ausgeführten Kommandos."

# select
#: builtins.c:1635
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Wählt Wörter aus einer Liste und führt anschließend das Kommando aus.\n"
"    \n"
"    Die angegebenen Wörter werden in eine Liste überführt. Diese wird\n"
"    auf die Standardausgabe mit einer vorangestellten Nummer gedruckt.\n"
"    Wenn keine Wörter angegeben sind, wird `in \"$@\"' verwendet. An-\n"
"    schließend wird der PS3 Prompt angezeigt und eine Zeile von der\n"
"    Standardeingabe gelesen. Wenn der gelesene Text einer angezeigten\n"
"    Nummer entspricht, wird der mit dem Wort bezeichnete Variable das\n"
"    angezeigte Wort zugewiesen. Wird eine leere Zeile gelesen, wird die\n"
"    Liste erneut angezeigt. Nachdem EOF (End of File) gelesen wurde,\n"
"    wird das Kommando beendet. Jeder andere Wert führt dazu, dass eine\n"
"    leere Zeichenkette zugewiesen wird. Die gelesene Zeile wird der\n"
"    Variable REPLY zugewiesen. Die Kommandos werden nach jeder Auswahl\n"
"    ausgeführt und durch Break beendet.\n"
"    \n"
"    Rückgabewert:\n"
"    Status des zuletzt ausgeführten Kommandos."

# time
#: builtins.c:1656
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Misst die für die Pipeline-Ausführung benötigte Zeit.\n"
"\n"
"    Führt die Pipeline aus und gibt deren abgelaufene echte Zeit, die\n"
"    Benutzer-CPU-Zeit und die System-CPU-Zeit aus.\n"
"\n"
"    Optionen:\n"
"    -p\tGibt die Zeitübersicht im portablen Posix-Format aus.\n"
"\n"
"    Der Wert der TIMEFORMAT-Variable wird als Ausgabeformat verwendet.\n"
"\n"
"    Rückgabewert:\n"
"    Der Rückgabewert entspricht dem der Pipeline."

# case
#: builtins.c:1673
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Befehle basierend auf Mustervergleichen ausführen.\n"
"\n"
"    Befehle basierend auf Mustern ausführen. Mit „|“ können mehrere\n"
"    Muster getrennt werden.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt den Status des zuletzt ausgeführten Befehls zurück."

# if
#: builtins.c:1685
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of the\n"
"    entire construct is the exit status of the last command executed, or zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Führt bedingt Befehle aus.\n"
"\n"
"    Zuerst wird die „if Kommandos“ Liste ausgeführt. Ist dessen\n"
"    Rückgabewert Null, wird die Liste „then Kommandos“ ausgeführt. Sonst\n"
"    wird jede Liste „elif Kommandos“ nacheinander ausgeführt. Ist ihr\n"
"    Rückgabewert Null, wird die zugehörige „then Kommandos“ Liste\n"
"    ausgeführt und der if-Befehl abgeschlossen. Andernfalls wird, wenn\n"
"    vorhanden, die Liste „else Kommandos“ ausgeführt. Der Rückgabewert\n"
"    des gesamten Befehls ist der Rückgabwert des zuletzt ausgeführten\n"
"    Kommandos oder Null, wenn keine Bedingung erfüllt ist.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt den Status des zuletzt ausgeführten Befehls zurück."

# while
#: builtins.c:1702
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Führt die Kommandos aus, so lange der Test erfolgreich ist.\n"
"    \n"
"    Führt die Kommandos aus, so lange das letzte Kommando vom Test ein\n"
"    Rückgabewert gleich Null hat.\n"
"    \n"
"    Rückgabewert:\n"
"    Meldet den Rückgabewert des zuletzt ausgeführten Kommandos."

# until
#: builtins.c:1714
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Führt die Kommandos aus, so lange der Test fehlschlägt.\n"
"    \n"
"    Führt die Kommandos aus, so lange das letzte Kommando vom Test ein\n"
"    Rückgabewert ungleich Null hat.\n"
"    \n"
"    Rückgabewert:\n"
"    Meldet den Rückgabewert des zuletzt ausgeführten Kommandos."

# coproc
#: builtins.c:1726
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Startet einen Koprozess mit dem angegebenen Namen.\n"
"    \n"
"     Führt das angegebene Kommando asynchron in einem Kindprozess aus.\n"
"     Deren Standardaus- und -eingabe werden mit jeweils einer Pipe\n"
"     verbunden. Deren Dateideskriptoren sind in den Indexen 0 und 1 der\n"
"     Feldvariable mit dem angegebenen Namen verknüpft.\n"
"     Der Standardname ist „COPROC“.\n"
"    \n"
"     Rückgabewert:\n"
"     Der Befehl gibt immer 0 zurück."

# function
#: builtins.c:1740
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Erstellt eine Shellfunktion.\n"
"    \n"
"    Erstellt eine Shellfunktion mt dem angegebenen Namen. Wenn der Name als\n"
"    Kommando aufgerufen wird, dann werden die angegebenen Kommandos im Kontext\n"
"    der aufrufenden Shell abgearbeitet. Deren Argumente werden der Funktion als\n"
"    die Variablen $1...$n übergeben und der Funktionsname als $FUNCNAME.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt Erfolg zurück, es sein denn, der Name ist schreibgeschützt."

# { ... }
#: builtins.c:1754
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Kommandos als Einheit gruppieren.\n"
"    \n"
"    Führt eine gruppierte Reihe von Kommandos aus. Dies ist eine Möglichkeit, um\n"
"    die Ausgabe von mehreren Kommandos umzuleiten.\n"
"    \n"
"     Rückgabewert:\n"
"     Gibt den Status des zuletzt ausgeführten Befehls zurück."

#: builtins.c:1766
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Job im Vordergrund fortsetzen.\n"
"    \n"
"    Entspricht dem JOB_SPEC-Argument des Befehls „fg“. Er nimmt einen gestoppten\n"
"    oder Hintergrundjob wieder auf. JOB_SPEC kann ein Jobname oder eine\n"
"    Jobnummer angeben. Ein nachfolgendes „&“ bringt den Job in den Hintergrund,\n"
"    ähnlich wie die Jobbezeichnung von „bg“.\n"
"    \n"
"    Exit-Status:\n"
"    Gibt den Status des wiederaufgenommenen Jobs zurück."

# (( ))
#: builtins.c:1781
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Wertet arithmetische Ausdrücke aus.\n"
"\n"
"    Der Ausdruck wird nach den Regeln für arithmetische Berechnungen\n"
"    ausgewertet. Diese Schreibweise entspricht »let Ausdruck«.\n"
"\n"
"    Rückgabewert:\n"
"    Ist »1«, wenn der arithmetische Ausdruck 0 ergibt, sonst »0«."

# [[
#: builtins.c:1793
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries used\n"
"    by the `test' builtin, and may be combined using the following operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Erweiterte Vergleiche.\n"
"    \n"
"    Der Status 0 oder 1 wird abhängig vom Vergleichsergebnis zurückgegeben.\n"
"    Es werden die gleichen Ausdrücke wie in der »test« Funktion unterstützt,\n"
"    die mit folgenden Operatoren verbunden werden können:\n"
"    \n"
"      ( AUSDRUCK )\tErgibt den Wert des AUSDRUCKs\n"
"      ! Ausdruck\t\tNegiert den AUSDRUCK\n"
"      AUSDR1 && AUSDR2\tUnd Verknüpfung der Ausdrücke\n"
"      AUSDR1 || AUSDR2\tOder Verknüpfung der Ausdrücke\n"
"    \n"
"    Die `==' und `!=' Operatoren ermöglichen einen Mustervergleich mit dem\n"
"    rechten Ausdruck als Muster.\n"
"    Der `=~' Operator führt einen Vergleich mit dem regulären Ausdruck\n"
"    in der rechten Seite aus.\n"
"    \n"
"    Die && und || Operatoren werten AUSDR2 nur aus, wenn nicht bereits\n"
"    AUSDR1 das gesamte Ergebnis bestimt.\n"
"    \n"
"    Rückgabewert:\n"
"    0 oder 1 abhängig vom Wert des AUSDRUCKs."

# variable_help
#: builtins.c:1819
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"    BASH_VERSION\tVersionsnummer der Bash.\n"
"    CDPATH\tEine durch Doppelpunkte getrennte Liste von\n"
"                Verzeichnissen, die durchsucht werden, wenn das\n"
"                Argument von »cd« nicht im aktuellen Verzeichnis\n"
"                gefunden wird.\n"
"    GLOBIGNORE  Eine durch Doppelpunkte getrennte Liste von\n"
"                Dateinamenmustern, die für die Dateinamensergänzung\n"
"                ignoriert werden.\n"
"    HISTFILE\tDatei, die den Kommandozeilenspeicher enthält.\n"
"    HISTFILESIZE\tMaximale Zeilenanzahl dieser Datei.\n"
"    HISTSIZE\tMaximale Anzahl von Zeilen, auf die der\n"
"                Historymechanismus der Shell zurückgreifen kann.\n"
"    HOME\tHeimatverzeichnis des aktuellen Benutzers.\n"
"    HOSTNAME    Der aktuelle Rechnername.\n"
"    HOSTTYPE\tCPU-Typ des aktuellen Rechners.\n"
"    IGNOREEOF\tLegt die Reaktion der Shell auf ein EOF-Zeichen fest.\n"
"                Wenn die Variable eine ganze Zahl enthält, wird diese\n"
"                Anzahl EOF Zeichen (Ctrl-D) abgewartet, bis die Shell\n"
"                verlassen wird. Der Vorgabewert ist 10. Ist IGNOREEOF\n"
"                nicht gesetzt, signalisiert EOF das Ende der Eingabe.\n"
"    MACHTYPE    Eine Zeichenkette die das aktuell laufende System beschreibt.\n"
"    MAILCHECK\tZeit in Sekunden, nach der nach E-Mails gesehen wird.\n"
"    MAILPATH\tEine durch Doppelpunkt getrennte Liste von Dateinamen,\n"
"                die nach E-Mail durchsucht werden.\n"
"    OSTYPE\tUnix Version, auf der die Bash gegenwärtig läuft.\n"
"    PATH\tDurch Doppelpunkt getrennte Liste von Verzeichnissen,\n"
"                die nach Kommandos durchsucht werden.\n"
"    PROMPT_COMMAND\tKommando, das vor der Anzeige einer primären\n"
"                        Eingabeaufforderung (PS1) ausgeführt wird.\n"
"    PS1                 Zeichenkette, die die primäre\n"
"                        Eingabeaufforderung enthält.\n"
"    PS2                 Zeichenkette, die die sekundäre\n"
"                        Eingabeaufforderung enthält.\n"
"    PWD                 Der vollständige aktuelle Verzeichnisname.\n"
"    SHELLOPTS           Durch Doppelpunkt getrennte Liste der aktiven\n"
"                        Shell-Optionen.\n"
"    TERM\tName des aktuellen Terminaltyps.\n"
"    auto_resume Ein Wert ungleich Null bewirkt, dass ein einzelnes\n"
"                Kommando auf einer Zeile zunächst in der Liste\n"
"                gegenwärtig gestoppter Jobs gesucht und dieser in den\n"
"                Vordergrund geholt wird. »exact« bewirkt, dass das\n"
"                Kommando genau dem Kommando in der Liste der\n"
"                gestoppten Jobs entsprechen muss. Wenn die Variable den\n"
"                Wert »substring« enthält, muss das Kommando einem\n"
"                Substring der Jobbezeichnung entsprechen. Bei einem\n"
"                anderen Wert müssen die ersten Zeichen übereinstimmen.\n"
"    histchars   Zeichen, die die Befehlswiederholung und die\n"
"                Schnellersetzung steuern. An erster Stelle steht\n"
"                das Befehlswiederholungszeichen (normalerweise\n"
"                `!'); an zweiter das `Schnell-Ersetzen-Zeichen'\n"
"                (normalerweise `^'). Das dritte Zeichen ist das\n"
"                `Kommentarzeichen' (normalerweise `#').\n"
"    HISTIGNORE  Eine durch Doppelpunkt getrennte Liste von\n"
"                Mustern, welche die in der\n"
"                Befehlswiederholungsliste zu speichernden\n"
"                Kommandos angibt.\n"

# pushd
#: builtins.c:1876
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Fügt ein Verzeichnis dem Stapel hinzu.\n"
"\n"
"    Legt einen Verzeichnisnamen auf den Verzeichnisstapel oder rotiert\n"
"    diesen so, dass das aktuelle Arbeitsverzeichnis oben liegt. Ohne\n"
"    Argumente werden die obersten zwei Verzeichnisse auf dem Stapel\n"
"    vertauscht.\n"
"\n"
"    Optionen: -n Es wird nur das angebene Verzeichnis dem Stapel\n"
"    \thinzugefügt, aber nicht in das Verzeichnis gewechselt.\n"
"\n"
"    Argumente:    \n"
"    +N\tRotiert den Stapel so, dass das N'te Verzeichnis (angezeigt\n"
"        von `dirs', gezählt von links) oben auf dem Stapels liegt.\n"
"\n"
"    -N\tRotiert den Stapel so, dass das N'te Verzeichnis (angezeigt\n"
"        von `dirs', gezählt von rechts) sich an der Spitze des Stapels\n"
"    \tbefindet.\n"
"\n"
"    Der Verzeichnisstapel kann mit dem Kommando `dirs' angezeigt\n"
"    werden.\n"
"\n"
"    Rückgabewert: \n"
"    Gibt Erfolg zurück, außer wenn ein ungültiges Argument angegeben\n"
"    wurde oder der Verzeichniswechsel nicht erfolgreich war."

# popd
#: builtins.c:1910
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Entfernt Einträge vom Verzeichnisstapel.\n"
"\n"
"    Entfernt Einträge vom Verzeichnisstapel. Ohne Argumente wird der\n"
"    oberste Eintrag entfernt und in das neue oberste Verzeichnis\n"
"    gewechselt.\n"
"\n"
"    Optionen:\n"
"    -n\tEntfernt nur den Verzeichniseintrag und wechselt nicht\n"
"       \tdas Verzeichnis.\n"
"          \n"
"    Argumente:\n"
"    +N\tEntfernt den N-ten Eintrag von links, gezählt von\n"
"        Null, aus der von »dirs« anzeigten Liste. Beispielsweise\n"
"        entfernen »popd +0« den ersten und »popd +1« den zweiten\n"
"        Verzeichniseintrag.\n"
"\n"
"    -N\tEntfernt den N-ten Eintrag von rechts, gezählt von Null,\n"
"      \taus der von »dirs« angeigten Liste. Beispielsweise entfernen\n"
"        »popd -0« den letzten und »popd -1« den vorletzten\n"
"        Verzeichniseintrag.\n"
"\n"
"        Mit »dirs« kann der Verzeichnisstapel angezeigt werden.\n"
"\n"
"        Rückgabewert:\n"
"        Gibt 0 zurück, außer wenn ein ungültiges Argument angegeben\n"
"        wurde oder der Verzeichniswechsel nicht erfolgreich war."

# dirs
#: builtins.c:1940
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Zeigt den Verzeichnisstapel an.\n"
"\n"
"    Zeigt die Liste der gegenwärtig gespeicherten Verzeichnisse.\n"
"    Diese werden mit dem `pushd' Kommando eingetragen und mit dem\n"
"    `popd' Kommando ausgelesen.\n"
"\n"
"    Optionen:\n"
"      -c        Löscht den Verzeichnisstapel.\n"
"      -l        Keine Abkürzung für das Heimatverzeichnis durch die\n"
"                Tilde (~).\n"
"      -p        Ausgabe von einem Eintrag pro Zeile.\n"
"      -v        Ausgabe von einem Eintrag pro Zeile mit Angabe der\n"
"                Position im Stapel<\n"
"\n"
"    Argumente:\n"
"      +N        Gibt das N'te Element von links der Liste aus, die\n"
"                ohne Argumente ausgegeben wird.  Die Zählung beginnt\n"
"                bei 0.\n"
"      -N        Gibt das N'te Element von rechts der Liste aus, die\n"
"                ohne Argumente ausgegeben wird.  Die Zählung beginnt\n"
"                bei 0.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt Erfolg zurück, außer bei einer ungültigen Option oder wenn\n"
"    ein Fehler auftritt."

#: builtins.c:1971
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Setzt oder löscht Shell-Optionen.\n"
"\n"
"    Ändert die in »Optionsnamen« genannten Shell-Optionen. Ohne\n"
"    Argumente wird eine Liste der Shell-Optionen und deren Status\n"
"    ausgegeben.\n"
"\n"
"    Optionen:\n"
"      -o        Beschränkt die Optionsmanen auf die, welche mit \n"
"                »set -o« definiert werden müssen.\n"
"      -p        Gibt alle Shelloptionen und deren Status aus.\n"
"      -q        Unterdrückt Ausgaben.\n"
"      -s        Setzt jede Option in »Optionsname.«\n"
"      -u        Deaktiviert jede Option in »Optionsname«.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt Erfolg zurück, wenn eine Option gesetzt worden ist. Wenn\n"
"    eine ungültige Option angegeben wurde oder eine Option deaktiviert\n"
"    worden ist, wird ein Fehler zurückgegeben."

# printf
#: builtins.c:1992
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: plain\n"
"    characters, which are simply copied to standard output; character escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format characters csndiouxXeEfFgGaA described\n"
"    in printf(3), printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or assignment\n"
"    error occurs."
msgstr ""
"Formatierte Ausgabe der ARGUMENTE.\n"
"\n"
"    Optionen:\n"
"      -v var\tDie formatierte Ausgabe wird der Variable \"var\" zugewiesen\n"
"              und nicht an die Standardausgabe gesendet.\n"
"\n"
"    Die \"Format\" Anweisung kann einfache Zeichen enthalten, die unverändert an\n"
"    die Standardausgabe geschickt werden. Escape-Sequenzen werden umgewandelt\n"
"    und an die Standardausgabe geschickt sowie Formatanweisungen, welche das\n"
"    nachfolgende \"Argument\" auswerten und ausgeben.\n"
"\n"
"    Zusätzich zu den in printf(3) beschriebenen Standardformatzeichen:\n"
"    csndiouxXeEfFgGaA werden ausgewertet:\n"
"\n"
"      %b\tErweitert Backslasch-Escapesequenzen im angegebenen Argument.\n"
"      %q\tSchützt nicht druckbare Zeichen, dass sie als Shelleingabe\n"
"          verwendet werden können.\n"
"      %Q  Wie %q, es wird zusätzlich die angegebene Genauigkeit vor dem\n"
"          Ausgeben angewendet.\n"
"      %(Fmt)T\tAusgabe des in \"Fmt\" angegebenen Zeitausdrucks, dass sie\n"
"          als Eingabe für strftime(3) verwendet werden kann.\n"
"\n"
"    Die Formatangabe wird wiederverwendet, bis alle Argumente ausgewertet\n"
"    sind. Wenn weniger Argumente als Formatangaben vorhanden sind, werden für\n"
"    die Argumente Nullwerte bzw. leere Zeichenketten eingesetzt.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt `Erfolg' zurück, außer es wird eine ungültige Option angegeben\n"
"    oder es tritt ein Aus- bzw. Zuweisungsfehler auf."

#: builtins.c:2028
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no options\n"
"    or NAMEs are supplied, display existing completion specifications in a way\n"
"    that allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

# compgen
#: builtins.c:2058
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is present, generate matches\n"
"    against WORD.\n"
"    \n"
"    If the -V option is supplied, store the possible completions in the indexed\n"
"    array VARNAME instead of printing them to the standard output.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Zeigt mögliche Komplettierungen.\n"
"\n"
"    Wird in Shellfunktionen benutzt, um mögliche Komplettierungen\n"
"    auszugeben. Wenn ein Wort als optionales Argument angegeben ist,\n"
"    werden Komplettierungen für dieses Wort erzeugt.\n"
"\n"
"    Wenn die -V Option angegeben ist, werden die möglichen Komplett-\n"
"    ierungen in der angegebenen indizierten Arrayvariable gespeichert,\n"
"    statt sie anzuzeigen.\n"
"\n"
"    Rückgabewert:\n"
"    Falsche Optionen oder Fehler führen zu Rückgabewerten ungleich Null."

#: builtins.c:2076
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, print\n"
"    the completion options for each NAME or the current completion specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""

# mapfile
#: builtins.c:2107
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly or\n"
"    not an indexed array."
msgstr ""
"Zeilen von der Standardeingabe in ein indiziertes Array einlesen.\n"
"    \n"
"    Liest Zeilen von der Standardeingabe in das angegebene indizierte Array.\n"
"    Mit der Option -u wird aus dem Dateideskriptor `fd' gelesen. Die\n"
"    Variable MAPFILE ist das Standard-Array.\n"
"    \n"
"    Optionen:\n"
"      -d Begrenzer\tVerwendet den `Begrenzer' als Zeilenende statt newline\n"
"      -n Anzahl\tBegrenzt die `Anzahl' gelesener Zeilen. Mit `Anzahl'\n"
"         gleich 0 werden alle Zeilen gelesen.\n"
"      -O Index\tWeist die Werte dem Array beginnend mit dem `Index' zu.\n"
"      \t\tDer Standardindex ist 0.\n"
"      -s Anzahl\tÜberspringen der ersten Zeilen.\n"
"      -t\tEntfernt das letzte Zeichen von jeder gelesenen Zeile\n"
"         (standardmäßig newline).\n"
"      -u fd\tAus dem Dateideskriptor `fr' statt der Standardeingabe lesen.\n"
"      -C Callback\tDen `Callback' jedes Mal auswerten, wenn die angegebene\n"
"         Zeilenanzahl gelesen worden ist.\n"
"      -c Anzahl\tZeilenanzahl für jeden Aufruf vom `Callback'.\n"
"\n"
"    Argumente:\n"
"      Feldvariable\tName der zu verwendenden Array-Variablen.\n"
"    \n"
"    Wenn -C ohne -c angegeben wird, ist das Standardquantum 5000. Wenn CALLBACK\n"
"    ausgewertet wird, erhält es den Index des nächsten zuzuweisenden Array\n"
"    Elementes und die Zeile, die diesem Element zugewiesen werden soll als\n"
"    zusätzliche Argumente.\n"
"    \n"
"    Wenn kein expliziter Ursprung angegeben wird, löscht mapfile ARRAY, bevor\n"
"    bevor es zugewiesen wird.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt `Erfolg' zurück, es sei denn, es wird eine ungültige Option angegeben,\n"
"    das ARRAY ist schreibgeschützt oder kein indiziertes Array."

# readarray
#: builtins.c:2143
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Liest Zeilen einer Datei in eine Array-Variable.\n"
"\n"
"    Ist ein Synonym für »mapfile«."

# caller
#~ msgid ""
#~ "Returns the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
#~ "    \"$line $subroutine $filename\"; this extra information can be used to\n"
#~ "    provide a stack trace.\n"
#~ "    \n"
#~ "    The value of EXPR indicates how many call frames to go back before the\n"
#~ "    current one; the top frame is frame 0."
#~ msgstr ""
#~ "Gibt Informationen zum aktuellen Subroutinenaufruf aus.\n"
#~ "\n"
#~ "    Ohne Argument wird die Zeilennummer und der Dateiname angezeigt. Mit\n"
#~ "    Argument werden Zeilennummer, Subroutinenname und Dateiname ausgegeben.\n"
#~ "    Mit diesen Informationen kann ein Stacktrace erzeugt werden.\n"
#~ "\n"
#~ "    Das Argument gibt die angezeigte Position im Funktionsaufrufstapel an,\n"
#~ "    wobei 0 der aktuelle Funktionsaufruf ist."

#, c-format
#~ msgid "%s: cannot open: %s"
#~ msgstr "%s: Kann die Datei nicht öffnen: %s"

#, c-format
#~ msgid "%s: inlib failed"
#~ msgstr "%s: inlib gescheitert."

#, c-format
#~ msgid "warning: %s: %s"
#~ msgstr "Warnung: %s: %s"

#, c-format
#~ msgid "%s: %s"
#~ msgstr "%s: %s"

#, c-format
#~ msgid "%s: cannot execute binary file: %s"
#~ msgstr "%s: Kann die Binärdatei nicht ausführen: %s"

#, c-format
#~ msgid "setlocale: LC_ALL: cannot change locale (%s)"
#~ msgstr "setlocale: LC_ALL: Kann die Regionseinstellungen nicht ändern (%s)."

#, c-format
#~ msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
#~ msgstr "setlocale: LC_ALL: Kann die Regionseinstellungen nicht ändern (%s): %s"

#, c-format
#~ msgid "setlocale: %s: cannot change locale (%s): %s"
#~ msgstr "setlocale: %s: Kann die Regionseinstellungen nicht ändern (%s): %s"

#, c-format
#~ msgid "%s: cannot create: %s"
#~ msgstr "%s: Kann die Datei %s nicht erzeugen."

#, c-format
#~ msgid "%s: missing colon separator"
#~ msgstr "%s: Fehlender Doppelpunkt."

#, c-format
#~ msgid "brace expansion: failed to allocate memory for %u elements"
#~ msgstr "Klammererweiterung: Konnte keinen Speicher für %u Elemente zuweisen."

#, c-format
#~ msgid "%s: cannot read: %s"
#~ msgstr "%s: Nicht lesbar: %s"

#, c-format
#~ msgid "write error: %s"
#~ msgstr "Schreibfehler: %s."

#, c-format
#~ msgid "error setting terminal attributes: %s"
#~ msgstr "Fehler beim Setzen der Terminalattribute: %s"

#, c-format
#~ msgid "error getting terminal attributes: %s"
#~ msgstr "Fehler beim Ermitteln der Terminalattribute: %s"

#, c-format
#~ msgid "%s: error retrieving current directory: %s: %s\n"
#~ msgstr "%s: Kann das aktuelle Verzeichnis nicht wiederfinden: %s: %s\n"

#, c-format
#~ msgid "%s: cannot execute binary file"
#~ msgstr "%s: Kann die Datei nicht ausführen."

#, c-format
#~ msgid "%s: cannot execute: %s"
#~ msgstr "%s: Kann nicht ausführen: %s"

#, c-format
#~ msgid "%s: cannot open temp file: %s"
#~ msgstr "%s: Kann die temporäre Datei nicht öffnen: %s"

#, c-format
#~ msgid "%d: invalid file descriptor: %s"
#~ msgstr "%d: Ungültiger Dateideskriptor: %s"

#, c-format
#~ msgid "read error: %d: %s"
#~ msgstr "Lesefehler: %d: %s"

#, c-format
#~ msgid "%s: cannot get limit: %s"
#~ msgstr "%s: Kann die nicht Grenze setzen: %s"

#, c-format
#~ msgid "%s: cannot modify limit: %s"
#~ msgstr "%s: Kann die Grenze nicht ändern: %s"

#, c-format
#~ msgid "cannot redirect standard input from /dev/null: %s"
#~ msgstr "Kann nicht die Standardeingabe von /dev/null umleiten: %s"

#, c-format
#~ msgid "%s: command not found"
#~ msgstr "%s: Kommando nicht gefunden."

#, c-format
#~ msgid "%s: %s: bad interpreter"
#~ msgstr "%s: %s: Defekter Interpreter"

#~ msgid "syntax error in expression"
#~ msgstr "Syntaxfehler im Ausdruck."

#~ msgid "syntax error in variable assignment"
#~ msgstr "Syntaxfehler in der Variablenzuweisung."

#~ msgid "syntax error: operand expected"
#~ msgstr "Syntaxfehler: Operator erwartet."

#~ msgid "syntax error: invalid arithmetic operator"
#~ msgstr "Syntaxfehler: Ungültiger arithmetischer Operator."

#, c-format
#~ msgid "setlocale: %s: cannot change locale (%s)"
#~ msgstr "setlocale: %s: Kann die Regionseinstellungen nicht ändern (%s)."

#, c-format
#~ msgid "%s: ambiguous redirect"
#~ msgstr "%s: Mehrdeutige Umlenkung."

#, c-format
#~ msgid "%s: cannot overwrite existing file"
#~ msgstr "%s: Kann existierende Datei nicht überschreiben."

#, c-format
#~ msgid "%s: restricted: cannot redirect output"
#~ msgstr "%s: eingeschränkt: Die Ausgabe darf nicht umgeleitet werden."

#, c-format
#~ msgid "cannot create temp file for here-document: %s"
#~ msgstr "Kann die temporäre Datei für das Hier-Dokument nicht anlegen: %s"

#, c-format
#~ msgid "%s: cannot assign fd to variable"
#~ msgstr "%s: Kann fd keiner Variable zuweisen."

#, c-format
#~ msgid "%s: integer expression expected"
#~ msgstr "%s: Ganzzahliger Ausdruck erwartet."

#~ msgid "Copyright (C) 2022 Free Software Foundation, Inc."
#~ msgstr "Copyright (C) 2022 Free Software Foundation, Inc."

#~ msgid "cd [-L|[-P [-e]] [-@]] [dir]"
#~ msgstr "cd [-L|[-P [-e]] [-@]] [Verzeichnis]"

#~ msgid "read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]"
#~ msgstr "read [-ers] [-a Feld] [-d Begrenzer] [-i Text] [-n Zeichenanzahl] [-N Zeichenanzahl] [-p Prompt] [-t Zeitlimit] [-u fd] [Name ...]"

#~ msgid "source filename [arguments]"
#~ msgstr "source Dateiname [Argumente]"

#~ msgid ". filename [arguments]"
#~ msgstr ". Dateiname [Argumente]"

#~ msgid "trap [-lp] [[arg] signal_spec ...]"
#~ msgstr "trap [-lp] [[Argument] Signalbezeichnung ...]"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00027.html
#~ msgid "compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
#~ msgstr "compgen [-abcdefgjksuv] [-o Option] [-A Aktion] [-G Suchmuster] [-W Wortliste] [-F Funktion] [-C Kommando] [-X Filtermuster] [-P Prefix] [-S Suffix] [Wort]"

# bind
#~ msgid ""
#~ "Set Readline key bindings and variables.\n"
#~ "    \n"
#~ "    Bind a key sequence to a Readline function or a macro, or set a\n"
#~ "    Readline variable.  The non-option argument syntax is equivalent to\n"
#~ "    that found in ~/.inputrc, but must be passed as a single argument:\n"
#~ "    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
#~ "                         command.  Acceptable keymap names are emacs,\n"
#~ "                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
#~ "                         vi-command, and vi-insert.\n"
#~ "      -l                 List names of functions.\n"
#~ "      -P                 List function names and bindings.\n"
#~ "      -p                 List functions and bindings in a form that can be\n"
#~ "                         reused as input.\n"
#~ "      -S                 List key sequences that invoke macros and their values\n"
#~ "      -s                 List key sequences that invoke macros and their values\n"
#~ "                         in a form that can be reused as input.\n"
#~ "      -V                 List variable names and values\n"
#~ "      -v                 List variable names and values in a form that can\n"
#~ "                         be reused as input.\n"
#~ "      -q  function-name  Query about which keys invoke the named function.\n"
#~ "      -u  function-name  Unbind all keys which are bound to the named function.\n"
#~ "      -r  keyseq         Remove the binding for KEYSEQ.\n"
#~ "      -f  filename       Read key bindings from FILENAME.\n"
#~ "      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
#~ "    \t\t\t\tKEYSEQ is entered.\n"
#~ "      -X                 List key sequences bound with -x and associated commands\n"
#~ "                         in a form that can be reused as input.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    bind returns 0 unless an unrecognized option is given or an error occurs."
#~ msgstr ""
#~ "Bestimmt Readline Tastenzuordnungen und Variablen.\n"
#~ "    \n"
#~ "    Weist eine Tastensequenz einer Readlinefunktion oder -makro zu\n"
#~ "    oder setzt eine Readlinevariable.  Die Argumentsyntax ist zu\n"
#~ "    den Einträgen in ~/.inputrc äquivalent, aber sie müssen als\n"
#~ "    einzelnes Argument übergeben werden.  Z.B: bind '\"\\C-x\\C-r\":\n"
#~ "    re-read-init-file'.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -m  Keymap         Benutzt KEYMAP as Tastaturbelegung für die Laufzeit\n"
#~ "                         dieses Kommandos.  Gültige Keymapnamen sind: emacs,\n"
#~ "                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
#~ "                         vi-command und vi-insert.\n"
#~ "      -l                 Listet Funktionsnamen auf.\n"
#~ "      -P                 Listet Funktionsnamen und Tastenzuordnungen auf.\n"
#~ "      -p                 Listet Funktionsnamen und Tastenzuordnungen so auf,\n"
#~ "                         dass sie direkt als Eingabe verwendet werden können.\n"
#~ "      -S                 Listet Tastenfolgen und deren Werte auf, die Makros \n"
#~ "                         aufrufen.\n"
#~ "      -s                 Listet Tastenfolgen und deren Werte auf, die Makros \n"
#~ "                         aufrufen, dass sie als Eingabe wiederverwendet werden\n"
#~ "                         können.\n"
#~ "      -V                 Listet Variablennamen und Werte auf.\n"
#~ "      -v                 Listet Variablennamen und Werte so auf, dass sie als\n"
#~ "                         Eingabe verwendet werden können.\n"
#~ "      -q  Funktionsname  Sucht die Tastenfolgen, welche die angegebene\n"
#~ "                         Funktion aufrufen.\n"
#~ "      -u  Funktionsname  Entfernt alle der Funktion zugeordneten Tastenfolgen.\n"
#~ "      -r  Tastenfolge    Entfernt die Zuweisungen der angegebeben Tastenfolge.\n"
#~ "      -f  Dateiname      Liest die Tastenzuordnungen aus der angegebenen Datei.\n"
#~ "      -x  Tastenfolge:Shellkommando\tWeist der Tastenfolge das Shellkommando\n"
#~ "    \t\t\t\t\tzu.\n"
#~ "      -X                                Listet mit -x erzeugte\n"
#~ "                                        Tastenfolgen und deren Werte\n"
#~ "                                        auf, die Makros aufrufen, dass\n"
#~ "                                        sie als Eingabe wiederverwendet werden\n"
#~ "                                        können.\n"
#~ "    \n"
#~ "    Rückgabewert: \n"
#~ "    Bind gibt 0 zurück, wenn keine unerkannte Option angegeben wurde\n"
#~ "    oder ein Fehler eintrat."

# cd
#~ msgid ""
#~ "Change the shell working directory.\n"
#~ "    \n"
#~ "    Change the current directory to DIR.  The default DIR is the value of the\n"
#~ "    HOME shell variable.\n"
#~ "    \n"
#~ "    The variable CDPATH defines the search path for the directory containing\n"
#~ "    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n"
#~ "    A null directory name is the same as the current directory.  If DIR begins\n"
#~ "    with a slash (/), then CDPATH is not used.\n"
#~ "    \n"
#~ "    If the directory is not found, and the shell option `cdable_vars' is set,\n"
#~ "    the word is assumed to be  a variable name.  If that variable has a value,\n"
#~ "    its value is used for DIR.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -L\tforce symbolic links to be followed: resolve symbolic\n"
#~ "    \t\tlinks in DIR after processing instances of `..'\n"
#~ "      -P\tuse the physical directory structure without following\n"
#~ "    \t\tsymbolic links: resolve symbolic links in DIR before\n"
#~ "    \t\tprocessing instances of `..'\n"
#~ "      -e\tif the -P option is supplied, and the current working\n"
#~ "    \t\tdirectory cannot be determined successfully, exit with\n"
#~ "    \t\ta non-zero status\n"
#~ "      -@\ton systems that support it, present a file with extended\n"
#~ "    \t\tattributes as a directory containing the file attributes\n"
#~ "    \n"
#~ "    The default is to follow symbolic links, as if `-L' were specified.\n"
#~ "    `..' is processed by removing the immediately previous pathname component\n"
#~ "    back to a slash or the beginning of DIR.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns 0 if the directory is changed, and if $PWD is set successfully when\n"
#~ "    -P is used; non-zero otherwise."
#~ msgstr ""
#~ "Wechselt das Arbeitsverzeichnis.\n"
#~ "\n"
#~ "    Wechselt in das angegebene Arbeitsverzeichnis. Ohne Angabe eines\n"
#~ "    Verzeichnisses wird in das in der Variable HOME definierte\n"
#~ "    Verzeichnis gewechselt.\n"
#~ "\n"
#~ "    Die Variable CDPATH definiert den Suchpfad, in dem nach dem\n"
#~ "    angegebenen Verzeichnisnamen gesucht wird. Mehrere Pfade werden\n"
#~ "    durch Doppelpunkte »:« getrennt. Ein leerer Pfadname entspricht\n"
#~ "    dem aktuellen Verzeichnis. Mit einem vollständigen Pfadnamen wird\n"
#~ "    CDPATH nicht benutzt.\n"
#~ "\n"
#~ "    Wird kein entsprechendes Verzeichnis gefunden und die Shelloption\n"
#~ "    »cdable_vars« ist gesetzt, dann wird der `Wert' als Variable\n"
#~ "    interpretiert. Dessen Inhalt wird dann als Verzeichnisname\n"
#~ "    verwendet.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -L        Erzwingt, dass symbolischen Links gefolgt wird.\n"
#~ "                Symbolische Links im aktuellen Verzeichnis werden nach\n"
#~ "                dem übergeordneten Verzeichnis aufgelöst.\n"
#~ "      -P        Symbolische Links werden ignoriert. Symbolische\n"
#~ "                Links im aktuellen Verzeichnis werden vor dem\n"
#~ "                übergeordneten Verzeichnis aufgelöst.\n"
#~ "      -e        Wenn mit der Option »-P« das aktuelle Arbeitsverzeichnis\n"
#~ "                nicht ermittelt werden kann, wird mit einem Rückgabewert\n"
#~ "                ungleich 0 abgebrochen.\n"
#~ "      -@        Wenn es das System unterstützt, wird eine Datei mit\n"
#~ "                erweiterten Attributen als ein Verzeichnis angezeigt,\n"
#~ "                welches die erweiterten Attribute enthält.\n"
#~ "\n"
#~ "    Standardmäßig wird symbolischen Links gefolgt (Option -L).\n"
#~ "    Das übergeordnete Verzeichnis wird ermittelt, indem der\n"
#~ "    Dateiname am letzten Schrägstrich gekürzt wird, oder es wird der\n"
#~ "    Anfang von DIR verwendet.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Der Rückgabewert ist 0, wenn das Verzeichnis erfolgreich\n"
#~ "    gewechselt wurde, oder wenn die Option -P angegeben und $PWD\n"
#~ "    erfolgreich gesetzt werden konnte. Sonst ist er ungleich 0."

# declare
#~ msgid ""
#~ "Set variable values and attributes.\n"
#~ "    \n"
#~ "    Declare variables and give them attributes.  If no NAMEs are given,\n"
#~ "    display the attributes and values of all variables.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -f\trestrict action or display to function names and definitions\n"
#~ "      -F\trestrict display to function names only (plus line number and\n"
#~ "    \t\tsource file when debugging)\n"
#~ "      -g\tcreate global variables when used in a shell function; otherwise\n"
#~ "    \t\tignored\n"
#~ "      -I\tif creating a local variable, inherit the attributes and value\n"
#~ "    \t\tof a variable with the same name at a previous scope\n"
#~ "      -p\tdisplay the attributes and value of each NAME\n"
#~ "    \n"
#~ "    Options which set attributes:\n"
#~ "      -a\tto make NAMEs indexed arrays (if supported)\n"
#~ "      -A\tto make NAMEs associative arrays (if supported)\n"
#~ "      -i\tto make NAMEs have the `integer' attribute\n"
#~ "      -l\tto convert the value of each NAME to lower case on assignment\n"
#~ "      -n\tmake NAME a reference to the variable named by its value\n"
#~ "      -r\tto make NAMEs readonly\n"
#~ "      -t\tto make NAMEs have the `trace' attribute\n"
#~ "      -u\tto convert the value of each NAME to upper case on assignment\n"
#~ "      -x\tto make NAMEs export\n"
#~ "    \n"
#~ "    Using `+' instead of `-' turns off the given attribute.\n"
#~ "    \n"
#~ "    Variables with the integer attribute have arithmetic evaluation (see\n"
#~ "    the `let' command) performed when the variable is assigned a value.\n"
#~ "    \n"
#~ "    When used in a function, `declare' makes NAMEs local, as with the `local'\n"
#~ "    command.  The `-g' option suppresses this behavior.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is supplied or a variable\n"
#~ "    assignment error occurs."
#~ msgstr ""
#~ "Setzt Variablenwerte und deren Attribute.\n"
#~ "\n"
#~ "    Deklariert Variablen und weist ihnen Attribute zu. Wenn keine Namen\n"
#~ "    angegeben sind, werden die Attribute und Werte aller Variablen ausgegeben.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -f        Schränkt Aktionen oder Anzeigen auf Funktionsnamen\n"
#~ "                und Definitionen ein.\n"
#~ "      -F        Zeigt nur Funktionsnamen an (inklusive Zeilennummer\n"
#~ "                und Quelldatei beim Debuggen).\n"
#~ "      -g        Deklariert globale Varieblen innerhalb einer\n"
#~ "                Shellfunktion; wird ansonsten ignoriert.\n"
#~ "      -I        Eine neue lokale Variable erhält die Attribute und Werte der\n"
#~ "                Variable mit gleichen Namen im vorherigen Gültigkeitsbereich. \n"
#~ "      -p        Zeigt die Attribute und Werte jeder angegebenen\n"
#~ "                Variable an.\n"
#~ "\n"
#~ "    Attribute setzen:\n"
#~ "      -a\tDeklariert ein indiziertes Feld (wenn unterstützt).\n"
#~ "      -A\tDeklariert ein assoziatives Feld (wenn unterstützt).\n"
#~ "      -i\tDeklariert eine ganzzahlige Variable.\n"
#~ "      -l\tKonvertiert die übergebenen Werte zu Kleinbuchstaben.\n"
#~ "      -n\tDer Name wird als Variable interpretiert. \n"
#~ "      -r\tDeklariert nur lesbare Variablen.\n"
#~ "      -t\tWeist das Attribut »trace« zu.\n"
#~ "      -u\tKonvertiert die übergebenen Werte in Großbuchstaben.\n"
#~ "      -x\tExportiert die Variablen.\n"
#~ "\n"
#~ "    Das Voranstellen von »+« anstelle von »-« schaltet die angegebenen\n"
#~ "    Attribute ab.\n"
#~ "\n"
#~ "    Für ganzzahlige Variablen werden bei der Zuweisung arithmetische\n"
#~ "    Berechnungen durchgeführt (siehe »help let«).\n"
#~ "\n"
#~ "    Innerhalb einer Funktion werden lokale Variablen erzeugt. Die\n"
#~ "    Option »-g« unterdrückt dieses Verhalten.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Gibt »Erfolg« zurück, außer eine ungültige Option wurde angegeben,\n"
#~ "    oder ein Fehler trat auf."

#~ msgid ""
#~ "Define local variables.\n"
#~ "    \n"
#~ "    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
#~ "    be any option accepted by `declare'.\n"
#~ "    \n"
#~ "    Local variables can only be used within a function; they are visible\n"
#~ "    only to the function where they are defined and its children.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is supplied, a variable\n"
#~ "    assignment error occurs, or the shell is not executing a function."
#~ msgstr ""
#~ "Definiert lokale Variablen.\n"
#~ "\n"
#~ "    Erzeugt eine lokale Variable Name und weist ihr den Wert Wert zu.\n"
#~ "    Option kann eine beliebige von »declare« akzeptierte Option sein.\n"
#~ "\n"
#~ "    Lokale Variablen können nur innerhalb einer Funktion benutzt\n"
#~ "    werden. Sie sind nur in der sie erzeugenden Funktion und ihren\n"
#~ "    Kindern sichtbar.\n"
#~ "\n"
#~ "    Rückgabewert: \n"
#~ "    Liefert 0 außer bei Angabe einer ungültigen Option, einer\n"
#~ "    fehlerhaften Variablenzuweisung oder dem Aufruf außerhalb einer\n"
#~ "    Funktion."

# enable
#~ msgid ""
#~ "Enable and disable shell builtins.\n"
#~ "    \n"
#~ "    Enables and disables builtin shell commands.  Disabling allows you to\n"
#~ "    execute a disk command which has the same name as a shell builtin\n"
#~ "    without using a full pathname.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -a\tprint a list of builtins showing whether or not each is enabled\n"
#~ "      -n\tdisable each NAME or display a list of disabled builtins\n"
#~ "      -p\tprint the list of builtins in a reusable format\n"
#~ "      -s\tprint only the names of Posix `special' builtins\n"
#~ "    \n"
#~ "    Options controlling dynamic loading:\n"
#~ "      -f\tLoad builtin NAME from shared object FILENAME\n"
#~ "      -d\tRemove a builtin loaded with -f\n"
#~ "    \n"
#~ "    Without options, each NAME is enabled.\n"
#~ "    \n"
#~ "    To use the `test' found in $PATH instead of the shell builtin\n"
#~ "    version, type `enable -n test'.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless NAME is not a shell builtin or an error occurs."
#~ msgstr ""
#~ "Eingebaute Shell-Kommandos aktivieren und deaktivieren.\n"
#~ "\n"
#~ "    Aktiviert und deaktiviert eingebaute Shell-Kommandos. Die Deaktivierung\n"
#~ "    erlaubt Ihnen, eigene Kommandos mit demselben Namen wie die eingebauten\n"
#~ "    Kommandos zu nutzen, ohne den kompletten Pfad angeben zu müssen.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -a\tGibt eine Liste der eingebauten Kommandos aus inklusive der\n"
#~ "        \tInformation, ob sie aktiv sind oder nicht.\n"
#~ "\n"
#~ "      -n\tdeaktiviert jedes angegebene Kommando oder gibt eine\n"
#~ "        \tListe der deaktivierten eingebauten Kommandos aus.\n"
#~ "      -p\tGibt eine Liste der eingebauten Kommandos in einem\n"
#~ "        \twiederverwendbaren Format aus.\n"
#~ "      -s\tGibt nur die Namen der »speziellen« in POSIX eingebauten\n"
#~ "        \tKommandos aus.\n"
#~ "\n"
#~ "    Optionen zum Beeinflussen des dynamischen Ladens:\n"
#~ "      -f\tLädt ein eingebautes Kommando aus der angegebenen Datei.\n"
#~ "      -d\tEntfernt ein mit »-f« geladenes Kommando.\n"
#~ "\n"
#~ "    Ohne Optionen wird jedes angegebene Kommando aktiviert.\n"
#~ "\n"
#~ "    Um das unter $PATH liegende Kommando »test« anstelle der eingebauten\n"
#~ "    Version zu nutzen, geben Sie »enable -n test« ein.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Gibt »Erfolg« zurück, außer Name ist kein eingebautes Kommando\n"
#~ "    oder ein Fehler tritt auf."

# fc
#~ msgid ""
#~ "Display or execute commands from the history list.\n"
#~ "    \n"
#~ "    fc is used to list or edit and re-execute commands from the history list.\n"
#~ "    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
#~ "    string, which means the most recent command beginning with that\n"
#~ "    string.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -e ENAME\tselect which editor to use.  Default is FCEDIT, then EDITOR,\n"
#~ "    \t\tthen vi\n"
#~ "      -l \tlist lines instead of editing\n"
#~ "      -n\tomit line numbers when listing\n"
#~ "      -r\treverse the order of the lines (newest listed first)\n"
#~ "    \n"
#~ "    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
#~ "    re-executed after the substitution OLD=NEW is performed.\n"
#~ "    \n"
#~ "    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
#~ "    runs the last command beginning with `cc' and typing `r' re-executes\n"
#~ "    the last command.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success or status of executed command; non-zero if an error occurs."
#~ msgstr ""
#~ "Anzeigen oder Ausführen von Befehlen aus der History-Liste.\n"
#~ "    \n"
#~ "    fc wird verwendet, um Befehle aus der History-Liste aufzulisten,\n"
#~ "    zu bearbeiten und erneut auszuführen.  FIRST und LAST können\n"
#~ "    Zahlen sein, die den Bereich angeben, oder FIRST kann eine\n"
#~ "    Zeichenkette sein, was bedeutet, dass der jüngste Befehl mit\n"
#~ "    dieser Zeichenfolge beginnt.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -e ENAME Auswahl des zu verwendenden Editors.  Standard sind FCEDIT,\n"
#~ "         dann EDITOR, dann vi.\n"
#~ "      -l Zeilen auflisten statt bearbeiten.\n"
#~ "      -n Zeilennummern beim Auflisten weglassen.\n"
#~ "      -r kehrt die Reihenfolge der Zeilen um (die neuesten Zeilen zuerst).\n"
#~ "    \n"
#~ "    Mit `fc -s [pat=rep ...] [command]' wird COMMAND erneut\n"
#~ "    ausgeführt, nachdem die Ersetzung OLD=NEW durchgeführt wurde.\n"
#~ "    \n"
#~ "    Ein nützlicher Alias ist r='fc -s', so dass die Eingabe von `r cc'\n"
#~ "    den letzten Befehl ausführt, der mit \"cc\" beginnt, und die Eingabe\n"
#~ "    von \"r\" den letzten Befehl erneut ausführt.\n"
#~ "    \n"
#~ "    Exit-Status:\n"
#~ "    Gibt den Erfolg oder den Status des ausgeführten Befehls zurück;\n"
#~ "    ungleich Null, wenn ein Fehler auftritt."

# history
#~ msgid ""
#~ "Display or manipulate the history list.\n"
#~ "    \n"
#~ "    Display the history list with line numbers, prefixing each modified\n"
#~ "    entry with a `*'.  An argument of N lists only the last N entries.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -c\tclear the history list by deleting all of the entries\n"
#~ "      -d offset\tdelete the history entry at position OFFSET. Negative\n"
#~ "    \t\toffsets count back from the end of the history list\n"
#~ "    \n"
#~ "      -a\tappend history lines from this session to the history file\n"
#~ "      -n\tread all history lines not already read from the history file\n"
#~ "    \t\tand append them to the history list\n"
#~ "      -r\tread the history file and append the contents to the history\n"
#~ "    \t\tlist\n"
#~ "      -w\twrite the current history to the history file\n"
#~ "    \n"
#~ "      -p\tperform history expansion on each ARG and display the result\n"
#~ "    \t\twithout storing it in the history list\n"
#~ "      -s\tappend the ARGs to the history list as a single entry\n"
#~ "    \n"
#~ "    If FILENAME is given, it is used as the history file.  Otherwise,\n"
#~ "    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
#~ "    \n"
#~ "    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
#~ "    as a format string for strftime(3) to print the time stamp associated\n"
#~ "    with each displayed history entry.  No time stamps are printed otherwise.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is given or an error occurs."
#~ msgstr ""
#~ "Zeigt die Verlaufsliste an oder bearbeitet sie.\n"
#~ "    \n"
#~ "    Zeigt die Verlaufsliste mit Zeilennummern an und stellt jedem\n"
#~ "    geänderten Eintrag ein `*' vorangestellt.  Ein Argument von N\n"
#~ "    listet nur die letzten N Einträge auf.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -c Löscht die Verlaufsliste, indem alle Einträge gelöscht werden.\n"
#~ "      -d offset löscht den Verlaufseintrag an der Position\n"
#~ "         OFFSET. Negative Offsets zählen vom Verlaufslistenende\n"
#~ "         zurück.\n"
#~ "      -a Anhängen vom Verlauf dieser Sitzung an die Verlaufsdatei.\n"
#~ "      -n alle nicht bereits aus der Verlaufsdatei gelesenen.\n"
#~ "         Verlaufszeilen lesen und an die Verlaufsliste anhängen.\n"
#~ "      -r liest die Verlaufsdatei und hängt den Inhalt an die\n"
#~ "         Verlaufsliste an.\n"
#~ "      -w schreibt den aktuellen Verlauf in die Verlaufsdatei.\n"
#~ "      -p führt eine Verlaufserweiterung für jedes ARG durch und zeigt\n"
#~ "         das Ergebnis an, ohne es in der Verlaufslise einzutragen.\n"
#~ "      -s die ARGs als einen einzigen Eintrag an die History-Liste anhängen.\n"
#~ "    \n"
#~ "    Wenn FILENAME angegeben ist, wird dieser als History-Datei verwendet.\n"
#~ "    Andernfalls, wenn HISTFILE einen Wert hat, wird dieser verwendet,\n"
#~ "    sonst ~/.bash_history.\n"
#~ "    \n"
#~ "    Wenn die Variable HISTTIMEFORMAT gesetzt und nicht null ist, wird\n"
#~ "    ihr Wert verwendet als Formatierungszeichenfolge für strftime(3)\n"
#~ "    verwendet, um den Zeitstempel zu Zeitstempel für jeden angezeigten\n"
#~ "    History-Eintrag zu drucken.  Andernfalls werden keine Zeitstempel\n"
#~ "    gedruckt.\n"
#~ "    \n"
#~ "    Rückgabewert:\n"
#~ "    Gibt einen Erfolg zurück, es sei denn, es wurde eine ungültige\n"
#~ "    Option angegeben oder es ist ein Fehler aufgetreten."

# read
#~ msgid ""
#~ "Read a line from the standard input and split it into fields.\n"
#~ "    \n"
#~ "    Reads a single line from the standard input, or from file descriptor FD\n"
#~ "    if the -u option is supplied.  The line is split into fields as with word\n"
#~ "    splitting, and the first word is assigned to the first NAME, the second\n"
#~ "    word to the second NAME, and so on, with any leftover words assigned to\n"
#~ "    the last NAME.  Only the characters found in $IFS are recognized as word\n"
#~ "    delimiters. By default, the backslash character escapes delimiter characters\n"
#~ "    and newline.\n"
#~ "    \n"
#~ "    If no NAMEs are supplied, the line read is stored in the REPLY variable.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -a array\tassign the words read to sequential indices of the array\n"
#~ "    \t\tvariable ARRAY, starting at zero\n"
#~ "      -d delim\tcontinue until the first character of DELIM is read, rather\n"
#~ "    \t\tthan newline\n"
#~ "      -e\tuse Readline to obtain the line\n"
#~ "      -i text\tuse TEXT as the initial text for Readline\n"
#~ "      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
#~ "    \t\tfor a newline, but honor a delimiter if fewer than\n"
#~ "    \t\tNCHARS characters are read before the delimiter\n"
#~ "      -N nchars\treturn only after reading exactly NCHARS characters, unless\n"
#~ "    \t\tEOF is encountered or read times out, ignoring any\n"
#~ "    \t\tdelimiter\n"
#~ "      -p prompt\toutput the string PROMPT without a trailing newline before\n"
#~ "    \t\tattempting to read\n"
#~ "      -r\tdo not allow backslashes to escape any characters\n"
#~ "      -s\tdo not echo input coming from a terminal\n"
#~ "      -t timeout\ttime out and return failure if a complete line of\n"
#~ "    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
#~ "    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
#~ "    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
#~ "    \t\timmediately, without trying to read any data, returning\n"
#~ "    \t\tsuccess only if input is available on the specified\n"
#~ "    \t\tfile descriptor.  The exit status is greater than 128\n"
#~ "    \t\tif the timeout is exceeded\n"
#~ "      -u fd\tread from file descriptor FD instead of the standard input\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    The return code is zero, unless end-of-file is encountered, read times out\n"
#~ "    (in which case it's greater than 128), a variable assignment error occurs,\n"
#~ "    or an invalid file descriptor is supplied as the argument to -u."
#~ msgstr ""
#~ "Liest eine Zeile von der Standardeingabe und teilt sie in Felder auf.\n"
#~ "    \n"
#~ "    Liest eine Zeile von der Standardeingabe oder, mit der Option -u, dem\n"
#~ "    Dateideskriptor FD. Die Zeile wird ähnlich der Wortaufteilung in Felder\n"
#~ "    geteilt, und in der angegebenen Reihenfolge den Namen zugewiesen.\n"
#~ "    Überzählige Felder werden dem letzten Namen zugewiesen. Die in $IFS\n"
#~ "    enthaltenen Zeichen werden als Trennzeichen verwendet.\n"
#~ "    \n"
#~ "    Wenn keine NAMEn angegeben werden, wird die gelesene Zeile in der\n"
#~ "    REPLY-Variablen gespeichert.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -a array weist die gelesenen Wörter den aufeinanderfolgenden\n"
#~ "               Indizes der Array Variable ARRAY, beginnend bei Null.\n"
#~ "      -d delim fortfahren, bis das erste Zeichen von DELIM gelesen\n"
#~ "               wird, anstelle von statt Newline.\n"
#~ "      -e Readline verwenden, um die Zeile zu lesen.\n"
#~ "      -i text TEXT als Anfangstext für Readline verwenden.\n"
#~ "      -n nchars Liest maximal NCHARS Zeichen, ohne ein Zeilenumbruch\n"
#~ "    \t\tzu suchen. Worttrennzeichen werden ausgewertet.\n"
#~ "      -N nchars Liest genau NCHARS Zeichen, bis EOF oder einer\n"
#~ "    \t\tZeitüberschreitung. Worttrennzeichen werden ignoriert.\n"
#~ "      -p prompt Gibt vor dem Lesen die Zeichenkette PROMPT ohne einen\n"
#~ "    \t\tabschließenden Zeilenumbruch aus.\n"
#~ "      -r        lässt keine Backslashes als Escape-Zeichen zu\n"
#~ "      -s        keine Echo-Eingabe von einem Terminal\n"
#~ "      -t timeout\n"
#~ "                Zeitüberschreitung und Rückgabe eines Fehlers, wenn\n"
#~ "    \t\teine vollständige Eingabezeile nicht innerhalb von\n"
#~ "    \t\tTIMEOUT Sekunden gelesen wird. Die TMOUT Variable\n"
#~ "    \t\tenthält das Standard-Timeout.  TIMEOUT kann als\n"
#~ "    \t\tBruchteil angegeben werden.  Wenn TIMEOUT gleich 0\n"
#~ "    \t\tist, werden keine daten geleden und gibt Erfolg\n"
#~ "    \t\tzurück, wenn Daten dem angegebenen Dateideskriptor\n"
#~ "    \t\tverfügbar sind.  Der Rückgabewert ist größer als 128,\n"
#~ "    \t\twenn die Zeitüberschreitung abgelaufen ist.\n"
#~ "      -u fd Lesen von Dateideskriptor FD statt von der Standardeingabe\n"
#~ "    \n"
#~ "    Rückgabewert: \n"
#~ "    Der Rückgabewert ist Null. Es sei denn, das Dateiende wurde\n"
#~ "    erreicht, die Lesezeit überschritten (in diesem Fall ist er größer\n"
#~ "    als 128), ein Variablenzuweisungsfehler tritt auf oder ein\n"
#~ "    ungültiger Dateideskriptor wurde als Argument von -u übergeben."

# set
#~ msgid ""
#~ "Set or unset values of shell options and positional parameters.\n"
#~ "    \n"
#~ "    Change the value of shell attributes and positional parameters, or\n"
#~ "    display the names and values of shell variables.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -a  Mark variables which are modified or created for export.\n"
#~ "      -b  Notify of job termination immediately.\n"
#~ "      -e  Exit immediately if a command exits with a non-zero status.\n"
#~ "      -f  Disable file name generation (globbing).\n"
#~ "      -h  Remember the location of commands as they are looked up.\n"
#~ "      -k  All assignment arguments are placed in the environment for a\n"
#~ "          command, not just those that precede the command name.\n"
#~ "      -m  Job control is enabled.\n"
#~ "      -n  Read commands but do not execute them.\n"
#~ "      -o option-name\n"
#~ "          Set the variable corresponding to option-name:\n"
#~ "              allexport    same as -a\n"
#~ "              braceexpand  same as -B\n"
#~ "              emacs        use an emacs-style line editing interface\n"
#~ "              errexit      same as -e\n"
#~ "              errtrace     same as -E\n"
#~ "              functrace    same as -T\n"
#~ "              hashall      same as -h\n"
#~ "              histexpand   same as -H\n"
#~ "              history      enable command history\n"
#~ "              ignoreeof    the shell will not exit upon reading EOF\n"
#~ "              interactive-comments\n"
#~ "                           allow comments to appear in interactive commands\n"
#~ "              keyword      same as -k\n"
#~ "              monitor      same as -m\n"
#~ "              noclobber    same as -C\n"
#~ "              noexec       same as -n\n"
#~ "              noglob       same as -f\n"
#~ "              nolog        currently accepted but ignored\n"
#~ "              notify       same as -b\n"
#~ "              nounset      same as -u\n"
#~ "              onecmd       same as -t\n"
#~ "              physical     same as -P\n"
#~ "              pipefail     the return value of a pipeline is the status of\n"
#~ "                           the last command to exit with a non-zero status,\n"
#~ "                           or zero if no command exited with a non-zero status\n"
#~ "              posix        change the behavior of bash where the default\n"
#~ "                           operation differs from the Posix standard to\n"
#~ "                           match the standard\n"
#~ "              privileged   same as -p\n"
#~ "              verbose      same as -v\n"
#~ "              vi           use a vi-style line editing interface\n"
#~ "              xtrace       same as -x\n"
#~ "      -p  Turned on whenever the real and effective user ids do not match.\n"
#~ "          Disables processing of the $ENV file and importing of shell\n"
#~ "          functions.  Turning this option off causes the effective uid and\n"
#~ "          gid to be set to the real uid and gid.\n"
#~ "      -t  Exit after reading and executing one command.\n"
#~ "      -u  Treat unset variables as an error when substituting.\n"
#~ "      -v  Print shell input lines as they are read.\n"
#~ "      -x  Print commands and their arguments as they are executed.\n"
#~ "      -B  the shell will perform brace expansion\n"
#~ "      -C  If set, disallow existing regular files to be overwritten\n"
#~ "          by redirection of output.\n"
#~ "      -E  If set, the ERR trap is inherited by shell functions.\n"
#~ "      -H  Enable ! style history substitution.  This flag is on\n"
#~ "          by default when the shell is interactive.\n"
#~ "      -P  If set, do not resolve symbolic links when executing commands\n"
#~ "          such as cd which change the current directory.\n"
#~ "      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.\n"
#~ "      --  Assign any remaining arguments to the positional parameters.\n"
#~ "          If there are no remaining arguments, the positional parameters\n"
#~ "          are unset.\n"
#~ "      -   Assign any remaining arguments to the positional parameters.\n"
#~ "          The -x and -v options are turned off.\n"
#~ "    \n"
#~ "    Using + rather than - causes these flags to be turned off.  The\n"
#~ "    flags can also be used upon invocation of the shell.  The current\n"
#~ "    set of flags may be found in $-.  The remaining n ARGs are positional\n"
#~ "    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
#~ "    ARGs are given, all shell variables are printed.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is given."
#~ msgstr ""
#~ "Setzen oder Aufheben von Shell-Optionen und Positionsparametern.\n"
#~ "    \n"
#~ "    Den Wert von Shell-Attributen und Positionsparametern ändern, oder\n"
#~ "    die Namen und Werte von Shell-Variablen anzeigen.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -a Markieren von Variablen die geändert oder erstellt wurden, für den Export.\n"
#~ "      -b Sofortige Benachrichtigung über das Auftragsende.\n"
#~ "      -e Sofortiger Abbruch, wenn ein Befehl mit einem Status ungleich Null beendet wird.\n"
#~ "      -f Deaktiviert das Generieren von Dateinamen (globbing).\n"
#~ "      -h Merkt sich den Speicherort von Befehlen, wenn sie nachgeschlagen werden.\n"
#~ "      -k Alle Zuweisungsargumente werden in die Umgebung für einen\n"
#~ "         Befehl in die Umgebung aufgenommen, nicht nur diejenigen,\n"
#~ "         die dem Befehl vorangestellt sind.\n"
#~ "      -m Die Auftragskontrolle ist aktiviert.\n"
#~ "      -n Befehle lesen, aber nicht ausführen.\n"
#~ "      -o Optionsname\n"
#~ "          Setzt die Variable, die dem Optionsname entspricht:\n"
#~ "              allexport wie -a\n"
#~ "              braceexpand wie -B\n"
#~ "              emacs verwendet eine emacsähnliche Schnittstelle zur Zeilenbearbeitung\n"
#~ "              errexit gleich wie -e\n"
#~ "              errtrace dasselbe wie -E\n"
#~ "              functrace dasselbe wie -T\n"
#~ "              hashall dasselbe wie -h\n"
#~ "              histexpand gleich wie -H\n"
#~ "              history Befehlshistorie aktivieren\n"
#~ "              ignoreeof die Shell wird beim Lesen von EOF nicht beendet\n"
#~ "              interaktive-Kommentare\n"
#~ "                           erlaubt das Erscheinen von Kommentaren in interaktiven Befehlen\n"
#~ "              keyword dasselbe wie -k\n"
#~ "              monitor gleich wie -m\n"
#~ "              noclobber dasselbe wie -C\n"
#~ "              noexec gleich wie -n\n"
#~ "              noglob gleich wie -f\n"
#~ "              nolog wird derzeit akzeptiert, aber ignoriert\n"
#~ "              notify gleich wie -b\n"
#~ "              nounset dasselbe wie -u\n"
#~ "              onecmd dasselbe wie -t\n"
#~ "              physical wie -P\n"
#~ "              pipefail der Rückgabewert einer Pipeline ist der Status\n"
#~ "                       des des letzten Befehls, der mit einem Status\n"
#~ "                       ungleich Null beendet wurde, oder Null, wenn\n"
#~ "                       kein Befehl mit einem Status ungleich Null\n"
#~ "                       beendet wurde.\n"
#~ "             posix     Ändert das Verhalten von bash, wo die Standard\n"
#~ "                       Operation vom Posix-Standard abweicht, um mit\n"
#~ "                       dem Standard übereinstimmen.\n"
#~ "              privilegiert gleich wie -p\n"
#~ "              verbose dasselbe wie -v\n"
#~ "              vi eine vi-ähnliche Schnittstelle zur Zeilenbearbeitung verwenden\n"
#~ "              xtrace dasselbe wie -x\n"
#~ "      -p Wird eingeschaltet, wenn die realen und effektiven\n"
#~ "         Benutzerkennungen nicht übereinstimmen.  Deaktiviert die\n"
#~ "         Verarbeitung der $ENV-Datei und das Importieren von Shell\n"
#~ "         Funktionen.  Wenn diese Option ausgeschalten ist, werden die\n"
#~ "         effektive uid und gid auf die reale uid und gid gesetzt. \n"
#~ "      -t Beenden nach dem Lesen und Ausführen eines Befehls.\n"
#~ "      -u Nicht gesetzte Variablen beim Substituieren als Fehler behandeln.\n"
#~ "      -v Shell-Eingabezeilen ausgeben, wenn sie gelesen werden.\n"
#~ "      -x Befehle und ihre Argumente ausgeben, wenn sie ausgeführt werden.\n"
#~ "      -B Die Shell führt eine Klammererweiterung durch\n"
#~ "      -C Dateien werden bei Ausgabeumleitung nicht überschrieben.\n"
#~ "      -E Wenn gesetzt, wird die Fehlerfalle (trap) an Shell-Funktionen vererbt.\n"
#~ "      -H Aktiviert die !-Stil Verlaufsersetzung.  Diese Option ist\n"
#~ "         bei einer interaktiven Shell standardmäßig aktiviert.\n"
#~ "      -P Symbolische Links werden nicht aufgelöst, wenn Befehle wie\n"
#~ "         z.B. cd, das aktuelle Verzeichnis ändern.\n"
#~ "      -T DEBUG und RETURN Fallen (trap) werden an Shellfunktionen vererbt.\n"
#~ "      -- Weist alle verbleibenden Argumente den Positionsparametern\n"
#~ "         zu.  Sind keine Argumente verblieben, werden die\n"
#~ "         Positionsparameter nicht gesetzt.\n"
#~ "      - Weist alle verbleibenden Argumente den Positionsparametern zu.\n"
#~ "        Die Optionen -x und -v sind ausgeschaltet.\n"
#~ "    \n"
#~ "    Durch Verwenden von + anstelle von - werden Option ausgeschaltet.\n"
#~ "    Die Optionen können auch beim Shellaufruf verwendet werden.  Die\n"
#~ "    aktuelle aktiven Optionen sind in $- gespeichert.  Die restlichen\n"
#~ "    n ARGs sind positionale Parameter und werden der Reihe nach $1,\n"
#~ "    $2, ... $n zugewiesen.  Wenn keine ARGs angegeben werden, werden\n"
#~ "    alle Shell-Variablen ausgegeben.\n"
#~ "    \n"
#~ "    Rückgabewert:\n"
#~ "    Gibt Erfolg zurück, es sei denn, eine ungültige Option wurde angegeben."

# "."
#~ msgid ""
#~ "Execute commands from a file in the current shell.\n"
#~ "    \n"
#~ "    Read and execute commands from FILENAME in the current shell.  The\n"
#~ "    entries in $PATH are used to find the directory containing FILENAME.\n"
#~ "    If any ARGUMENTS are supplied, they become the positional parameters\n"
#~ "    when FILENAME is executed.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns the status of the last command executed in FILENAME; fails if\n"
#~ "    FILENAME cannot be read."
#~ msgstr ""
#~ "Kommandos in einer Datei mit der aktuellen Shell ausführen.\n"
#~ "\n"
#~ "    Liest Befehle aus der angegebenen Datei und führt sie in der\n"
#~ "    aktuellen Shell aus. Die Datei wird in denen in $PATH angegebenen\n"
#~ "    Verzeichnissen gesucht. Zusätzlich angegebene Argumente werden als\n"
#~ "    Positionsparameter an die ausgeführte Datei übergeben.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Status des letzten in der Datei ausgeführten Befehls; Fehler, wenn\n"
#~ "    die Datei nicht gelesen werden kann."

# suspend
#~ msgid ""
#~ "Suspend shell execution.\n"
#~ "    \n"
#~ "    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
#~ "    Unless forced, login shells cannot be suspended.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -f\tforce the suspend, even if the shell is a login shell\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless job control is not enabled or an error occurs."
#~ msgstr ""
#~ "Shellausführung  aussetzen.\n"
#~ "    \n"
#~ "     Hält die die Shell so lange an, bis sie wieder ein SIGCONT-Signal\n"
#~ "     empfängt. Eine Anmeldeshell kann nur angehalten werden, wenn dies\n"
#~ "     erzwungen wird.\n"
#~ "    \n"
#~ "     Optionen:\n"
#~ "       -f erzwingt das Anhalten für eine Anmeldeshell.\n"
#~ "    \n"
#~ "     Exit-Status:\n"
#~ "     Gibt Erfolg zurück, außer bei inaktiver Jobsteuerung oder einem\n"
#~ "     anderen Fehler."

# trap
#~ msgid ""
#~ "Trap signals and other events.\n"
#~ "    \n"
#~ "    Defines and activates handlers to be run when the shell receives signals\n"
#~ "    or other conditions.\n"
#~ "    \n"
#~ "    ARG is a command to be read and executed when the shell receives the\n"
#~ "    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
#~ "    is supplied) or `-', each specified signal is reset to its original\n"
#~ "    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
#~ "    shell and by the commands it invokes.\n"
#~ "    \n"
#~ "    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  If\n"
#~ "    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  If\n"
#~ "    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or a\n"
#~ "    script run by the . or source builtins finishes executing.  A SIGNAL_SPEC\n"
#~ "    of ERR means to execute ARG each time a command's failure would cause the\n"
#~ "    shell to exit when the -e option is enabled.\n"
#~ "    \n"
#~ "    If no arguments are supplied, trap prints the list of commands associated\n"
#~ "    with each signal.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -l\tprint a list of signal names and their corresponding numbers\n"
#~ "      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
#~ "    \n"
#~ "    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\n"
#~ "    Signal names are case insensitive and the SIG prefix is optional.  A\n"
#~ "    signal may be sent to the shell with \"kill -signal $$\".\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless a SIGSPEC is invalid or an invalid option is given."
#~ msgstr ""
#~ "Signale und andere Ereignisse abfangen.\n"
#~ "\n"
#~ "    Definiert und aktiviert einen Befehl oder Funktion, der ausgeführt\n"
#~ "    wird, sobald die Shell Signale oder andere Bedingungen empfängt.\n"
#~ "\n"
#~ "    Das Argument ist der Befehl, welcher gelesen und ausgeführt werden\n"
#~ "    soll, sobald die Shell ein oder mehrere der angegebenen Signale\n"
#~ "    empfängt. Die Signale werden auf ihren ursprünglichen Wert zurück-\n"
#~ "    gesetzt wenn nur eine Signalbezeichnung oder `-' angegeben wird.\n"
#~ "    Wenn das Argument eine Nullzeichenfolge ist, wird jedes angegebene\n"
#~ "    Signal von der Shell und den von ihr aufgerufenen Befehlen\n"
#~ "    ignoriert.\n"
#~ "\n"
#~ "    Wenn das angegebene Signal EXIT (0) ist, wird das Argument vor\n"
#~ "    Beenden der Shell ausgeführt. Für das Signal DEBUG, wird das\n"
#~ "    angegebene Argument vor jedem einfachen Kommando ausgeführt. Wenn\n"
#~ "    das Signal RETURN ist, wird das Argument jedes Mal ausgeführt, wenn\n"
#~ "    eine Shell-Funktion oder ein Skript, das von den . oder source\n"
#~ "    ausgeführt wird, die Ausführung beendet. Das Signal ERR fühhrt das\n"
#~ "    Argument beim Auftreten eines Fehlers aus, der zum Abbruch führen\n"
#~ "    würde. Die Option -e muss dafür aktiviert sein.\n"
#~ "\n"
#~ "    Wenn keine Argumente angegeben werden, druckt Trap die Liste der\n"
#~ "    verknüpften Befehle aus.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -l druckt eine Liste der Signalnamen mit deren Nummern\n"
#~ "      -p zeigt die mit einem Signal verknüpften Kommandos an.\n"
#~ "\n"
#~ "    Jede Signalbezeichnung ist entweder ein Signalname entsprechend <signal.h>\n"
#~ "    oder deren Signalnummer. Die Signalnamen berücksichtigen keine\n"
#~ "    Groß-/Kleinschreibung und das SIG-Präfix ist optional. Ein Signal kann mit\n"
#~ "    „kill -signal $$“ an die Shell gesendet werden.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Gibt Erfolg zurück, sofern keine ungültige Signalbezeichnung oder\n"
#~ "    Argument angegeben wurde."

# printf
#~ msgid ""
#~ "Formats and prints ARGUMENTS under control of the FORMAT.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -v var\tassign the output to shell variable VAR rather than\n"
#~ "    \t\tdisplay it on the standard output\n"
#~ "    \n"
#~ "    FORMAT is a character string which contains three types of objects: plain\n"
#~ "    characters, which are simply copied to standard output; character escape\n"
#~ "    sequences, which are converted and copied to the standard output; and\n"
#~ "    format specifications, each of which causes printing of the next successive\n"
#~ "    argument.\n"
#~ "    \n"
#~ "    In addition to the standard format specifications described in printf(1),\n"
#~ "    printf interprets:\n"
#~ "    \n"
#~ "      %b\texpand backslash escape sequences in the corresponding argument\n"
#~ "      %q\tquote the argument in a way that can be reused as shell input\n"
#~ "      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
#~ "    \t\tquoting\n"
#~ "      %(fmt)T\toutput the date-time string resulting from using FMT as a format\n"
#~ "    \t        string for strftime(3)\n"
#~ "    \n"
#~ "    The format is re-used as necessary to consume all of the arguments.  If\n"
#~ "    there are fewer arguments than the format requires,  extra format\n"
#~ "    specifications behave as if a zero value or null string, as appropriate,\n"
#~ "    had been supplied.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is given or a write or assignment\n"
#~ "    error occurs."
#~ msgstr ""
#~ "Formatierte Ausgabe der ARGUMENTE.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -v var\tDie formatierte Ausgabe wird der Variable \"var\" zugewiesen\n"
#~ "              und nicht an die Standardausgabe gesendet.\n"
#~ "\n"
#~ "    Die \"Format\" Anweisung kann einfache Zeichen enthalten, die unverändert an\n"
#~ "    die Standardausgabe geschickt werden. Escape-Sequenzen werden umgewandelt\n"
#~ "    und an die Standardausgabe geschickt sowie Formatanweisungen, welche das\n"
#~ "    nachfolgende \"Argument\" auswerten und ausgeben.\n"
#~ "\n"
#~ "    Zusätzlich zu dem in printf(1) beschriebenen Standard werden ausgewertet:\n"
#~ "\n"
#~ "      %b\tErlaubt Escapesequenzen im angegebenen Argument.\n"
#~ "      %q\tSchützt nicht druckbare Zeicheen, dass sie als Shelleingabe\n"
#~ "          verwendet werden können.\n"
#~ "      %Q  Wie %q, es wird zusätzlich die angegebene Genauigkeit vor dem\n"
#~ "          Ausgeben angewendet.\n"
#~ "      %(Fmt)T\tAusgabe des in \"Fmt\" angegebenen Zeitausdrucks, dass sie\n"
#~ "          als Eingabe für strftime(3) verwendet werden kann.\n"
#~ "\n"
#~ "    Die Formatangabe wird wiederverwendet, bis alle Argumente ausgewertet\n"
#~ "    sind. Wenn weniger Argumente als Formatangaben vorhanden sind, werden für\n"
#~ "    die Argumente Nullwerte bzw. leere Zeichenketten eingesetzt.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Gibt Erfolg zurück, außer es wird eine ungültige Option angegeben\n"
#~ "    oder es tritt ein Aus- bzw. Zuweisungsfehler auf."

# compgen
#~ msgid ""
#~ "Display possible completions depending on the options.\n"
#~ "    \n"
#~ "    Intended to be used from within a shell function generating possible\n"
#~ "    completions.  If the optional WORD argument is supplied, matches against\n"
#~ "    WORD are generated.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is supplied or an error occurs."
#~ msgstr ""
#~ "Zeigt mögliche Komplettierungen.\n"
#~ "\n"
#~ "    Wird in Shellfunktionen benutzt, um mögliche Komplettierungen anzuzeigen.\n"
#~ "    Wenn ein Wort als optionales Argument angegeben ist, werden Komplettierungen\n"
#~ "    für dieses Wort erzeugt.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Falsche Optionen oder Fehler führen zu Rückgabewerten ungleich Null."
