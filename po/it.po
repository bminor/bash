# Italian translation for bash
# Copyright (C) 2009 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Sergio Zanchetta <primes2h@ubuntu.com>, 2010, 2011.
# Luca Vercelli <luca.vercelli.to@gmail.com>, 2025
#
msgid ""
msgstr ""
"Project-Id-Version: bash-5.3-rc2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-22 09:37-0400\n"
"PO-Revision-Date: 2025-06-16 11:00+0000\n"
"Last-Translator: Luca Vercelli <luca.vercelli.to@gmail.com>\n"
"Language-Team: Italian <tp@lists.linux.it>\n"
"Language: it\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural= (n != 1)\n"
"X-Loco-Source-Locale: it_IT\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"X-Loco-Parser: loco_parse_po\n"
"X-Generator: Loco https://localise.biz/\n"

#: arrayfunc.c:63
msgid "bad array subscript"
msgstr "indice dell'array errato"

#: arrayfunc.c:466 builtins/declare.def:748 variables.c:2196 variables.c:2225
#: variables.c:3099
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: rimosso attributo nameref"

#: arrayfunc.c:493 builtins/declare.def:920
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: impossibile convertire un array indicizzato in uno associativo"

#: arrayfunc.c:789
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: impossibile assegnare a un indice non numerico"

#: arrayfunc.c:841
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: deve essere usato un indice nell'assegnazione di un array associativo"

# (ndt) builtin_error ("%s: %s: %s", filename, _("cannot create"), strerror (errno));
#: bashhist.c:464
msgid "cannot create"
msgstr "impossibile creare"

#: bashline.c:4642
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: impossibile trovare una combinazione di tasti per il comando"

#: bashline.c:4813
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: il primo carattere non spazio non è «\"»"

#: bashline.c:4842
#, c-format
msgid "no closing `%c' in %s"
msgstr "carattere di chiusura \"%c\" non presente in %s"

#: bashline.c:4873
#, c-format
msgid "%s: missing separator"
msgstr "%s: separatore mancante"

# (ndt) errore in rl_bind_keyseq_in_map(keyseq, NULL)
#: bashline.c:4920
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "\"%s\": impossibile eliminare l'associazione nella combinazione di tasti del comando"

#: braces.c:340
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "espansione delle parentesi: impossibile allocare memoria per %s"

#: braces.c:403
#, c-format
msgid "brace expansion: failed to allocate memory for %s elements"
msgstr "espansione delle parentesi: errore nell'allocazione di memoria per %s elementi"

#: braces.c:462
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "espansione delle parentesi: errore nell'allocazione di memoria per \"%s\""

#: builtins/alias.def:131 variables.c:1789
#, c-format
msgid "`%s': invalid alias name"
msgstr "\"%s\": nome alias non valido"

#: builtins/bind.def:123
msgid "line editing not enabled"
msgstr "modifica delle righe non abilitata"

#: builtins/bind.def:208
#, c-format
msgid "`%s': invalid keymap name"
msgstr "\"%s\": nome della combinazione di tasti non valido"

# (ndt) builtin_error ("%s: %s: %s", t, _("cannot read"), strerror (errno))
#: builtins/bind.def:277
msgid "cannot read"
msgstr "impossibile leggere"

#: builtins/bind.def:353 builtins/bind.def:382
#, c-format
msgid "`%s': unknown function name"
msgstr "\"%s\" nome della funzione sconosciuto"

#: builtins/bind.def:361
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s non è associato ad alcun tasto.\n"

#: builtins/bind.def:365
#, c-format
msgid "%s can be invoked via "
msgstr "%s può essere invocato tramite "

#: builtins/bind.def:401 builtins/bind.def:418
#, c-format
msgid "`%s': cannot unbind"
msgstr "\"%s\": impossibile eliminare l'associazione"

#: builtins/break.def:80 builtins/break.def:125
msgid "loop count"
msgstr "numero di cicli"

#: builtins/break.def:145
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "significativo solo in un ciclo \"for\", \"while\" o \"until\""

#: builtins/caller.def:135
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Restituisce il contesto della chiamata alla subroutine corrente.\n"
"    \n"
"    Senza ESPR, restituisce \"$riga $nomefile\". Con ESPR, restituisce\n"
"    \"$riga $subroutine $nomefile\"; questa informazione aggiuntiva può essere usata\n"
"    per fornire uno stack trace.\n"
"    \n"
"    Il valore dell'ESPR indica di quanti frame di chiamata tornare indietro rispetto\n"
"    a quello attuale; in cima c'è il frame 0.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce 0 a meno che non sia in esecuzione una funzione di shell o che l'ESPR\n"
"    non sia valida."

#: builtins/cd.def:321
msgid "HOME not set"
msgstr "HOME non impostata"

#: builtins/cd.def:329 builtins/common.c:143 builtins/fc.def:293 test.c:946
msgid "too many arguments"
msgstr "troppi argomenti"

#: builtins/cd.def:335
msgid "null directory"
msgstr "directory null"

#: builtins/cd.def:345
msgid "OLDPWD not set"
msgstr "OLDPWD non impostata"

#: builtins/common.c:91
#, c-format
msgid "line %d: "
msgstr "riga %d: "

#: builtins/common.c:117 error.c:227
#, c-format
msgid "warning: "
msgstr "attenzione: "

#: builtins/common.c:131
#, c-format
msgid "%s: usage: "
msgstr "%s: uso: "

#: builtins/common.c:178 shell.c:524 shell.c:865
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: l'opzione richiede un argomento"

#: builtins/common.c:184
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: è necessario un argomento numerico"

#  (ndt) messaggio generico, maschile o femminile?
#: builtins/common.c:190
#, c-format
msgid "%s: not found"
msgstr "%s: non trovato"

#: builtins/common.c:198 shell.c:878
#, c-format
msgid "%s: invalid option"
msgstr "%s: opzione non valida"

#: builtins/common.c:204
#, c-format
msgid "%s: invalid option name"
msgstr "%s: nome dell'opzione non valido"

#: builtins/common.c:210 error.c:461
#, c-format
msgid "`%s': not a valid identifier"
msgstr "\"%s\": non è un identificatore valido"

#: builtins/common.c:219
msgid "invalid octal number"
msgstr "numero ottale non valido"

#: builtins/common.c:221
msgid "invalid hex number"
msgstr "numero esadecimale non valido"

#: builtins/common.c:223 expr.c:1577 expr.c:1591
msgid "invalid number"
msgstr "numero non valido"

#: builtins/common.c:230
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: specifica di segnale non valida"

#: builtins/common.c:236
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "\"%s\": non è un pid o una specifica di job valida"

#: builtins/common.c:242 error.c:455
#, c-format
msgid "%s: readonly variable"
msgstr "%s: variabile in sola lettura"

#: builtins/common.c:248
#, c-format
msgid "%s: cannot assign"
msgstr "%s: impossibile assegnare"

#: builtins/common.c:255
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s fuori dall'intervallo"

#: builtins/common.c:255 builtins/common.c:257
msgid "argument"
msgstr "argomento"

#: builtins/common.c:257
#, c-format
msgid "%s out of range"
msgstr "%s fuori dall'intervallo"

#: builtins/common.c:264
#, c-format
msgid "%s: no such job"
msgstr "%s: job inesistente"

#  (ndt) questo sarebbe da verificare
#: builtins/common.c:271
#, c-format
msgid "%s: no job control"
msgstr "%s: controllo dei job non attivo"

#: builtins/common.c:273
msgid "no job control"
msgstr "controllo dei job non attivo"

#: builtins/common.c:279
#, c-format
msgid "%s: invalid job specification"
msgstr "%s: specifica di job non valida"

#: builtins/common.c:289
#, c-format
msgid "%s: restricted"
msgstr "%s: limitato"

#: builtins/common.c:291
msgid "restricted"
msgstr "limitato"

#: builtins/common.c:298
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: non è un comando interno di shell"

#: builtins/common.c:307
msgid "write error"
msgstr "errore in scrittura"

#: builtins/common.c:314
msgid "error setting terminal attributes"
msgstr "errore nell'impostazione degli attributi del terminale"

#: builtins/common.c:316
msgid "error getting terminal attributes"
msgstr "errore nel recupero degli attributi del terminale"

#: builtins/common.c:611
msgid "error retrieving current directory"
msgstr "errore nel recupero della directory corrente"

#: builtins/common.c:675 builtins/common.c:677
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: specifica di job ambigua"

#: builtins/common.c:709
#, c-format
msgid "%s: job specification requires leading `%%'"
msgstr "%s: la specifica di job richiede un `%%' iniziale"

#: builtins/common.c:937
msgid "help not available in this version"
msgstr "l'aiuto non è disponibile in questa versione"

#: builtins/common.c:1005
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: non è un array indicizzato"

#: builtins/common.c:1028 builtins/set.def:964 variables.c:3868
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: impossibile rimuovere: %s in sola lettura"

#: builtins/common.c:1033 builtins/set.def:930 variables.c:3873
#, c-format
msgid "%s: cannot unset"
msgstr "%s: impossibile rimuovere"

#: builtins/complete.def:285
#, c-format
msgid "%s: invalid action name"
msgstr "%s: nome azione non valido"

#: builtins/complete.def:501 builtins/complete.def:644
#: builtins/complete.def:899
#, c-format
msgid "%s: no completion specification"
msgstr "%s: nessuna specifica di completamento"

#: builtins/complete.def:703
msgid "warning: -F option may not work as you expect"
msgstr "attenzione: l'opzione -F potrebbe non funzionare come previsto"

#: builtins/complete.def:705
msgid "warning: -C option may not work as you expect"
msgstr "attenzione: l'opzione -C potrebbe non funzionare come previsto"

#: builtins/complete.def:872
msgid "not currently executing completion function"
msgstr "funzione di completamento attualmente non in esecuzione"

#: builtins/declare.def:139
msgid "can only be used in a function"
msgstr "può essere usato solo in una funzione"

#: builtins/declare.def:471
msgid "cannot use `-f' to make functions"
msgstr "impossibile usare \"-f\" per creare funzioni"

#: builtins/declare.def:499 execute_cmd.c:6320
#, c-format
msgid "%s: readonly function"
msgstr "%s: funzione in sola lettura"

#: builtins/declare.def:556 builtins/declare.def:843
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: la variabile di riferimento non può essere un array"

#: builtins/declare.def:567 variables.c:3346
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s: una variabile nameref non può puntare a se stessa"

#: builtins/declare.def:572 variables.c:2035 variables.c:3343
#, c-format
msgid "%s: circular name reference"
msgstr "%s: riferimento circolare a nome"

#: builtins/declare.def:576 builtins/declare.def:850 builtins/declare.def:859
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "\"%s\": nome variabile non valido per un riferimento a nome"

#: builtins/declare.def:908
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: impossibile eliminare variabili array in questo modo"

#: builtins/declare.def:914
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: impossibile convertire un array associativo in uno indicizzato"

#: builtins/declare.def:943
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s: assegnazione di array composti tra virgolette deprecata"

#: builtins/enable.def:149 builtins/enable.def:157
msgid "dynamic loading not available"
msgstr "caricamento dinamico non disponibile"

#: builtins/enable.def:389
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "impossibile aprire l'oggetto condiviso %s: %s"

#: builtins/enable.def:408
#, c-format
msgid "%s: builtin names may not contain slashes"
msgstr "%s: i nomi dei comandi interni non possono contenere slash"

#: builtins/enable.def:423
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "impossibile trovare %s nell'oggetto condiviso %s: %s"

#: builtins/enable.def:440
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: comando interno dinamico già caricato"

#: builtins/enable.def:444
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "la funzione di caricamento per %s restituisce un errore (%d): non caricato"

#: builtins/enable.def:565
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: non caricato dinamicamente"

#: builtins/enable.def:591
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: impossibile eliminare: %s"

#: builtins/evalfile.c:137 builtins/hash.def:190 execute_cmd.c:6140
#, c-format
msgid "%s: is a directory"
msgstr "%s: è una directory"

#: builtins/evalfile.c:143
#, c-format
msgid "%s: not a regular file"
msgstr "%s: non è un file normale"

#: builtins/evalfile.c:152
#, c-format
msgid "%s: file is too large"
msgstr "%s: file troppo grande"

#: builtins/evalfile.c:189 builtins/evalfile.c:207 execute_cmd.c:6222
#: shell.c:1687
msgid "cannot execute binary file"
msgstr "impossibile eseguire il file binario"

#: builtins/evalstring.c:478
#, c-format
msgid "%s: ignoring function definition attempt"
msgstr "%s: tentativo di definizione della funzione ignorato"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:249
msgid "cannot execute"
msgstr "impossibile eseguire"

#: builtins/exit.def:61
#, c-format
msgid "logout\n"
msgstr "logout\n"

#: builtins/exit.def:85
msgid "not login shell: use `exit'"
msgstr "non è una shell di login: utilizzare \"exit\""

#: builtins/exit.def:116
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Sono presenti job interrotti.\n"

#: builtins/exit.def:118
#, c-format
msgid "There are running jobs.\n"
msgstr "Sono presenti job in esecuzione.\n"

#: builtins/fc.def:284 builtins/fc.def:391 builtins/fc.def:435
msgid "no command found"
msgstr "nessun comando trovato"

#: builtins/fc.def:381 builtins/fc.def:386 builtins/fc.def:425
#: builtins/fc.def:430
msgid "history specification"
msgstr "specifica della cronologia"

#: builtins/fc.def:462
msgid "cannot open temp file"
msgstr "impossibile aprire il file temporaneo"

#: builtins/fg_bg.def:150 builtins/jobs.def:293
msgid "current"
msgstr "attuale"

#: builtins/fg_bg.def:159
#, c-format
msgid "job %d started without job control"
msgstr "job %d avviato senza controllo dei job"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opzione non valida -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: l'opzione richiede un argomento -- %c\n"

#: builtins/hash.def:88
msgid "hashing disabled"
msgstr "hashing disabilitato"

#: builtins/hash.def:144
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: tabella di hash vuota\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "rich.\tcomando\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Comandi di shell corrispondenti alla parola chiave \""
msgstr[1] "Comandi di shell corrispondenti alle parole chiave \""

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"\"\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid "no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr "nessun argomento della guida corrisponde a \"%s\". Provare \"help help\" o \"man -k %s\" o \"info %s\"."

# (ndt) builtin_error ("%s: %s: %s", name, _("cannot open"), strerror (errno))
#: builtins/help.def:214
msgid "cannot open"
msgstr "impossibile aprire"

#: builtins/help.def:264 builtins/help.def:306 builtins/history.def:306
#: builtins/history.def:325 builtins/read.def:909
msgid "read error"
msgstr "errore in lettura"

#: builtins/help.def:517
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Questi comandi della shell sono definiti internamente. Digitare \"help\" per consultare questa lista.\n"
"Digitare \"help nome\" per saperne di più sulla funzione \"nome\".\n"
"Usare \"info bash\" per saperne di più sulla shell in generale.\n"
"Usare \"man -k\" o \"info\" per saperne di più su comandi non presenti nella lista.\n"
"\n"
"Un asterisco (*) vicino a un nome significa che il comando è disabilitato.\n"
"\n"

#: builtins/history.def:164
msgid "cannot use more than one of -anrw"
msgstr "impossibile usare più di uno tra -anrw"

#: builtins/history.def:197 builtins/history.def:209 builtins/history.def:220
#: builtins/history.def:245 builtins/history.def:252
msgid "history position"
msgstr "posizione nella cronologia"

#: builtins/history.def:280
msgid "empty filename"
msgstr "nome del file vuoto"

#: builtins/history.def:282 subst.c:8226
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: parametro nullo o non impostato"

#: builtins/history.def:362
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: timestamp non valido"

#: builtins/history.def:470
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: espansione della cronologia non riuscita"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "nessuna altra opzione permessa con \"-x\""

#: builtins/kill.def:214
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: gli argomenti devono essere ID di processo o di job"

#: builtins/kill.def:280
msgid "Unknown error"
msgstr "Errore sconosciuto"

#: builtins/let.def:96 builtins/let.def:120 expr.c:647 expr.c:665
msgid "expression expected"
msgstr "attesa espressione"

#: builtins/mapfile.def:249 builtins/read.def:373
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: specifica di descrittore di file non valida"

#: builtins/mapfile.def:257 builtins/read.def:380
msgid "invalid file descriptor"
msgstr "descrittore di file non valido"

#: builtins/mapfile.def:266 builtins/mapfile.def:304
#, c-format
msgid "%s: invalid line count"
msgstr "%s: numero di righe non valido"

#: builtins/mapfile.def:277
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: origine dell'array non valida"

#: builtins/mapfile.def:294
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: quantum di callback non valido"

#: builtins/mapfile.def:327
msgid "empty array variable name"
msgstr "nome della variabile array vuoto"

#: builtins/mapfile.def:347
msgid "array variable support required"
msgstr "necessario il supporto alla variabile array"

#: builtins/printf.def:483
#, c-format
msgid "`%s': missing format character"
msgstr "\"%s\": manca il carattere di formato"

#: builtins/printf.def:609
#, c-format
msgid "`%c': invalid time format specification"
msgstr "\"%c\": specifica di formato dell'orario non valida"

#: builtins/printf.def:711
msgid "string length"
msgstr "lunghezza stringa"

#: builtins/printf.def:811
#, c-format
msgid "`%c': invalid format character"
msgstr "\"%c\": carattere di formato non valido"

#: builtins/printf.def:928
#, c-format
msgid "format parsing problem: %s"
msgstr "problema nell'analisi del formato: %s"

#: builtins/printf.def:1113
msgid "missing hex digit for \\x"
msgstr "cifra esadecimale mancante in \\x"

#: builtins/printf.def:1128
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "cifra unicode mancante in \\%c"

#: builtins/pushd.def:198
msgid "no other directory"
msgstr "nessun'altra directory"

#: builtins/pushd.def:358 builtins/pushd.def:383
#, c-format
msgid "%s: invalid argument"
msgstr "%s: argomento non valido"

#: builtins/pushd.def:501
msgid "<no current directory>"
msgstr "<nessuna directory corrente>"

#: builtins/pushd.def:543
msgid "directory stack empty"
msgstr "stack delle directory vuoto"

#: builtins/pushd.def:545
msgid "directory stack index"
msgstr "indice dello stack delle directory"

#: builtins/pushd.def:708
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Visualizza l'elenco delle directory attualmente in memoria. Le directory\n"
"    vengono inserite nell'elenco con il comando \"pushd\"; è possibile\n"
"    andare a ritroso nell'elenco con il comando \"popd\".\n"
"    \n"
"    Opzioni:\n"
"      -c\tPulisce lo stack delle directory eliminandone tutti gli elementi\n"
"      -l\tNon stampa la tilde come prefisso per le directory relative alla\n"
"    \tpropria directory home\n"
"      -p\tStampa lo stack delle directory una voce per riga\n"
"      -v\tStampa lo stack delle directory una voce per riga usando la\n"
"    \tposizione nello stack stesso come prefisso\n"
"    \n"
"    Argomenti:\n"
"      +N\tVisualizza l'N-sima voce contando a partire da sinistra\n"
"    \tdell'elenco mostrato da dirs quando invocato senza opzioni, iniziando\n"
"    \tda zero.\n"
"    \n"
"      -N\tVisualizza l'N-sima voce contando a partire da destra dell'elenco\n"
"\tmostrato da dirs quando invocato senza opzioni, iniziando da zero."

#: builtins/pushd.def:730
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Aggiunge una directory in cima allo stack delle directory o ruota lo\n"
"    stack stesso, mettendo come primo elemento l'attuale directory\n"
"    di lavoro. Senza argomenti scambia le prime due directory in cima.\n"
"    \n"
"    Opzioni:\n"
"      -n\tEvita il normale cambio di directory quando vengono aggiunte\n"
"    \tdirectory allo stack, così da manipolare solo lo stack stesso.\n"
"    \n"
"    Argomenti:\n"
"      +N\tRuota lo stack in modo che l'N-sima directory (contando\n"
"    \ta partire da sinistra dell'elenco mostrato da \"dirs\", iniziando da\n"
"    \tzero) sia in cima.\n"
"    \n"
"      -N\tRuota lo stack in modo che l'N-sima directory (contando\n"
"    \ta partire da destra dell'elenco mostrato da \"dirs\", iniziando da\n"
"    \tzero) sia in cima.\n"
"    \n"
"      dir\tAggiunge DIR in cima allo stack delle directory, facendone la\n"
"    \tdirectory di lavoro corrente.\n"
"    \n"
"    Il comando interno \"dirs\" visualizza lo stack delle directory."

#: builtins/pushd.def:755
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Rimuove voci dallo stack delle directory. Senza argomenti, rimuove\n"
"    la directory in cima allo stack e passa alla nuova prima directory.\n"
"    \n"
"    Opzioni:\n"
"      -n\tEvita il normale cambio di directory quando vengono rimosse\n"
"    \tdirectory dallo stack, così da manipolare solo lo stack stesso.\n"
"    \n"
"    Argomenti:\n"
"      +N\tRimuove l'N-sima voce contando a partire da sinistra dell'elenco\n"
"    \tmostrato da \"dirs\", iniziando da zero. Per esempio: \"popd +0\"\n"
"    \trimuove la prima directory, \"popd +1\" la seconda.\n"
"    \n"
"      -N\tRimuove l'N-sima voce contando a partire da destra dell'elenco\n"
"    \tmostrato da \"dirs\", iniziando da zero. Per esempio: \"popd -0\"\n"
"    \trimuove l'ultima directory, \"popd -1\" la penultima.\n"
"    \n"
"    Il comando interno \"dirs\" visualizza lo stack delle directory."

#: builtins/read.def:346
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: specifica di timeout non valida"

#: builtins/return.def:73
msgid "can only `return' from a function or sourced script"
msgstr "è possibile eseguire \"return\" solo da una funzione o da uno script chiamato"

#: builtins/set.def:863
msgid "cannot simultaneously unset a function and a variable"
msgstr "impossibile rimuovere contemporaneamente una funzione e una variabile"

#: builtins/set.def:981
#, c-format
msgid "%s: not an array variable"
msgstr "%s: non è una variabile array"

#: builtins/setattr.def:187
#, c-format
msgid "%s: not a function"
msgstr "%s: non è una funzione"

#: builtins/setattr.def:192
#, c-format
msgid "%s: cannot export"
msgstr "%s: impossibile esportare"

#: builtins/shift.def:74 builtins/shift.def:86
msgid "shift count"
msgstr "numero di scorrimenti"

#: builtins/shopt.def:332
msgid "cannot set and unset shell options simultaneously"
msgstr "impossibile impostare e rimuovere opzioni di shell contemporaneamente"

#: builtins/shopt.def:457
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: nome dell'opzione di shell non valido"

#: builtins/source.def:143
msgid "filename argument required"
msgstr "necessario un nome file come argomento"

#: builtins/source.def:179
#, c-format
msgid "%s: file not found"
msgstr "%s: file non trovato"

#: builtins/suspend.def:105
msgid "cannot suspend"
msgstr "impossibile sospendere"

#: builtins/suspend.def:111
msgid "cannot suspend a login shell"
msgstr "impossibile sospendere una shell di login"

#: builtins/test.def:146 test.c:926
msgid "missing `]'"
msgstr "\"]\" mancante"

#: builtins/type.def:231
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s ha \"%s\" come alias\n"

#: builtins/type.def:252
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s è una parola chiave di shell\n"

#: builtins/type.def:270 builtins/type.def:314
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s è un comando interno di shell speciale\n"

#: builtins/type.def:289
#, c-format
msgid "%s is a function\n"
msgstr "%s è una funzione\n"

#: builtins/type.def:316
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s è un comando interno di shell\n"

#: builtins/type.def:338 builtins/type.def:425
#, c-format
msgid "%s is %s\n"
msgstr "%s è %s\n"

#: builtins/type.def:358
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "hash effettuato su %s (%s)\n"

#: builtins/ulimit.def:403
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: argomento di limite non valido"

#: builtins/ulimit.def:429
#, c-format
msgid "`%c': bad command"
msgstr "\"%c\": comando errato"

#: builtins/ulimit.def:465 builtins/ulimit.def:748
msgid "cannot get limit"
msgstr "impossibile recuperare il limite"

#: builtins/ulimit.def:498
msgid "limit"
msgstr "limite"

#: builtins/ulimit.def:511 builtins/ulimit.def:812
msgid "cannot modify limit"
msgstr "impossibile modificare il limite"

#: builtins/umask.def:114
msgid "octal number"
msgstr "numero ottale"

#: builtins/umask.def:256
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "\"%c\": operatore di modo simbolico non valido"

#: builtins/umask.def:345
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "\"%c\": carattere di modo simbolico non valido"

#: error.c:83 error.c:311 error.c:313 error.c:315
msgid " line "
msgstr " riga "

#: error.c:151
#, c-format
msgid "last command: %s\n"
msgstr "ultimo comando: %s\n"

#: error.c:159
#, c-format
msgid "Aborting..."
msgstr "Interruzione..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:244
#, c-format
msgid "INFORM: "
msgstr "INFO: "

#: error.c:261
#, c-format
msgid "DEBUG warning: "
msgstr "DEBUG attenzione: "

#: error.c:413
msgid "unknown command error"
msgstr "errore di comando sconosciuto"

#: error.c:414
msgid "bad command type"
msgstr "tipo di comando errato"

#: error.c:415
msgid "bad connector"
msgstr "connettore errato"

#: error.c:416
msgid "bad jump"
msgstr "salto errato"

#: error.c:449
#, c-format
msgid "%s: unbound variable"
msgstr "%s: variabile non assegnata"

#: eval.c:260
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\atempo di attesa scaduto per l'input: auto-logout\n"

#: execute_cmd.c:606
msgid "cannot redirect standard input from /dev/null"
msgstr "impossibile redirigere lo standard input da /dev/null"

#: execute_cmd.c:1412
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: \"%c\": carattere di formato non valido"

#: execute_cmd.c:2493
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr "execute_coproc: coproc [%d:%s] esiste ancora"

#: execute_cmd.c:2647
msgid "pipe error"
msgstr "errore della pipe"

#: execute_cmd.c:4100
#, c-format
msgid "invalid regular expression `%s': %s"
msgstr "espressione regolare non valida \"%s\": %s"

#: execute_cmd.c:4102
#, c-format
msgid "invalid regular expression `%s'"
msgstr "espressione regolare non valida \"%s\""

#: execute_cmd.c:5056
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: superato il massimo livello di annidamento di eval (%d)"

#: execute_cmd.c:5069
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: superato il massimo livello di annidamento di sorgenti (%d)"

#: execute_cmd.c:5198
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: superato il massimo livello di annidamento di funzioni (%d)"

#: execute_cmd.c:5754
msgid "command not found"
msgstr "comando non trovato"

#: execute_cmd.c:5783
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: limitato: impossibile specificare \"/\" nei nomi dei comandi"

#: execute_cmd.c:6176
msgid "bad interpreter"
msgstr "interprete errato"

#: execute_cmd.c:6185
#, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: impossibile eseguire: file richiesto non trovato"

#: execute_cmd.c:6361
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "impossibile duplicare fd %d su fd %d"

#: expr.c:272
msgid "expression recursion level exceeded"
msgstr "superato il livello di ricorsione dell'espressione"

#: expr.c:300
msgid "recursion stack underflow"
msgstr "underflow dello stack di ricorsione"

# (ndt) sintassi aritmetica?
#: expr.c:485
msgid "arithmetic syntax error in expression"
msgstr "errore di sintassi aritmetica nell'espressione"

#: expr.c:529
msgid "attempted assignment to non-variable"
msgstr "tentata un'assegnazione a una non variabile"

# (ndt) sintassi aritmetica?
#: expr.c:538
msgid "arithmetic syntax error in variable assignment"
msgstr "errore di sintassi aritmetica nell'assegnazione di variabile"

#: expr.c:552 expr.c:917
msgid "division by 0"
msgstr "divisione per 0"

#  (ndt) questo è un messaggio tecnico, expassing è il nome di una funzione
#: expr.c:600
msgid "bug: bad expassign token"
msgstr "bug: token di expassign errato"

#: expr.c:654
msgid "`:' expected for conditional expression"
msgstr "atteso \":\" per l'espressione condizionale"

#: expr.c:979
msgid "exponent less than 0"
msgstr "esponente minore di 0"

#: expr.c:1040
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "atteso identificatore dopo un pre-incremento o un pre-decremento"

#: expr.c:1067
msgid "missing `)'"
msgstr "\")\" mancante"

# (ndt) sintassi aritmetica?
#: expr.c:1120 expr.c:1507
msgid "arithmetic syntax error: operand expected"
msgstr "errore di sintassi aritmetica: atteso un operando"

#: expr.c:1468 expr.c:1489
msgid "--: assignment requires lvalue"
msgstr "--: l'assegnazione richiede un lvalue"

#: expr.c:1470 expr.c:1491
msgid "++: assignment requires lvalue"
msgstr "++: l'assegnazione richiede un lvalue"

# (ndt) sintassi aritmetica?
#: expr.c:1509
msgid "arithmetic syntax error: invalid arithmetic operator"
msgstr "errore di sintassi aritmetica: operatore aritmetico non valido"

#: expr.c:1532
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (il token dell'errore è \"%s\")"

#: expr.c:1595
msgid "invalid arithmetic base"
msgstr "base aritmetica non valida"

#: expr.c:1604
msgid "invalid integer constant"
msgstr "costante intera non valida"

#: expr.c:1620
msgid "value too great for base"
msgstr "valore troppo grande per la base"

#: expr.c:1671
#, c-format
msgid "%s: expression error\n"
msgstr "%s: errore di espressione\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: impossibile accedere alle directory padre"

#: general.c:459
#, c-format
msgid "`%s': is a special builtin"
msgstr "\"%s\": è un comando interno di shell speciale"

#: input.c:98 subst.c:6542
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "impossibile reimpostare il modo nodelay per fd %d"

#: input.c:254
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "impossibile allocare un nuovo descrittore di file per l'input della bash da fd %d"

#: input.c:262
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: buffer già esistente per il nuovo fd %d"

#: jobs.c:549
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pipe pgrp"

#: jobs.c:910
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_delete: CICLO: psi (%d) == storage[psi].bucket_next"

#: jobs.c:962
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_search: CICLO: psi (%d) == storage[psi].bucket_next"

#: jobs.c:1380
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "il pid %d del fork appare nel job in esecuzione %d"

#: jobs.c:1496
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "eliminazione del job %d interrotto con il gruppo di processi %ld"

#: jobs.c:1620
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: pid %5ld (%s) segnato come ancora in vita"

#: jobs.c:1949
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: pid inesistente"

#: jobs.c:1963
#, c-format
msgid "Signal %d"
msgstr "Segnale %d"

#: jobs.c:1974 jobs.c:2000
msgid "Done"
msgstr "Completato"

#: jobs.c:1979 siglist.c:123
msgid "Stopped"
msgstr "Fermato"

#: jobs.c:1983
#, c-format
msgid "Stopped(%s)"
msgstr "Fermato(%s)"

#: jobs.c:1987
msgid "Running"
msgstr "In esecuzione"

#: jobs.c:2004
#, c-format
msgid "Done(%d)"
msgstr "Completato(%d)"

#: jobs.c:2006
#, c-format
msgid "Exit %d"
msgstr "Uscita %d"

#: jobs.c:2009
msgid "Unknown status"
msgstr "Stato sconosciuto"

#: jobs.c:2105
#, c-format
msgid "(core dumped) "
msgstr "(core dump creato) "

#: jobs.c:2124
#, c-format
msgid "  (wd: %s)"
msgstr "  (dir: %s)"

#: jobs.c:2391
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "setpgid del figlio (%ld a %ld)"

#: jobs.c:2754 nojobs.c:640
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: il pid %ld non è un figlio di questa shell"

#: jobs.c:3052
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: nessun record del processo %ld"

#: jobs.c:3410
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: il job %d è fermo"

#: jobs.c:3838
#, c-format
msgid "%s: no current jobs"
msgstr "%s: non ci sono job"

#: jobs.c:3845
#, c-format
msgid "%s: job has terminated"
msgstr "%s: il job è terminato"

#: jobs.c:3854
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: il job %d è già in background"

#: jobs.c:4092
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld: attivato WNOHANG per evitare blocchi indefiniti"

#: jobs.c:4641
#, c-format
msgid "%s: line %d: "
msgstr "%s: riga %d: "

#: jobs.c:4657 nojobs.c:895
#, c-format
msgid " (core dumped)"
msgstr " (core dump creato)"

#: jobs.c:4677 jobs.c:4697
#, c-format
msgid "(wd now: %s)\n"
msgstr "(dir ora: %s)\n"

#: jobs.c:4741
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp non riuscita"

#: jobs.c:4797
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: nessun controllo dei job in background"

# (ndt) questa non mi piace
#: jobs.c:4813
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: disciplina di riga"

#: jobs.c:4823
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:4844 jobs.c:4853
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "impossibile impostare il gruppo di processi del terminale (%d)"

#: jobs.c:4858
msgid "no job control in this shell"
msgstr "nessun controllo dei job in questa shell"

#: lib/malloc/malloc.c:364
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: asserzione fallita: %s\n"

#: lib/malloc/malloc.c:375
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: asserzione fallita\r\n"

#: lib/malloc/malloc.c:376 lib/malloc/malloc.c:925
msgid "unknown"
msgstr "sconosciuto"

#: lib/malloc/malloc.c:876
msgid "malloc: block on free list clobbered"
msgstr "malloc: blocco rovinato nell'elenco dei disponibili"

#: lib/malloc/malloc.c:961
msgid "free: called with already freed block argument"
msgstr "free: chiamata con un argomento di blocco già liberato"

#: lib/malloc/malloc.c:964
msgid "free: called with unallocated block argument"
msgstr "free: chiamata con un argomento di blocco non allocato"

#: lib/malloc/malloc.c:982
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: riscontrato un underflow; mh_nbytes fuori intervallo"

#: lib/malloc/malloc.c:988
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: riscontrato un underflow; magic8 corrotto"

#: lib/malloc/malloc.c:995
msgid "free: start and end chunk sizes differ"
msgstr "free: dimensioni diverse dei blocchi di inizio e di fine"

#: lib/malloc/malloc.c:1155
msgid "realloc: called with unallocated block argument"
msgstr "realloc: chiamata con un argomento di blocco non allocato"

#: lib/malloc/malloc.c:1170
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: riscontrato un underflow; mh_nbytes fuori intervallo"

#: lib/malloc/malloc.c:1176
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: riscontrato un underflow; magic8 corrotto"

#: lib/malloc/malloc.c:1184
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: dimensioni diverse dei blocchi di inizio e di fine"

#: lib/malloc/table.c:179
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: forse la tavola di allocazione è piena con FIND_ALLOC\n"

#: lib/malloc/table.c:188
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: forse %p è già come allocato nella tabella\n"

#: lib/malloc/table.c:237
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_alloc: forse %p è già come libero nella tabella\n"

#: lib/sh/fmtulong.c:90
msgid "invalid base"
msgstr "base non valida"

#: lib/sh/netopen.c:161
#, c-format
msgid "%s: host unknown"
msgstr "%s: host sconosciuto"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: invalid service"
msgstr "%s: servizio non valido"

#: lib/sh/netopen.c:294
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: specifica del percorso di rete errata"

#: lib/sh/netopen.c:332
msgid "network operations not supported"
msgstr "operazioni di rete non supportate"

#: locale.c:226 locale.c:228 locale.c:301 locale.c:303
msgid "cannot change locale"
msgstr "impossibile cambiare la localizzazione"

#: mailcheck.c:435
msgid "You have mail in $_"
msgstr "È presente della posta in $_"

#: mailcheck.c:460
msgid "You have new mail in $_"
msgstr "È presente della nuova posta in $_"

#: mailcheck.c:476
#, c-format
msgid "The mail in %s has been read\n"
msgstr "La posta in %s è stata letta\n"

#: make_cmd.c:286
msgid "syntax error: arithmetic expression required"
msgstr "errore di sintassi: richiesta espressione aritmetica"

#: make_cmd.c:288
msgid "syntax error: `;' unexpected"
msgstr "errore di sintassi: \";\" non atteso"

#: make_cmd.c:289
#, c-format
msgid "syntax error: `((%s))'"
msgstr "errore di sintassi: \"((%s))\""

#: make_cmd.c:523
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: tipo di istruzione errata %d"

#: make_cmd.c:627
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "here-document alla riga %d è delimitato da un EOF (era richiesto \"%s\")"

#: make_cmd.c:722
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: istruzione di reindirizzamento \"%d\" fuori dell'intervallo"

#: parse.y:2572
#, c-format
msgid "shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line truncated"
msgstr "shell_getc: shell_input_line_size (%zu) supera SIZE_MAX (%lu): riga troncata"

#: parse.y:2864
msgid "script file read error"
msgstr "errore in lettura del file dello script"

#: parse.y:3101
msgid "maximum here-document count exceeded"
msgstr "superato massimo numero di here-document"

#: parse.y:3901 parse.y:4799 parse.y:6859
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "EOF non atteso durante la ricerca di \"%c\""

#: parse.y:5006
msgid "unexpected EOF while looking for `]]'"
msgstr "EOF non atteso durante la ricerca di \"]]\""

#: parse.y:5011
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "errore di sintassi nell'espressione condizionale: token non atteso \"%s\""

#: parse.y:5015
msgid "syntax error in conditional expression"
msgstr "errore di sintassi nell'espressione condizionale"

#: parse.y:5093
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "token non atteso \"%s\", era atteso \")\""

#: parse.y:5097
msgid "expected `)'"
msgstr "atteso \")\""

#: parse.y:5127
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "argomento non atteso \"%s\" per l'operatore unario condizionale"

#: parse.y:5131
msgid "unexpected argument to conditional unary operator"
msgstr "argomento non atteso per l'operatore unario condizionale"

#: parse.y:5178
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "token non atteso \"%s\", era atteso un operatore binario condizionale"

#: parse.y:5182
msgid "conditional binary operator expected"
msgstr "atteso operatore binario condizionale"

#: parse.y:5211
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "argomento non atteso \"%s\" per l'operatore binario condizionale"

#: parse.y:5215
msgid "unexpected argument to conditional binary operator"
msgstr "argomento non atteso per l'operatore binario condizionale"

#: parse.y:5226
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "token non atteso \"%c\" nel comando condizionale"

#: parse.y:5229
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "token non atteso \"%s\" nel comando condizionale"

#: parse.y:5233
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "token non atteso %d nel comando condizionale"

#: parse.y:6827
#, c-format
msgid "syntax error near unexpected token `%s' while looking for matching `%c'"
msgstr "errore di sintassi vicino al token non atteso \"%s\" mentre si cerca una corrispondenza per \"%c\""

#: parse.y:6829
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "errore di sintassi vicino al token non atteso \"%s\""

#: parse.y:6848
#, c-format
msgid "syntax error near `%s'"
msgstr "errore di sintassi vicino a \"%s\""

#: parse.y:6867
#, c-format
msgid "syntax error: unexpected end of file from `%s' command on line %d"
msgstr "errore di sintassi: fine del file non attesa dal comando \"%s\" alla riga %d"

#: parse.y:6869
#, c-format
msgid "syntax error: unexpected end of file from command on line %d"
msgstr "errore di sintassi: fine del file non attesa dal comando alla riga %d"

#: parse.y:6873
msgid "syntax error: unexpected end of file"
msgstr "errore di sintassi: EOF non atteso"

#: parse.y:6873
msgid "syntax error"
msgstr "errore di sintassi"

#: parse.y:6922
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Usare \"%s\" per uscire dalla shell.\n"

#: parse.y:7120
msgid "unexpected EOF while looking for matching `)'"
msgstr "EOF non atteso durante la ricerca di \")\""

#: pathexp.c:897
msgid "invalid glob sort type"
msgstr "tipo di ordinamento glob non valido"

#: pcomplete.c:1070
#, c-format
msgid "completion: function `%s' not found"
msgstr "completion: funzione \"%s\" non trovata"

# (ndt) da rivedere
#: pcomplete.c:1654
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr "programmable_completion: %s: possibile ciclo di tentativi"

#: pcomplib.c:176
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: COMPSPEC NULL"

#: print_cmd.c:324
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: connettore errato \"%d\""

#: print_cmd.c:399
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: descrittore di file non valido"

#: print_cmd.c:404
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: puntatore a file NULL"

#: print_cmd.c:408
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != numfile xtrace fp (%d)"

#: print_cmd.c:1597
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: \"%c\": carattere di formato non valido"

#: redir.c:146 redir.c:194
msgid "file descriptor out of range"
msgstr "descrittore di file fuori dell'intervallo"

#: redir.c:201
msgid "ambiguous redirect"
msgstr "redirezione ambigua"

#: redir.c:205
msgid "cannot overwrite existing file"
msgstr "impossibile sovrascrivere il file esistente"

#: redir.c:210
msgid "restricted: cannot redirect output"
msgstr "limitato: impossibile redirigere l'output"

#: redir.c:215
msgid "cannot create temp file for here-document"
msgstr "impossibile creare un file temporaneo per here-document"

#: redir.c:219
msgid "cannot assign fd to variable"
msgstr "impossibile assegnare fd a una variabile"

#: redir.c:639
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "/dev/(tcp|udp)/host/port non supportata senza rete"

#: redir.c:945 redir.c:1062 redir.c:1124 redir.c:1291
msgid "redirection error: cannot duplicate fd"
msgstr "errore di reindirizzamento: impossibile duplicare fd"

#: shell.c:359
msgid "could not find /tmp, please create!"
msgstr "impossibile trovare /tmp, è necessario crearla"

#: shell.c:363
msgid "/tmp must be a valid directory name"
msgstr "/tmp deve essere un nome di directory valido"

# (ndt) pretty print?
#: shell.c:827
msgid "pretty-printing mode ignored in interactive shells"
msgstr "modalità di stampa formattata ignorata nelle shell interattive"

#: shell.c:969
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: opzione non valida"

#: shell.c:1354
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "impossibile impostare uid a %d: uid effettivo %d"

#: shell.c:1370
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "impossibile impostare gid a %d: gid effettivo %d"

#: shell.c:1559
msgid "cannot start debugger; debugging mode disabled"
msgstr "impossibile avviare il debugger; modalità di debug disabilitata"

#: shell.c:1672
#, c-format
msgid "%s: Is a directory"
msgstr "%s: è una directory"

#: shell.c:1748 shell.c:1750
msgid "error creating buffered stream"
msgstr "errore durante la creazione del buffered stream"

#  (ndt) mock username
#: shell.c:1899
msgid "I have no name!"
msgstr "Senza nome"

#: shell.c:2063
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, versione %s-(%s)\n"

#: shell.c:2064
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Uso:\t%s [opzione lunga GNU] [opzione] ...\n"
"\t%s [opzione lunga GNU] [opzione] file-script ...\n"

#: shell.c:2066
msgid "GNU long options:\n"
msgstr "Opzioni lunghe GNU:\n"

#: shell.c:2070
msgid "Shell options:\n"
msgstr "Opzioni di shell:\n"

#: shell.c:2071
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-ilrsD o -c comando o -O opzione_shopt\t\t(solo invocazione)\n"

#: shell.c:2090
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\topzione -%s oppure -o\n"

#: shell.c:2096
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "Digitare «%s -c \"help set\"» per ulteriori informazioni sulle opzioni di shell.\n"

#: shell.c:2097
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "Digitare \"%s -c help\" per ulteriori informazioni sui comandi interni di shell.\n"

#: shell.c:2098
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Usare il comando \"bashbug\" per segnalare i bug.\n"

#: shell.c:2100
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "home page di bash: <http://www.gnu.org/software/bash>\n"

#: shell.c:2101
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Aiuto generale sull'utilizzo di software GNU: <http://www.gnu.org/gethelp/>\n"

#: sig.c:809
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: operazione non valida"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Segnale inesistente"

#  (ndt) signal SIGHUP
#: siglist.c:51
msgid "Hangup"
msgstr "Chiusura"

#  (ndt) signal SIGINT
#: siglist.c:55
msgid "Interrupt"
msgstr "Interruzione"

#: siglist.c:59
msgid "Quit"
msgstr "Uscita"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Istruzione non valida"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "Rilevato trace/breakpoint"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Istruzione ABORT"

#: siglist.c:79
msgid "EMT instruction"
msgstr "Istruzione EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Eccezione in virgola mobile"

#: siglist.c:87
msgid "Killed"
msgstr "Ucciso"

#: siglist.c:91
msgid "Bus error"
msgstr "Errore di bus"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Errore di segmentazione"

#: siglist.c:99
msgid "Bad system call"
msgstr "Chiamata di sistema errata"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Pipe interrotta"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Sveglia"

#: siglist.c:111
msgid "Terminated"
msgstr "Terminato"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Condizione di I/O urgente"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Fermato (segnale)"

#: siglist.c:127
msgid "Continue"
msgstr "Continuato"

#: siglist.c:135
msgid "Child death or stop"
msgstr "Processo figlio concluso o fermato"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Fermato (input da terminale)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Fermato (output da terminale)"

#: siglist.c:147
msgid "I/O ready"
msgstr "I/O pronto"

#: siglist.c:151
msgid "CPU limit"
msgstr "Limite di CPU"

#: siglist.c:155
msgid "File limit"
msgstr "Limite di file"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Timer (virtuale)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Timer (profilo)"

#: siglist.c:167
msgid "Window changed"
msgstr "Finestra modificata"

#: siglist.c:171
msgid "Record lock"
msgstr "Blocco del record"

#: siglist.c:175
msgid "User signal 1"
msgstr "Segnale 1 dell'utente"

#: siglist.c:179
msgid "User signal 2"
msgstr "Segnale 2 dell'utente"

#  (ndt) signal SIGMSG
#: siglist.c:183
msgid "HFT input data pending"
msgstr "Dati di input HFT in sospeso"

#  (ndt) signal SIGPWR
#: siglist.c:187
msgid "power failure imminent"
msgstr "mancanza di alimentazione imminente"

#  (ndt) signal SIGDANGER
#: siglist.c:191
msgid "system crash imminent"
msgstr "crash di sistema imminente"

#  (ndt) signal SIGMIGRATE
#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "spostamento processo su altra CPU"

#  (ndt) signal SIGPRE
#: siglist.c:199
msgid "programming error"
msgstr "errore di programmazione"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "Modalità di monitoraggio HFT concessa"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "Modalità di monitoraggio HFT revocata"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "la sequenza sonora HFT è stata completata"

#: siglist.c:215
msgid "Information request"
msgstr "Richiesta di informazioni"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Segnale sconosciuto n° %d"

#: subst.c:1503 subst.c:1795 subst.c:2001
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "sostituzione errata: nessuna chiusura di \"%s\" in %s"

#: subst.c:3601
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: impossibile assegnare una lista a un membro di un array"

#: subst.c:6381 subst.c:6397
msgid "cannot make pipe for process substitution"
msgstr "impossibile creare una pipe per la sostituzione del processo"

#: subst.c:6457
msgid "cannot make child for process substitution"
msgstr "impossibile creare un figlio per la sostituzione del processo"

#: subst.c:6532
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "impossibile aprire la pipe con nome %s in lettura"

#: subst.c:6534
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "impossibile aprire la pipe con nome %s in scrittura"

#: subst.c:6557
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "impossibile duplicare una pipe con nome %s come fd %d"

#: subst.c:6723
msgid "command substitution: ignored null byte in input"
msgstr "sostituzione comando: ignorato byte null in input"

#: subst.c:6962
msgid "function_substitute: cannot open anonymous file for output"
msgstr "function_substitute: impossibile aprire un file anonimo come output"

#: subst.c:7036
msgid "function_substitute: cannot duplicate anonymous file as standard output"
msgstr "function_substitute: impossibile duplicare un file anonimo come standard output"

#: subst.c:7210 subst.c:7231
msgid "cannot make pipe for command substitution"
msgstr "impossibile creare una pipe per la sostituzione del comando"

#: subst.c:7282
msgid "cannot make child for command substitution"
msgstr "impossibile creare un figlio per la sostituzione del comando"

#: subst.c:7315
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: impossibile duplicare la pipe come fd 1"

#: subst.c:7813 subst.c:10989
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: nome variabile non valido per il riferimento a nome"

#: subst.c:7906 subst.c:7924 subst.c:8100
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: espansione indiretta non valida"

#: subst.c:7940 subst.c:8108
#, c-format
msgid "%s: invalid variable name"
msgstr "%s: nome di variabile non valido"

#: subst.c:8125 subst.c:10271 subst.c:10298
#, c-format
msgid "%s: bad substitution"
msgstr "%s: sostituzione errata"

#: subst.c:8224
#, c-format
msgid "%s: parameter not set"
msgstr "%s: parametro non impostato"

#: subst.c:8480 subst.c:8495
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: expressione di sottostringa < 0"

#: subst.c:10397
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: impossibile assegnare in questo modo"

#: subst.c:10855
msgid "future versions of the shell will force evaluation as an arithmetic substitution"
msgstr "le versioni future della shell forzeranno la valutazione come fosse una sostituzione aritmetica"

#: subst.c:11563
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "sostituzione errata: manca \"`\" di chiusura in %s"

#: subst.c:12636
#, c-format
msgid "no match: %s"
msgstr "nessuna corrispondenza: %s"

#: test.c:156
msgid "argument expected"
msgstr "atteso argomento"

#: test.c:164
#, c-format
msgid "%s: integer expected"
msgstr "%s: atteso intero"

#: test.c:292
msgid "`)' expected"
msgstr "atteso \")\""

#: test.c:294
#, c-format
msgid "`)' expected, found %s"
msgstr "atteso \")\", trovato %s"

#: test.c:488 test.c:831
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: atteso operatore binario"

#: test.c:792 test.c:795
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: atteso operatore unario"

#: test.c:944
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "errore di sintassi: \"%s\" non atteso"

#: trap.c:225
msgid "invalid signal number"
msgstr "numero di segnale non valido"

#: trap.c:358
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "trap_handler: superato il massimo livello di gestori di trap (%d)"

#: trap.c:455
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: valore errato in trap_list[%d]: %p"

#  (ndt) to myself? sembra un reindirizzamento del segnale
#: trap.c:459
#, c-format
msgid "run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr "run_pending_traps: il gestore dei segnali è SIG_DFL, verrà inviato nuovamente %d (%s) al programma stesso"

#: trap.c:592
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: segnale errato %d"

#: unwind_prot.c:246 unwind_prot.c:292
msgid "frame not found"
msgstr "frame non trovato"

#: variables.c:441
#, c-format
msgid "error importing function definition for `%s'"
msgstr "errore nell'importazione della definizione di funzione per \"%s\""

#: variables.c:864
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "livello di shell (%d) troppo alto, reimpostato a 1"

#: variables.c:2191 variables.c:2220 variables.c:2278 variables.c:2297
#: variables.c:2315 variables.c:2350 variables.c:2378 variables.c:2405
#: variables.c:2431 variables.c:3274 variables.c:3282 variables.c:3797
#: variables.c:3841
#, c-format
msgid "%s: maximum nameref depth (%d) exceeded"
msgstr "%s: superata la massima profondità di riferimenti a nome (%d)"

#: variables.c:2641
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: nessun contesto di funzione nell'ambito corrente"

#: variables.c:2660
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: non si può assegnare un valore a questa variabile"

#: variables.c:2831 variables.c:2884
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr "%s: non si può ereditare un valore da un tipo incompatibile"

# (ndt) tradotto name reference con riferimento a nome
#: variables.c:3437
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: si sta assegnando un intero a un riferimento a nome"

#: variables.c:4387
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: nessun contesto di funzione nell'ambito corrente"

#: variables.c:4816
#, c-format
msgid "%s has null exportstr"
msgstr "%s ha exportstr null"

#: variables.c:4821 variables.c:4830
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "carattere non valido %d in exportstr per %s"

#: variables.c:4836
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "nessun \"=\" in exportstr per %s"

#: variables.c:5354
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: la prima parte di shell_variables non è un contesto di funzione"

#: variables.c:5367
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: nessun contesto global_variables"

#: variables.c:5457
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: la prima parte di shell_variables non è un ambito temporaneo d'ambiente"

#: variables.c:6448
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: impossibile aprire come FILE"

#: variables.c:6453
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: valore non valido per il descrittore del file di traccia"

#: variables.c:6497
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s valore di compatibilità fuori dall'intervallo"

#: version.c:50
msgid "Copyright (C) 2025 Free Software Foundation, Inc."
msgstr "Copyright (C) 2025 Free Software Foundation, Inc."

#: version.c:51
msgid "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
msgstr "Licenza GPLv3+: GNU GPL versione 3 o successiva <http://gnu.org/licenses/gpl.html>\n"

#: version.c:90
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, versione %s (%s)\n"

#: version.c:95
msgid "This is free software; you are free to change and redistribute it."
msgstr "Questo è software libero; è possibile modificarlo e ridistribuirlo."

#: version.c:96
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "Non c'è ALCUNA GARANZIA, nei limiti permessi dalla legge."

#: xmalloc.c:84
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: impossibile allocare %lu byte (%lu byte allocati)"

#: xmalloc.c:86
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: impossibile allocare %lu byte"

#: xmalloc.c:164
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: impossibile allocare %lu byte (%lu byte allocati)"

#: xmalloc.c:166
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: impossibile allocare %lu byte"

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [nome[=valore] ... ]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] nome [nome ...]"

#: builtins.c:53
msgid "bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr "bind [-lpvsPVSX] [-m combinazione di tasti] [-f nomefile] [-q nome] [-u nome] [-r seqtasti] [-x seqtasti:comando-shell] [seqtasti:funzione-readline o comando-readline]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [comando-interno-shell [arg ...]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [espr]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]]] [-@] [dir]"
msgstr "cd [-L|[-P [-e]]] [-@] [dir]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] comando [arg ...]"

#: builtins.c:78
msgid "declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] [name ...]"
msgstr "declare [-aAfFgiIlnrtux] [nome[=valore] ...] o declare -p [-aAfFilnrtux] [nome ...]"

#: builtins.c:80
msgid "typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] [name ...]"
msgstr "typeset [-aAfFgiIlnrtux] nome[=valore] ... o  typeset -p [-aAfFilnrtux] [nome ...]"

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [opzione] nome[=valore] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [arg ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [arg ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f nome_file] [nome ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [arg ...]"

#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts stringaopz nome [arg ...]"

#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a nome] [comando [argomento ...]] [redirezione ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e ename] [-lnr] [primo] [ultimo] oppure fc -s [pat=rep] [comando]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [spec_job]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [spec_job ...]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p nomepercorso] [-dt] [nome ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [modello ...]"

#: builtins.c:123
msgid "history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]"
msgstr "history [-c] [-d posiz] [n] oppure history -anrw [nomefile] oppure history -ps arg [arg...]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [specjob ...] oppure jobs -x comando [argomenti]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [specjob ... | pid ...]"

#: builtins.c:134
msgid "kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]"
msgstr "kill [-s specsegn | -n numsegn | -specsegn] pid | specjob ... oppure kill -l [specsegn]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let arg [arg ...]"

#: builtins.c:138
msgid "read [-Eers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]"
msgstr "read [-Eers] [-a array] [-d delim] [-i testo] [-n ncaratt] [-N ncaratt] [-p stringa] [-t secondi] [-u fd] [nome ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCEHPT] [-o nome-opzione] [--] [-] [arg ...]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [nome ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p [-f]"
msgstr "export [-fn] [nome[=valore] ...] oppure export -p [-f]"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [nome[=valore] ...] oppure readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source [-p path] filename [arguments]"
msgstr "source [-p percorso] nomefile [argomenti]"

#: builtins.c:154
msgid ". [-p path] filename [arguments]"
msgstr ". [-p percorso] nomefile [argomenti]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [espr]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ arg... ]"

#: builtins.c:166
msgid "trap [-Plp] [[action] signal_spec ...]"
msgstr "trap [-Plp] [[azione] spec_segnale ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] nome [nome ...]"

#: builtins.c:171
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limite]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [modo]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p var] [id ...]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [pid ...]"

#: builtins.c:184
msgid "! PIPELINE"
msgstr "! PIPELINE"

#: builtins.c:186
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NOME [in PAROLE ... ] ; do COMANDI; done"

#: builtins.c:188
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( espr1; espr2; espr3 )); do COMANDI; done"

#: builtins.c:190
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NOME [in PAROLE ... ;] do COMANDI; done"

#: builtins.c:192
msgid "time [-p] pipeline"
msgstr "time [-p] pipeline"

#: builtins.c:194
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case PAROLA in [MODELLO [| MODELLO]...) COMANDI ;;]... esac"

#: builtins.c:196
msgid "if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi"
msgstr "if COMANDI; then COMANDI; [ elif COMANDI; then COMANDI; ]... [ else COMANDI; ] fi"

#: builtins.c:198
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while COMANDI; do COMANDI-2; done"

#: builtins.c:200
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until COMANDI; do COMANDI-2; done"

#: builtins.c:202
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [NOME] comando [redirezioni]"

#: builtins.c:204
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function nome { COMANDI ; } oppure nome () { COMANDI ; }"

#: builtins.c:206
msgid "{ COMMANDS ; }"
msgstr "{ COMANDI ; }"

#: builtins.c:208
msgid "job_spec [&]"
msgstr "spec_job [&]"

#: builtins.c:210
msgid "(( expression ))"
msgstr "(( espressione ))"

#: builtins.c:212
msgid "[[ expression ]]"
msgstr "[[ espressione ]]"

#: builtins.c:214
msgid "variables - Names and meanings of some shell variables"
msgstr "variabili - nomi e significati di alcune variabili di shell"

#: builtins.c:217
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | dir]"

#: builtins.c:221
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:225
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:228
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [nomeopz ...]"

#: builtins.c:230
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] formato [argomenti]"

#: builtins.c:233
msgid "complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]"
msgstr "complete [-abcdefgjksuv] [-pr] [-DEI] [-o opzione] [-A azione] [-G modglob] [-W elencoparole]  [-F funzione] [-C comando] [-X modfiltro] [-P prefisso] [-S suffisso] [nome ...]"

#: builtins.c:237
#, fuzzy
#| msgid "compgen [-V nomevar] [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgid "compgen [-V varname] [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr "compgen [-V nomevar] [-abcdefgjksuv] [-o opzione]  [-A azione] [-G modglob] [-W elencoparole]  [-F funzione] [-C comando] [-X modfiltro] [-P prefisso] [-S suffisso] [parola]"

#: builtins.c:241
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o opzione] [-DEI] [nome ...]"

#: builtins.c:244
msgid "mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "mapfile [-d delimitatore] [-n numero] [-O origine] [-s numero] [-t] [-u fd] [-C callback] [-c quantità] [array]"

#: builtins.c:246
msgid "readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "readarray [-d delimitatore] [-n numero] [-O origine] [-s numero] [-t] [-u fd] [-C callback] [-c quantità] [array]"

#: builtins.c:258
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has been\n"
"    defined."
msgstr ""
"Definisce o visualizza alias.\n"
"    \n"
"    Senza argomenti, \"alias\" stampa l'elenco degli alias nella forma\n"
"    riusabile \"alias NOME=VALORE\" sullo standard output.\n"
"    \n"
"    Altrimenti, un alias è definito per ogni NOME a cui è fornito un VALORE.\n"
"    Uno spazio finale in VALORE determina un controllo della parola successiva\n"
"    che andrà a sostituire l'alias quando viene espanso.\n"
"    \n"
"    Opzioni:\n"
"      -p\tstampa tutti gli alias definiti in un formato riusabile\n"
"    \n"
"    Stato di uscita:\n"
"    alias restituisce vero a meno che non venga fornito un NOME per il quale\n"
"    non sia stato definito alcun alias."

#: builtins.c:280
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Rimuove ogni NOME dall'elenco degli alias definiti.\n"
"    \n"
"    Opzioni:\n"
"      -a\trimuove tutte le definizioni di alias\n"
"    \n"
"    Restituisce successo a meno che un NOME non sia un alias esistente."

#: builtins.c:293
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their values\n"
"      -s                 List key sequences that invoke macros and their values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    If arguments remain after option processing, the -p and -P options treat\n"
"    them as readline command names and restrict output to those names.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Imposta le associazioni di tasti e le variabili di Readline.\n"
"    \n"
"    Associa una sequenza di tasti a una funzione o a una macro Readline, oppure imposta una\n"
"    variabile di Readline. La sintassi di argomento senza opzione è equivalente a quella\n"
"    trovata in ~/.inputrc, ma deve essere passata come singolo argomento:\n"
"    es., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Opzioni:\n"
"      -m  mappatura      Usa MAPPATURA per le combinazioni di tasti per la\n"
"                         durata di questo comando. Nomi accettabili per la\n"
"                         mappatura sono emacs, emacs-standard, emacs-meta,\n"
"                         emacs-ctlx, vi, vi-move, vi-command e vi-insert.\n"
"      -l                 Elenca i nomi delle funzioni.\n"
"      -P                 Elenca i nomi delle funzioni e le associazioni.\n"
"      -p                 Elenca le funzioni e le associazioni in una forma che\n"
"                         possa essere riusata come input.\n"
"      -S                 Elenca le sequenze di tasti che invocano le macro e i loro valori.\n"
"      -s                 Elenca le sequenze di tasti che invocano le macro e i loro valori\n"
"                         in una forma che possa essere riusata come input.\n"
"      -V                 Elenca i nomi e i valori delle variabili.\n"
"      -v                 Elenca i nomi e i valori delle variabili in una forma che possa\n"
"                         essere riusata come input.\n"
"      -q  nome-funzione  Identifica il tasto che invoca la funzione nominata.\n"
"      -u  nome-funzione  Rimuove l'associazione tra la funzione nominata e tutti i tasti associati.\n"
"      -r  seqtasti       Rimuove l'associazione per la SEQTASTI.\n"
"      -f  nomefile       Legge le associazioni di tasti da NOMEFILE.\n"
"      -x  seqtasti:comando-shell\tEsegue il COMANDO-SHELL quando viene inserita\n"
"    \t\t\t\t\tla SEQTASTI.\n"
"      -X                 Elenca le sequenze di tasti associate a -x e i\n"
"                         comandi associati, in una forma che può essere\n"
"                         riutilizzata come input.\n"
"    \n"
"    Se rimangono degli argomenti dopo l'elaborazione dell'opzione, le opzioni\n"
"    -p e -P li trattano come nomi di comandi readline e limitano l'output\n"
"    a quei nomi.\n"
"    \n"
"    Stato di uscita:\n"
"    bind restituisce 0 a meno che non sia fornita una opzione non riconosciuta o si riscontri un errore."

#: builtins.c:335
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Esce da cicli for, while o until.\n"
"    \n"
"    Esce da un ciclo FOR, WHILE o UNTIL. Se è specificato N, interrompe N cicli\n"
"    racchiusi.\n"
"    \n"
"    Stato di uscita:\n"
"    Lo stato di uscita è 0 a meno che N non sia maggiore o uguale a 1."

#: builtins.c:347
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Riprende cicli for, while o until.\n"
"    \n"
"    Riprende l'iterazione successiva del ciclo FOR, WHILE o UNTIL.\n"
"    Se è specificato N, riprende l'N-simo ciclo contenente il comando.\n"
"    \n"
"    Stato di uscita:\n"
"    Lo stato di uscita è 0 a meno che N non sia maggiore o uguale a 1."

#: builtins.c:359
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Esegue comandi interni di shell.\n"
"    \n"
"    Esegue il COMANDO-INTERNO-SHELL con ARGOMENTI senza eseguire la ricerca\n"
"    di comandi. Questo è utile quando si desidera reimplementare un comando\n"
"    interno come una funzione di shell, ma è necessario eseguire il comando\n"
"    all'interno della funzione.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato di uscita del COMANDO-INTERNO-SHELL, o falso se il\n"
"    COMANDO-INTERNO-SHELL non è un comando interno di shell."

#: builtins.c:374
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Restituisce il contesto della chiamata alla subroutine corrente.\n"
"    \n"
"    Senza ESPR, restituisce \"$riga $nomefile\". Con ESPR, restituisce\n"
"    \"$riga $subroutine $nomefile\"; questa informazione aggiuntiva può\n"
"    essere usata per fornire uno stack trace.\n"
"    \n"
"    Il valore dell'ESPR indica di quanti frame di chiamata tornare indietro\n"
"    rispetto a quello attuale; in cima c'è il frame 0.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce 0 a meno che non sia in esecuzione una funzione di shell o\n"
"    che l'ESPR non sia valida."

#: builtins.c:392
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of the\n"
"    HOME shell variable. If DIR is \"-\", it is converted to $OLDPWD.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n"
"    A null directory name is the same as the current directory.  If DIR begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is set,\n"
"    the word is assumed to be  a variable name.  If that variable has a value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Cambia la directory di lavoro della shell.\n"
"    \n"
"    Cambia la directory corrente a DIR. La DIR predefinita è il valore della variabile\n"
"    HOME della shell. Se DIR è \"-\", viene convertito in $OLDPWD.\n"
"    \n"
"    La variabile CDPATH definisce il percorso di ricerca per la directory che contiene\n"
"    DIR. I nomi di directory alternative in CDPATH sono separati da un due punti (:).\n"
"    Una nome nullo di directory corrisponde alla directory corrente. Se DIR inizia\n"
"    con uno slash (/), CDPATH non viene usato.\n"
"    \n"
"    Se la directory non viene trovata e l'opzione di shell \"cdable_vars\" è impostata,\n"
"    si assume che la parola sia un nome di variabile. Se questa variabile ha un valore,\n"
"    viene usato per DIR.\n"
"    \n"
"    Opzioni:\n"
"      -L\tforza a seguire i collegamenti simbolici: risolve i link simbolici\n"
"    \t\tin DIR dopo aver processato le istanze di \"..\"\n"
"      -P\tusa la struttura fisica della directory senza seguire i collegamenti\n"
"    \t\tsimbolici: risolve i link simbolici in DIR prima\n"
"    \t\tdi aver processato le istanze di \"..\"\n"
"      -e\tse viene fornita l'opzione -P e non può essere determinata con successo\n"
"    \t\tla directory di lavoro corrente, esce con uno stato diverso da zero\n"
"      -@\tsu sistemi che lo supportano, presenta un file con attributi\n"
"    \t\testesi come una directory contenente gli attributi del file\n"
"    \n"
"    Il valore predefinito è seguire i collegamenti simbolici, come se fosse specificato \"-L\".\n"
"    \"..\" viene processato rimuovendo la componente del percorso immediatamente precedente, fino a uno slash o all'inizio di DIR.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce 0 se viene cambiata la directory o se $PWD è impostata con successo quando\n"
"    viene usato -P; altrimenti un valore diverso da zero."

#: builtins.c:430
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Stampa il nome della directory di lavoro corrente.\n"
"    \n"
"    Opzioni:\n"
"      -L\tStampa il valore di $PWD se contiene il nome della directory\n"
"    \t\tdi lavoro corrente\n"
"      -P\tStampa la directory fisica senza alcun collegamento simbolico\n"
"    \n"
"    In maniera predefinita \"pwd\" si comporta come se fosse specificato \"-L\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce 0 a meno che non venga fornita una opzione non valida o che la\n"
"    directory corrente non possa essere letta."

#: builtins.c:447
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Comando nullo.\n"
"    \n"
"    Nessun effetto; il comando non fa nulla.\n"
"    \n"
"    Stato di uscita:\n"
"    ha sempre successo."

#: builtins.c:458
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Restituisce successo come risultato.\n"
"    \n"
"    Stato di uscita:\n"
"    ha sempre successo."

#: builtins.c:467
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Restituisce un risultato di insuccesso.\n"
"    \n"
"    Stato di uscita:\n"
"    Sempre un insuccesso."

#: builtins.c:476
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a single word indicating the command or filename that\n"
"            invokes COMMAND\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Esegue un comando semplice o visualizza informazioni sui comandi.\n"
"    \n"
"    Esegue il COMANDO con gli ARGOMENTI ignorando la ricerca delle funzioni di shell o\n"
"    visualizza informazioni sui COMANDI specificati. Può essere usato per invocare comandi\n"
"    sul disco quando esiste una funzione con lo stesso nome.\n"
"    \n"
"    Opzioni:\n"
"      -p    usa un valore predefinito per il PERCORSO che garantisce che\n"
"            vengano trovate tutte le utilità standard\n"
"      -v    stampa una singola parola che indica il comando o il nome del\n"
"            file che invoca COMANDO\n"
"            \"type\"\n"
"      -V    stampa una descrizione più prolissa di ciascun COMANDO\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato di uscita del COMANDO o insuccesso se il COMANDO non viene trovato."

#: builtins.c:496
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute, except for a,\n"
"    A, and r.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the `local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Imposta i valori e gli attributi delle variabili.\n"
"    \n"
"    Dichiara le variabili e fornisce loro attributi. Se non vengono forniti NOMI,\n"
"    visualizza gli attributi e i valori di tutte le variabili.\n"
"    \n"
"    Opzioni:\n"
"      -f\tlimita l'azione o la visualizzazione ai nomi e alle definizioni di funzione\n"
"      -F\tlimita la visualizzazione ai soli nomi di funzione (più numero di riga e\n"
"    \t\tfile sorgente durante il debug)\n"
"      -g\tcrea variabili globali quando usato in una funzione di shell; altrimenti\n"
"    \t\tè ignorato\n"
"      -I\tcreando una variabile locale, eredita attributi e valore\n"
"    \t\tdi una variable con stesso nome in uno scope precedente\n"
"      -p\tvisualizza gli attributi e i valori di ciascun NOME\n"
"    \n"
"    Opzioni che impostano gli attributi:\n"
"      -a\trende i NOMI array indicizzati (se supportata)\n"
"      -A\trende i NOMI array associativi (se supportata)\n"
"      -i\tfornisce ai NOMI l'attributo \"integer\"\n"
"      -l\tconverte i valori dei NOMI in lettere minuscole in fase di assegnazione\n"
"      -n\trende NOME un riferimento alla variabile indicata dal suo valore\n"
"      -r\timposta i NOMI in sola lettura\n"
"      -t\tfornisce ai NOMI l'attributo \"trace\"\n"
"      -u\tconverte i valori dei NOMI in lettere maiuscole in fase di assegnazione\n"
"      -x\timposta i NOMI come esportabili\n"
"    \n"
"    Usando \"+\" al posto di \"-\" disattiva l'attributo fornito, ad\n"
"    eccezione di a, A e r.\n"
"    \n"
"    Le variabili con attributo \"integer\" vengono valutate aritmeticamente\n"
"    (vedereil comando \"let\") quando alla variabile è assegnato un valore.\n"
"    \n"
"    Quando viene usato in una funzione, \"declare\" rende locali i NOMI, come\n"
"    con il comando \"local\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o\n"
"    si riscontri un errore nell'assegnazione di variabili."

#: builtins.c:539
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Imposta valori e attributi di variabile.\n"
"    \n"
"    Sinonimo per \"declare\". Vedere \"help declare\"."

#: builtins.c:547
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    If any NAME is \"-\", local saves the set of shell options and restores\n"
"    them when the function returns.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Definisce variabili locali.\n"
"    \n"
"    Crea una variabile locale chiamata NOME fornendogli un VALORE. L'OPZIONE può\n"
"    essere una qualsiasi opzione accettata da \"declare\".\n"
"    \n"
"    Se uno dei NOMI è \"-\", salva localmente l'insieme delle opzioni di shell\n"
"    e le riattiva quando la funzione termina.\n"
"    \n"
"    Le variabili locali possono essere usate solo all'interno di una funzione; sono\n"
"    visibili solo alla funzione nella quale sono definite e ai relativi figli.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita un'opzione non valida,\n"
"    non si riscontri un errore nell'assegnazione di variabili, o la shell non\n"
"    stia eseguendo una funzione."

#: builtins.c:567
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Scrive argomenti sullo standard output.\n"
"    \n"
"    Visualizza gli ARG sullo standard output, separati da un singolo carattere\n"
"    spazio, e seguiti da un ritorno a capo.\n"
"    \n"
"    Opzioni:\n"
"      -n\tNon accoda un carattere di ritorno a capo\n"
"      -e\tAbilita l'interpretazione dei seguenti caratteri backslash di escape\n"
"      -E\tDisabilita esplicitamente l'interpretazione dei caratteri backslash di escape\n"
"    \n"
"    \"echo\" interpreta i seguenti caratteri backslash di escape:\n"
"      \\a\tavviso (campanello)\n"
"      \\b\tbackspace\n"
"      \\c\telimina ulteriore output\n"
"      \\e\tcarattere di escape\n"
"      \\E\tcarattere di escape\n"
"      \\f\tavanzamento pagina\n"
"      \\n\tritorno a capo\n"
"      \\r\tritorno carrello\n"
"      \\t\ttabulazione orizzontale\n"
"      \\v\ttabulazione verticale\n"
"      \\\\\tbackslash\n"
"      \\0nnn\til carattere il cui codice ASCII è NNN (ottale). NNN può avere\n"
"    \t\tda 0 a 3 cifre ottali\n"
"      \\xHH\til carattere otto bit il cui valore è HH (esadecimale). HH può\n"
"    \t\tavere una o due cifre esadecimali\n"
"      \\uHHHH\til carattere Unicode il cui valore è il valore esadecimale HHHH.\n"
"    \t\tHHHH può avere da una a quattro cifre esadecimali.\n"
"      \\UHHHHHHHH il carattere Unicode il cui valore è HHHH (esadecimale).\n"
"    \t\tHHHHHHHH. HHHHHHHH può avere da una a otto cifre esadecimali.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga riscontrato un errore di scrittura."

#: builtins.c:607
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Scrive argomenti sullo standard output.\n"
"    \n"
"    Visualizza gli ARG sullo standard output seguiti da un ritorno a capo.\n"
"    \n"
"    Opzioni:\n"
"      -n\tNon accoda un ritorno a capo\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga riscontrato un errore di scrittura."

#: builtins.c:622
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    On systems with dynamic loading, the shell variable BASH_LOADABLES_PATH\n"
"    defines a search path for the directory containing FILENAMEs that do\n"
"    not contain a slash. It may include \".\" to force a search of the current\n"
"    directory.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Abilita o disabilita comandi interni di shell.\n"
"    \n"
"    Abilita o disabilita comandi interni di shell. La disabilitazione permette di\n"
"    eseguire un comando su disco che abbia lo stesso nome del comando interno\n"
"    di shell senza dover usare un nome di percorso completo.\n"
"    \n"
"    Opzioni:\n"
"      -a\tStampa un elenco di comandi interni mostrando se sono abilitati o meno\n"
"      -n\tDisabilita ogni NOME o visualizza un elenco di comandi interni disabilitati\n"
"      -p\tStampa l'elenco dei comandi interni in un formato riusabile\n"
"      -s\tStampa solo i nomi dei comandi interni \"speciali\" Posix\n"
"    \n"
"    Opzioni che controllano il caricamento dinamico:\n"
"      -f\tCarica il comando interno NOME dall'oggetto condiviso NOMEFILE\n"
"      -d\tRimuove un comando interno caricato con -f\n"
"    \n"
"    Senza opzioni viene abilitato ogni NOME.\n"
"    \n"
"    Su sistemi con caricamento dinamico, la variabile di ambiente BASH_LOADABLES_PATH\n"
"    definisce un percorso di ricerca per la directory contenente i NOMEFILE, che\n"
"    non contiene uno slash. Può includere \".\" per forzare la ricerca nella\n"
"    directory corrente.\n"
"    \n"
"    Per usare il comando \"test\" trovato in $PATH invece di quello interno della\n"
"    shell, digitare \"enable -n test\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che NOME non sia un comando interno di shell o si riscontri un errore."

#: builtins.c:655
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Esegue argomenti come un comando di shell.\n"
"    \n"
"    Combina gli ARGOMENTI dentro una singola stringa usando il risultato\n"
"    come input per la shell ed esegue i comandi risultanti.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato di uscita del comando o successo se il comando è nullo."

#: builtins.c:667
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Analizza gli argomenti di opzione.\n"
"    \n"
"    Getopts è usato dalle procedure di shell per analizzare i parametri\n"
"    posizionali come opzioni.\n"
"    \n"
"    STRINGAOPZ contiene le lettere di opzione da riconoscere; se una\n"
"    lettera è seguita da un due punti, ci si aspetta che l'opzione abbia\n"
"    un argomento, che dovrebbe essere separato da uno spazio.\n"
"    \n"
"    Ogni volta che viene evocato getopts posiziona l'opzione successiva\n"
"    nella variabile di shell $nome inizializzando il nome, se non esiste,\n"
"    e l'indice dell'argomento successivo da elaborare nella variabile di\n"
"    shell OPTIND. OPTIND è inizializzata a 1 ogni volta che viene invocata\n"
"    la shell o uno script di shell. Quando una opzione richiede un argomento,\n"
"    getopts posiziona tale argomento nella variabile di shell OPTARG.\n"
"    \n"
"    getopts riporta gli errori in uno o due modi. Se il primo carattere della\n"
"    STRINGAOPZ è un due punti, riporta gli errori in silenzio. In questa\n"
"    modalità non vengono stampati messaggi di errore. Se viene riscontrata una\n"
"    opzione non valida, getopts posiziona il carattere di opzione trovato in\n"
"    ARGOPZ. Se un argomento richiesto non viene trovato, getopts posiziona\n"
"    un \":\" nel NOME e imposta ARGOPZ al carattere di opzione trovato. Se getopts\n"
"    non è in modalità silenziosa e viene riscontrata una opzione non valida, getopts\n"
"    posiziona \"?\" nel NOME e rimuove ARGOPZ. Se un argomento richiesto non viene\n"
"    trovato, viene posizionato un \"?\" nel NOME, ARGOPZ viene rimosso e viene stampato\n"
"    un messaggio diagnostico.\n"
"    \n"
"    Se il valore della variabile di shell ERROPZ è pari a 0, getopts disabilita\n"
"    la stampa dei messaggi di errore anche se il primo carattere della STRINGAOPZ\n"
"    non è un due punti. Il valore predefinito di ERROPZ è pari a 1.\n"
"    \n"
"    Getopts normalmente analizza i parametri posizionali, ma se vengono\n"
"    forniti degli argomenti come valori ARG, vengono analizzati questi ultimi.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo se viene trovata una opzione, insuccesso se viene raggiunta\n"
"    la fine delle opzioni o viene riscontrato un errore."

#: builtins.c:709
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error occurs."
msgstr ""
"Sostituisce la shell con il comando fornito.\n"
"    \n"
"    Esegue il COMANDO, sostituendo questa shell con il programma specificato.\n"
"    Gli ARGOMENTI diventano gli argomenti per il COMANDO. Se il COMANDO non è specificato,\n"
"    ogni redirezione avrà effetto nella shell corrente.\n"
"    \n"
"    Opzioni:\n"
"      -a nome\tPassa NOME come l'argomento zero per il COMANDO\n"
"      -c\tEsegue il COMANDO con un ambiente vuoto\n"
"      -l\tPosiziona un trattino nell'argomento zero per il COMANDO\n"
"    \n"
"    Se il comando non può essere eseguito una shell non interattiva esce, a meno che\n"
"    non venga impostata l'opzione di shell \"execfail\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia trovato il COMANDO o si\n"
"    riscontri un errore di redirezione."

#: builtins.c:730
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Esce dalla shell.\n"
"    \n"
"    Esce dalla shell con uno stato N. Se N è omesso lo stato di uscita\n"
"    è quello dell'ultimo comando eseguito."

#: builtins.c:739
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not executed\n"
"    in a login shell."
msgstr ""
"Esce da una shell di login.\n"
"    \n"
"    Esce da una shell di login con stato di uscita N. Restituisce un errore se non eseguito\n"
"    in una shell di login."

#: builtins.c:749
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    The history builtin also operates on the history list.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error occurs."
msgstr ""
"Visualizza o esegue comandi dall'elenco della cronologia.\n"
"    \n"
"    fc è usato per elencare, modificare e rieseguire comandi dall'elenco della cronologia.\n"
"    PRIMO e ULTIMO possono essere numeri che specificano l'intervallo oppure PRIMO può\n"
"    essere una stringa, nel qual caso significa il comando più recente che inizia con\n"
"    quella stringa.\n"
"    \n"
"    Opzioni:\n"
"      -e EDITOR\tSeleziona l'editor da usare. Il predefinito è FCEDIT, quindi EDITOR,\n"
"    \t\tinfine vi\n"
"      -l \tElenca le righe invece di modificarle\n"
"      -n\tOmette i numeri di riga nell'elencare i comandi\n"
"      -r\tInverte l'ordine delle righe (elenca prima le più recenti)\n"
"    \n"
"    Con il formato \"fc -s [pat=rep ...] [comando]\", il COMANDO è\n"
"    rieseguito dopo aver effettuato la sostituzione VECCHIO=NUOVO.\n"
"    \n"
"    Un alias utile da usare insieme è r=\"fc -s\", in modo che digitando \"r cc\"\n"
"    viene eseguito l'ultimo comando che inizia con \"cc\" e digitando \"r\" riesegue\n"
"    l'ultimo comando.\n"
"    \n"
"    Il comando interno history opera anche sull'elenco della cronologia.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo o lo stato del comando eseguito, non zero se si riscontra un errore."

#: builtins.c:781
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Sposta un job in primo piano.\n"
"    \n"
"    Mette il job identificato da SPEC_JOB in primo piano, rendendolo il\n"
"    job corrente. Se SPEC_JOB non è presente, viene usata la nozione di\n"
"    job corrente della shell.\n"
"    \n"
"    Stato di uscita:\n"
"    Stato del comando messo in primo piano, o insuccesso se si riscontra un errore."

#: builtins.c:796
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Sposta i job in background.\n"
"    \n"
"    Mette il job identificato da ogni SPEC_JOB in background, come se\n"
"    fossero stati avviati con \"&\". Se SPEC_JOB non è presente, viene\n"
"    usata la nozione di job corrente della shell.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che il controllo dei job non sia abilitato o\n"
"    si riscontri un errore."

#: builtins.c:810
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Ricorda o visualizza le posizioni dei programmi.\n"
"    \n"
"    Determina e ricorda il nome completo di percorso per ogni comando NOME. Se non\n"
"    viene fornito alcun argomento, sono visualizzate le informazioni sui comandi memorizzati.\n"
"    \n"
"    Opzioni:\n"
"      -d\tDimentica la posizione memorizzata di ogni NOME\n"
"      -l\tVisualizza in un formato che può essere riusato come input\n"
"      -p nomepercorso\tUsa NOMEPERCORSO come il nome completo di percorso per NOME\n"
"      -r\tDimentica tutte le posizioni memorizzate\n"
"      -t\tStampa la posizione memorizzata di ogni NOME, facendo\n"
"    \t\tprecedere ciascuna posizione con il NOME corrispondente se vengono\n"
"    \t\tforniti valori NOME multipli\n"
"    Argomenti:\n"
"      NOME\tOgni NOME è ricercato in $PATH e aggiunto all'elenco\n"
"    \t\tdei comandi memorizzati.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia trovato NOME o sia fornita una opzione non valida."

#: builtins.c:835
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is given."
msgstr ""
"Visualizza informazioni sui comandi interni.\n"
"    \n"
"    Visualizza un breve sommario dei comandi interni. Se viene specificato il\n"
"    MODELLO fornisce un aiuto dettagliato su tutti i comandi corrispondenti al\n"
"    MODELLO, altrimenti viene stampato l'elenco degli argomenti di aiuto.\n"
"    \n"
"    Opzioni:\n"
"      -d\tVisualizza una breve descrizione per ciascun argomento\n"
"      -m\tVisualizza l'uso in formato pseudo manpage\n"
"      -s\tVisualizza solo una breve sintassi sull'uso per ciascun argomento che\n"
"    \t\tcorrisponde al MODELLO\n"
"    \n"
"    Argomenti:\n"
"      MODELLO\tModello che specifica un argomento di aiuto\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga trovato il MODELLO o sia fornita una opzione non valida."

#: builtins.c:859
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"      -d start-end\tdelete the history entries beginning at position START\n"
"    \t\tthrough position END.\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used. If FILENAME is not supplied\n"
"    and HISTFILE is unset or null, the -a, -n, -r, and -w options have\n"
"    no effect and return success.\n"
"    \n"
"    The fc builtin also operates on the history list.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Visualizza o manipola l'elenco della cronologia.\n"
"    \n"
"    Visualizza l'elenco della cronologia con i numeri di riga, aggiungendo a ciascuna voce\n"
"    modificata il prefisso \"*\". Un argomento pari a N elenca solo le ultime N voci.\n"
"    \n"
"    Opzioni:\n"
"      -c\tpulisce la cronologia eliminando tutte le voci\n"
"      -d posiz\telimina la voce della cronologia alla posizione POSIZ.\n"
"    \t\tPosizioni negative indicano di contare all'indietro dalla fine\n"
"    \t\tdell'elenco della cronologia.\n"
"      -d inizio-fine\telimina le voci della cronologia iniziando alla\n"
"    \t\tposizione INIZIO fino alla posizione FINE.\n"
"    \n"
"      -a\taccoda righe al file della cronologia relative alla sessione attuale\n"
"      -n\tlegge tutte le righe non ancora lette dal file della cronologia\n"
"    \t\te le accoda all'elenco della cronologia\n"
"      -r\tlegge il file della cronologia e ne accoda il contenuto all'elenco\n"
"    \t\tdella cronologia\n"
"      -w\tscrive la cronologia corrente nel file della cronologia\n"
"    \n"
"      -p\teffettua l'espansione della cronologia su ciascun ARG e visualizza il\n"
"    \t\trisultato senza memorizzarlo nell'elenco della cronologia\n"
"      -s\taccoda gli ARG all'elenco della cronologia come una voce singola\n"
"    \n"
"    Se viene fornito il NOMEFILE, viene usato come file della cronologia. \n"
"    Altrimenti, se HISTFILE è valorizzato, viene usato quest'ultimo. Se\n"
"\n"
"    NOMEFILE non viene fornito, e HISTFILE non è impostato oppure è null, le\n"
"    opzioni -a, -n, -r e -w non hanno effetto e termina con successo.\n"
"    \n"
"    Se la variabile $HISTTIMEFORMAT è impostata e non è nulla, il suo valore\n"
"    viene usato come una stringa di formato per strftime(3) per stampare\n"
"    l'orario associato a ciascuna voce di cronologia visualizzata. Altrimenti\n"
"    non viene stampato alcun orario.\n"
"    \n"
"    Il comando interno fc opera anche sull'elenco della cronologia.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o si riscontri un errore."

#: builtins.c:902
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Visualizza lo stato dei job.\n"
"    \n"
"    Elenca i job attivi. SPECJOB limita l'output a quei job.\n"
"    Senza opzioni, è visualizzato lo stato di tutti i job attivi.\n"
"    \n"
"    Opzioni:\n"
"      -l\tElenca gli ID dei processi in aggiunta alle normali informazioni\n"
"      -n\tElenca solo i processi che hanno cambiato stato dall'ultima\n"
"    \t\tnotifica\n"
"      -p\tElenca solo l'ID dei processi\n"
"      -r\tLimita l'output ai job in esecuzione\n"
"      -s\tLimita l'output ai processi fermati\n"
"    \n"
"    Se viene fornito -x, il COMANDO è eseguito dopo che tutte le specifiche\n"
"    dei job che appaiono in ARGOMENTI sono state rimpiazzate con l'ID del\n"
"    processo leader nel gruppo di quel job.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o\n"
"    si riscontri un errore.\n"
"    Se viene usato -x, restituisce lo stato di uscita del COMANDO."

#: builtins.c:929
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Rimuove job dalla shell corrente.\n"
"    \n"
"    Rimuove ciascun argomento SPECJOB dalla tabella dei job attivi. Senza alcun\n"
"    SPECJOB, la shell usa la sua nozione del job corrente.\n"
"    \n"
"    Opzioni:\n"
"      -a\tRimuove tutti i job se non viene fornito uno SPECJOB\n"
"      -h\tMarca ciascun SPECJOB in modo che non venga inviato un SIGHUP al\n"
"    \t\tjob se la shell lo riceve\n"
"      -r\tRimuove solo i job in esecuzione\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita una opzione non valida\n"
"    o uno SPECJOB."

#: builtins.c:948
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Invia un segnale a un job.\n"
"    \n"
"    Invia il segnale chiamato dallo SPECSEGN o dal NUMSEGN ai processi identificati\n"
"    dal PID o dallo SPECJOB. Se non è presente né lo SPECSEGN né il NUMSEGN, viene\n"
"    allora considerato SIGTERM.\n"
"    \n"
"    Opzioni:\n"
"      -s segn\tSEGN è il nome di un segnale\n"
"      -n segn\tSEGN è il numero di un segnale\n"
"      -l\telenca i nomi dei segnali; se ci sono argomenti dopo \"-l\"\n"
"    \t\tvengono considerati come numeri di segnale di cui elencare i nomi\n"
"      -L\tsinonimo di -l\n"
"    \n"
"    Kill è un comando interno di shell per due ragioni: permette di usare\n"
"    gli ID dei job invece degli ID dei processi e permette di terminare\n"
"    processi anche se è stato raggiunto il limite di processi che l'utente\n"
"    può creare.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o si riscontri un errore."

#: builtins.c:972
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Valuta espressioni aritmetiche.\n"
"    \n"
"    Valuta ciascun ARG come una espressione aritmetica. La valutazione è\n"
"    effettuata con interi a larghezza fissa senza alcun controllo sull'overflow,\n"
"    sebbene la divisione per 0 sia catturata e contrassegnata come un errore.\n"
"    Il seguente elenco di operatori è raggruppato per livelli di operatore\n"
"    di uguale precedenza. I livelli sono elencati in ordine di precedenza\n"
"    decrescente.\n"
"    \n"
"    \tid++, id--\tIncremento e decremento successivo di variabile\n"
"    \t++id, --id\tIncremento e decremento precedente di variabile\n"
"    \t-, +\t\tMeno e più unari\n"
"    \t!, ~\t\tNegazione logica e bit a bit\n"
"    \t**\t\tEsponenziazione\n"
"    \t*, /, %\t\tMoltiplicazione, divisione, resto\n"
"    \t+, -\t\tAddizione, sottrazione\n"
"    \t<<, >>\t\tScorrimento bit a bit sinistro e destro\n"
"    \t<=, >=, <, >\tComparazione\n"
"    \t==, !=\t\tUguaglianza, disuguaglianza\n"
"    \t&\t\tAND bit a bit\n"
"    \t^\t\tXOR bit a bit\n"
"    \t|\t\tOR bit a bit\n"
"    \t&&\t\tAND logico\n"
"    \t||\t\tOR logico\n"
"    \tespr ? espr : espr\n"
"    \t\t\tOperatore condizionale\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tAssegnazione\n"
"    \n"
"    Le variabili di shell sono ammesse come operandi. Il nome della variabile è\n"
"    sostituito dal suo valore (forzato a un intero a larghezza fissa) all'interno\n"
"    di una espressione. Non è necessario che la variabile abbia il proprio attributo\n"
"    intero abilitato per essere usata in una espressione.\n"
"    \n"
"    Gli operatori sono valutati in ordine di precedenza. Le sottoespressioni\n"
"    tra parentesi sono valutate per prime e possono avere la precedenza sulle\n"
"    regole sopradescritte.\n"
"    \n"
"    Stato di uscita:\n"
"    Se l'ultimo ARG viene valutato pari a 0 restituisce 1, altrimenti restituisce 0."

#: builtins.c:1017
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as word\n"
"    delimiters. By default, the backslash character escapes delimiter characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -E\tuse Readline to obtain the line and use the bash default\n"
"    \t\tcompletion instead of Readline's default completion\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times out\n"
"    (in which case it's greater than 128), a variable assignment error occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Legge una riga dallo standard input e la divide in campi.\n"
"    \n"
"    Legge una singola riga dallo standard input o, se viene fornita l'opzione -u,\n"
"    dal descrittore di file FD. La riga è divisa in campi corrispondenti a\n"
"    parole dove la prima parola è assegnata al primo NOME, la seconda parola\n"
"    al secondo NOME e così via, con ciascuna parola rimanente assegnata al\n"
"    corrispondente ultimo NOME. Sono riconosciuti come delimitatori di parola\n"
"    solo quelli presenti in $IFS. Come impostazione predefinita, il carattere\n"
"    backslash viene usato come escape per i caratteri delimitatore e\n"
"    \"a capo\".\n"
"    \n"
"    Se non viene fornito alcun NOME, la riga letta è memorizzata nella variabile REPLY.\n"
"    \n"
"    Opzioni:\n"
"      -a array\tAssegna le parole lette agli indici sequenziali della variabile\n"
"    \t\tdi ARRAY, iniziando da zero\n"
"      -d delim\tContinua fino alla lettura del primo carattere di DELIM, invece\n"
"    \t\tdi un ritorno a capo \n"
"      -e\tUsa Readline per ottenere la riga\n"
"      -E\tUsa Readline per ottenere la riga, e utilizza il completamento\n"
"    \t\tpredefinito d bash anziché quello predefinito di Readline\n"
"      -i testo\tUsa TESTO come testo iniziale per Readline\n"
"      -n ncarat\tRitorna dopo la lettura di NCARAT caratteri invece di attendere\n"
"    \t\tun a capo, ma rispetta un delimitatore se vengono letti meno di\n"
"    \t\tNCARAT caratteri prima del delimitatore stesso\n"
"      -N ncarat\tRitorna solo dopo la lettura di NCARAT caratteri esatti, a meno che non si\n"
"    \t\triscontri un EOF o un time out di lettura, ignorando qualsiasi\n"
"    \t\tdelimitatore\n"
"      -p stringa\tVisualizza la stringa PROMPT senza un a capo finale prima\n"
"    \t\tdel tentativo di lettura\n"
"      -r\t\tNon ammette backslash per fare l'escape dei caratteri\n"
"      -s\t\tNon fa l'echo dell'input proveniente da un terminale\n"
"      -t secondi\tVa in timeout e restituisce insuccesso se non viene letta\n"
"    \t\tuna riga di input completa entro i SECONDI forniti. Il valore della\n"
"    \t\tvariabile TMOUT è il timeout predefinito. SECONDI può essere\n"
"    \t\tuna frazione. Se SECONDI è pari a 0, la lettura termina immediata-\n"
"    \t\tmente, senza provare a leggere dati, restituendo successo\n"
"    \t\tsolo se l'input è disponibile sul descrittore di file specificato.\n"
"    \t\tSe viene superato il timeout lo stato di uscita è maggiore di 128\n"
"      -u fd\t\tLegge dal descrittore di file FD invece che dallo standard input\n"
"    \n"
"    Stato di uscita:\n"
"    Il codice restituito è zero a meno che non sia riscontrato un EOF, un\n"
"    timeout in lettura (nel qual caso sarà maggiore di 128), un errore di\n"
"    assegnazione di variabili, o venga fornito un descrittore di file non\n"
"    valido come argomento per -u."

#: builtins.c:1067
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Ritorna da una funzione di shell.\n"
"    \n"
"    Causa l'uscita da una funzione o da uno script sorgente con il valore di\n"
"    ritorno specificato da N. Se N è omesso, lo stato di ritorno è quello\n"
"    dell'ultimo comando eseguito all'interno della funzione o dello script.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce N, oppure insuccesso se la shell non sta eseguendo una funzione\n"
"    o uno script."

#: builtins.c:1080
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    If -o is supplied with no option-name, set prints the current shell\n"
"    option settings. If +o is supplied with no option-name, set prints a\n"
"    series of set commands to recreate the current option settings.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Imposta o rimuove i valori delle opzioni di shell e dei parametri posizionali.\n"
"    \n"
"    Cambia il valore degli attributi di shell e dei parametri posizionali,\n"
"    o visualizza i nomi e i valori delle variabili di shell.\n"
"    \n"
"    Opzioni:\n"
"      -a  Marca le variabili che sono modificate o create per l'esportazione.\n"
"      -b  Notifica immediatamente della terminazione di un job.\n"
"      -e  Esce immediatamente se un comando esce con uno stato diverso da\n"
"          zero.\n"
"      -f  Disabilita la generazione dei nomi file (globbing).\n"
"      -h  Ricorda la posizione dei comandi quando vengono cercati.\n"
"      -k  Tutte le assegnazioni degli argomenti sono posizionate nell'ambiente\n"
"          per un comando, non solo quelle che precedono il nome del comando\n"
"          stesso.\n"
"      -m  Abilita il controllo dei job.\n"
"      -n  Legge i comandi senza eseguirli.\n"
"      -o nome-opzione\n"
"          Imposta la variabile corrispondente al nome dell'opzione:\n"
"              allexport    Uguale a -a\n"
"              braceexpand  Uguale a -B\n"
"              emacs        Usa una interfaccia di modifica righe di stile\n"
"                           emacs\n"
"              errexit      Uguale a -e\n"
"              errtrace     Uguale a -E\n"
"              functrace    Uguale a -T\n"
"              hashall      Uguale a -h\n"
"              histexpand   Uguale a -H\n"
"              history      Abilita la cronologia comandi\n"
"              ignoreeof    Non esce dalla shell dopo aver raggiunto EOF\n"
"              interactive-comments\n"
"                           Permette ai commenti di comparire nei comandi\n"
"                           interattivi\n"
"              keyword      Uguale a -k\n"
"              monitor      Uguale a -m\n"
"              noclobber    Uguale a -C\n"
"              noexec       Uguale a -n\n"
"              noglob       Uguale a -f\n"
"              nolog        Accettato al momento ma ignorato\n"
"              notify       Uguale a -b\n"
"              nounset      Uguale a -u\n"
"              onecmd       Uguale a -t\n"
"              physical     Uguale a -P\n"
"              pipefail     Il valore restituito da una pipeline è lo stato\n"
"                           dell'ultimo comando che esce con uno stato\n"
"                           diverso da zero, oppure zero se nessun comando\n"
"                           esce con uno stato diverso da zero\n"
"              posix        Modifica il comportamento di bash dove\n"
"                           l'operazione predefinita è diversa dallo standard\n"
"                           Posix per rispettare\n"
"                           lo standard stesso\n"
"              privileged   Uguale a -p\n"
"              verbose      Uguale a -v\n"
"              vi           Usa un'editor di riga stile vi\n"
"              xtrace       Uguale a -x\n"
"      -p  Abilitato ogni qualvolta l'id utente reale non corrisponda a\n"
"          quello effettivo. Disabilita l'analisi del file $ENV e l'importazione\n"
"          delle funzioni di shell. Disabilitare questa opzione comporta\n"
"          l'impostazione degli uid e gid effettivi a uid e gid reali.\n"
"      -t  Esce dopo la lettura e l'esecuzione di un comando.\n"
"      -u  Tratta le variabili non impostate come un errore durante la\n"
"          sostituzione.\n"
"      -v  Stampa le righe di input della shell mentre vengono lette.\n"
"      -x  Stampa i comandi e i loro argomenti mentre vengono eseguiti.\n"
"      -B  La shell effettua l'espansione delle parentesi graffe\n"
"      -C  Se impostata, non permette la sovrascrittura dei file regolari\n"
"          esistenti da parte della redirezione dell'output.\n"
"      -E  Se impostata, la trap ERR è ereditata dalle funzioni di shell.\n"
"      -H  Abilita la sostituzione per la cronologia stile !. Questo flag è\n"
"          abilitato in modo predefinito quando la shell è interattiva.\n"
"      -P  Se impostata, non risolve i link simbolici quando vengono eseguiti\n"
"          dei comandi come cd, che cambiano la directory corrente.\n"
"      -T  Se impostata, le trap DEBUG e RETURN sono ereditate dalle funzioni\n"
"          di shell.\n"
"      --  Assegna tutti gli argomenti rimasti ai parametri posizionali.\n"
"          Se non sono rimasti argomenti, i parametri posizionali\n"
"          vengono rimossi.\n"
"      -   Assegna tutti gli argomenti rimasti ai parametri posizionali.\n"
"          Le opzioni -x e -v sono disabilitate.\n"
"    \n"
"    Se viene passato -o senza nome-opzione, set stampa le impostazioni\n"
"    correnti delle opzioni della shell. Se viene passato +o senza\n"
"    nome-opzione, set stampa una serie di comandi set per ricreare le\n"
"    impostazioni correnti dell'opzione.\n"
"    \n"
"    Usando + al posto di - questi flag vengono disabilitati. I\n"
"    flag possono anche essere usati subito dopo l'invocazione della shell.\n"
"    Il set corrente dei flag può essere trovato in $-. I restanti n ARG sono\n"
"    parametri posizionali e vengono assegnati, in ordine, a $1, $2, .. $n.\n"
"    Se non vengono forniti ARG, vengono stampate tutte le variabili di shell.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita una opzione non valida."

#: builtins.c:1169
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Rimuove i valori e gli attributi delle variabili e delle funzioni di shell.\n"
"    \n"
"    Per ciascun NOME, rimuove la corrispondente variabile o funzione.\n"
"    \n"
"    Opzioni:\n"
"      -f\tconsidera ciascun NOME come una funzione di shell\n"
"      -v\tconsidera ciascun NOME come una variabile di shell\n"
"      -n\tconsidera ciascun NOME come un riferimento a nome e reimposta la\n"
"    \t\tvariabile stessa piuttosto che la variabile referenziata\n"
"    \n"
"    Senza opzioni, unset prima prova a rimuovere una variabile e, in caso di\n"
"    insuccesso, prova a rimuovere una funzione.\n"
"    \n"
"    Alcune variabili non possono essere rimosse; vedere anche \"readonly\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o\n"
"    NOME sia in sola lettura."

#: builtins.c:1191
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables or functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Imposta l'attributo di esportazione per le variabili di shell.\n"
"    \n"
"    Marca ciascun NOME per l'esportazione automatica all'ambiente dei\n"
"    comandi eseguiti successivi. Se è fornito un VALORE, lo assegna prima\n"
"    dell'esportazione.\n"
"    \n"
"    Opzioni:\n"
"      -f\tfa riferimento alle funzioni di shell\n"
"      -n\trimuove la proprietà di esportazione da ciascun NOME\n"
"      -p\tvisualizza un elenco di tutte le variabili o funzioni esportate\n"
"    \n"
"    L'argomento \"--\" disabilita l'elaborazione di ulteriori opzioni.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o\n"
"    il NOME non sia valido."

#: builtins.c:1210
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Marca la variabili di shell come non modificabili.\n"
"    \n"
"    Marca ciascun NOME in sola lettura; i valori di questi NOMI non possono\n"
"    essere modificati da un assegnamento successivo. Se viene fornito il\n"
"     VALORE, lo assegna prima di marcarlo in sola lettura.\n"
"    \n"
"    Opzioni:\n"
"      -a\tfa riferimento alle variabili degli array indicizzati\n"
"      -A\tfa riferimento alle variabili degli array associativi\n"
"      -f\tfa riferimento alle funzioni di shell\n"
"      -p\tvisualizza un elenco di tutte le variabili oppure funzioni in sola\n"
"    \t\tlettura, a seconda che venga passata o meno l'opzione -f\n"
"    \n"
"    Un argomento pari a \"--\" disabilita ulteriori analisi delle opzioni.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita una opzione non valida\n"
"    o NOME non sia valido."

#: builtins.c:1232
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Sposta i parametri posizionali.\n"
"    \n"
"    Rinomina i parametri posizionali $N+1,$N+2 ... a $1,$2 ... Se N non\n"
"    è fornito, viene assunto a 1.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che N non sia negativo o maggiore di $#."

#: builtins.c:1244 builtins.c:1260
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell. If the\n"
"    -p option is supplied, the PATH argument is treated as a colon-\n"
"    separated list of directories to search for FILENAME. If -p is not\n"
"    supplied, $PATH is searched to find FILENAME. If any ARGUMENTS are\n"
"    supplied, they become the positional parameters when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Esegue comandi da un file nella shell corrente.\n"
"    \n"
"    Legge ed esegue comandi da NOMEFILE nella shell corrente. Se viene\n"
"    passata l'opzione -p, l'argomento PATH viene trattato come una lista\n"
"    separata dai due punti di directory in cui cercare NOMEFILE. Se non\n"
"    viene passata -p, NOMEFILE viene ricercato nel $PATH.\n"
"    Se vengono forniti ARGOMENTI, essi diventano i parametri di posizione\n"
"    quando viene eseguito NOMEFILE.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito in NOMEFILE; insuccesso\n"
"    se il NOMEFILE non può essere letto."

#: builtins.c:1277
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells and shells without job control cannot be\n"
"    suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell or job\n"
"    \t\tcontrol is not enabled.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Sospende l'esecuzione della shell.\n"
"    \n"
"    Sospende l'esecuzione di questa shell fino a che non riceve un segnale\n"
"    SIGCONT.\n"
"    A meno di forzature, le shell di login e le shell senza controllo dei job\n"
"    non possono essere sospese.\n"
"    \n"
"    Opzioni:\n"
"      -f\tforza la sospensione, anche se in presenza di una shell di login\n"
"    \t\to con controllo dei job disabilitato.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia abilitato il controllo dei job o\n"
"    si riscontri un errore."

#: builtins.c:1295
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Valuta espressioni condizionali.\n"
"    \n"
"    Esce con stato 0 (vero) o 1 (falso) in base all'analisi\n"
"    dell'ESPR. Le espressioni possono essere unarie o binarie. Le\n"
"    espressioni unarie sono spesso usate per esaminare lo stato di un file.\n"
"    Esistono anche operatori di stringa e di comparazione numerica.\n"
"    \n"
"    Il comportamento del test dipende dal numero degli argomenti. Leggere\n"
"    la pagina di manuale di bash per le specifiche complete.\n"
"    \n"
"    Operatori su file:\n"
"    \n"
"      -a FILE        Vero se il file esiste.\n"
"      -b FILE        Vero se è un file speciale a blocchi.\n"
"      -c FILE        Vero se è un file speciale a caratteri.\n"
"      -d FILE        Vero se il file è una directory.\n"
"      -e FILE        Vero se il file esiste.\n"
"      -f FILE        Vero se il file esiste ed è un file normale.\n"
"      -g FILE        Vero se il file è un set-group-id.\n"
"      -h FILE        Vero se il file è un link simbolico.\n"
"      -L FILE        Vero se il file è un link simbolico.\n"
"      -k FILE        Vero se il file ha il suo bit \"sticky\" impostato.\n"
"      -p FILE        Vero se il file è una pipe con nome.\n"
"      -r FILE        Vero se il file è leggibile dall' utente corrente.\n"
"      -s FILE        Vero se il file esiste e non è vuoto.\n"
"      -S FILE        Vero se il file è un socket.\n"
"      -t FD          Vero se il descrittore di file è aperto su un terminale.\n"
"      -u FILE        Vero se il file è un set-user-id.\n"
"      -w FILE        Vero se il file è scrivibile dall'utente corrente.\n"
"      -x FILE        Vero se il file è eseguibile dall'utente corrente.\n"
"      -O FILE        Vero se l'utente corrente è il reale proprietario del\n"
"                     file.\n"
"      -G FILE        Vero se il gruppo dell'utente corrente è il reale\n"
"                     proprietario del file.\n"
"      -N FILE        Vero se il file è stato modificato dall'ultima volta\n"
"                     che è stato letto.\n"
"    \n"
"      FILE1 -nt FILE2  Vero se il file1 è più recente del file2 (in accordo\n"
"                        con la data di modifica).\n"
"    \n"
"      FILE1 -ot FILE2  Vero se il file1 è più vecchio del file2.\n"
"    \n"
"      FILE1 -ef FILE2  Vero se il file1 è un link hardware al file2.\n"
"    \n"
"    Operatori di stringa:\n"
"    \n"
"      -z STRINGA     Vero se la stringa è vuota.\n"
"    \n"
"      -n STRINGA     Vero se la stringa non è vuota.\n"
"    \n"
"      STRINGA1 = STRINGA2\n"
"                     Vero se le stringhe sono uguali.\n"
"      STRINGA1 != STRINGA2\n"
"                     Vero se le stringhe non sono uguali.\n"
"      STRINGA1 < STRINGA2\n"
"                     Vero se la STRINGA1 viene ordinata lessicograficamente\n"
"                     prima della STRINGA2.\n"
"      STRINGA1 > STRINGA2\n"
"                     Vero se la STRINGA1 viene ordinata lessicograficamente\n"
"                     dopo la STRINGA2.\n"
"    \n"
"    Altri operatori:\n"
"    \n"
"      -o OPZIONE     Vero se l'OPZIONE di shell è abilitata.\n"
"      -v VAR         Vero se la variabile di shell VAR è impostata.\n"
"      -R VAR         Vero se la variabile di shell VAR è impostata\n"
"                     ed è un riferimento a nome.\n"
"      ! ESPR         Vero se l'ESPR è falsa.\n"
"      ESPR1 -a ESPR2 Vero se entrambe le espressioni espr1 E espr2 sono vere.\n"
"      ESPR1 -o ESPR2 Vero se è vera almeno una delle due espressioni\n"
"                     espr1 O espr2.\n"
"    \n"
"      arg1 OP arg2   Test aritmetici. OP è uno tra -eq, -ne,\n"
"                     -lt, -le, -gt oppure -ge.\n"
"    \n"
"    Gli operatori aritmetici binari restituiscono vero se ARG1 è uguale, non\n"
"    uguale, più piccolo di, più piccolo o uguale, più grande di o più grande\n"
"    o uguale ad ARG2.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo se l'ESPR viene valutata vera; insuccesso se l'ESPR\n"
"    viene valutata falsa o viene fornito un argomento non valido."

#: builtins.c:1377
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Valuta l'espressione condizionale.\n"
"    \n"
"    Questo è un sinonimo del comando interno \"test\", ma l'ultimo argomento\n"
"    deve essere un \"]\" letterale per corrispondere al \"[\" di apertura."

#: builtins.c:1386
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Visualizza le durate dei processi.\n"
"    \n"
"    Stampa i tempi utente e di sistema accumulati per la shell e per tutti\n"
"    i relativi processi figli.\n"
"    \n"
"    Stato di uscita:\n"
"    Sempre successo."

#: builtins.c:1398
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives signals\n"
"    or other conditions.\n"
"    \n"
"    ACTION is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ACTION is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ACTION is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ACTION is executed on exit from the shell.\n"
"    If a SIGNAL_SPEC is DEBUG, ACTION is executed before every simple command\n"
"    and selected other commands. If a SIGNAL_SPEC is RETURN, ACTION is\n"
"    executed each time a shell function or a script run by the . or source\n"
"    builtins finishes executing.  A SIGNAL_SPEC of ERR means to execute ACTION\n"
"    each time a command's failure would cause the shell to exit when the -e\n"
"    option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands associated\n"
"    with each trapped signal in a form that may be reused as shell input to\n"
"    restore the same signal dispositions.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC in a\n"
"    \t\tform that may be reused as shell input; or for all trapped\n"
"    \t\tsignals if no arguments are supplied\n"
"      -P\tdisplay the trap commands associated with each SIGNAL_SPEC. At least\n"
"    \t\tone SIGNAL_SPEC must be supplied. -P and -p cannot be used\n"
"    \t\ttogether.\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is given."
msgstr ""
"Cattura segnali e altri eventi.\n"
"    \n"
"    Definisce e attiva i gestori da eseguire quando la shell riceve segnali\n"
"    o altre condizioni.\n"
"    \n"
"    AZIONE è un comando da leggere ed eseguire quando la shell riceve il o i\n"
"    segnali SPEC_SEGNALE. Se AZIONE o \"-\" non sono presenti (e viene fornito\n"
"    un singolo SPEC_SEGNALE), ciascun segnale specificato è riportato\n"
"    al suo valore originario. Se AZIONE è la stringa null, ogni SPEC_SEGNALE è\n"
"    ignorato dalla shell e dai comandi che invoca.\n"
"    \n"
"    Se uno SPEC_SEGNALE è EXIT (0) AZIONE viene eseguita all'uscita dalla shell.\n"
"    Se uno SPEC_SEGNALE è DEBUG, AZIONE viene eseguita prima di ogni comando\n"
"    semplice e altri comandi selezionati. Se uno SPEC_SEGNALE è RETURN, AZIONE\n"
"    viene eseguita al termine di ogni esecuzione di una funzione di shell o di\n"
"    uno script avviato dai comandi interni \".\" o source.\n"
"    Uno SPEC_SEGNALE di ERR indica di eseguire AZIONE ogni volta che un errore\n"
"    di comando causerebbe l'uscita della shell quando è abilitata l'opzione -e.\n"
"    \n"
"    Se non vengono forniti argomenti, trap stampa l'elenco di comandi\n"
"    associati a ciascun segnale catturato, in un formato che può essere\n"
"    riutilizzato come input di shell per ricreare le stesse impostazioni\n"
"    sulla cattura dei segnali.\n"
"    \n"
"    Ozioni:\n"
"      -l\tstampa un elenco di nomi di segnale e i loro corrispondenti numeri\n"
"      -p\tvisualizza i comandi trap associati a ciascun SPEC_SEGNALE in un\n"
"    \t\tformato che può essere riutilizzato come input di shell; oppure per\n"
"    \t\ttutti i signali catturati, se non vengono passati argomenti\n"
"      -P\tmostra i comandi trap associati a ciascun SPEC_SEGNALE. Deve essere\n"
"     \t\tfornito almeno un SPEC_SEGNALE. -P e -p non possono essere usate\n"
"    \t\tinsieme.\n"
"    \n"
"    \n"
"    Ciascun SPEC_SEGNALE è un nome di segnale in <signal.h> oppure un numero\n"
"    di segnale.\n"
"    I nomi di segnale sono case insensitive e il prefisso SIG è opzionale.\n"
"    Per inviare un segnale alla shell usare \"kill -signal $$\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che SPEC_SEGNALE non sia valido o si fornisca\n"
"    una opzione non valida."

#: builtins.c:1441
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not found."
msgstr ""
"Visualizza informazioni sul tipo di comando.\n"
"    \n"
"    Per ciascun NOME, indica come sarebbe interpretato se fosse usato come\n"
"    un nome di comando.\n"
"    \n"
"    Opzioni:\n"
"      -a\tvisualizza tutte le posizioni contenenti un eseguibile chiamato NOME,\n"
"    \t\tincludendo alias, comandi interni e funzioni se e solo se\n"
"    \t\tnon viene usata anche l'opzione \"-p\"\n"
"      -f\tnon esegue la ricerca delle funzioni di shell\n"
"      -P\tforza una ricerca del PERCORSO per ciascun NOME anche se è un alias,\n"
"    \t\tun comando interno o una funzione, e restituisce il nome del file su disco\n"
"    \t\tche sarebbe eseguito\n"
"      -p\trestituisce o il nome del file su disco che sarebbe eseguito,\n"
"    \t\toppure niente se \"type -t NOME\" non restituisce \"file\".\n"
"      -t\tvisualizza una singola parola che è una tra \"alias\", \"keyword\",\n"
"    \t\t\"function\", \"builtin\", \"file\" or \"\", se il NOME è\n"
"    \t\trispettivamente un alias, una parola riservata di shell, una\n"
"    \t\tfunzione di shell, un comando interno di shell,\n"
"    \t\tun file su disco oppure non trovato\n"
"    \n"
"    Argomenti:\n"
"      NOME\tIl nome del comando da interpretare.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo se tutti i NOMI vengono trovati; insuccesso in caso\n"
"    contrario."

#: builtins.c:1472
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds;\n"
"    -p, which is in increments of 512 bytes; -R, which is in microseconds;\n"
"    -b, which is in bytes; and -e, -i, -k, -n, -q, -r, -u, -x, and -P,\n"
"    which accept unscaled values.\n"
"    \n"
"    When in posix mode, values supplied with -c and -f are in 512-byte\n"
"    increments.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Modifica i limiti delle risorse di shell.\n"
"    \n"
"    Fornisce il controllo sulle risorse disponibili per la shell e per i processi\n"
"    che crea, sui sistemi che permettono tale controllo.\n"
"    \n"
"    Opzioni:\n"
"      -S\tusa il limite di risorse \"leggero\"\n"
"      -H\tusa il limite di risorse \"pesante\"\n"
"      -a\triporta tutti i limiti correnti\n"
"      -b\tla dimensione del buffer del socket\n"
"      -c\tla dimensione massima dei file di core creati\n"
"      -d\tla dimensione massima di un segmento di dati di processo\n"
"      -e\tla priorità massima di scheduling (\"nice\")\n"
"      -f\tla dimensione massima dei file scritti dalla shell e dai suoi figli\n"
"      -i\til numero massimo di segnali pendenti\n"
"      -k\til numero massimo di k-code allocate per questo processo\n"
"      -l\tla dimensione massima di memoria che un processo può bloccare\n"
"      -m\tla dimensione massima di memoria utilizzabile (RSS)\n"
"      -n\til numero massimo di descrittori di file aperti\n"
"      -p\tla dimensione del buffer della pipe\n"
"      -q\til numero massimo di byte nelle code messaggi POSIX\n"
"      -r\tla priorità massima di scheduling in tempo reale\n"
"      -s\tla dimensione massima dello stack\n"
"      -t\tla quantità massima di tempo CPU in secondi\n"
"      -u\til numero massimo di processi utente\n"
"      -v\tla dimensione della memoria virtuale\n"
"      -x\til numero massimo di lock dei file\n"
"      -P\til numero massimo di pseudoterminali\n"
"      -R\til tempo massimo per cui un processo in tempo reale può eseguire\n"
"    \t\tprima di venire bloccato\n"
"      -T\til numero massimo di thread\n"
"    \n"
"    Non tutte le opzioni sono disponibili su tutte le piattaforme.\n"
"    \n"
"    Se viene fornito un LIMITE, questo sarà il nuovo valore della risorsa\n"
"    specificata; i valori LIMITE speciali \"soft\", \"hard\" e \"unlimited\"\n"
"    corrispondono rispettivamente al limite leggero corrente, al limite pesante\n"
"    corrente, e a nessun  limite.\n"
"    Altrimenti viene stampato il valore attuale della risorsa specificata.\n"
"    Se non viene fornita alcuna opzione, si assume -f.\n"
"    \n"
"    I valori sono ad incrementi di 1024-byte, ad eccezione di -t che è in\n"
"    secondi; -p che è ad incrementi di 512 byte; -R che è in microsecondi;\n"
"    -b che è in byte; e -e, -i, -k, -n, -q, -r, -u, -x e -P che accettano\n"
"    valori senza scala.\n"
"    \n"
"    In modalità POSIX i valori forniti a -c e -f sono ad incrementi di 512 byte.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita una opzione non valida\n"
"    o venga riscontrato un errore."

#: builtins.c:1527
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Visualizza o imposta la maschera del modo file.\n"
"    \n"
"    Imposta la maschera di creazione file dell'utente su MODO. Se MODO\n"
"    viene omesso, stampa il valore corrente della maschera.\n"
"    \n"
"    Se MODO inizia con una cifra, è interpretato con un numero ottale;\n"
"    altrimenti come una stringa di modo simbolico come quella accettata da\n"
"    chmod(1).\n"
"    \n"
"    Opzioni:\n"
"      -p\tSe MODO viene omesso, mostra in una forma che possa essere riusata\n"
"    \t\tcome input\n"
"      -S\tRende simbolico l'output; altrimenti viene mostrato un numero\n"
"    \t\tottale\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che MODO non sia valido o venga fornita una\n"
"    opzione non valida."

#: builtins.c:1547
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Attende il completamento del job e lo stato di uscita.\n"
"\n"
"    Attende ogni processo identificato da ID, che può essere un ID di processo\n"
"    oppure una specifica di job, e riporta lo stato di uscita. Se non è fornito ID,\n"
"    attende tutti i processi figli attualmente attivi, e restituisce\n"
"    stato zero. Se ID è una specifica di job, attende tutti i processi nella\n"
"    pipeline di quel job.\n"
"\n"
"    Se viene fornita l'opzione -n, attende un singolo job dalla lista degli ID,\n"
"    oppure, se nessun ID viene fornito, il prossimo job che si completi, e\n"
"    restituisce il suo stato d'uscita.\n"
"\n"
"    Se viene fornita l'opzione -p, l'identificativo del processo o job  di cui\n"
"    viene restituito lo stato d'uscita viene assegnato alla variabile VAR\n"
"    indicata dall'argomento dell'opzione. La variabile sarà inizialmente\n"
"    rimossa, prima di qualsiasi assegnazione. Questo è utile solo quando\n"
"    viene fornita l'opzione -n.\n"
"\n"
"    Se viene fornita l'opzione -f, e il controllo del job è abilitato, attende\n"
"    che l'ID specificato termini, invece di aspettare che cambi stato.\n"
"\n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo ID; fallisce se ID non è valido o se\n"
"    viene passata un'opzione non valida, o se viene passato -n e la shell\n"
"    non ha figli da attendere."

#: builtins.c:1578
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an invalid\n"
"    option is given."
msgstr ""
"Attende il completamento del processo e restituisce lo stato di uscita.\n"
"    \n"
"    Attende ogni processo specificato da un PID e riporta il suo stato di\n"
"    uscita. Se non viene fornito il PID, attende tutti i processi figlio\n"
"    correntemente attivi e lo stato restituito è zero.\n"
"    Il PID deve essere un ID di processo.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo PID; insuccesso se il PID non è valido\n"
"    o viene fornita una opzione non valida."

#: builtins.c:1593
msgid ""
"Execute PIPELINE, which can be a simple command, and negate PIPELINE's\n"
"    return status.\n"
"    \n"
"    Exit Status:\n"
"    The logical negation of PIPELINE's return status."
msgstr ""
"Esegue la PIPELINE, che può essere un semplice comando, e inverte lo stato di \n"
"    ritorno della PIPELINE.\n"
"\n"
"    Stato di uscita:\n"
"    La negazione logica dello stato di uscita della PIPELINE."

#: builtins.c:1603
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Esegue comandi per ciascun membro di un elenco.\n"
"    \n"
"    Il ciclo \"for\" esegue una sequenza di comandi per ciascun membro di\n"
"    un elenco di voci. Se \"in PAROLE ...;\" non è presente, allora viene\n"
"    assunto \"in \"$@\"\". Per ciascun elemento in PAROLE, NOME è impostato\n"
"    a quell'elemento e i COMANDI vengono eseguiti.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito."

#: builtins.c:1617
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Ciclo \"for\" aritmetico.\n"
"    \n"
"    Equivalente a\n"
"    \t(( ESPR1 ))\n"
"    \twhile (( ESPR2 )); do\n"
"    \t\tCOMANDI\n"
"    \t\t(( ESPR3 ))\n"
"    \tdone\n"
"    ESPR1, ESPR2 e ESPR3 sono espressioni aritmetiche. Se viene omessa\n"
"    qualche espressione, si comporta come se valesse 1.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito."

#: builtins.c:1635
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Seleziona le parole da un elenco ed esegue i comandi.\n"
"    \n"
"    Le PAROLE vengono estese, generando un elenco di parole. L'insieme\n"
"    di parole estese viene stampato sullo standard error, ognuna delle\n"
"    quali preceduta da un numero. Se non è presente \"in PAROLE\", viene\n"
"    assunto «in \"$@\"». Viene poi visualizzato il prompt PS3 e viene letta\n"
"    una riga dallo standard input. Se la riga è composta dal numero che\n"
"    corrisponde a una delle parole visualizzate, NOME è impostato a quella\n"
"    parola. Se la riga è vuota, le PAROLE e il prompt vengono\n"
"    rivisualizzati. Se viene letto EOF, il comando termina. Se vengono\n"
"    letti altri valori NOME viene impostato a null. La riga letta viene\n"
"    salvata nella variabile REPLY. I COMANDI vengono eseguiti dopo ogni\n"
"    selezione finché non viene eseguito un comando di interruzione.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato di uscita dell'ultimo comando eseguito."

#: builtins.c:1656
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Riporta il tempo speso nell'esecuzione della pipeline.\n"
"    \n"
"    Esegue la PIPELINE e stampa, quando termina, un sommario del tempo reale, tempo utente della CPU\n"
"    e tempo di sistema della CPU dedicato all'esecuzione della PIPELINE.\n"
"    \n"
"    Opzioni:\n"
"      -p\tstampa il riepilogo dei tempi nel formato portabile Posix\n"
"    \n"
"    Il valore della variabile TIMEFORMAT è usato come formato di output.\n"
"    \n"
"    Stato di uscita:\n"
"    Viene restituito lo stato della PIPELINE."

#: builtins.c:1673
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Esegue comandi basati sulla corrispondenza di modello.\n"
"    \n"
"    Esegue in modo selettivo COMANDI basati sulla PAROLA corrispondente al\n"
"    MODELLO. Il carattere \"|\" è usato per separare modelli multipli.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito."

#: builtins.c:1685
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of the\n"
"    entire construct is the exit status of the last command executed, or zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Esegue comandi basati su condizioni.\n"
"    \n"
"    Viene eseguito l'elenco degli \"if COMANDI\". Se lo stato di uscita è\n"
"    zero viene eseguito l'elenco \"then COMANDI\", altrimenti viene eseguito\n"
"    l'elenco degli \"elif COMANDI\" e, se il loro stato è zero, viene\n"
"    eseguito l'elenco dei \"then COMANDI\" corrispondente e viene completato\n"
"    l'\"if COMANDO\". Altrimenti, viene eseguito l'elenco \"else COMANDI\",\n"
"    se presente. Lo stato di uscita dell'intero costrutto corrisponde a\n"
"    quello dell'ultimo comando eseguito, o zero se nessuna condizione provata\n"
"    è vera.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito."

#: builtins.c:1702
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Esegue i comandi finché un test ha successo.\n"
"    \n"
"    Espande ed esegue i COMANDI-2 fino a quando il comando finale nei\n"
"    COMANDI ha uno stato di uscita pari a zero.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito."

#: builtins.c:1714
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Esegue i comandi finché un test non ha successo.\n"
"    \n"
"    Espande ed esegue i COMANDI-2 fino a quando il comando finale nei\n"
"    COMANDI ha uno stato di uscita diverso da zero.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito."

#: builtins.c:1726
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Crea un coprocesso chiamato NOME.\n"
"    \n"
"    Esegue il COMANDO in modo asincrono, con lo standard output e lo standard\n"
"    input del comando connessi attraverso una pipe ai descrittori di file\n"
"    assegnati agli indici 0 e 1 di una variabile di array NOME nella shell in\n"
"    esecuzione. Il NOME predefinito è \"COPROC\".\n"
"    \n"
"    Stato di uscita:\n"
"    Il comando coproc restituisce stato di uscita 0."

#: builtins.c:1740
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Definisce una funzione di shell.\n"
"    \n"
"    Crea una funzione di shell chiamata NOME. Quando invocato come un\n"
"    semplice comando, NOME esegue i COMANDI nel contesto della shell\n"
"    chiamante. Quando viene invocato NOME, gli argomenti sono passati alla\n"
"    funzione come $1...$n e il nome della funzione si trova in $FUNCNAME.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che il NOME non sia in sola lettura."

#: builtins.c:1754
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Raggruppa i comandi come un'unità.\n"
"    \n"
"    Esegue un insieme di comandi in un gruppo. Questo è un modo per\n"
"    reindirizzare un intero insieme di comandi.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato dell'ultimo comando eseguito."

#: builtins.c:1766
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Ripristina un job in primo piano.\n"
"    \n"
"    Equivale all'argomento SPEC_JOB per il comando \"fg\". Ripristina\n"
"    un job fermato o sullo sfondo. SPEC_JOB può specificare un nome\n"
"    job o un numero di job. SPEC_JOB seguito da \"&\" mette il job\n"
"    sullo sfondo, come se la specifica del job fosse stata fornita\n"
"    come argomento per \"bg\".\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce lo stato del job ripristinato."

#: builtins.c:1781
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Valuta espressioni aritmetiche.\n"
"    \n"
"    L'ESPRESSIONE è valutata seguendo le regole di valutazione\n"
"    aritmetica. Equivalente a «let \"ESPRESSIONE\"».\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce 1 se ESPRESSIONE è valutata 0, altrimenti restituisce 0."

#: builtins.c:1793
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries used\n"
"    by the `test' builtin, and may be combined using the following operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Esegue comandi condizionali.\n"
"    \n"
"    Restituisce uno stato di 0 o 1 a seconda della valutazione     dell'espressione condizionale ESPRESSIONE. Le espressioni sono composte\n"
"    dalle stesse basilari usate dal comando interno \"test\", e possono \n"
"    essere combinate usando i seguenti operatori:\n"
"    \n"
"      ( ESPRESSIONE )\tRestituisce il valore dell'ESPRESSIONE\n"
"      ! ESPRESSIONE\t\tVero se l'ESPRESSIONE è falsa; falso in caso contrario\n"
"      ESPR1 && ESPR2\tVero se sia ESPR1 che ESPR2 sono vere; falso in caso contrario\n"
"      ESPR1 || ESPR2\tVero se una tra ESPR1 ed ESPR2 è vera; falso in caso contrario\n"
"    \n"
"    Quando vengono usati gli operatori \"==\" e \"!=\", la stringa a destra dell'operatore\n"
"    è usata come un modello e ne viene effettuata la corrispondenza.\n"
"    Quando viene usato l'operatore \"=~\", la stringa a destra dell'operatore è valutata\n"
"    corrispondente a un'espressione regolare.\n"
"    \n"
"    Gli operatori && e || non valutano ESPR2 se ESPR1 è sufficiente a\n"
"    determinare il valore dell'espressione.\n"
"    \n"
"    Stato di uscita:\n"
"    0 o 1 a seconda del valore dell'ESPRESSIONE."

#: builtins.c:1819
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Nomi e usi comuni delle variabili di shell.\n"
"    \n"
"    BASH_VERSION\tInformazioni sulla versione di Bash.\n"
"    CDPATH\tUn elenco di directory da cercare separate da un due punti\n"
"    \tfornite come argomenti per \"cd\".\n"
"    GLOBIGNORE\tUn elenco di modelli separato da un due punti che descrivono\n"
"    \t\ti nomi di file che devono essere ignorati dall'espansione di percorso.\n"
"    HISTFILE\tIl nome del file in cui è memorizzata la cronologia dei comandi.\n"
"    HISTFILESIZE\tIl numero massimo di righe che può contenere questo file.\n"
"    HISTSIZE\tIl numero massimo di righe di cronologia a cui può accedere\n"
"    \t\tuna shell in esecuzione.\n"
"    HOME\tIl nome completo del percorso della propria directory di login.\n"
"    HOSTNAME\tIl nome dell'host corrente.\n"
"    HOSTTYPE\tIl tipo di CPU sulla quale è in esecuzione questa versione di\n"
"    \t\tbash.\n"
"    IGNOREEOF\tControlla il comportamento della shell quando riceve un\n"
"    \t\tcarattere EOF come unico input. Se impostato, il suo valore\n"
"    \t\tcorrisponde al numero di caratteri EOF che si possono trovare in una\n"
"    \t\tfila in una riga vuota prima che la shell esca (predefinito 10).\n"
"    \t\tQuando viene rimosso, EOF indica la fine dell'input.\n"
"    MACHTYPE\tUna stringa che descrive l'attuale sistema dove è in\n"
"    \t\tesecuzione bash.\n"
"    MAILCHECK\tQuanto spesso, in secondi, Bash controlla la presenza di\n"
"    \t\tnuova posta.\n"
"    MAILPATH\tUn elenco di nomi di file separati da un due punti usati da\n"
"    \t\tBash per controllare la presenza di nuova posta.\n"
"    OSTYPE\tLa versione di Unix sulla quale è in esecuzione questa versione\n"
"    \t\tdi bash.\n"
"    PATH\tUn elenco di directory, separato da un due punti, da analizzare\n"
"    \t\tquando si cercano i comandi.\n"
"    PROMPT_COMMAND\tUn comando da eseguire prima della stampa di ciascun prompt\n"
"    \t\tprimario.\n"
"    PS1\t\tLa stringa del prompt primario.\n"
"    PS2\t\tLa stringa del prompt secondario.\n"
"    PWD\t\tIl nome completo del percorso della directory corrente.\n"
"    SHELLOPTS\tUn elenco di opzioni di shell abilitate, separate da un due punti.\n"
"    TERM\tIl nome del tipo di terminale corrente.\n"
"    TIMEFORMAT\tIl formato di output per le statistiche temporali visualizzato\n"
"    \t\tdalla parola riservata \"time\".\n"
"    auto_resume\tNon null significa che una parola di un comando che compare\n"
"    \t\tda sola in una riga viene prima cercata nell'elenco dei job correnti\n"
"    \t\tfermati. Se trovato, questo job viene messo in primo piano.\n"
"    \t\tUn valore pari a \"exact\" significa che la parola del comando deve\n"
"    \t\tcorrispondere esattamente a un comando nell'elenco dei job fermati.\n"
"    \t\tUn valore pari a \"substring\" significa che la parola del comando\n"
"    \t\tdeve corrispondere a una sottostringa del job. Qualsiasi altro valore\n"
"    \t\tsignifica che il comando deve essere un prefisso di un lavoro fermato.\n"
"    histchars\tCaratteri che controllano l'espansione della cronologia e la\n"
"    \t\tsostituzione rapida. Il primo carattere è quello di sostituzione\n"
"    \t\tdella cronologia, solitamente \"!\". Il secondo è il carattere di\n"
"    \t\t\"sostituzione rapida\", solitamente \"^\". Il terzo è il carattere\n"
"    \t\tdi \"commento della cronologia\", solitamente \"#\".\n"
"    HISTIGNORE\tUn elenco di modelli separato da un due punti usato per\n"
"    \t\tdecidere quale comando dovrebbe essere salvato nell'elenco della\n"
"    \t\tcronologia.\n"

#: builtins.c:1876
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Aggiunge directory allo stack.\n"
"    \n"
"    Aggiunge una directory in cima allo stack delle directory o ruota lo\n"
"    stack stesso, mettendo come primo elemento la directory di lavoro\n"
"    corrente. Senza argomenti scambia le prime due directory in cima.\n"
"    \n"
"    Opzioni:\n"
"      -n\tEvita il normale cambio di directory quando vengono aggiunte\n"
"    \t\tdirectory allo stack, così da manipolare solo lo stack stesso.\n"
"    \n"
"    Argomenti:\n"
"      +N\tRuota lo stack in modo che l'N-sima directory (contando\n"
"    \t\ta partire da sinistra dell'elenco mostrato da \"dirs\", iniziando da\n"
"    \t\tzero) sia in cima.\n"
"    \n"
"      -N\tRuota lo stack in modo che l'N-sima directory (contando\n"
"    \t\ta partire da destra dell'elenco mostrato da \"dirs\", iniziando da\n"
"    \t\tzero) sia in cima.\n"
"    \n"
"      dir\tAggiunge DIR in cima allo stack delle directory, facendone la\n"
"    \t\tdirectory di lavoro corrente.\n"
"    \n"
"    Il comando interno \"dirs\" mostra lo stack delle directory.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornito un argomento valido o\n"
"    non abbia successo il cambio di directory."

#: builtins.c:1910
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Rimuove directory dallo stack.\n"
"    \n"
"    Rimuove voci dallo stack delle directory. Senza argomenti, rimuove\n"
"     la directory in cima allo stack e si sposta alla nuova prima directory.\n"
"    \n"
"    Opzioni:\n"
"      -n\tEvita il normale cambio di directory quando vengono rimosse\n"
"    \t\tdirectory dallo stack, così da manipolare solo lo stack stesso.\n"
"    \n"
"    Argomenti:\n"
"      +N\tRimuove l'N-sima voce contando a partire da sinistra dell'elenco\n"
"    \t\tmostrato da \"dirs\", iniziando da zero. Per esempio: \"popd +0\"\n"
"    \t\trimuove la prima directory, \"popd +1\" la seconda.\n"
"    \n"
"      -N\tRimuove l'N-sima voce contando a partire da destra dell'elenco\n"
"    \t\tmostrato da \"dirs\", iniziando da zero. Per esempio: \"popd -0\"\n"
"    \t\trimuove l'ultima directory, \"popd -1\" la penultima.\n"
"    \n"
"    Il comando interno \"dirs\" mostra lo stack delle directory.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornito un argomento non valido o non\n"
"    abbia successo il cambio di directory."

#: builtins.c:1940
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Visualizza lo stack delle directory.\n"
"    \n"
"    Visualizza l'elenco delle directory ricordate attualmente. Le directory\n"
"    vengono inserite nell'elenco con il comando \"pushd\"; è possibile\n"
"    andare a ritroso nell'elenco con il comando \"popd\".\n"
"    \n"
"    Opzioni:\n"
"      -c\tPulisce lo stack delle directory eliminandone tutti gli elementi\n"
"      -l\tNon stampa le directory con prefisso tilde relative alla propria\n"
"    \t\tdirectory home\n"
"      -p\tStampa lo stack delle directory una voce per riga\n"
"      -v\tStampa lo stack delle directory una voce per riga usando come\n"
"    \t\tprefisso la posizione nello stack\n"
"    \n"
"    Argomenti:\n"
"      +N\tMostra l'N-sima voce contando a partire da sinistra dell'elenco\n"
"    \t\tmostrato da dirs quando invocato senza opzioni, iniziando da zero.\n"
"    \n"
"      -N\tMostra l'N-sima voce contando a partire da destro dell'elenco\n"
"    \t\tmostrato da dirs quando invocato senza opzioni, iniziando da zero.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita un'opzione non valida o si riscontri un errore."

#: builtins.c:1971
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Imposta o rimuove le opzioni della shell.\n"
"    \n"
"    Cambia le impostazioni di ciascuna opzione di shell NOMEOPZ. Senza\n"
"    argomenti per le opzioni, elenca tutte le NOMEOPZ fornite, oppure tutte\n"
"    le opzioni di shell se nessun NOMEOPZ viene indicato, indicando per\n"
"     ciascuna se sono o non sono impostate.\n"
"    \n"
"    Opzioni:\n"
"      -o\tLimita i NOMEOPZ a quelli definiti per essere usati con\n"
"    \t\t\"set -o\"\n"
"      -p\tStampa ogni opzione di shell indicando il relativo stato\n"
"      -q\tNon stampa l'output\n"
"      -s\tAbilita (imposta) ciascun NOMEOPZ\n"
"      -u\tDisabilita (elimina) ciascun NOMEOPZ\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo se NOMEOPZ è abilitato; insuccesso se viene\n"
"    fornita una opzione non valida o NOMEOPZ è disabilitato."

#: builtins.c:1992
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: plain\n"
"    characters, which are simply copied to standard output; character escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format characters csndiouxXeEfFgGaA described\n"
"    in printf(3), printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or assignment\n"
"    error occurs."
msgstr ""
"Formatta e stampa gli ARGOMENTI come indicato dal FORMATO.\n"
"    \n"
"    Opzioni:\n"
"      -v var\tAssegna l'output alla variabile di shell VAR invece\n"
"    \t\tdi visualizzarlo sullo standard output\n"
"    \n"
"    FORMATO è una stringa di caratteri che contiene tre tipi di oggetto: caratteri\n"
"    semplici, che sono semplicemente copiati sullo standard output; sequenze di escape\n"
"    dei caratteri, che sono convertite e copiate sullo standard output;\n"
"    specifiche di formato, ognuna delle quali provoca la stampa del successivo argomento\n"
"    consecutivo.\n"
"    \n"
"    In aggiunta alle specifiche di formato standard csndiouxXeEfFgGaA\n"
"    descritte in printf(3), printf interpreta:\n"
"    \n"
"      %b\tEspande le sequenze di escape di backslash nell'argomento corrispondente\n"
"      %q\tQuota l'argomento in modo che possa essere riusato come input per la shell\n"
"      %Q\tcome %q, ma applica una precisione qualsiasi all'argomento\n"
"    \t\tnon quotato prima di quotarlo\n"
"      %(fmt)T\tVisualizza la stringa della data/ora risultante dall'uso di\n"
"    \t\tFMT come stringa di formato per strftime(3)\n"
"    \n"
"    Il formato è riutilizzato quanto necessario per consumare tutti gli\n"
"    argomenti. Se ci sono meno argomenti di quanti ne richieda il formato,\n"
"    le specifiche di formato di troppo si comportano come se venisse fornito\n"
"    un valore zero oppure una stringa null, come pertinente.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita una opzione non valida o si riscontri\n"
"    un errore di scrittura o assegnazione."

#: builtins.c:2028
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no options\n"
"    or NAMEs are supplied, display existing completion specifications in a way\n"
"    that allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Specifica come gli argomenti debbano essere completati da Readline.\n"
"    \n"
"    Per ciascun NOME, specifica come gli argomenti debbano essere completati.\n"
"    Se non vengono fornite opzioni o NOME, visualizza le specifiche di\n"
"    completamento esistenti in un modo tale che possano essere riutilizzate\n"
"    come input.\n"
"    \n"
"    Opzioni:\n"
"      -p\tvisualizza le specifiche di completamento esistenti in un formato\n"
"    \t\triutilizzabile\n"
"      -r\trimuove una specifica di completamento per ciascun NOME, oppure\n"
"    \t\ttutte se non viene fornito alcun NOME\n"
"      -D\tapplica i completamenti e le azioni come predefiniti per i comandi\n"
"    \t\tsenza alcun completamento definito specifico\n"
"      -E\tapplica i completamenti e le azioni ai comandi \"vuoti\" --\n"
"    \t\tcompletamenti tentati su una riga vuota\n"
"      -I\tapplica i completamenti e le azioni alla parola iniziale\n"
"    \t\t(solitamente il comando)\n"
"    \n"
"    Quando viene tentato un completamento, le azioni sono applicate\n"
"    nell'ordine in cui sono sopra elencate le opzioni a lettera maiuscola.\n"
"    Se vengono specificate più opzioni, l'opzione -D ha precedenza su -E,\n"
"    ed entrambe hanno precedenza su -I.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o si riscontri un errore."

#: builtins.c:2058
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is present, generate matches\n"
"    against WORD.\n"
"    \n"
"    If the -V option is supplied, store the possible completions in the indexed\n"
"    array VARNAME instead of printing them to the standard output.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Visualizza i possibili completamenti a seconda delle opzioni.\n"
"    \n"
"    È pensata per essere usata all'interno di una funzione di shell per\n"
"    generare dei possibili completamenti. Se è presente l'argomento\n"
"    opzionale PAROLA, genera le corrispondenze relative a PAROLA.\n"
"    \n"
"    Se viene fornita l'opzione -V, salva i possibili completamenti\n"
"    nell'array VARNAME invece che stamparli sullo standard output.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non sia fornita una opzione non valida o\n"
"    si riscontri un errore."

#: builtins.c:2076
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, print\n"
"    the completion options for each NAME or the current completion specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Modifica o visualizza le opzioni di completamento.\n"
"    \n"
"    Modifica le opzioni di completamento per ciascun NOME, oppure, se non\n"
"    viene fornito alcun NOME, il completamento attualmente in esecuzione.\n"
"    Con nessuna OPZIONE fornita, stampa le opzioni di completamento per\n"
"    ciascun NOME o le specifiche di completamento correnti.\n"
"    \n"
"    Opzioni:\n"
"    \t-o opzione\tImposta l'OPZIONE di completamento per ciascun NOME\n"
"    \t-D\t\tCambia le opzioni per il completamento di comando \"predefinito\"\n"
"    \t-E\t\tCambia le opzioni per il completamento di comando \"vuoto\"\n"
"    \t-I\t\tCambia le opzioni per il completamento della parola iniziale\n"
"    \n"
"    Usando \"+o\" al posto di \"-o\" disabilita l'opzione specificata.\n"
"    \n"
"    Argomenti:\n"
"    \n"
"    Ciascun NOME si riferisce a un comando per il quale deve essere stata\n"
"    precedentemente definita una specifica di completamento con il comando\n"
"    interno \"complete\". Se non viene fornito alcun NOME, compopt deve\n"
"    essere richiamato da una funzione che generi attualmente\n"
"    completamenti, e le opzioni per questo generatore di completamenti\n"
"    attualmente in esecuzione sono modificate\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita una opzione non valida\n"
"    o NOME non abbia una specifica di completamento definita."

#: builtins.c:2107
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly or\n"
"    not an indexed array."
msgstr ""
"Legge righe dallo standard input in una variabile di array indicizzato.\n"
"    \n"
"    Legge righe dallo standard input nella variabile di ARRAY indicizzato,\n"
"    oppure dal descrittore di file FD se viene fornita l'opzione -u.\n"
"    La variabile MAPFILE è l'ARRAY predefinito.\n"
"    \n"
"    Opzioni:\n"
"      -d delim\tUsa DELIM per terminare le righe, al posto di \"a capo\"\n"
"      -n numero\t\tCopia al massimo NUMERO righe. Se NUMERO è 0, vengono\n"
"    \t\tcopiate tutte\n"
"      -O origine\tInizia assegnando all'ARRAY all'indice ORIGINE. L'indice\n"
"    \t\tpredefinito è 0\n"
"      -s numero \tScarta le prime NUMERO righe lette\n"
"      -t\t\tRimuove un DELIMITATORE finale da ciascuna riga letta\n"
"      -u fd\t\tLegge le righe da un descrittore di file FD invece che dallo\n"
"    \t\tstandard input\n"
"      -C callback\tEsamina CALLBACK ogni volta che vengono lette un numero\n"
"    \t\tQUANTITÀ di righe\n"
"      -c quantità\tSpecifica il numero di righe lette tra ciascuna chiamata\n"
"    \t\ta CALLBACK\n"
"    \n"
"    Argomenti:\n"
"      ARRAY\t\tNome della variabile di array da usare per i dati dei file.\n"
"    \n"
"    Se viene fornito -C senza -c, il quanto predefinito è 5000. Quando\n"
"    viene analizzata CALLBACK, viene fornito l'indice dell'elemento di\n"
"    array successivo da assegnare e la riga da attribuire a quell'elemento\n"
"    come argomenti aggiuntivi.\n"
"    \n"
"    Se non viene fornito con una origine esplicita, il file di mappa rimuoverà\n"
"    l'ARRAY prima della relativa assegnazione.\n"
"    \n"
"    Stato di uscita:\n"
"    Restituisce successo a meno che non venga fornita una opzione non valida,\n"
"    ARRAY sia in sola lettura oppure non indicizzato."

#: builtins.c:2143
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Legge le righe da un file in una variabile di array.\n"
"    \n"
"    Sinonimo per \"mapfile\"."
