# Mensajes en español para GNU bash
# Copyright (C) 2018, 2019, 2020 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Cristian Othón Martínez Vera <cfuga@cfuga.mx>, 2000 - 2011.
# Francisco Javier Serrador <fserrador@gmail.com>
# Antonio Ceballos Roa <aceballos@gmail.com>, 2018, 2019, 2020, 2022, 2025
#
msgid ""
msgstr ""
"Project-Id-Version: GNU bash 5.3-rc2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-22 09:37-0400\n"
"PO-Revision-Date: 2025-06-03 20:06+0200\n"
"Last-Translator: Antonio Ceballos Roa <aceballos@gmail.com>\n"
"Language-Team: Spanish <es@tp.org.es>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: arrayfunc.c:63
msgid "bad array subscript"
msgstr "subíndice de matriz incorrecto"

#: arrayfunc.c:466 builtins/declare.def:748 variables.c:2196 variables.c:2225
#: variables.c:3099
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: se elimina el atributo nameref"

#: arrayfunc.c:493 builtins/declare.def:920
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: no se puede convertir la matriz indexada en asociativa"

#: arrayfunc.c:789
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: no se puede asignar a un índice que no es numérico"

#: arrayfunc.c:841
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: se debe usar un subíndice al asignar a una matriz asociativa"

#: bashhist.c:464
msgid "cannot create"
msgstr "no se puede crear"

#: bashline.c:4642
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: no se puede encontrar la combinación de teclas para la orden"

#: bashline.c:4813
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: el primer carácter que no es espacio en blanco no es «\"»"

#: bashline.c:4842
#, c-format
msgid "no closing `%c' in %s"
msgstr "no hay un `%c' que cierre en %s"

#: bashline.c:4873
#, c-format
msgid "%s: missing separator"
msgstr "%s: falta separador"

#: bashline.c:4920
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "`%s': no se puede borrar la asignación en la combinación de teclas de órdenes"

#: braces.c:340
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "expansión de llaves: no se puede asignar memoria a %s"

#: braces.c:403
#, c-format
msgid "brace expansion: failed to allocate memory for %s elements"
msgstr "expansión de llaves: fallo al asignar memoria a %s elementos"

#: braces.c:462
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "expansión de llaves: fallo al asignar memoria a «%s»"

#: builtins/alias.def:131 variables.c:1789
#, c-format
msgid "`%s': invalid alias name"
msgstr "`%s': nombre de alias inválido"

#: builtins/bind.def:123
msgid "line editing not enabled"
msgstr "no se activó la edición de línea"

#: builtins/bind.def:208
#, c-format
msgid "`%s': invalid keymap name"
msgstr "`%s': nombre de combinación de teclas inválido"

#: builtins/bind.def:277
msgid "cannot read"
msgstr "no se puede leer"

#: builtins/bind.def:353 builtins/bind.def:382
#, c-format
msgid "`%s': unknown function name"
msgstr "`%s': nombre de función desconocido"

#: builtins/bind.def:361
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s no está asignado a ninguna tecla.\n"

#: builtins/bind.def:365
#, c-format
msgid "%s can be invoked via "
msgstr "%s se puede invocar vía "

#: builtins/bind.def:401 builtins/bind.def:418
#, c-format
msgid "`%s': cannot unbind"
msgstr "`%s': no se puede borrar la asignación"

#: builtins/break.def:80 builtins/break.def:125
msgid "loop count"
msgstr "cuenta de bucle"

#: builtins/break.def:145
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "solo tiene significado en un bucle `for', `while', o `until'"

#: builtins/caller.def:135
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Devuelve el contexto de la llamada a subrutina actual.\n"
"    \n"
"    Sin EXPR, devuelve \"$linea $nombrefichero\".  Con EXPR, devuelve\n"
"    \"$linea $subrutina $nombrefichero\"; esta información adicional\n"
"    se puede usar para proporcionar un volcado de pila.\n"
"    \n"
"    El valor de EXPR indica cuántos marcos de llamada hay que retroceder\n"
"    antes del actual; el marco superior es el marco 0.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve 0 a menos que el shell no esté ejecutando una función de shell\n"
"    o EXPR sea inválida."

#: builtins/cd.def:321
msgid "HOME not set"
msgstr "HOME no está definido"

#: builtins/cd.def:329 builtins/common.c:143 builtins/fc.def:293 test.c:946
msgid "too many arguments"
msgstr "demasiados argumentos"

#: builtins/cd.def:335
msgid "null directory"
msgstr "directorio nulo"

#: builtins/cd.def:345
msgid "OLDPWD not set"
msgstr "OLDPWD no está establecido"

#: builtins/common.c:91
#, c-format
msgid "line %d: "
msgstr "línea %d: "

#: builtins/common.c:117 error.c:227
#, c-format
msgid "warning: "
msgstr "aviso: "

#: builtins/common.c:131
#, c-format
msgid "%s: usage: "
msgstr "%s: modo de empleo: "

#: builtins/common.c:178 shell.c:524 shell.c:865
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: la opción requiere un argumento"

#: builtins/common.c:184
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: se requiere un argumento numérico"

#: builtins/common.c:190
#, c-format
msgid "%s: not found"
msgstr "%s: no encontrado"

#: builtins/common.c:198 shell.c:878
#, c-format
msgid "%s: invalid option"
msgstr "%s: opción inválida"

#: builtins/common.c:204
#, c-format
msgid "%s: invalid option name"
msgstr "%s: nombre de opción inválido"

#: builtins/common.c:210 error.c:461
#, c-format
msgid "`%s': not a valid identifier"
msgstr "`%s': no es un identificador válido"

#: builtins/common.c:219
msgid "invalid octal number"
msgstr "número octal inválido"

#: builtins/common.c:221
msgid "invalid hex number"
msgstr "número hexadecimal inválido"

#: builtins/common.c:223 expr.c:1577 expr.c:1591
msgid "invalid number"
msgstr "número inválido"

#: builtins/common.c:230
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: la especificación de señal no es válida"

#: builtins/common.c:236
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "`%s': no es un pid o una especificación válida de trabajo"

#: builtins/common.c:242 error.c:455
#, c-format
msgid "%s: readonly variable"
msgstr "%s: variable de sólo lectura"

#: builtins/common.c:248
#, c-format
msgid "%s: cannot assign"
msgstr "%s: no se puede asignar"

#: builtins/common.c:255
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s fuera de rango"

#: builtins/common.c:255 builtins/common.c:257
msgid "argument"
msgstr "argumento"

#: builtins/common.c:257
#, c-format
msgid "%s out of range"
msgstr "%s fuera de rango"

#: builtins/common.c:264
#, c-format
msgid "%s: no such job"
msgstr "%s: no existe ese trabajo"

#: builtins/common.c:271
#, c-format
msgid "%s: no job control"
msgstr "%s: no hay control de trabajos"

#: builtins/common.c:273
msgid "no job control"
msgstr "no hay control de trabajos"

#: builtins/common.c:279
#, c-format
msgid "%s: invalid job specification"
msgstr "%s: especificación de trabajo inválida"

#: builtins/common.c:289
#, c-format
msgid "%s: restricted"
msgstr "%s: restringido"

#: builtins/common.c:291
msgid "restricted"
msgstr "restringido"

#: builtins/common.c:298
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: no es una orden interna de shell"

#: builtins/common.c:307
msgid "write error"
msgstr "error de escritura"

#: builtins/common.c:314
msgid "error setting terminal attributes"
msgstr "error al establecer los atributos del terminal"

#: builtins/common.c:316
msgid "error getting terminal attributes"
msgstr "error al obtener los atributos del terminal"

#: builtins/common.c:611
msgid "error retrieving current directory"
msgstr "error al obtener el directorio actual"

#: builtins/common.c:675 builtins/common.c:677
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: especificación de trabajo ambigua"

#: builtins/common.c:709
#, c-format
msgid "%s: job specification requires leading `%%'"
msgstr "%s: la especificación del trabajo requiere «%%» al inicio"

#: builtins/common.c:937
msgid "help not available in this version"
msgstr "ayuda no disponible en esta versión"

#: builtins/common.c:1005
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: no es una matriz indexada"

#: builtins/common.c:1028 builtins/set.def:964 variables.c:3868
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: no se puede borrar: %s es de solo lectura"

#: builtins/common.c:1033 builtins/set.def:930 variables.c:3873
#, c-format
msgid "%s: cannot unset"
msgstr "%s: no se puede borrar"

#: builtins/complete.def:285
#, c-format
msgid "%s: invalid action name"
msgstr "%s: nombre de acción inválido"

#: builtins/complete.def:501 builtins/complete.def:644
#: builtins/complete.def:899
#, c-format
msgid "%s: no completion specification"
msgstr "%s: no hay especificación para completado"

#: builtins/complete.def:703
msgid "warning: -F option may not work as you expect"
msgstr "aviso: es posible que la opción -F no funcione como se espera"

#: builtins/complete.def:705
msgid "warning: -C option may not work as you expect"
msgstr "aviso: es posible que la opción -C no funcione como se espera"

#: builtins/complete.def:872
msgid "not currently executing completion function"
msgstr "no se está ejecutando la función de completado"

# sólo se puede usar. sv
# De acuerdo. cfuga
#: builtins/declare.def:139
msgid "can only be used in a function"
msgstr "sólo se puede usar dentro de una función"

#: builtins/declare.def:471
msgid "cannot use `-f' to make functions"
msgstr "no se puede usar `-f' para hacer funciones"

#: builtins/declare.def:499 execute_cmd.c:6320
#, c-format
msgid "%s: readonly function"
msgstr "%s: función de sólo lectura"

#: builtins/declare.def:556 builtins/declare.def:843
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: referencia variable no puede ser una matriz"

#: builtins/declare.def:567 variables.c:3346
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s: no se permiten las autoreferencias a variables nameref"

#: builtins/declare.def:572 variables.c:2035 variables.c:3343
#, c-format
msgid "%s: circular name reference"
msgstr "%s: referencia de nombre circular"

#: builtins/declare.def:576 builtins/declare.def:850 builtins/declare.def:859
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "`%s': nombre variable inválido para referencia de nombre"

#: builtins/declare.def:908
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: no se pueden destruir variables de matriz de esta forma"

#: builtins/declare.def:914
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: no se puede convertir una matriz asociativa a indexada"

#: builtins/declare.def:943
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s: asignación obsoleta de matriz compuesta entrecomillada"

#: builtins/enable.def:149 builtins/enable.def:157
msgid "dynamic loading not available"
msgstr "la carga dinámica no está disponible"

#: builtins/enable.def:389
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "no se puede abrir el objeto compartido %s: %s"

#: builtins/enable.def:408
#, c-format
msgid "%s: builtin names may not contain slashes"
msgstr "%s: los nombres internos no pueden contener barras inclinadas"

#: builtins/enable.def:423
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "no se puede encontrar %s en el objeto compartido %s: %s"

#: builtins/enable.def:440
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: la orden interna dinámica ya está cargada"

#: builtins/enable.def:444
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "función de carga para %s devuelve fallo (%d): no se ha efectuado la carga"

#: builtins/enable.def:565
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: no cargado dinámicamente"

#: builtins/enable.def:591
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: no se puede borrar: %s"

#: builtins/evalfile.c:137 builtins/hash.def:190 execute_cmd.c:6140
#, c-format
msgid "%s: is a directory"
msgstr "%s: es un directorio"

#: builtins/evalfile.c:143
#, c-format
msgid "%s: not a regular file"
msgstr "%s: no es un fichero regular"

#: builtins/evalfile.c:152
#, c-format
msgid "%s: file is too large"
msgstr "%s: el fichero es demasiado grande"

# file=fichero. archive=archivo. Si no, es imposible traducir tar. sv
# De acuerdo. Corregido en todo el fichero. cfuga
#: builtins/evalfile.c:189 builtins/evalfile.c:207 execute_cmd.c:6222
#: shell.c:1687
msgid "cannot execute binary file"
msgstr "no se puede ejecutar el fichero binario"

#: builtins/evalstring.c:478
#, c-format
msgid "%s: ignoring function definition attempt"
msgstr "%s: se ignora el intento de definición de la función"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:249
msgid "cannot execute"
msgstr "no se puede ejecutar"

#: builtins/exit.def:61
#, c-format
msgid "logout\n"
msgstr "cerrar sesión\n"

#: builtins/exit.def:85
msgid "not login shell: use `exit'"
msgstr "no es un shell de inicio de sesión: utilice `exit'"

#: builtins/exit.def:116
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Hay trabajos detenidos.\n"

#: builtins/exit.def:118
#, c-format
msgid "There are running jobs.\n"
msgstr "Hay trabajos en ejecución.\n"

#: builtins/fc.def:284 builtins/fc.def:391 builtins/fc.def:435
msgid "no command found"
msgstr "no se ha encontrado ninguna orden"

#: builtins/fc.def:381 builtins/fc.def:386 builtins/fc.def:425
#: builtins/fc.def:430
msgid "history specification"
msgstr "especificación de historia"

#: builtins/fc.def:462
msgid "cannot open temp file"
msgstr "no se puede abrir el fichero temporal"

#: builtins/fg_bg.def:150 builtins/jobs.def:293
msgid "current"
msgstr "actual"

#: builtins/fg_bg.def:159
#, c-format
msgid "job %d started without job control"
msgstr "trabajo %d iniciado sin control de trabajo"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opción ilegal -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: la opción requiere un argumento -- %c\n"

#: builtins/hash.def:88
msgid "hashing disabled"
msgstr "asociación desactivada"

#: builtins/hash.def:144
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: tabla de asociación vacía\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "coinc\torden\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Órdenes de shell que coinciden con la palabra clave`"
msgstr[1] "Órdenes de shell que coinciden con las palabras claves`"

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"'\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid "no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr "no hay temas de ayuda que coincidan con `%s'.  Pruebe `help help' o `man -k %s' o `info %s'."

#: builtins/help.def:214
msgid "cannot open"
msgstr "no se puede abrir"

#: builtins/help.def:264 builtins/help.def:306 builtins/history.def:306
#: builtins/history.def:325 builtins/read.def:909
msgid "read error"
msgstr "error de lectura"

#: builtins/help.def:517
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Estas órdenes de shell están definidas internamente.  Teclee `help' para\n"
"ver esta lista.\n"
"Teclee `help nombre' para saber más sobre la función `nombre'.\n"
"Utilice `info bash' para saber más sobre la shell en general.\n"
"Utilice `man -k' o `info' para saber más sobre las órdenes que no están en\n"
"esta lista.\n"
"\n"
"Un asterisco (*) junto a un nombre significa que la orden está desactivada.\n"
"\n"

#: builtins/history.def:164
msgid "cannot use more than one of -anrw"
msgstr "no se puede usar más de uno de -anrw"

#: builtins/history.def:197 builtins/history.def:209 builtins/history.def:220
#: builtins/history.def:245 builtins/history.def:252
msgid "history position"
msgstr "posición en la historia"

#: builtins/history.def:280
msgid "empty filename"
msgstr "nombre de fichero vacío"

#: builtins/history.def:282 subst.c:8226
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: parámetro nulo o no establecido"

#: builtins/history.def:362
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: marca de tiempo inválida"

#: builtins/history.def:470
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: falló la expansión de la historia"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "no se permiten otras opciones con `-x'"

#: builtins/kill.def:214
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: los argumentos deben ser IDs de procesos o trabajos"

#: builtins/kill.def:280
msgid "Unknown error"
msgstr "Error desconocido"

#: builtins/let.def:96 builtins/let.def:120 expr.c:647 expr.c:665
msgid "expression expected"
msgstr "se esperaba una expresión"

#: builtins/mapfile.def:249 builtins/read.def:373
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: especificación de descriptor de fichero inválida"

#: builtins/mapfile.def:257 builtins/read.def:380
msgid "invalid file descriptor"
msgstr "descriptor de fichero inválido"

#: builtins/mapfile.def:266 builtins/mapfile.def:304
#, c-format
msgid "%s: invalid line count"
msgstr "%s: cuenta de líneas inválida"

#: builtins/mapfile.def:277
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: origen de matriz inválido"

#: builtins/mapfile.def:294
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: quantum de llamada inválido"

#: builtins/mapfile.def:327
msgid "empty array variable name"
msgstr "nombre de variable matriz vacío"

#: builtins/mapfile.def:347
msgid "array variable support required"
msgstr "se requiere el soporte de variable de matriz"

#: builtins/printf.def:483
#, c-format
msgid "`%s': missing format character"
msgstr "`%s': falta el carácter de formato"

#: builtins/printf.def:609
#, c-format
msgid "`%c': invalid time format specification"
msgstr "`%c': especificación de formato de tiempo inválida"

#: builtins/printf.def:711
msgid "string length"
msgstr "longitud de cadena"

#: builtins/printf.def:811
#, c-format
msgid "`%c': invalid format character"
msgstr "`%c': carácter de formato inválido"

#: builtins/printf.def:928
#, c-format
msgid "format parsing problem: %s"
msgstr "problema con el análisis del formato: %s"

#: builtins/printf.def:1113
msgid "missing hex digit for \\x"
msgstr "falta el dígito hexadecimal para \\x"

#: builtins/printf.def:1128
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "falta el dígito unicode para \\%c"

#: builtins/pushd.def:198
msgid "no other directory"
msgstr "no hay otro directorio"

#: builtins/pushd.def:358 builtins/pushd.def:383
#, c-format
msgid "%s: invalid argument"
msgstr "%s: argumento inválido"

#: builtins/pushd.def:501
msgid "<no current directory>"
msgstr "<no hay directorio actual>"

#: builtins/pushd.def:543
msgid "directory stack empty"
msgstr "la pila de directorios está vacía"

#: builtins/pushd.def:545
msgid "directory stack index"
msgstr "índice de pilas de directorios"

#: builtins/pushd.def:708
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Muestra la lista de directorios actualmente grabados.  Los directorios\n"
"    encuentran en la lista con la orden `pushd'; pueden ir saliendo de\n"
"    la lista con la orden `popd'.\n"
"    \n"
"    Opciones:\n"
"      -c\tlimpia la pila de directorios eliminando todos los elementos\n"
"      -l\tno muestra las versiones con prefijo de tilde de los directorios\n"
"    \t\trelativos a su directorio inicial\n"
"      -p\tmuestra la pila de directorios con una entrada por línea\n"
"      -v\tmuestra la pila de directorios con una entrada por línea con\n"
"    \tsu posición en la pila como prefijo\n"
"    \n"
"    Argumentos:\n"
"      +N\tMuestra la N-ésima entrada contando desde la izquierda de la lista\n"
"    \tmostrada por dirs cuando se llama sin opciones, empezando en cero.\n"
"    \n"
"      -N\tMuestra la N-ésima entrada contando desde la derecha de la lista\n"
"    \tmostrada por dirs cuando se llama sin opciones, empezando en cero."

#: builtins/pushd.def:730
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Agrega un directorio a la parte superior de la pila de directorios\n"
"    o rota la pila, haciendo que la nueva parte superior de la pila\n"
"    sea el directorio de trabajo actual.  Sin argumentos, intercambia\n"
"    los dos directorios de la parte superior.\n"
"    \n"
"    Opciones:\n"
"      -n\tSuprime el cambio normal de directorio al añadir directorios\n"
"    \ta la pila, de forma que solo se manipula la pila.\n"
"    \n"
"    Argumentos:\n"
"      +N\tRota la pila para que el N-ésimo directorio (contando\n"
"    \tdesde la izquierda de la lista mostrada por `dirs',\n"
"    \tcomenzando desde cero) esté en la parte superior.\n"
"      -N\tRota la pila para que el N-ésimo directorio (contando\n"
"    \tdesde la derecha de la lista mostrada por `dirs',\n"
"    \tcomenzando desde cero) esté en la parte superior.\n"
"    \n"
"      dir\tAñade DIR a la pila de directorios en la parte superior,\n"
"    \thaciéndolo el nuevo directorio de trabajo actual.\n"
"    \n"
"    La orden interna `dirs' muestra la pila de directorios."

#: builtins/pushd.def:755
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Quita entradas de la pila de directorios.  Sin argumentos, borra\n"
"    el directorio superior de la pila, y cambia al nuevo directorio superior.\n"
"    \n"
"    Opciones:\n"
"      -n\tSuprime el cambio normal de directorio cuando se borran\n"
"    \tdirectorios de la pila, de modo que solo se manipula la pila.\n"
"    \n"
"    Argumentos:\n"
"      +N\tBorra la N-ésima entrada contando desde la izquierda de\n"
"    \tla lista mostrada por `dirs', comenzando desde cero.\n"
"    \tPor ejemplo: `popd +0' borra el primer directorio, `popd +1'\n"
"    \tel segundo.\n"
"    \n"
"      -N\tBorra la N-ésima entrada contando desde la derecha de\n"
"    \tla lista mostrada por `dirs', comenzando desde cero. Por\n"
"    \tejemplo: `popd -0' borra el último directorio, `popd -1' el\n"
"    \tpenúltimo.\n"
"    \n"
"    La orden interna `dirs' muestra la pila de directorios."

#: builtins/read.def:346
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: especificación del tiempo de expiración inválida"

#: builtins/return.def:73
msgid "can only `return' from a function or sourced script"
msgstr "sólo se puede usar `return' desde una función o un script leído con `source'"

#: builtins/set.def:863
msgid "cannot simultaneously unset a function and a variable"
msgstr "no se puede borrar al mismo tiempo una función y una variable"

#: builtins/set.def:981
#, c-format
msgid "%s: not an array variable"
msgstr "%s: no es una variable de matriz"

#: builtins/setattr.def:187
#, c-format
msgid "%s: not a function"
msgstr "%s: no es una función"

#: builtins/setattr.def:192
#, c-format
msgid "%s: cannot export"
msgstr "%s: no se puede exportar"

#: builtins/shift.def:74 builtins/shift.def:86
msgid "shift count"
msgstr "contador de desplazamiento"

#: builtins/shopt.def:332
msgid "cannot set and unset shell options simultaneously"
msgstr "no se pueden activar y desactivar opciones del shell simultáneamente"

#: builtins/shopt.def:457
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: nombre de opción de shell inválido"

#: builtins/source.def:143
msgid "filename argument required"
msgstr "argumento de nombre de fichero requerido"

#: builtins/source.def:179
#, c-format
msgid "%s: file not found"
msgstr "%s: no se encontró el fichero"

#: builtins/suspend.def:105
msgid "cannot suspend"
msgstr "no se puede suspender"

#: builtins/suspend.def:111
msgid "cannot suspend a login shell"
msgstr "no se puede suspender un shell de entrada"

# Singular em+
# Puede faltar más de un ] cfuga
# Cierto, pero al menos uno seguro que falta.
# Yo creo que no hace falta el (n). sv
# Abreviando "falta [al menos] un `]'" saldría: "falta un `]'".
# ¿No es mejor "falta algún `]'"? cfuga
# Tiene razón Enrique: singular. cfuga
#: builtins/test.def:146 test.c:926
msgid "missing `]'"
msgstr "falta un `]'"

#: builtins/type.def:231
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s es un alias de `%s'\n"

#: builtins/type.def:252
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s es una palabra clave del shell\n"

#: builtins/type.def:270 builtins/type.def:314
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s es una función interna de shell especial\n"

#: builtins/type.def:289
#, c-format
msgid "%s is a function\n"
msgstr "%s: es una función\n"

#: builtins/type.def:316
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s es una orden interna del shell\n"

#: builtins/type.def:338 builtins/type.def:425
#, c-format
msgid "%s is %s\n"
msgstr "%s is %s\n"

#: builtins/type.def:358
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s está asociado (%s)\n"

#: builtins/ulimit.def:403
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: límite de argumento inválido"

#: builtins/ulimit.def:429
#, c-format
msgid "`%c': bad command"
msgstr "`%c': orden incorrecta"

#: builtins/ulimit.def:465 builtins/ulimit.def:748
msgid "cannot get limit"
msgstr "no se puede obtener el límite"

#: builtins/ulimit.def:498
msgid "limit"
msgstr "límite"

#: builtins/ulimit.def:511 builtins/ulimit.def:812
msgid "cannot modify limit"
msgstr "no se puede modificar el límite"

#: builtins/umask.def:114
msgid "octal number"
msgstr "número octal"

#: builtins/umask.def:256
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "`%c': operador de modo simbólico inválido"

#: builtins/umask.def:345
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "`%c': carácter de modo simbólico inválido"

#: error.c:83 error.c:311 error.c:313 error.c:315
msgid " line "
msgstr " línea "

#: error.c:151
#, c-format
msgid "last command: %s\n"
msgstr "última orden: %s\n"

#: error.c:159
#, c-format
msgid "Aborting..."
msgstr "Abortando..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:244
#, c-format
msgid "INFORM: "
msgstr "INFORME: "

#: error.c:261
#, c-format
msgid "DEBUG warning: "
msgstr "DEBUG aviso: "

#: error.c:413
msgid "unknown command error"
msgstr "error de orden desconocida"

#: error.c:414
msgid "bad command type"
msgstr "tipo de orden incorrecto"

#: error.c:415
msgid "bad connector"
msgstr "conector erróneo"

#: error.c:416
msgid "bad jump"
msgstr "salto erróneo"

#: error.c:449
#, c-format
msgid "%s: unbound variable"
msgstr "%s: variable sin asignar"

#: eval.c:260
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\aha expirado mientras esperaba alguna entrada: auto-logout\n"

#: execute_cmd.c:606
msgid "cannot redirect standard input from /dev/null"
msgstr "no se puede redirigir la entrada estándar desde /dev/null"

#: execute_cmd.c:1412
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: `%c': carácter de formato inválido"

#: execute_cmd.c:2493
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr "execute_coproc: coproc [%d:%s] aún existe"

#: execute_cmd.c:2647
msgid "pipe error"
msgstr "error de tubería"

#: execute_cmd.c:4100
#, c-format
msgid "invalid regular expression `%s': %s"
msgstr "expresión regular inválida `%s': %s"

#: execute_cmd.c:4102
#, c-format
msgid "invalid regular expression `%s'"
msgstr "expresión regular inválida `%s'"

#: execute_cmd.c:5056
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: nivel máximo de anidamiento de evaluaciones excedido (%d)"

#: execute_cmd.c:5069
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: nivel máximo de anidamiento de lecturas con `source' excedido (%d)"

#: execute_cmd.c:5198
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: nivel máximo de anidamiento de funciones excedido (%d)"

#: execute_cmd.c:5754
msgid "command not found"
msgstr "orden no encontrada"

#: execute_cmd.c:5783
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: restringido: no se puede especificar `/' en nombres de órdenes"

#: execute_cmd.c:6176
msgid "bad interpreter"
msgstr "intérprete erróneo"

# file=fichero. archive=archivo. Si no, es imposible traducir tar. sv
# De acuerdo. Corregido en todo el fichero. cfuga
#: execute_cmd.c:6185
#, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: no se puede ejecutar: no se ha encontrado el fichero requerido"

#: execute_cmd.c:6361
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "no se puede duplicar el df %d al df %d"

#: expr.c:272
msgid "expression recursion level exceeded"
msgstr "se ha excedido el nivel de recursión de la expresión"

#: expr.c:300
msgid "recursion stack underflow"
msgstr "desbordamiento de la pila de recursión"

#: expr.c:485
msgid "arithmetic syntax error in expression"
msgstr "error de sintaxis aritmética en la expresión"

#: expr.c:529
msgid "attempted assignment to non-variable"
msgstr "se intentó asignar a algo que no es una variable"

#: expr.c:538
msgid "arithmetic syntax error in variable assignment"
msgstr "error de sintaxis aritmética en asignación de variable"

#: expr.c:552 expr.c:917
msgid "division by 0"
msgstr "división por 0"

# token en bison fue traducido como terminal. ¿Lo traducimos igual aquí
# o lo dejamos como 'unidad' o 'elemento'? cfuga
#: expr.c:600
msgid "bug: bad expassign token"
msgstr "defecto: elemento de asignación de expresión erróneo"

#: expr.c:654
msgid "`:' expected for conditional expression"
msgstr "se esperaba `:' para la expresión condicional"

#: expr.c:979
msgid "exponent less than 0"
msgstr "exponente menor que 0"

#: expr.c:1040
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "se esperaba un identificador después del pre-incremento o pre-decremento"

# falta , singular em+
# mmmh, puede faltar más de un paréntesis cfuga
# tiene razón Enrique, es singular. cfuga
#: expr.c:1067
msgid "missing `)'"
msgstr "falta un `)'"

#: expr.c:1120 expr.c:1507
msgid "arithmetic syntax error: operand expected"
msgstr "error de sintaxis aritmética: se esperaba un operando"

#: expr.c:1468 expr.c:1489
msgid "--: assignment requires lvalue"
msgstr "--: la signación requiere valor-l"

#: expr.c:1470 expr.c:1491
msgid "++: assignment requires lvalue"
msgstr "++: la signación requiere valor-l"

#: expr.c:1509
msgid "arithmetic syntax error: invalid arithmetic operator"
msgstr "error de sintaxis aritmética: operador aritmético inválido"

#: expr.c:1532
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (el elemento de error es \"%s\")"

#: expr.c:1595
msgid "invalid arithmetic base"
msgstr "base aritmética inválida"

#: expr.c:1604
msgid "invalid integer constant"
msgstr "constante entera inválida"

#: expr.c:1620
msgid "value too great for base"
msgstr "valor demasiado grande para la base"

#: expr.c:1671
#, c-format
msgid "%s: expression error\n"
msgstr "%s: error de expresión\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: no se puede acceder a los directorios padre"

#: general.c:459
#, c-format
msgid "`%s': is a special builtin"
msgstr "`%s': es una orden interna especial"

#: input.c:98 subst.c:6542
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "no se puede reestablecer el modo nodelay para el df %d"

#: input.c:254
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "no se puede asignar un nuevo descriptor de fichero para la entrada de bash desde el df %d"

# buffer: espacio intermedio , alojamiento intermedio ( me gusta menos )
# em+
# almacenamiento intermedio. cfuga
#: input.c:262
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: el almacenamiento intermedio ya existe para el nuevo df %d"

#: jobs.c:549
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: tubería de pgrp"

#: jobs.c:910
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_delete: BUCLE: psi (%d) == storage[psi].bucket_next"

#: jobs.c:962
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_search: BUCLE: psi (%d) == storage[psi].bucket_next"

#: jobs.c:1380
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "el pid `forked' %d aparece en el trabajo en ejecución %d"

#: jobs.c:1496
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "borrando el trabajo detenido %d con grupo de proceso %ld"

#: jobs.c:1620
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: pid %5ld (%s) se marca como vivo aún"

# Cambiaría 'hay' por 'existe' em+
#: jobs.c:1949
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: no existe tal pid"

#: jobs.c:1963
#, c-format
msgid "Signal %d"
msgstr "Señal %d"

#: jobs.c:1974 jobs.c:2000
msgid "Done"
msgstr "Hecho"

#: jobs.c:1979 siglist.c:123
msgid "Stopped"
msgstr "Detenido"

#: jobs.c:1983
#, c-format
msgid "Stopped(%s)"
msgstr "Detenido(%s)"

#: jobs.c:1987
msgid "Running"
msgstr "Ejecutando"

#: jobs.c:2004
#, c-format
msgid "Done(%d)"
msgstr "Hecho(%d)"

#: jobs.c:2006
#, c-format
msgid "Exit %d"
msgstr "Salida %d"

#: jobs.c:2009
msgid "Unknown status"
msgstr "Estado desconocido"

#: jobs.c:2105
#, c-format
msgid "(core dumped) "
msgstr "(`core' generado) "

#: jobs.c:2124
#, c-format
msgid "  (wd: %s)"
msgstr "  (da: %s)"

#: jobs.c:2391
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "setpgid hijo (%ld a %ld)"

#: jobs.c:2754 nojobs.c:640
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: pid %ld no es un proceso hijo de este shell"

#: jobs.c:3052
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: No hay un registro del proceso %ld"

#: jobs.c:3410
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: el trabajo %d está detenido"

#: jobs.c:3838
#, c-format
msgid "%s: no current jobs"
msgstr "%s: no hay trabajos actuales"

#: jobs.c:3845
#, c-format
msgid "%s: job has terminated"
msgstr "%s: el trabajo ha terminado"

#: jobs.c:3854
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: el trabajo %d ya está en segundo plano"

#: jobs.c:4092
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld: se activa WNOHANG para evitar el bloque indefinido"

#: jobs.c:4641
#, c-format
msgid "%s: line %d: "
msgstr "%s: línea %d: "

#: jobs.c:4657 nojobs.c:895
#, c-format
msgid " (core dumped)"
msgstr " (`core' generado)"

#: jobs.c:4677 jobs.c:4697
#, c-format
msgid "(wd now: %s)\n"
msgstr "(dir ahora: %s)\n"

#: jobs.c:4741
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: falló getpgrp"

#: jobs.c:4797
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: no hay control de trabajos en segundo plano"

#: jobs.c:4813
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: disciplina de línea"

#: jobs.c:4823
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:4844 jobs.c:4853
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "no se puede establecer el grupo de proceso de terminal (%d)"

#: jobs.c:4858
msgid "no job control in this shell"
msgstr "no hay control de trabajos en este shell"

#: lib/malloc/malloc.c:364
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: falló la aserción: %s\n"

#: lib/malloc/malloc.c:375
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: aserción arruinada\r\n"

#: lib/malloc/malloc.c:376 lib/malloc/malloc.c:925
msgid "unknown"
msgstr "desconocido"

#: lib/malloc/malloc.c:876
msgid "malloc: block on free list clobbered"
msgstr "malloc: bloque en la lista libre sobreescrito"

#: lib/malloc/malloc.c:961
msgid "free: called with already freed block argument"
msgstr "free: se llamó con un argumento de bloque previamente liberado"

#: lib/malloc/malloc.c:964
msgid "free: called with unallocated block argument"
msgstr "free: se llamó con un argumento de bloque sin asignar"

#: lib/malloc/malloc.c:982
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: se detectó un desbordamiento por debajo; mh_nbytes fuera de rango"

#: lib/malloc/malloc.c:988
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: se detectó un desbordamiento por debajo; magic8 corrupto"

#: lib/malloc/malloc.c:995
msgid "free: start and end chunk sizes differ"
msgstr "free: los tamaños de los fragmentos del inicio y del final son diferentes"

#: lib/malloc/malloc.c:1155
msgid "realloc: called with unallocated block argument"
msgstr "realloc: se llamó con un argumento de bloque sin asignar"

#: lib/malloc/malloc.c:1170
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: se detectó un desbordamiento por debajo; mh_nbytes fuera de rango"

#: lib/malloc/malloc.c:1176
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: se detectó un desbordamiento por debajo; magic8 corrupto"

#: lib/malloc/malloc.c:1184
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: los tamaños de los pedazos de inicio y fin son diferentes"

#: lib/malloc/table.c:179
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: ¿la tabla alloc está llena con FIND_ALLOC?\n"

#: lib/malloc/table.c:188
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: ¿%p ya está en la tabla como asignado?\n"

#: lib/malloc/table.c:237
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: ¿%p ya está en la tabla como libre?\n"

#: lib/sh/fmtulong.c:90
msgid "invalid base"
msgstr "base inválida"

#: lib/sh/netopen.c:161
#, c-format
msgid "%s: host unknown"
msgstr "%s: anfitrión desconocido"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: invalid service"
msgstr "%s: servicio inválido"

#: lib/sh/netopen.c:294
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: especificación de ruta de red errónea"

#: lib/sh/netopen.c:332
msgid "network operations not supported"
msgstr "no hay soporte para operaciones de red"

#: locale.c:226 locale.c:228 locale.c:301 locale.c:303
msgid "cannot change locale"
msgstr "no se puede cambiar el local"

#: mailcheck.c:435
msgid "You have mail in $_"
msgstr "Tiene correo en $_"

#: mailcheck.c:460
msgid "You have new mail in $_"
msgstr "Tiene correo nuevo en $_"

#: mailcheck.c:476
#, c-format
msgid "The mail in %s has been read\n"
msgstr "El correo en %s fue leído\n"

#: make_cmd.c:286
msgid "syntax error: arithmetic expression required"
msgstr "error de sintaxis: se requiere una expresión aritmética"

#: make_cmd.c:288
msgid "syntax error: `;' unexpected"
msgstr "error de sintaxis: `;' inesperado"

#: make_cmd.c:289
#, c-format
msgid "syntax error: `((%s))'"
msgstr "error de sintaxis: `((%s))'"

#: make_cmd.c:523
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: tipo de instrucción %d erróneo"

#: make_cmd.c:627
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "el documento-aquí en la línea %d está delimitado por fin-de-fichero (se esperaba `%s')"

#: make_cmd.c:722
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: la instrucción de redirección `%d' está fuera de rango"

#: parse.y:2572
#, c-format
msgid "shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line truncated"
msgstr "shell_getc: shell_input_line_size (%zu) excede TAMAÑO_MAX (%lu): línea truncada"

#: parse.y:2864
msgid "script file read error"
msgstr "error de lectura del fichero script"

#: parse.y:3101
msgid "maximum here-document count exceeded"
msgstr "número máximo de documentos en «here--document» excedido"

#: parse.y:3901 parse.y:4799 parse.y:6859
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "EOF inesperado mientras se buscaba un `%c' coincidente"

#: parse.y:5006
msgid "unexpected EOF while looking for `]]'"
msgstr "EOF inesperado mientras se buscaba `]]'"

#: parse.y:5011
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "error de sintaxis en la expresión condicional: elemento inesperado `%s'"

#: parse.y:5015
msgid "syntax error in conditional expression"
msgstr "error de sintaxis en la expresión condicional"

#: parse.y:5093
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "elemento inesperado `%s', se esperaba `)'"

#: parse.y:5097
msgid "expected `)'"
msgstr "se esperaba `)'"

#: parse.y:5127
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "argumento inesperado `%s' para el operador unario condicional"

#: parse.y:5131
msgid "unexpected argument to conditional unary operator"
msgstr "argumento inesperado para el operador unario condicional"

#: parse.y:5178
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "elemento inesperado `%s', se esperaba un operador binario condicional"

#: parse.y:5182
msgid "conditional binary operator expected"
msgstr "se esperaba un operador binario condicional"

#: parse.y:5211
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "argumento inesperado `%s' para el operador binario condicional"

#: parse.y:5215
msgid "unexpected argument to conditional binary operator"
msgstr "argumento inesperado para el operador binario condicional"

#: parse.y:5226
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "elemento inesperado `%c' en la orden condicional"

#: parse.y:5229
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "elemento inesperado `%s' en la orden condicional"

#: parse.y:5233
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "elemento inesperado %d en la orden condicional"

#: parse.y:6827
#, c-format
msgid "syntax error near unexpected token `%s' while looking for matching `%c'"
msgstr "error de sintaxis cerca del elemento inesperado «%s» mientras se buscaba la pareja de «%c»"

# Token: elemento ?
# error de sintaxis, no se esperaba el símbolo `%c' em+
# No puedo tomar tal cual la corrección. El error puede no ser
# provocado por el símbolo. Simplemente estar cerca del mismo. cfuga
# Por consistencia con el siguiente, yo borraría la coma. sv
# Cierto. Coma borrada. cfuga
#: parse.y:6829
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "error de sintaxis cerca del elemento inesperado `%s'"

#: parse.y:6848
#, c-format
msgid "syntax error near `%s'"
msgstr "error de sintaxis cerca de `%s'"

# Propongo cambio de orden:
# no se esperaba el final de la línea em+
# Ojo, que end of file es fin de fichero, no de línea. sv
# Se hicieron ambos cambios. cfuga
#: parse.y:6867
#, c-format
msgid "syntax error: unexpected end of file from `%s' command on line %d"
msgstr "error de sintaxis: no se esperaba el final del fichero desde la orden «%s» en la línea %d"

# Propongo cambio de orden:
# no se esperaba el final de la línea em+
# Ojo, que end of file es fin de fichero, no de línea. sv
# Se hicieron ambos cambios. cfuga
#: parse.y:6869
#, c-format
msgid "syntax error: unexpected end of file from command on line %d"
msgstr "error de sintaxis: no se esperaba el final del fichero desde la orden en la línea %d"

# Propongo cambio de orden:
# no se esperaba el final de la línea em+
# Ojo, que end of file es fin de fichero, no de línea. sv
# Se hicieron ambos cambios. cfuga
#: parse.y:6873
msgid "syntax error: unexpected end of file"
msgstr "error de sintaxis: no se esperaba el final del fichero"

#: parse.y:6873
msgid "syntax error"
msgstr "error de sintaxis"

#: parse.y:6922
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Utilice \"%s\" para dejar el shell.\n"

#: parse.y:7120
msgid "unexpected EOF while looking for matching `)'"
msgstr "EOF inesperado mientras se buscaba un `)' coincidente"

#: pathexp.c:897
msgid "invalid glob sort type"
msgstr "tipo de ordenamiento global no válido"

#: pcomplete.c:1070
#, c-format
msgid "completion: function `%s' not found"
msgstr "completion: función `%s' no encontrada"

#: pcomplete.c:1654
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr "programmable_completion: %s: posible bucle de reintento"

#: pcomplib.c:176
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: COMPSPEC nulo"

#: print_cmd.c:324
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: conector erróneo `%d'"

#: print_cmd.c:399
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: descriptor de fichero inválido"

#: print_cmd.c:404
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: puntero NULL a fichero"

#: print_cmd.c:408
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != numfich xtrace fp (%d)"

#: print_cmd.c:1597
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: `%c': carácter de formato inválido"

#: redir.c:146 redir.c:194
msgid "file descriptor out of range"
msgstr "descriptor de fichero fuera de rango"

#: redir.c:201
msgid "ambiguous redirect"
msgstr "redireccionamiento ambiguo"

#: redir.c:205
msgid "cannot overwrite existing file"
msgstr "no se puede sobreescribir un fichero existente"

#: redir.c:210
msgid "restricted: cannot redirect output"
msgstr "restringido: no se puede redirigir la salida"

#: redir.c:215
msgid "cannot create temp file for here-document"
msgstr "no se puede crear un fichero temporal para el documento-aquí"

#: redir.c:219
msgid "cannot assign fd to variable"
msgstr "no se puede asignar el fd a la variable"

#: redir.c:639
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "no se admite /dev/(tcp|udp)/anfitrion/puerto sin red"

#: redir.c:945 redir.c:1062 redir.c:1124 redir.c:1291
msgid "redirection error: cannot duplicate fd"
msgstr "error de redirección: no se puede duplicar el df"

#: shell.c:359
msgid "could not find /tmp, please create!"
msgstr "¡no se puede encontrar /tmp, crear por favor!"

#: shell.c:363
msgid "/tmp must be a valid directory name"
msgstr "/tmp debe ser un nombre de directorio válido"

#: shell.c:827
msgid "pretty-printing mode ignored in interactive shells"
msgstr "modo de impresión bonita desactivado en shells interactivos"

#: shell.c:969
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: opción inválida"

#: shell.c:1354
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "no se puede establecer el uid %d: uid efectivo %d"

#: shell.c:1370
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "no se puede establecer gid a %d: gid efectivo %d"

#: shell.c:1559
msgid "cannot start debugger; debugging mode disabled"
msgstr "no puede ejecutar el depurador; modo depurado desactivado"

#: shell.c:1672
#, c-format
msgid "%s: Is a directory"
msgstr "%s: es un directorio"

#: shell.c:1748 shell.c:1750
msgid "error creating buffered stream"
msgstr "error al crear flujo con búfer"

# Yo pondría "no tengo ningún nombre". sv
# Revisé el código fuente de bash. Es un mensaje de error cuando no se
# encuentra el nombre del usuario que ejecuta el shell. cfuga
#: shell.c:1899
msgid "I have no name!"
msgstr "¡No tengo nombre de usuario!"

#: shell.c:2063
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, versión %s-(%s)\n"

# En la lista spanglish se discutió mucho sobre script,
# no sé en que quedó, ni puedo decirte ahora cómo lo hemos
# traducido en otras ocasiones. Sehll script lo henmos traducido
# como guión del shell , eso es seguro ... así que puede estar
# bien así , ya lo verán otros em+
#: shell.c:2064
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Modo de empleo:\t%s [opción GNU larga] [opción] ...\n"
"\t%s [opción GNU larga] [opción] fichero de shell ...\n"

#: shell.c:2066
msgid "GNU long options:\n"
msgstr "Opciones GNU largas:\n"

#: shell.c:2070
msgid "Shell options:\n"
msgstr "Opciones del shell:\n"

#: shell.c:2071
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-irsD o -c orden o -O opción_shopt\t\t(sólo invocación)\n"

#: shell.c:2090
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s o -o opción\n"

#: shell.c:2096
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "Teclee `%s -c \"help set\"' para más información sobre las opciones del shell.\n"

#: shell.c:2097
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "Teclee `%s -c help' para más información sobre las órdenes internas del shell.\n"

#: shell.c:2098
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Utilice la orden `bashbug' para reportar defectos.\n"

#: shell.c:2100
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "página inicial bash: <http://www.gnu.org/software/bash>\n"

#: shell.c:2101
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Ayuda general utilizando software GNU: <http://www.gnu.org/gethelp/>\n"

#: sig.c:809
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: operación inválida"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Señal ambigua"

#: siglist.c:51
msgid "Hangup"
msgstr "Colgar"

#: siglist.c:55
msgid "Interrupt"
msgstr "Interrumpir"

#: siglist.c:59
msgid "Quit"
msgstr "Salir"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Instrucción ilegal"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "BPT rastreo/captura"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "instrucción ABORT"

#: siglist.c:79
msgid "EMT instruction"
msgstr "instrucción EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Excepción de coma flotante"

#: siglist.c:87
msgid "Killed"
msgstr "Matado"

#: siglist.c:91
msgid "Bus error"
msgstr "Error del bus"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Violación de segmento"

# llamada del sistema em+
# Es una llamada a una función del sistema em+
# De acuerdo, pero lo que está mal es la forma de invocar la
# llamada a la función del sistema, no la llamada en sí cfuga
#: siglist.c:99
msgid "Bad system call"
msgstr "Llamada al sistema errónea"

# (pipe) no, por favor. Esto ya está traducido en libc, así que a estas
# alturas, la gente ya debería saber qué es eso de la tubería. sv
# De acuerdo. cfuga
#: siglist.c:103
msgid "Broken pipe"
msgstr "Tubería rota"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Temporizador"

#: siglist.c:111
msgid "Terminated"
msgstr "Terminado"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Condición de E/S urgente"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Detenido (señal)"

#: siglist.c:127
msgid "Continue"
msgstr "Continúa"

#: siglist.c:135
msgid "Child death or stop"
msgstr "El proceso hijo ha muerto o está parado"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Detenido (entrada por terminal)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Detenido (salida por terminal)"

#: siglist.c:147
msgid "I/O ready"
msgstr "E/S listas"

#: siglist.c:151
msgid "CPU limit"
msgstr "Límite de CPU"

#: siglist.c:155
msgid "File limit"
msgstr "Límite de ficheros"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Alarma (virtual)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Alarma (entorno)"

#: siglist.c:167
msgid "Window changed"
msgstr "Ventana cambiada"

#: siglist.c:171
msgid "Record lock"
msgstr "Bloqueo de registro"

#: siglist.c:175
msgid "User signal 1"
msgstr "Señal de usuario 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Señal de usuario 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "entrada de datos HFT pendiente"

# falla: fallo em+
# Suscribo lo anterior. falla suena muy raro.
# Yo lo pondría además al revés: fallo de energía inminente. sv
# Me gusta como lo sugieres. Cambio hecho. cfuga
#: siglist.c:187
msgid "power failure imminent"
msgstr "fallo de energía inminente"

#: siglist.c:191
msgid "system crash imminent"
msgstr "caída del sistema inminente"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "migrando el proceso a otra CPU"

#: siglist.c:199
msgid "programming error"
msgstr "error de programación"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "el modo monitor HFT ha sido concedido"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "el modo monitor HTF ha sido retirado"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "la secuencia de sonido HFT ha sido completada"

#: siglist.c:215
msgid "Information request"
msgstr "Solicitud de información"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Señal Desconocida #%d"

#: subst.c:1503 subst.c:1795 subst.c:2001
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "sustitución errónea: no hay un `%s' que cierre en %s"

#: subst.c:3601
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: no se puede asignar una lista a un miembro de la matriz"

#: subst.c:6381 subst.c:6397
msgid "cannot make pipe for process substitution"
msgstr "no se puede crear la tubería para la sustitución del proceso"

#: subst.c:6457
msgid "cannot make child for process substitution"
msgstr "no se puede crear un proceso hijo para la sustitución del proceso"

#: subst.c:6532
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "no se puede abrir la tubería llamada %s para lectura"

#: subst.c:6534
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "no se puede abrir la tubería llamada %s para escritura"

#: subst.c:6557
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "no se puede duplicar la tubería llamada %s como df %d"

#: subst.c:6723
msgid "command substitution: ignored null byte in input"
msgstr "sustitución de orden: se ignora byte nulo en la entrada"

#: subst.c:6962
msgid "function_substitute: cannot open anonymous file for output"
msgstr "function_substitute: no se puede abrir un fichero anónimo para salida"

#: subst.c:7036
msgid "function_substitute: cannot duplicate anonymous file as standard output"
msgstr "function_substitute: no se puede duplicar un fichero anónimo como salida estándar"

#: subst.c:7210 subst.c:7231
msgid "cannot make pipe for command substitution"
msgstr "no se puede crear la tubería para la sustitución de la orden"

#: subst.c:7282
msgid "cannot make child for command substitution"
msgstr "no se puede crear un proceso hijo para la sustitución de la orden"

#: subst.c:7315
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: no se puede duplicar la tubería como df 1"

#: subst.c:7813 subst.c:10989
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: nombre de variable inválido para referencia de nombre"

#: subst.c:7906 subst.c:7924 subst.c:8100
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: expansión indirecta inválida"

#: subst.c:7940 subst.c:8108
#, c-format
msgid "%s: invalid variable name"
msgstr "%s: nombre de variable inválido"

#: subst.c:8125 subst.c:10271 subst.c:10298
#, c-format
msgid "%s: bad substitution"
msgstr "%s: sustitución errónea"

#: subst.c:8224
#, c-format
msgid "%s: parameter not set"
msgstr "%s: parámetro no establecido"

#: subst.c:8480 subst.c:8495
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: expresión de subcadena < 0"

#: subst.c:10397
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: no se puede asignar de esta forma"

#: subst.c:10855
msgid "future versions of the shell will force evaluation as an arithmetic substitution"
msgstr "versiones futuras del intérprete obligarán la evaluación como una sustitución aritmética"

#: subst.c:11563
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "sustitución errónea: no hay una \"`\" que cierre en %s"

#: subst.c:12636
#, c-format
msgid "no match: %s"
msgstr "no hay coincidencia: %s"

#: test.c:156
msgid "argument expected"
msgstr "se esperaba un argumento"

#: test.c:164
#, c-format
msgid "%s: integer expected"
msgstr "%s: se esperaba un entero"

#: test.c:292
msgid "`)' expected"
msgstr "`)' esperado"

#: test.c:294
#, c-format
msgid "`)' expected, found %s"
msgstr "se esperaba `)', se encontró %s"

#: test.c:488 test.c:831
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: se esperaba un operador binario"

#: test.c:792 test.c:795
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: se esperaba un operador unario"

#: test.c:944
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "error de sintaxis: `%s' inesperado"

#: trap.c:225
msgid "invalid signal number"
msgstr "número de señal inválido"

#: trap.c:358
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "manejador de capturas: se ha excedido el nivel máximo de manejadores de capturas (%d)"

#: trap.c:455
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: valor erróneo en trap_list[%d]: %p"

#: trap.c:459
#, c-format
msgid "run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr "run_pending_traps: el manejador de señal es SIG_DFL, reenviando %d (%s) a mí mismo"

#: trap.c:592
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: señal errónea %d"

#: unwind_prot.c:246 unwind_prot.c:292
msgid "frame not found"
msgstr "no se encontró el marco"

#: variables.c:441
#, c-format
msgid "error importing function definition for `%s'"
msgstr "error al importar la definición de la función para `%s'"

#: variables.c:864
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "el nivel de shell (%d) es demasiado alto, se reestablece a 1"

#: variables.c:2191 variables.c:2220 variables.c:2278 variables.c:2297
#: variables.c:2315 variables.c:2350 variables.c:2378 variables.c:2405
#: variables.c:2431 variables.c:3274 variables.c:3282 variables.c:3797
#: variables.c:3841
#, c-format
msgid "%s: maximum nameref depth (%d) exceeded"
msgstr "%s: profundidad máxima de de referencias de nombre (%d) excedida"

#: variables.c:2641
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: no hay contexto de función en el ámbito actual"

#: variables.c:2660
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: variable quizá no es valor asignado"

#: variables.c:2831 variables.c:2884
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr "%s: no se puede heredar un valor de un tipo incompatible"

#: variables.c:3437
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: asignando entero a nombre referencia"

#: variables.c:4387
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: no hay contexto de función en el ámbito actual"

#: variables.c:4816
#, c-format
msgid "%s has null exportstr"
msgstr "%s tiene exportstr nulo"

#: variables.c:4821 variables.c:4830
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "carácter inválido %d en exportstr para %s"

#: variables.c:4836
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "no hay `=' en exportstr para %s"

#: variables.c:5354
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: la cabeza de shell_variables no es un contexto de función"

#: variables.c:5367
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: no es un contexto global_variables"

#: variables.c:5457
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: la cabeza de shell_variables no es un ámbito de entorno temporal"

#: variables.c:6448
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: no se puede abrir como FICHERO"

#: variables.c:6453
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: valor inválido para el descriptor de fichero de rastreo"

#: variables.c:6497
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: valor de compatibilidad fuera del rango"

#: version.c:50
msgid "Copyright (C) 2025 Free Software Foundation, Inc."
msgstr "Copyright (C) 2025 Free Software Foundation, Inc."

#: version.c:51
msgid "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
msgstr "Licencia GPLv3+: GPL de GNU versión 3 o posterior <http://gnu.org/licenses/gpl.html>\n"

#: version.c:90
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, versión %s (%s)\n"

#: version.c:95
msgid "This is free software; you are free to change and redistribute it."
msgstr "Esto es software libre, es libre para modificar y redistribuirlo."

#: version.c:96
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "No hay NINGUNA GARANTÍA, a la extensión permitida por la ley."

#: xmalloc.c:84
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: no se pueden asignar %lu bytes (%lu bytes asignados)"

#: xmalloc.c:86
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: no se pueden asignar %lu bytes"

#: xmalloc.c:164
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: no se pueden asignar %lu bytes (%lu bytes asignados)"

#: xmalloc.c:166
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: no se pueden asignar %lu bytes"

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [nombre[=valor] ... ]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] nombre [nombre ...]"

#: builtins.c:53
msgid "bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr "bind [-lpsvPSVX] [-m comb_teclas] [-f fichero] [-q nombre] [-u nombre] [-r secteclas] [-x secteclas:orden-shell] [secteclas:función-leerlinea o orden-leerlinea]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [orden-interna-shell [arg ...]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [expresión]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]]] [-@] [dir]"
msgstr "cd [-L|[-P [-e]]] [-@] [dir]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] orden [arg ...]"

#: builtins.c:78
msgid "declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] [name ...]"
msgstr "declare [-aAfFgiIlnrtux] [nombre[=valor] ...] o declare -p [-aAfFilnrtux] [nombre ...]"

#: builtins.c:80
msgid "typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] [name ...]"
msgstr "typeset [-aAfFgiIlnrtux] nombre[=valor] ... o typeset -p [-aAfFilnrtux] [nombre ...]"

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [opción] nombre[=valor] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [arg ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [arg ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f fichero] [nombre ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [arg ...]"

#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts cadena_opciones nombre [arg ...]"

#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a nombre] [orden [argumento ...]] [redirección ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e nombre_e] [-lnr] [primero] [último] o fc -s [pat=rep] [orden]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [id_trabajo]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [id_trabajo ...]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p ruta] [-dt] [nombre ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [patrón ...]"

#: builtins.c:123
msgid "history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]"
msgstr "history [-c] [-d despl] [n] o history -anrw [fichero] o history -ps arg [arg...]"

# jobspec no es sólo el pid del proceso, puede ser tambien
# el nombre de la orden que se creo con el proceso em+
# por eso es idtrabajo, no pidtrabajo. De cualquier forma, no me agrada
# mucho. ¿Sugerencias? cfuga
#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [idtrabajo ...] o jobs -x orden [args]"

# lo mismo em+
#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [idtrabajo ... | pid ...]"

#: builtins.c:134
msgid "kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]"
msgstr "kill [-s id_señal | -n num_señal | -id_señal] pid | idtrabajo ... o kill -l [id_señal]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let arg [arg ...]"

#: builtins.c:138
msgid "read [-Eers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]"
msgstr "read [-Eers] [-a matriz] [-d delim] [-i texto] [-n ncars] [-N ncars] [-p prompt] [-t tiempo] [-u df] [nombre ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCEHPT] [-o nombre-opción] [--] [-] [arg ...]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [nombre ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p [-f]"
msgstr "export [-fn] [nombre[=valor] ...] ó export -p [-f]"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [nombre[=valor] ...] ó readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source [-p path] filename [arguments]"
msgstr "source [-p ruta] fichero [argumentos]"

#: builtins.c:154
msgid ". [-p path] filename [arguments]"
msgstr ". [-p ruta] fichero [argumentos]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [expresión]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ arg... ]"

#: builtins.c:166
msgid "trap [-Plp] [[action] signal_spec ...]"
msgstr "trap [-Plp] [[acción] id_señal ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] nombre [nombre ...]"

#: builtins.c:171
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPRT] [límite]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [modo]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p var] [id ...]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [pid ...]"

#: builtins.c:184
msgid "! PIPELINE"
msgstr "! TUBERÍA"

#: builtins.c:186
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NOMBRE [in PALABRAS ... ] ; do ÓRDENES; done"

#: builtins.c:188
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( exp1; exp2; exp3 )); do ÓRDENES; done"

#: builtins.c:190
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NOMBRE [in PALABRAS ... ;] do ÓRDENES; done"

#: builtins.c:192
msgid "time [-p] pipeline"
msgstr "time [-p] tubería"

#: builtins.c:194
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case PALABRA in [PATRÓN [| PATRÓN]...) ÓRDENES ;;]... esac"

#: builtins.c:196
msgid "if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi"
msgstr "if ÓRDENES; then ÓRDENES; [ elif ÓRDENES; then ÓRDENES; ]...[ else ÓRDENES; ] fi"

#: builtins.c:198
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while ÓRDENES; do ÓRDENES-2; done"

#: builtins.c:200
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until ÓRDENES; do ÓRDENES-2; done"

#: builtins.c:202
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [NOMBRE] orden [redirecciones]"

#: builtins.c:204
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function nombre { ÓRDENES ; } o nombre () { ÓRDENES ; }"

#: builtins.c:206
msgid "{ COMMANDS ; }"
msgstr "{ ÓRDENES ; }"

#: builtins.c:208
msgid "job_spec [&]"
msgstr "id_trabajo [&]"

#: builtins.c:210
msgid "(( expression ))"
msgstr "(( expresión ))"

#: builtins.c:212
msgid "[[ expression ]]"
msgstr "[[ expresión ]]"

#: builtins.c:214
msgid "variables - Names and meanings of some shell variables"
msgstr "variables - Nombres y significados de algunas variables de shell"

#: builtins.c:217
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | dir"

#: builtins.c:221
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:225
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:228
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [nombre_opción...]"

#: builtins.c:230
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] formato [argumentos]"

#: builtins.c:233
msgid "complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]"
msgstr "complete [-abcdefgjksuv] [-pr] [-DEI] [-o opción] [-A acción] [-G patglob] [-W listapalabras] [-F función] [-C orden] [-X patfiltro] [-P prefijo] [-S sufijo] [nombre ...]"

#: builtins.c:237
msgid "compgen [-V varname] [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr "compgen [-V variable][-abcdefgjksuv] [-o opción] [-A acción] [-G patglob] [-W listapalabras] [-F función] [-C orden] [-X patfiltro] [-P prefijo] [-S sufijo] [palabra]"

#: builtins.c:241
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o opción] [-DEI] [nombre ...]"

#: builtins.c:244
msgid "mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "mapfile [-d delim] [-n cuenta] [-O origen] [-s cuenta] [-t] [-u df] [-C llamada] [-c quantum] [matriz]"

#: builtins.c:246
msgid "readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "readarray [-d delim] [-n cuenta] [-O origen] [-s cuenta] [-t] [-u df] [-C llamada] [-c quantum] [matriz]"

# Más en español sería: se define un alias por cada NOMBRE cuyo VALOR se da. sv
# Lo mismo de antes: el alias es expandido -> el alias se expande. sv
# no alias -> ningún alias. sv
# De acuerdo. cfuga
#: builtins.c:258
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has been\n"
"    defined."
msgstr ""
"Define o muestra alias.\n"
"    \n"
"    Sin argumentos `alias' muestra la lista de alias en el formato\n"
"    reutilizable `alias NOMBRE=VALOR' en la salida estándar.\n"
"    \n"
"    En caso contrario, se define un alias por cada NOMBRE cuyo VALOR se\n"
"    proporcione.  Un espacio final en VALOR causa que se revise\n"
"    la siguiente palabra para sustitución de alias cuando se expande\n"
"    el alias.\n"
"    \n"
"    Opciones:\n"
"      -p\tmuestra todos los alias definidos en un formato reutilizable\n"
"    \n"
"    Estado de Salida:\n"
"    alias devuelve verdadero a menos que se dé un NOMBRE para el cual\n"
"    no se haya definido ningún alias."

#: builtins.c:280
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Quita cada NOMBRE de la lista de alias definidos.\n"
"    \n"
"    Opciones:\n"
"      -a\tquita todas las definiciones de alias.\n"
"    \n"
"    Devuelve verdadero a menos que un NOMBRE no sea un alias existente."

# lee 'la'... em+
# Corregido. Además, es plural: lee las asignaciones... cfuga
#: builtins.c:293
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their values\n"
"      -s                 List key sequences that invoke macros and their values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    If arguments remain after option processing, the -p and -P options treat\n"
"    them as readline command names and restrict output to those names.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Establece secuencias de teclas y variables de Readline.\n"
"    \n"
"    Asigna una secuencia de teclas a una función Readline o a una macro, o\n"
"    establece una variable Readline.  La sintaxis de los argumentos que\n"
"    no son opciones es equivalente a la que se encuentra en ~/.inputrc,\n"
"    pero se debe pasar como un solo argumento:\n"
"    p.ej., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Opciones:\n"
"      -m  comb_teclas    Usa COMB_TECLAS como la combinación de teclas durante el\n"
"                         que dure esta orden.  Los nombres de combinaciones\n"
"                         de teclas aceptables son emacs, emacs-standard,\n"
"                         emacs-meta, emacs-ctlx, vi, vi-move, vi-command y\n"
"                         vi-insert.\n"
"      -l                 Lista los nombres de las funciones.\n"
"      -P                 Lista los nombres de las funciones y asignaciones.\n"
"      -p                 Lista las funciones y asignaciones de tal forma que\n"
"                         se pueda ruutilizar como entrada.\n"
"      -S                 Lista las secuencias de teclas que invocan macros\n"
"                         y sus valores.\n"
"      -s                 Lista las secuencias de teclas que invocan macros\n"
"                         y sus valores en una forma que se pueden reutilizar como\n"
"                         entrada.\n"
"      -V                 Lista los nombres de variables y valores.\n"
"      -v                 Lista los nombres de variables y valores en una\n"
"                         forma que se pueden reutilizar como entrada.\n"
"      -q nombre-función  Pregunta qué teclas invocan la función nombrada.\n"
"      -u nombre-función  Borra todas las teclas que están ligadas a\n"
"                         la función nombrada.\n"
"      -r secteclas       Borra la asignación para la SECTECLAS.\n"
"      -f fichero         Lee las asignaciones de teclas del FICHERO.\n"
"      -x secteclas:orden-shell\tCausa que se ejecute la ORDEN-SHELL cuando\n"
"    \t\t\t\tse introduce la SECTECLAS.\n"
"    \n"
"    Si quedan argumentos después de procesar las opciones, las opciones -p y\n"
"    -P los tratan como nombres de órdenes de readline y restringen la salida\n"
"    a esos nombres.\n"
"    \n"
"    Estado de Salida:\n"
"    bind devuelve 0 a menos que se presente una opción desconocida o suceda\n"
"    un error."

#: builtins.c:335
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Termina bucles for, while o until.\n"
"    \n"
"    Termina un bucle FOR, WHILE o UNTIL.  Si se especifica N, termina\n"
"    N bucles anidados.\n"
"    \n"
"    Estado de Salida:\n"
"    El estado de salida es 0 a menos que N no sea mayor o igual a 1."

#: builtins.c:347
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Reanuda bucles for, while o until\n"
"    \n"
"    Reanuda la siguiente iteración del bucle FOR, WHILE o UNTIL\n"
"    circundante.  Si se especifica N, reanuda en el N-ésimo bucle circundante.\n"
"    \n"
"    Estado de Salida:\n"
"    El estado de salida es 0 a menos que N no sea mayor o igual a 1."

#: builtins.c:359
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Ejecuta órdenes internas del shell\n"
"    \n"
"    Ejecuta la ORDEN-INTERNA-SHELL con los argumentos ARGs sin realizar la\n"
"    búsqueda interna de órdenes.  Esto es útil cuando se desea reimplementar\n"
"    una orden interna de la shell como una función de shell, pero se necesita\n"
"    ejecutar la orden interna dentro de la función.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de salida de la ORDEN-INTERNA-SHELL, o falso si la\n"
"    ORDEN-INTERNA-SHELL no es una orden interna de shell."

#: builtins.c:374
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Devuelve el contexto de la llamada a subrutina actual.\n"
"    \n"
"    Sin EXPR, devuelve \"$linea $nombrefichero\".  Con EXPR, devuelve\n"
"    \"$linea $subrutina $nombrefichero\"; esta información adicional\n"
"    se puede usar para proporcionar un volcado de pila.\n"
"    \n"
"    El valor de EXPR indica cuántos marcos de llamada hay que retroceder\n"
"    antes del actual; el marco superior es el marco 0.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve 0 a menos que el shell no esté ejecutando una función de shell\n"
"    o EXPR sea inválida."

# Slash lo venimos traduciendo por barra inclinada , y backslash
# por barra invertida em++
# Corregido en toda la traducción. cfuga
#: builtins.c:392
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of the\n"
"    HOME shell variable. If DIR is \"-\", it is converted to $OLDPWD.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n"
"    A null directory name is the same as the current directory.  If DIR begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is set,\n"
"    the word is assumed to be  a variable name.  If that variable has a value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Modifica el directorio de trabajo del shell.\n"
"    \n"
"    Modifica el directorio actual a DIR.  DIR por defecto es el valor de la\n"
"    variable de shell HOME. Si DIR es \"-\", se convierte a $OLDPWD.\n"
"    \n"
"    La variable CDPATH define la ruta de búsqueda para el directorio que\n"
"    contiene DIR.  Los nombres alternativos de directorio en CDPATH se\n"
"    separan con dos puntos (:).  Un nombre de directorio nulo es igual que\n"
"    el directorio actual.  Si DIR comienza con una barra inclinada (/),\n"
"    entonces no se usa CDPATH.\n"
"    \n"
"    Si no se encuentra el directorio, y la opción del shell `cdable_vars'\n"
"    está activa, entonces se trata la palabra como un nombre de variable.\n"
"    Si esa variable tiene un valor, se utiliza su valor para DIR.\n"
"    \n"
"    Opciones:\n"
"      -L\tfuerza a seguir los enlaces simbólicos: resuelve los enlaces\n"
"    \t\tsimbólicos en DIR después de procesar las instancias de `..'\n"
"      -P\tusa la estructura física de directorios sin seguir los enlaces\n"
"    \t\tsimbólicos: resuelve los enlaces simbólicos en DIR antes de procesar\n"
"    \t\tlas instancias de `..'\n"
"      -e\tsi se da la opción -P y el directorio actual de trabajo no se\n"
"    \t\tpuede determinar con éxito, termina con un estado diferente de cero.\n"
"    \n"
"    La acción por defecto es seguir los enlaces simbólicos, como si se\n"
"    especificara `-L'.\n"
"    `..' se procesa quitando la componente del nombre de la ruta inmediatamente\n"
"    anterior hasta una barra inclinada o el comienzo de DIR.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve 0 si se cambia el directorio, y si $PWD está definido como\n"
"    correcto cuando se emplee -P; de otra forma es diferente a cero."

#: builtins.c:430
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Muestra el nombre del directorio de trabajo actual.\n"
"    \n"
"    Opciones:\n"
"      -L\tmuestra el valor de $PWD si nombra al directorio de\n"
"    \ttrabajo actual\n"
"      -P\tmuestra el directorio físico, sin enlaces simbólicos\n"
"    \n"
"    Por defecto, `pwd' se comporta como si se especificara `-L'.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve 0 a menos que se de una opción inválida o no se pueda leer\n"
"    el directorio actual."

#: builtins.c:447
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Orden nula.\n"
"    \n"
"    Sin efecto; la orden no hace nada.\n"
"    \n"
"    Estado de Salida:\n"
"    Siempre correcto."

#: builtins.c:458
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Devuelve un resultado correcto.\n"
"    \n"
"    Estado de Salida:\n"
"    Siempre correcto."

#: builtins.c:467
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Devuelve un resultado incorrecto.\n"
"    \n"
"    Estado de Salida:\n"
"    Siempre incorrecto."

#: builtins.c:476
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a single word indicating the command or filename that\n"
"            invokes COMMAND\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Ejecuta una orden simple o muestra información sobre órdenes.\n"
"    \n"
"    Ejecuta la ORDEN con ARGumentos, suprimiendo la búsqueda de funciones\n"
"    de shell, o muestra información sobre las ORDENes especificadas. Se puede\n"
"    usar para invocar órdenes en disco cuando existe una función con el mismo\n"
"    nombre.\n"
"    \n"
"    Opciones:\n"
"      -p    utiliza un valor predeterminado de RUTA que garantiza que se\n"
"            encuentren todas las utilidades comunes\n"
"      -v    muestra una sola palabra que indica la orden o el fichero que\n"
"            invoca ORDEN\n"
"      -V    muestra una descripción más detallada de cada ORDEN\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de salida de la ORDEN, o fallo si no se encuentra\n"
"    la ORDEN."

#: builtins.c:496
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute, except for a,\n"
"    A, and r.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the `local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Establece valores de variable y atributos.\n"
"    \n"
"    Declara variables y les da atributos.  Si no se da ningún NOMBRE,\n"
"    muestra los atributos y valores de todas las variables.\n"
"    \n"
"    Opciones:\n"
"      -f\trestringe la acción o la información a nombres y definiciones\n"
"    \t\tde funciones\n"
"      -F\trestringe la información a nombres de funciones únicamente (con\n"
"    \t\tnúmero de línea y fichero fuente al depurar)\n"
"      -g\tcrea variables globales cuando se usa en una función de shell;\n"
"    \t\ten caso contrario, se descarta\n"
"      -I\tsi se está creando una variable local, hereda los atributos y\n"
"    \t\tel valor de una variable con igual nombre en un ámbito previo\n"
"      -p\tmuestra los atributos y el valor de cada NOMBRE\n"
"    \n"
"    Opciones que establecen atributos:\n"
"      -a\testablece NOMBREs como matrices indexadas (si se admiten)\n"
"      -A\testablece NOMBREs como matrices asociativas (si se admiten)\n"
"      -i\testablece NOMBREs con el atributo `integer'\n"
"      -l\tconvierte el valor de cada NOMBRE a minúsculas en la asignación\n"
"      -r\tcrea NOMBREs como de sólo lectura\n"
"      -t\tcrea NOMBREs con el atributo `trace'\n"
"      -u\tconvierte el valor de cada NOMBRE a mayúsculas en la asignación\n"
"      -x\tcrea NOMBREs para exportar\n"
"    \n"
"    Si se usa `+' en lugar de `-', se desactiva el atributo dado, excepto\n"
"    para a, A y r.\n"
"    \n"
"    Las variables con el atributo ‘integer’ realizan evaluación aritmética\n"
"    (vea la orden `let') cuando se asigna un valor a la variable.\n"
"    \n"
"    Cuando se usa en una función, `declare' hace locales a los NOMBREs,\n"
"    como sucede con la orden `local'.  La opción `-g' suprime esta\n"
"    conducta.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se dé una opción inválida o\n"
"    suceda un error de asignación de variable."

#: builtins.c:539
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Establece valores de variables y atributos.\n"
"    \n"
"    Sinónimo de `declare'.  Vea `help declare'."

#: builtins.c:547
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    If any NAME is \"-\", local saves the set of shell options and restores\n"
"    them when the function returns.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Define variables locales.\n"
"    \n"
"    Crea una variable local llamada NOMBRE, y le da un VALOR.  OPCIÓN puede\n"
"    ser cualquier opción aceptada por `declare'.\n"
"    \n"
"    Si algún NOMBRE es \"-\", «local» guarda el conjunto de opciones de shell\n"
"    y los restaura cuando la función retorna.\n"
"    \n"
"    Las variables locales sólo pueden usarse dentro de funciones; son\n"
"    visibles solo en la función donde se definen y sus hijos.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se dé una opción inválida, suceda\n"
"    un error de asignación, o el shell no esté ejecutando una función."

#: builtins.c:567
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Escribe argumentos en la salida estándar.\n"
"    \n"
"    Muestra los ARGumentos en la salida estándar seguidos por un carácter\n"
"    de fin de línea.\n"
"    \n"
"    Opciones:\n"
"      -n\tno agrega un carácter de fin de línea\n"
"      -e\tactiva la interpretación de los siguientes caracteres de escape de\n"
"    \t\tbarra invertida\n"
"      -E\tdesactiva explícitamente la interpretación de caracteres de\n"
"    \t\tescape de barra invertida\n"
"    \n"
"    `echo' interpreta los siguientes caracteres de escape de barra invertida:\n"
"      \\a\talerta (timbre)\n"
"      \\b\tborrado hacia atrás\n"
"      \\c\tsuprime toda salida a continuación\n"
"      \\e\tcarácter de escape\n"
"      \\E\tcarácter de escape\n"
"      \\f\talimentación de papel\n"
"      \\n\tlínea nueva\n"
"      \\r\tretorno de carro\n"
"      \\t\ttabulador horizontal\n"
"      \\v\ttabulador vertical\n"
"      \\\\\tbarra invertida\n"
"      \\0nnn\tcarácter cuyo código ASCII es NNN (octal).  NNN puede ser\n"
"    \t\tde 0 a 3 dígitos octales\n"
"      \\xHH\tel de ocho bits cuyo valor es HH (hexadecimal).  HH\n"
"    \t\tpuede ser de uno o dos dígitos hexadecimales\n"
"      \\uHHHH\tcarácter Unicode cuyo valor es el valor hexadecimal HHHH.\n"
"    \t\tHHHH puede tener de uno a cuatro dígitos hexadecimales.\n"
"      \\UHHHHHHHH carácter Unicode cuyo valor es el valor hexadecimal HHHHHHHH.\n"
"    \t\tHHHHHHHH puede tener de uno a ocho dígitos hexadecimales.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que suceda un error de escritura."

#: builtins.c:607
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Escribe argumentos en la salida estándar.\n"
"    \n"
"    Muestra los ARGumentos en la salida estándar seguidos por un carácter\n"
"    de fin de línea.\n"
"    Opciones:\n"
"      -n\tno agrega un carácter de fin de línea\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que suceda un error de escritura."

#: builtins.c:622
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    On systems with dynamic loading, the shell variable BASH_LOADABLES_PATH\n"
"    defines a search path for the directory containing FILENAMEs that do\n"
"    not contain a slash. It may include \".\" to force a search of the current\n"
"    directory.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Activa y desactiva las órdenes internas del shell.\n"
"    \n"
"    Activa y desactiva las órdenes internas del shell.  El desactivar le\n"
"    permite ejecutar una orden del disco que tenga el mismo nombre que\n"
"    la orden interna del shell, sin usar el nombre de ruta completo.\n"
"    \n"
"    Opciones:\n"
"      -a\tmuestra la lista de órdenes internas indicando si están activas o no\n"
"      -n\tdesactiva cada NOMBRE o muestra la lista de órdenes internas\n"
"    \t\tdesactivadas\n"
"      -p\tmuestra la lista de órdenes internas en una forma reusable\n"
"      -s\tmuestra solo los nombres de las órdenes internas `especiales' Posix\n"
"    \n"
"    Opciones que controlan la carga dinámica:\n"
"      -f\tCarga la función interna NOMBRE desde el objeto compartido FICHERO\n"
"      -d\tBorra una orden interna cargada con -f\n"
"    \n"
"    Sin opciones, se activa cada NOMBRE.\n"
"    \n"
"    En sistemas con carga dinámica, la variable de shell BASH_LOADABLES_PATH\n"
"    define una ruta de búsqueda para el directorio que contiene FICHEROs sin\n"
"    barra inclinada en el nombre. Puede incluir \".\" para forzar una búsqueda\n"
"    en el directoria actual.\n"
"    \n"
"    Para usar el `test' que se encuentra en $PATH en lugar de la orden interna\n"
"    del shell, ejecute `enable -n test'.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que NOMBRE no sea una orden interna del shell\n"
"    o suceda un error."

#: builtins.c:655
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Ejecuta argumentos como una orden de shell.\n"
"    \n"
"    Combina los ARGumentos en una sola cadena, usa el resultado como entrada\n"
"    para el shell, y ejecuta las órdenes resultantes.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de salida de la orden o éxito si la orden es nula."

# "a ser reconocidas" no está en español.
# Yo pondría "las letras de opción que se reconocen". sv
# en una de dos formas -> en una de las dos formas siguientes em+
# dar argumentos -> especificar em+
# De acuerdo. cfuga
#: builtins.c:667
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Decodifica argumentos de opción.\n"
"\n"
"    Getopts se usa en procedimientos del shell para decodificar parámetros\n"
"    posicionales como opciones.\n"
"    \n"
"    CADENA_OPCIONES contiene las letras de opción para reconocer; si\n"
"    una letra es seguida por dos puntos, se espera que la opción tenga\n"
"    un argumento, del cual se debe separar con espacios en blanco.\n"
"    \n"
"    Cada vez que se invoca, getopts colocará la siguiente opción en la\n"
"    variable de shell $nombre, inicializando nombre si no existe, y el\n"
"    índice del siguiente argumento a ser procesado en la variable de\n"
"    shell OPTIND.  OPTIND se inicializa a 1 cada vez que se invoca el\n"
"    shell, o un guión de shell.  Cuando una opción requiere un argumento,\n"
"    getopts coloca ese argumento en la variable de shell OPTARG.\n"
"    \n"
"    getopts reporta errores en una de las dos formas siguientes.  Si\n"
"    el primer carácter de OPTSTRING es dos puntos, getopts usa el\n"
"    aviso de errores silencioso.  En este modo, no se muestran\n"
"    mensajes de error.  Si se encuentra una opción inválida, getopts\n"
"    coloca el carácter de opción encontrado en OPTARG.  Si no se\n"
"    encuentra el argumento necesario, getopts coloca ':' en NOMBRE y\n"
"    define OPTARG con el carácter de opción encontrado.  Si getopts no\n"
"    está en modo silencioso, y se encuentra una opción inválida, getopts\n"
"    coloca '?' en NOMBRE y borra OPTARG.  Si no se encuentra un argumento\n"
"    necesario, se coloca '?' en NOMBRE, se borra OPTARG, y se muestra\n"
"    un mensaje de diagnóstico.\n"
"    \n"
"    Si la variable de shell OPTERR tiene el valor 0, getopts desactiva\n"
"    la notificación de mensajes de error, aún si el primer carácter de\n"
"    OPTSTRING no es ':'.  OPTERR tiene el valor 1 por defecto.\n"
"    \n"
"    Getopts normalmente compara los parámetros de posición, pero si se\n"
"    especifican argumentos como valores ARG, se comparan estos en lugar\n"
"    lugar de aquellos.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto si se encuentra una opción; falla si se encuentra\n"
"    el final de las opciones o sucede un error."

#: builtins.c:709
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error occurs."
msgstr ""
"Reemplaza el shell con la orden dada.\n"
"    \n"
"    Ejecuta la ORDEN, reemplazando este shell con el programa especificado.\n"
"    Los ARGUMENTOS se vuelven los argumentos de la ORDEN.  Si no se\n"
"    especifica la ORDEN, cualquier redirección toma efecto en el shell actual.\n"
"    \n"
"    Opciones:\n"
"      -a nombre\tpasa el NOMBRE como el argumento cero de la ORDEN\n"
"      -c\tejecuta la ORDEN en un entorno vacío\n"
"      -l\tcoloca un guion en el argumento cero de la ORDEN\n"
"    \n"
"    Si la orden no se puede ejecutar, termina un shell no interactivo,\n"
"    a menos que la opción de shell `execfail' esté activa.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve éxito a menos que no se encuentre la ORDEN o que suceda un\n"
"    error de redirección."

#: builtins.c:730
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Termina el shell.\n"
"    \n"
"    Termina el shell con un estado de N.  Si se omite N, el estado de salida\n"
"    es el mismo de la última orden ejecutada."

#: builtins.c:739
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not executed\n"
"    in a login shell."
msgstr ""
"Termina un shell de entrada.\n"
"    \n"
"    Termina un shell de entrada con un estado de salida de N. Devuelve un\n"
"    error si no se ejecuta en un shell de entrada."

#: builtins.c:749
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    The history builtin also operates on the history list.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error occurs."
msgstr ""
"Muestra o ejecuta órdenes de la lista de la historia.\n"
"    \n"
"    fc se usa para listar o editar y reejecutar órdenes de la lista de la\n"
"    historia.  PRIMERO y ÚLTIMO pueden ser números que especifican el rango,\n"
"    o PRIMERO puede ser una cadena, que significa la orden más reciente que\n"
"    comience con esa cadena.\n"
"    \n"
"       -e NOMBRE_E\tselecciona el editor a usar.  Por defecto es FCEDIT,\n"
"    \t\tdespués EDITOR, después vi\n"
"       -l \tlista laslíneas en lugar de editar\n"
"       -n\tomite los números de línea al listar\n"
"       -r\tinvierte el orden de las líneas (muestra primero las más recientes)\n"
"    \n"
"    Con el formato `fc -s [pat=rep ...] [orden]', la ORDEN se\n"
"    ejecuta de nuevo después de realizar la sustitución ANT=NUEVO.\n"
"    \n"
"    Un alias útil para usar con esto es r='fc -s', tal que al teclear\n"
"    `r cc' ejecuta la última orden que comience con `cc' y al teclear\n"
"    `r' reejecuta la última orden.\n"
"    \n"
"    El interno de historial también opera sobre la lista de la historia.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto o el estado de la orden ejecutada; si sucede un error,\n"
"    es diferente de cero."

#: builtins.c:781
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Mueve el trabajo al primer plano.\n"
"    \n"
"    Ubica el trabajo identificado con IDTRABAJO en primer plano y\n"
"    lo convierte en el trabajo actual.  Si IDTRABAJO no está presente, se usa\n"
"    la noción del shell del trabajo actual.\n"
"    \n"
"    Estado de Salida:\n"
"    El estado de la orden ubicada en primer plano, o falla si sucede un error."

#: builtins.c:796
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Mueve trabajos al segundo plano.\n"
"    \n"
"    Coloca los trabajos identificados por cada IDTRABAJO en segundo plano,\n"
"    como si se hubieran iniciado con `&'.  Si IDTRABAJO no está presente,\n"
"    se usa la noción del shell del trabajo actual.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que el control de trabajos no esté activado o\n"
"    suceda un error."

#: builtins.c:810
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Almacena o muestra la ubicación de los programas.\n"
"    \n"
"    Determina y almacena la ruta completa de cada órden NOMBRE. Si\n"
"    no se proporcionan argumentos, se muestra la información de las\n"
"    órdenes almacenadas.\n"
"    \n"
"    Opciones:\n"
"      -d\tolvida la ubicación almacenada de cada NOMBRE\n"
"      -l\tmuestra en un formato que se puede reutilizar como entrada\n"
"      -p ruta\tusa RUTA como la ruta completa de NOMBRE\n"
"      -r\tolvida todas las ubicaciones almacenadas\n"
"      -t\tmuestra la ubicación almacenada de cada NOMBRE,\n"
"    \t\tcada ubicación precedida del NOMBRE correspondiente\n"
"    \t\tsi se dan varios NOMBREs\n"
"    Argumentos:\n"
"      NOMBRE\tCada NOMBRE se busca en $PATH y se agrega a la lista\n"
"    \t\tde órdenes almacenadas.\n"
"    \n"
"    Estado de Salida\n"
"    Devuelve correcto a menos que no se encuentre NOMBRE o se proporcione\n"
"    una opción inválida."

#: builtins.c:835
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is given."
msgstr ""
"Muestra información sobre órdenes internas.\n"
"    \n"
"    Muestra un resumen breve de las órdenes internas.  Si se especifica\n"
"    un PATRÓN, da ayuda detallada sobre todas las órdenes que\n"
"    coincidan con el PATRÓN; en caso contrario, se muestra la lista de\n"
"    tópicos de ayuda.\n"
"    \n"
"    Opciones:\n"
"      -d\tmuestra una descripción corta para cada tópico\n"
"      -m\tmuestra el uso en un formato similar a página man\n"
"      -s\tmuestra sólo una sinopsis breve de uso para cada tópico que\n"
"    \t\tcoincida con el PATRÓN\n"
"    \n"
"    Argumentos:\n"
"      PATRÓN\tPatrón que especifica un tópico de ayuda\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que no se encuentre PATRÓN o se proporcione\n"
"    una opción inválida."

#: builtins.c:859
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"      -d start-end\tdelete the history entries beginning at position START\n"
"    \t\tthrough position END.\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used. If FILENAME is not supplied\n"
"    and HISTFILE is unset or null, the -a, -n, -r, and -w options have\n"
"    no effect and return success.\n"
"    \n"
"    The fc builtin also operates on the history list.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Muestra o manipula la lista de la historia.\n"
"    \n"
"    Muestra la lista de la historia con números de línea, mostrando\n"
"    cada línea modificada con un `*' como prefijo.  El argumento N\n"
"    muestra solamente las últimas N entradas.\n"
"    \n"
"    Opciones:\n"
"      -c\tborra la lista de historia eliminando todas las entradas\n"
"      -d despl\tborra la entrada de la historia en la posición DESPL. Los\n"
"    \t\tdesplazamientos negativos se cuentan hacia atrás desde el final de\n"
"    \t\tla lista de historia\n"
"      -d principio-fin\tborra las entradas de la historia que empiezan en la\n"
"    \t\tposición PRINCIPIO y terminan en la posición FIN.\n"
"    \n"
"      -a\tagrega las líneas de historia de esta sesión al fichero de historia\n"
"      -n\tlee todas las líneas de historia que no se han leído del fichero\n"
"    \tde historia\n"
"      -r\tlee el fichero de historia y agrega el contenido al fichero\n"
"    \tde historia\n"
"      -w\tescribe la historia actual en el fichero de historia\n"
"    \n"
"      -p\thace expansión de historia en cada ARGumento y muestra el\n"
"    \tresultado, sin guardarlo en la lista de historia\n"
"      -s\tagrega los ARGumentos a la lista de historia como\n"
"    \tuna sola entrada\n"
"    \n"
"    Si se proporciona FICHERO, entonces se usa como el fichero de\n"
"    historia. Si no, si HISTFILE tiene un valor, éste se usa. Si no se\n"
"    proporciona FICHERO y HISTFILE está suprimido o es nulo, las\n"
"    opciones -a, -n, -r y -w no tienen ningún efecto y devuelven éxito.\n"
"    \n"
"    El interno fc también opera en la lista de la historia.\n"
"    \n"
"    Si la variable $HISTTIMEFORMAT está definida y no es nula, se usa su\n"
"    valor como una cadena de formato strftime(3) para mostrar la marca de\n"
"    tiempo asociada con cada entrada de historia mostrada.  No se muestra\n"
"    ninguna marca de tiempo de otra forma.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a no ser que se dé una opción inválida u ocurra un error."

#: builtins.c:902
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Muestra el estado de los trabajos.\n"
"    \n"
"    Muestra los trabajos activos.  IDTRABAJO restringe la salida a\n"
"    esa trabajo.  Sin opciones, se muestra el estado de todas los trabajos\n"
"    activos.\n"
"    \n"
"    Opciones:\n"
"      -l\tmuestra los IDs de los procesos, además de la información normal\n"
"      -n\tsolo muestra los procesos que han cambiado de estado desde\n"
"    \t\tla última notificación\n"
"      -p\tsolo muestra los IDs de los procesos\n"
"      -r\trestringe la salida a los trabajos en ejecución\n"
"      -s\trestringe la salida a los trabajos detenidos\n"
"    \n"
"    Si se especifica -x, la ORDEN se ejecuta después de que todas las\n"
"    especificaciones de trabajo que aparecen en ARGS se hayan reemplazado\n"
"    con el ID de proceso del líder del grupo de procesos de dicho trabajo.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se dé una opción inválida o suceda un\n"
"    error.  Si se usa -x, devuelve el estado de salida de la ORDEN."

#: builtins.c:929
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Quita trabajos del shell actual.\n"
"    \n"
"    Quita cada argumento IDTRABAJO de la tabla de trabajos activos.  Sin\n"
"    ningún IDTRABAJO, el shell utiliza su noción del trabajo actual.\n"
"    \n"
"    Opciones:\n"
"      -a\tquita todas los trabajos si no se proporciona IDTRABAJO\n"
"      -h\tmarca cada IDTRABAJO para que no se le envíe SIGHUP\n"
"    \t\tsi el shell recibe un SIGHUP\n"
"      -r\tquita solo los trabajos en ejecución\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se proporcionen una opción o\n"
"    un IDTRABAJO inválida."

#: builtins.c:948
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Envía una señal a una trabajo.\n"
"    \n"
"    Envía a los procesos nombrados por PID (o IDTRABAJO) la señal ID_SEÑAL\n"
"    o NUM_SEÑAL. Si no están presentes ni ID_SEÑAL o NUM_SEÑAL, se asume\n"
"    SIGTERM.\n"
"    \n"
"    Opciones:\n"
"      -s sig\tSIG es un nombre de señal\n"
"      -n sig\tSIG es un número de señal\n"
"      -l\tlista los nombres de señales; si hay argumentos a continuación\n"
"    \t\tde `-l', se asume que son números de señal para las cuales se debe\n"
"    mostrar el nombre.\n"
"    \n"
"    Kill es una orden interna del shell por dos razones: permite que se\n"
"    puedan utilizar IDs de trabajo en lugar de IDs de proceso y permite\n"
"    matar procesos si se ha alcanzado el límite de procesos que se pueden\n"
"    crear.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se dé una opción inválida o suceda un error."

# "a ser evaluada" no está en español. sv
# Cierto. ¿Así está mejor? cfuga
# overflow -> desbordamiento o sobrepasamiento. nunca lo he visto
# traducido como sobreflujo. sv
# Corregido. cfuga
# No sé si existe precedencia en español, pero me suena fatal.
# Yo pondría simplemente "prioridad". sv
# Creo que si existe, pero tu sugerencia es mejor. cfuga
#: builtins.c:972
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Evalúa expresiones aritméticas.\n"
"    \n"
"    Evalúa cada ARG como una expresión aritmética.  La evaluación se hace\n"
"    con enteros de longitud fija, sin revisar desbordamientos, aunque la\n"
"    la división por 0 se captura y se marca como un error.  La siguiente\n"
"    lista de operadores está agrupada en niveles de operadores de la misma\n"
"    prioridad.  Los niveles se muestran en orden de prioridad decreciente.\n"
"    \n"
"    \tid++, id--\tpost-incremento, post-decremento de variable\n"
"    \t++id, --id\tpre-incremento, pre-decremento de variable\n"
"    \t-, +\t\tmenos, más unario\n"
"    \t!, ~\t\tnegación lógica y basada en bits\n"
"    \t**\t\texponenciación\n"
"    \t*, /, %\t\tmultiplicación, división, residuo\n"
"    \t+, -\t\tadición, sustracción\n"
"    \t<<, >>\t\tdesplazamientos de varios bit izquierdo y derecho\n"
"    \t<=, >=, <, >\tcomparación\n"
"    \t==, !=\t\tequivalencia, inequivalencia\n"
"    \t&\t\tAND de varios bit\n"
"    \t^\t\tXOR de varios bit\n"
"    \t|\t\tOR de varios bit\n"
"    \t&&\t\tAND lógico\n"
"    \t||\t\tOR lógico\n"
"    \texpr ? expr : expr\n"
"    \t\t\toperador condicional\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tasignación\n"
"    \n"
"    Se permiten las variables de shell como operandos.  El nombre\n"
"    de la variable se reemplaza por su valor (coercionado a un\n"
"    entero de longitud fija) dentro de una expresión.  La variable\n"
"    no necesita tener activado su atributo entero para emplearse\n"
"    en una expresión.\n"
"    \n"
"    Los operadores se evalúan en orden de prioridad.  Primero se\n"
"    evalúan las sub-expresiones en paréntesis y pueden sobrepasar\n"
"    las reglas de prioridad anteriores.\n"
"    \n"
"    Estado de Salida:\n"
"    Si el último ARGumento se evalúa como 0, ‘let’ devuelve 1; de\n"
"    otra forma, ‘let’ devuelve 0."

#: builtins.c:1017
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as word\n"
"    delimiters. By default, the backslash character escapes delimiter characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -E\tuse Readline to obtain the line and use the bash default\n"
"    \t\tcompletion instead of Readline's default completion\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times out\n"
"    (in which case it's greater than 128), a variable assignment error occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Lee una línea de la salida estándar y la divide en campos.\n"
"    \n"
"    Lee una sola línea de la entrada estándar, o del descriptor de\n"
"    fichero FD si se proporciona la opción -u.  La línea se divide en campos\n"
"    con separación de palabras, y la primera palabra se asigna al primer\n"
"    NOMBRE, la segunda palabra al segundo NOMBRE, y así sucesivamente, con\n"
"    las palabras restantes asignadas al último NOMBRE.  Sólo los caracteres\n"
"    que se encuentran en $IFS se reconocen como delimitadores de palabras.\n"
"    Lo predefinido es que el carácter de barra inclinada inversa escape los\n"
"    delimitadores de caracteres y las nuevas líneas.\n"
"    \n"
"    Si no se proporciona ningún NOMBRE, la línea leída se guarda en la\n"
"    variable REPLY.\n"
"    \n"
"    Opciones:\n"
"      -a matriz\tasigna las palabras leídas a índices secuenciales de\n"
"    \t\tla variable matricial MATRIZ, empezando en cero\n"
"      -d delim\tcontinúa hasta que se lea el primer carácter de DELIM,\n"
"    \t\ten lugar de línea nueva\n"
"      -e\tusa Readline para obtener la línea\n"
"      -E\tusa Readline para obtener la línea y utiliza el\n"
"    \t\tcompletado predefinido de bash en lugar de la de Readline\n"
"      -i texto\tEmplea el TEXTO como el texto inicial para Readline\n"
"      -n ncars\tregresa tras leer NCARS caracteres en lugar de\n"
"    \t\tesperar una línea nueva, pero honra a un delimitador si\n"
"    \t\tse leen menos de NCARS caracteres antes del delimitador\n"
"      -N ncars\tdevuelve sólo después de leer exactamente NCARS\n"
"    \t\tcaracteres, a menos que se encuentre el fin del fichero\n"
"    \t\to expire la lectura, descartando cualquier delimitador\n"
"      -p prompt\tsale la cadena PROMPT sin un carácter de línea nueva\n"
"    \t\tal final antes de intentar leer\n"
"      -r\t\tno permite que las barras invertidas escapen caracteres\n"
"      -s\t\tno muestra la salida que proviene de una terminal\n"
"      -t tiempo\texpira y devuelve fallo si no se lee una línea completa\n"
"    \t\tde entrada en TIEMPO segundos.  El valor de la variable TMOUT\n"
"    \t\tes el tiempo de expiración por defecto.  TIEMPO puede ser un\n"
"    \t\tnúmero fraccionario.  Si TIEMPO es 0, ‘read’ devuelve correcto\n"
"    \t\tsólo si hay entrada disponible en el descriptor de fichero\n"
"    \t\tespecificado.  El estado de salida es mayor que 128 si se excede\n"
"    \t\tel tiempo de expiración.\n"
"      -u df\t\tlee del descriptor de fichero DF en lugar de la entrada\n"
"    \t\testándar\n"
"    \n"
"    Estado de Salida:\n"
"    El código de devolución es cero, a menos que se encuentre un final de\n"
"    línea, el tiempo de lectura se agote, o se proporcione un descriptor\n"
"    de fichero inválido como el argumento de -u."

#: builtins.c:1067
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Devuelve de una función de shell.\n"
"    \n"
"    Causa que una función o un script leído termine con el valor devuelto\n"
"    especificado por N.  Si se omite N, el estado devuelto es el de la última\n"
"    orden ejecutada dentro de la función o script.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve N, o falla si el shell no está ejecutando una función o un script."

#: builtins.c:1080
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    If -o is supplied with no option-name, set prints the current shell\n"
"    option settings. If +o is supplied with no option-name, set prints a\n"
"    series of set commands to recreate the current option settings.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Establece o borra los valores de las opciones de shell y los parámetros\n"
"posicionales.\n"
"    \n"
"    Modifica el valor de los atributos de shell y los parámetros posicionales,\n"
"    o muestra los nombres y valores de las variables de shell.\n"
"    \n"
"    Opciones:\n"
"      -a  Marca las variables que se modifican o crean para exportación.\n"
"      -b  Notifica el término de trabajos inmediatamente.\n"
"      -e  Termina inmediatamente si una orden termina con un estado\n"
"          diferente a cero.\n"
"      -f  Desactiva la generación de nombres de ficheros (englobamiento).\n"
"      -h  Recuerda la ubicación de las órdenes como se localizaron.\n"
"      -k  Todos los argumentos de asignación se colocan en el ambiente para una\n"
"          orden, no solo aquellos que preceden al nombre de la orden.\n"
"      -m  Activa el control de trabajos.\n"
"      -n  Lee órdenes pero no las ejecuta.\n"
"      -o nombre-opción\n"
"          Establece la variable correspondiente a nombre-opción:\n"
"              allexport    igual que -a\n"
"              braceexpand  igual que -B\n"
"              emacs        usa una interfaz de edición lineal estilo emacs\n"
"              errexit      igual que -e\n"
"              errtrace     igual que -E\n"
"              functrace    igual que -T\n"
"              hashall      igual que -h\n"
"              histexpand   igual que -H\n"
"              history      activa la historia de órdenes\n"
"              ignoreeof    el shell no terminará después de leer EOF\n"
"              interactive-comments\n"
"                           permite que haya comentarios en órdenes interactivas\n"
"              keyword      igual que -k\n"
"              monitor      igual que -m\n"
"              noclobber    igual que -C\n"
"              noexec       igual que -n\n"
"              noglob       igual que -f\n"
"              nolog        actualmente se acepta pero se descarta\n"
"              notify       igual que -b\n"
"              nounset      igual que -u\n"
"              onecmd       igual que -t\n"
"              physical     igual que -P\n"
"              pipefail     el valor de retorno de una tubería es el estado\n"
"                           de la última orden que sale con un estado diferente\n"
"                           de cero, o cero si ninguna orden termina con un\n"
"                           estado diferente de cero\n"
"              posix        modifica el comportamiento de bash donde la\n"
"                           operación por defecto difiere del estándar POSIX\n"
"                           para que coincida con el estándar\n"
"              privileged   igual que -p\n"
"              verbose      igual que -v\n"
"              vi           usa una interfaz de edición de línea estilo vi\n"
"              xtrace       igual que -x\n"
"      -p  Activo cuando los ids real y efectivo del usuario no coinciden.\n"
"          Desactiva el procesamiento del fichero $ENV y la importación de\n"
"          funciones de shell.  Si se desactiva esta opción causa que el uid y\n"
"          el gid efectivos sean iguales al uid y el gid real.\n"
"      -t  Termina después de leer y ejecutar una orden.\n"
"      -u  Trata las variables sin definir como un error al sustituir.\n"
"      -v  Muestra las líneas de entrada del shell mientras se leen.\n"
"      -x  Muestra las órdenes y sus argumentos mientras se ejecutan.\n"
"      -B  el shell realizará expansión de llaves.\n"
"      -C  Si se activa, no permite que los ficheros regulares existentes\n"
"          se sobreescriban por redirección de la salida.\n"
"      -E  Si se activa, las funciones del shell heredan la trampa ERR.\n"
"      -H  Activa el estilo de sustitución de historia ! . Esta opción está\n"
"          activa por defecto cuando el shell es interactivo.\n"
"      -P  Si se activa, no sigue enlaces simbólicos cuando se ejecutan órdenes\n"
"          como cd, que cambian el directorio actual.\n"
"      -T  Si se activa, las funciones del shell heredan la trampa DEBUG.\n"
"      --  Asigna cualquier argumento restante a los parámetros posicionales.\n"
"          Si no restan argumentos, se desactivan los parámetros posicionales.\n"
"      -   Asigna cualquier argumento restante a los parámetros posicionales.\n"
"          Las opciones -x y -v se desactivan.\n"
"    \n"
"    Si se proporciona -o sin nombre de opción, «set» imprime la configuración\n"
"    de opciones actual de la shell. Si se proporciona +o sin nombre de opción,\n"
"    «set» imprime una serie de comandos «set» para recrear la configuración\n"
"    de opciones actual.\n"
"    \n"
"    Si se usa + en lugar de - causa que estas opciones se desactiven. Las\n"
"    opciones también se pueden usar en la invocación del shell.  El conjunto\n"
"    actual de opciones se puede encontrar en $-.  Los n ARGs restantes son\n"
"    parámetros posicionales que se asignan, en orden, a $1, $2, .. $n.  Si no\n"
"    se proporciona ningún ARG, se muestran todas las variables del shell.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se proporcione una opción inválida."

#: builtins.c:1169
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Desactiva valores y atributos de las variables y funciones del shell.\n"
"    \n"
"    Por cada NOMBRE, borra la función o variable correspondiente.\n"
"    \n"
"    Opciones:\n"
"      -f\ttrata cada NOMBRE como una función de shell\n"
"      -v\ttrata cada NOMBRE como una variable de shell\n"
"      -n\ttrata cada NOMBRE como una referencia de nombre y desasigna\n"
"    \t\tla propia variable, no aquella a la que hace referencia\n"
"    \n"
"    Sin opciones, unset primero trata de borrar una variable, y si falla,\n"
"    trata de borrar una función.\n"
"    \n"
"    Algunas variables no se pueden borrar; también consulte `readonly'.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se proporcione una opción inválida o\n"
"    un NOMBRE sea de sólo lectura."

#: builtins.c:1191
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables or functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Establece el atributo de exportación para las variables de shell.\n"
"    \n"
"    Marca cada NOMBRE para exportación automática al ambiente para las órdenes\n"
"    ejecutadas subsecuentemente.  Si se proporciona un VALOR, se asigna el\n"
"    VALOR antes de exportar.\n"
"    \n"
"    Opciones:\n"
"      -f\tse refiere a funciones de shell\n"
"      -n\tborra la propiedad de exportación para cada NOMBRE\n"
"      -p\tmuestra una lista de todas las variables o funciones exportadas\n"
"    \n"
"    El argumento `--' desactiva el procesamiento posterior de opciones.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se proporcione una opción inválida o que\n"
"    NOMBRE sea inválido."

#: builtins.c:1210
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Marca las variables de shell para evitar su modificación.\n"
"    \n"
"    Marca cada NOMBRE como de sólo lectura; los valores de esos NOMBREs\n"
"    no se pueden modificar por asignaciones subsecuentes.  Si se proporciona\n"
"    un VALOR, se asigna el VALOR antes de marcar como de sólo lectura.\n"
"    \n"
"    Opciones:\n"
"      -a\tse refiere a variables de matriz indexada\n"
"      -A\tse refiere a variables de matriz asociativa\n"
"      -f\tse refiere a funciones de shell\n"
"      -p\tmuestra una lista de todas las variables y funciones de sólo lectura,\n"
"    \t\tdependiendo de si se pone o no la opción -f\n"
"    \n"
"    El argumento `--' desactiva el procesamiento posterior de opciones.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se proporcione una opción inválida o\n"
"    el NOMBRE sea inválido."

#: builtins.c:1232
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Desplaza los parámetros posicionales.\n"
"    \n"
"    Renombra los parámetros posicionales $N+1,$N+2 ... a $1,$2 ... Si no\n"
"    se proporciona N, se asume que es 1.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que N sea negativo o mayor que $#."

#: builtins.c:1244 builtins.c:1260
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell. If the\n"
"    -p option is supplied, the PATH argument is treated as a colon-\n"
"    separated list of directories to search for FILENAME. If -p is not\n"
"    supplied, $PATH is searched to find FILENAME. If any ARGUMENTS are\n"
"    supplied, they become the positional parameters when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Ejecuta órdenes de un fichero en el shell actual.\n"
"    \n"
"    Lee y ejecuta órdenes del FICHERO en el shell actual. Si se proporciona\n"
"    la opción -p, el argumento PATH se trata como una lista de directorios\n"
"    separados por dos puntos para buscar FICHERO. Si no se proporciona la\n"
"    opción -p, se busca FICHERO en $PATH. Si se proporcionan ARGUMENTOS,\n"
"    estos serán los parámetros posicionales cuando se ejecute FICHERO.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada del FICHERO; falla si\n"
"    no se puede leer el FICHERO."

#: builtins.c:1277
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells and shells without job control cannot be\n"
"    suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell or job\n"
"    \t\tcontrol is not enabled.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Suspende la ejecución del shell.\n"
"    \n"
"    Suspende la ejecución de este shell hasta que recibe una señal SIGCONT.\n"
"    A menos que se fuerce, los shells de entrada y los shells sin control\n"
"    de trabajos no se pueden suspender.\n"
"    \n"
"    Opciones:\n"
"      -f\tfuerza la suspensión, aún si el shell es un shell de entrada\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que no esté activo el control de trabajos o\n"
"    suceda un error."

#: builtins.c:1295
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Evalúa expresiones condicionales.\n"
"    \n"
"    Termina con un estado de 0 (verdadero) o 1 (falso) dependiendo de\n"
"    la evaluación de EXPR.  Las expresiones pueden ser unarias o binarias.\n"
"    Las expresiones unarias se usan generalmente para examinar el estado\n"
"    de un fichero.  Hay también operadores de cadenas, y operadores de\n"
"    comparación numérica.\n"
"    \n"
"    El comportamiento de test depende del número de argumentos.  Lea la página\n"
"    de manual de bash para la especificación completa.\n"
"    \n"
"    Operadores de fichero:\n"
"    \n"
"      -a FICHERO     Verdadero si el fichero existe.\n"
"      -b FICHERO     Verdadero si el fichero es especial de bloques.\n"
"      -c FICHERO     Verdadero si el fichero es especial de caracteres.\n"
"      -d FICHERO     Verdadero si el fichero es un directorio.\n"
"      -e FICHERO     Verdadero si el fichero existe.\n"
"      -f FICHERO     Verdadero si el fichero existe y es un fichero regular.\n"
"      -g FICHERO     Verdadero si el fichero tiene activado el set-group-id.\n"
"      -h FICHERO     Verdadero si el fichero es un enlace simbólico.\n"
"      -L FICHERO     Verdadero si el fichero es un enlace simbólico.\n"
"      -k FICHERO     Verdadero si el fichero tiene el bit `sticky' activado.\n"
"      -p FICHERO     Verdadero si el fichero es una tubería nombrada.\n"
"      -r FICHERO     Verdadero si el fichero es legible para usted.\n"
"      -s FICHERO     Verdadero si el fichero existe y no está vacío.\n"
"      -S FICHERO     Verdadero si el fichero es un `socket'.\n"
"      -t DF          Verdadero si el DF está abierto en una terminal.\n"
"      -u FICHERO     Verdadero si el fichero tiene activado el set-user-id.\n"
"      -w FICHERO     Verdadero si usted puede escribir en el fichero.\n"
"      -x FICHERO     Verdadero si usted puede ejecutar el fichero.\n"
"      -O FICHERO     Verdadero si usted efectivamente posee el fichero.\n"
"      -G FICHERO     Verdadero si su grupo efectivamente posee el fichero.\n"
"      -N FICHERO     Verdadero si el fichero se modificó desde la última lectura.\n"
"    \n"
"      FICH1 -nt FICH2  Verdadero si fich1 es más reciente que fich2\n"
"                       (de acuerdo a la fecha de modificación).\n"
"    \n"
"      FICH1 -ot FICH2  Verdadero si fich1 es más antiguo que fich2.\n"
"    \n"
"      FICH1 -ef FICH2  Verdadero si fich1 es un enlace duro a fich2.\n"
"    \n"
"    Operadores de cadenas:\n"
"    \n"
"      -z CADENA      Verdadero si la cadena está vacía.\n"
"    \n"
"      -n CADENA\n"
"         CADENA      Verdadero si la cadena no está vacía.\n"
"    \n"
"      CADENA1 = CADENA2\n"
"                     Verdadero si las cadenas son iguales.\n"
"      CADENA1 != CADENA2\n"
"                     Verdadero si las cadenas no son iguales.\n"
"      CADENA1 < CADENA2\n"
"                     Verdadero si STRING1 se ordena antes que STRING2\n"
"                     lexicográficamente.\n"
"      CADENA1 > CADENA2\n"
"                     Verdadero si STRING1 se ordena después que STRING2\n"
"                     lexicográficamente.\n"
"    \n"
"    Otros operadores:\n"
"    \n"
"      -o OPCIÓN      Verdadero si la opción del shell OPCIÓN está activada.\n"
"      -v VAR         Verdadero si la variable de shell VAR está activada.\n"
"      -R VAR         Verdadero si la variable VAR está activada y es una\n"
"                       referencia de nombre\n"
"      ! EXPR         Verdadero si expr es falso.\n"
"      EXPR1 -a EXPR2 Verdadero si expr1 Y expr2 son ambas verdaderas.\n"
"      EXPR1 -o EXPR2 Verdadero si cualquiera de expr1 O expr2 es verdadera.\n"
"    \n"
"      arg1 OP arg2   Pruebas aritméticas.  OP es uno de -eq, -ne,\n"
"                       -lt, -le, -gt, or -ge.\n"
"    \n"
"    Los operadores binarios aritméticos devuelven verdadero si ARG1 es\n"
"    igual, no igual, menor, menor o igual, mayor, mayor o igual que ARG2.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto si EXPR evalúa a verdadero; falla si EXPR evalúa a\n"
"    falso o se proporciona un argumento inválido."

#: builtins.c:1377
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Evalúa una expresión condicional.\n"
"    \n"
"    Este es un sinónimo para la orden interna \"test\", pero el último\n"
"    argumento debe ser un `]' literal, que concuerde con el `[' inicial."

#: builtins.c:1386
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Muestra los tiempos de proceso.\n"
"    \n"
"    Muestra los tiempos de usuario y sistema acumulados por el shell y todos\n"
"    sus procesos hijos.\n"
"    \n"
"    Estado de Salida:\n"
"    Siempre correcto."

#: builtins.c:1398
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives signals\n"
"    or other conditions.\n"
"    \n"
"    ACTION is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ACTION is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ACTION is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ACTION is executed on exit from the shell.\n"
"    If a SIGNAL_SPEC is DEBUG, ACTION is executed before every simple command\n"
"    and selected other commands. If a SIGNAL_SPEC is RETURN, ACTION is\n"
"    executed each time a shell function or a script run by the . or source\n"
"    builtins finishes executing.  A SIGNAL_SPEC of ERR means to execute ACTION\n"
"    each time a command's failure would cause the shell to exit when the -e\n"
"    option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands associated\n"
"    with each trapped signal in a form that may be reused as shell input to\n"
"    restore the same signal dispositions.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC in a\n"
"    \t\tform that may be reused as shell input; or for all trapped\n"
"    \t\tsignals if no arguments are supplied\n"
"      -P\tdisplay the trap commands associated with each SIGNAL_SPEC. At least\n"
"    \t\tone SIGNAL_SPEC must be supplied. -P and -p cannot be used\n"
"    \t\ttogether.\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is given."
msgstr ""
"Atrapa señales y otros eventos.\n"
"    \n"
"    Define y activa manejadores para ejecutar cuando el shell recibe señales\n"
"    u otras condiciones.\n"
"    \n"
"    ACCIÓN es una orden para leer y ejecutar cuando el shell recibe la(s)\n"
"    señal(es) ID_SEÑAL.  Si ACCIÓN no está presente (y sólo se proporciona\n"
"    una sola ID_SEÑAL) o se proporciona `-', cada señal especificada se\n"
"    reestablece a su valor original.  Si ACCIÓN es la cadena nula, el shell\n"
"    y las órdenes que invoque ignoran cada ID_SEÑAL.\n"
"    \n"
"    Si una ID_SEÑAL es EXIT (0) se ejecuta ACCIÓN al salir del shell.\n"
"    Si una ID_SEÑAL es DEBUG, se ejecuta ACCIÓN antes de cada orden simple y\n"
"    otras órdenes seleccionadas. Si una ID_SEÑAL es RETURN, se ejecuta ACCIÓN\n"
"    cada vez que una función de shell o un script ejecutado por las órdenes\n"
"    internas . o source termina su ejecución.  Una ID_SEÑAL de ERR conlleva\n"
"    que se ejecute ACCIÓN cada vez que un fallo de una orden provocaría que\n"
"    el shell terminase si la opción -e está activada.\n"
"    \n"
"    Si no se proporcionan argumentos, trap muestra la lista de órdenes\n"
"    asociadas con cada señal.\n"
"    \n"
"    Opciones:\n"
"      -l\tmuestra una lista de nombres de señal con su número correspondiente\n"
"      -p\tmuestra las órdenes trap asociadas con cada ID_SEÑAL\n"
"    \n"
"    Cada ID_SEÑAL es un nombre de señal en <signal.h> o un número de señal.\n"
"    Los nombres de señal no son sensibles a mayúsculas y minúsculas y el\n"
"    prefijo SIG es opcional.  Se puede enviar una señal al shell con\n"
"    \"kill -signal $$\".    \n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que una ID_SEÑAL sea inválida o se proporcione\n"
"    una opción inválida."

#  No he visto que este fichero incluya la posibilidad de traducir las
#  palabras que muestra `type -t'. Por esta razón, se dejan en inglés. cfuga
#: builtins.c:1441
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not found."
msgstr ""
"Muestra información sobre el tipo de orden.\n"
"    \n"
"    Por cada NOMBRE, indica cómo se interpretaría si se utilizara como un\n"
"    nombre de orden.\n"
"    \n"
"    Opciones:\n"
"      -a\tmuestra todas las ubicaciones que contienen un ejecutable llamado\n"
"    \t\tNOMBRE; incluye aliases, órdenes internas y funciones, si y solo si\n"
"    \t\tno se utilizó también la opción `-p'\n"
"      -f\tsuprime la búsqueda de funciones de shell\n"
"      -P\tfuerza una búsqueda en PATH por cada nombre, aun si hay un alias,\n"
"    \t\torden interna o función, y devuelve el nombre del fichero en disco\n"
"    \t\tque se ejecutaría\n"
"      -p\tdevuelve el nombre del fichero en disco que se ejecutaría,\n"
"    \t\to nada si `type -t NOMBRE' no devuelve `fichero'\n"
"      -t\tsaca una sola palabra, que es una de entre `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' o `', si el NOMBRE es un alias,\n"
"    \t\tpalabra reservada del shell, función del shell, orden interna del\n"
"    \t\tshell, fichero de disco, o no se encuentra, respectivamente.\n"
"    \n"
"    Argumentos:\n"
"      NOMBRE\tNombre de orden a interpretar.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto si se encuentran todos los NOMBREs; falla si alguno\n"
"    no se encuentra."

#: builtins.c:1472
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds;\n"
"    -p, which is in increments of 512 bytes; -R, which is in microseconds;\n"
"    -b, which is in bytes; and -e, -i, -k, -n, -q, -r, -u, -x, and -P,\n"
"    which accept unscaled values.\n"
"    \n"
"    When in posix mode, values supplied with -c and -f are in 512-byte\n"
"    increments.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Modifica los límites de recursos del shell.\n"
"    \n"
"    Provee control sobre los recursos disponibles para el shell y los\n"
"    procesos que crea, en sistemas que permiten tal control.\n"
"    \n"
"    Opciones:\n"
"    \n"
"      -S\tusa el límite de recurso `soft'\n"
"      -H\tusa el límite de recurso `hard'\n"
"      -a\tmuestra todos los límites actuales\n"
"      -b\tel tamaño del almacenamiento intermedio del `socket'\n"
"      -c\tel tamaño máximo de los ficheros `core' creados\n"
"      -d\tel tamaño máximo del segmento de datos de un proceso\n"
"      -e\tla prioridad máxima de calendarización (`nice')\n"
"      -f\tel tamaño máximo de los ficheros escritos por el shell y sus hijos\n"
"      -i\tel número máximo de señales pendientes\n"
"      -k\tel número máximo de kcolas ubicadas para este proceso\n"
"      -l\tel tamaño máximo que un proceso puede bloquear en memoria\n"
"      -m\tel tamaño máximo para las variables residentes\n"
"      -n\tel número máximo de descriptores de fichero abiertos\n"
"      -p\tel tamaño del almacenamiento intermedio para tuberías\n"
"      -q\tel tamaño máximo de bytes en las colas de mensajes POSIX\n"
"      -r\tla prioridad máxima de calendarización en tiempo real\n"
"      -s\tel tamaño máximo de pila\n"
"      -t\tla cantidad máxima de tiempo de cpu en segundos\n"
"      -u\tel número máximo de procesos de usuario\n"
"      -v\tel tamaño de la memoria virtual\n"
"      -x\tel número máximo de bloqueos de ficheros\n"
"      -P\tel número máximo de pseudoterminales\n"
"      -R\tel tiempo máximo que un proceso de tiempo real puede correr antes de bloquearse\n"
"      -T\tel número máximo de hilos\n"
"    \n"
"    No todas las opciones están disponibles en todas las plataformas.\n"
"    \n"
"    Si se establece LÍMITE, éste es el nuevo valor del recurso especificado;\n"
"    los valores especiales de LÍMITE `soft', `hard' y `unlimited'\n"
"    corresponden al límite suave actual, el límite duro actual, y\n"
"    sin límite, respectivamente.  De otra forma, se muestra el valor actual\n"
"    de los recursos especificados.  Si no se proporciona una opción, se\n"
"    asume -f.\n"
"    \n"
"    Los valores se toman en incrementos de 1024 bytes, excepto -t, que está\n"
"    en segundos; -p, que está en incrementos de 512 bytes; -R, que está en\n"
"    microsegundos; -b, que está en bytes; y -e, -i, -k, -n, -q, -r, -u, -x\n"
"    y -P, que aceptan valores sin escala.\n"
"    \n"
"    En modo posix, los valores proporcionados con -c y -f están en\n"
"    incrementos de 512 bytes.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se proporcione una opción inválida o suceda\n"
"    un error."

#: builtins.c:1527
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Muestra o establece la máscara de modo de ficheros.\n"
"    \n"
"    Establece la máscara de creación de ficheros del usuario a MODO. Si se\n"
"    omite el MODO, muestra el valor actual de la máscara.\n"
"    \n"
"    Si el MODO empieza con un dígito, se interpreta como un número octal;\n"
"    de otra forma es una cadena de modo simbólico como la que acepta chmod (1).\n"
"    \n"
"    Opciones:\n"
"      -p\tsi se omite el MODO, muestra en una forma reusable como entrada\n"
"      -S\tsalida simbólica; de otra forma muestra el modo como número octal\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que el MODO sea inválido o se proporcione\n"
"    una opción inválida."

#: builtins.c:1547
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Espera la terminación del trabajo y devuelve el estado de salida.\n"
"    \n"
"    Espera al proceso identificado por ID, el cual puede ser un ID de\n"
"    proceso o una especificación de trabajo e informa de su estado de salida.\n"
"    Si no se proporciona un ID, espera a todos los procesos hijos activos,\n"
"    y el estado de devolución es cero.  Si ID es una especificación de\n"
"    trabajo, espera a todos los procesos en la cola de trabajos.\n"
"    \n"
"    Si se proporciona la opción -n, espera por un único trabajo de la lista de\n"
"    IDs o, si no se ha especificado ningún ID, espera a que termine el\n"
"    siguiente trabajo y devuelve su estado de salida.\n"
"    \n"
"    Si se proporciona la opción -p, el identificador de proceso o trabajo del\n"
"    trabajo cuyo estado de salida es devuelto se le asigna a la variable VAR\n"
"    designada por el argumento de la opción. La variable se anulará inicialmente\n"
"    antes de ninguna otra asignación. Esto es útil únicamente cuando se\n"
"    proporciona la opción -n.\n"
"    \n"
"    Si se proporciona la opción -f y el control de trabajos está activado,\n"
"    espera a que termine el ID especificado, en vez de esperar a que cambie de\n"
"    estado.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de ID; falla si ID es inválido o se proporciona una\n"
"    opción inválida o si proporciona -n y la shell no tiene ningún hijo al que\n"
"    esperar."

#: builtins.c:1578
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an invalid\n"
"    option is given."
msgstr ""
"Espera la terminación del proceso y devuelve el estado de salida.\n"
"    \n"
"    Espera a cada proceso especificado por un PID y reporta su\n"
"    estado de salida.  Si no se proporciona un PID, espera a todos los\n"
"    procesos hijos activos, y el código de devolución es cero.\n"
"    El PID debe ser un ID de proceso.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado del último PID; falla si PID es inválido o se proporciona\n"
"    una opción inválida."

#: builtins.c:1593
msgid ""
"Execute PIPELINE, which can be a simple command, and negate PIPELINE's\n"
"    return status.\n"
"    \n"
"    Exit Status:\n"
"    The logical negation of PIPELINE's return status."
msgstr ""
"Ejecuta TUBERÍA, que puede ser una orden sencilla, y niega el estado de retorno\n"
"    de TUBERÍA.\n"
"    \n"
"    Estado de Salida:\n"
"    La negación lógica del estado de retorno de TUBERÍA."

#: builtins.c:1603
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Ejecuta órdenes por cada miembro en una lista.\n"
"    \n"
"    El bucle `for' ejecuta una secuencia de órdenes para cada miembro en\n"
"    una lista de elementos.  Si `in PALABRAS ...;' no está presente,\n"
"    entonces se asume `in \"$@\"'.  Para cada elemento en PALABRAS,\n"
"    se define NOMBRE como ese elemento, y se ejecutan las ÓRDENES.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1617
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Aritmétical de bucle for.\n"
"    \n"
"    Equivalente a\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tÓRDENES\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, y EXP3 son expresiones aritméticas.  Si se omite\n"
"    cualquiera de ellas, se comporta como si se evaluara a 1.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1635
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Selecciona palabras de una lista y ejecuta órdenes.\n"
"    \n"
"    Se expanden las PALABRAS, generando una lista de palabras.  El\n"
"    conjunto de palabras expandidas se muestra en la salida de error\n"
"    estándar, cada una precedida por un número.  Si `in PALABRAS' no\n"
"    está presente, se asume `in \"$@\"'.  Entonces se muestra el\n"
"    prompt PS3 y se lee una línea de la entrada estándar.  Si la\n"
"    línea consiste en el número correspondiente a una de las palabras\n"
"    mostradas, entonces se define NOMBRE como esa palabra.  Si la\n"
"    línea está vacía, PALABRAS y el prompt se muestran de nuevo.  Si\n"
"    se lee EOF, se completa la orden.  Cualquier otro valor leído\n"
"    causa que NOMBRE se defina como nulo.  La línea leída se guarda\n"
"    en la variable REPLY.  Se ejecutan las ÓRDENES después de cada\n"
"    selección hasta que se ejecuta una orden break.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1656
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Reporta el tiempo consumido por la ejecución de la tubería.\n"
"    \n"
"    Ejecuta la TUBERÍA y muestra un resumen del tiempo real, el tiempo de\n"
"    CPU del usuario, y el tiempo de CPU del sistema utilizado por\n"
"    la ejecución de la TUBERÍA cuando termina.\n"
"    \n"
"    Opciones:\n"
"      -p\tmuestra el resumen de tiempos en el formato Posix transportable\n"
"    \n"
"    Estado de Salida:\n"
"    El estado de devolución es el estado de devolución de la TUBERÍA."

#: builtins.c:1673
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Ejecuta órdenes en base a la coincidencia de patrones.\n"
"    \n"
"    Ejecuta ÓRDENES selectivamente basado en coincidencias de la PALABRA\n"
"    con el PATRÓN. Se utiliza `|' para separar patrones múltiples.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1685
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of the\n"
"    entire construct is the exit status of the last command executed, or zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Ejecuta comandos en base a condicionales.\n"
"    \n"
"    Se ejecuta la lista `if ÓRDENES'.  Si su estado de salida es cero,\n"
"    entonces se ejecuta la lista `then ÓRDENES`.  De otra forma, cada lista\n"
"    `elif ÓRDENES' se ejecuta en su lugar, y si su estado de salida es cero,\n"
"    se ejecuta la lista `then ÓRDENES' correspondiente y se completa la\n"
"    orden if.  De otra forma, se ejecuta la lista `else ÓRDENES', si está\n"
"    presente.  El estado de salida del bloque entero es el estado saliente\n"
"    de la última orden ejecutada, o cero si ninguna condición resultó\n"
"    verdadera.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1702
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Ejecuta órdenes mientras una prueba sea correcta.\n"
"    \n"
"    Expande y ejecuta ÓRDENES-2 mientras la orden final en ÓRDENES\n"
"    tenga un estado de salida de cero.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1714
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Ejecuta órdenes mientras una prueba sea correcta.\n"
"    \n"
"    Expande y ejecuta ÓRDENES-2 mientras la orden final en ÓRDENES\n"
"    tenga un estado de salida que no sea cero.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1726
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Crea un coproceso llamado NOMBRE.\n"
"    \n"
"    Ejecuta la ORDEN asíncronamente, con la salida y la entrada estándar\n"
"    de la orden conectadas a través de una tubería a los descriptores\n"
"    de fichero asignados a los índices 0 y 1 de una variable de matriz\n"
"    NOMBRE en el shell en ejecución.  El nombre por defecto es\n"
"    \"COPROC\".\n"
"    \n"
"    Estado de Salida:\n"
"    La orden «coproc» devuelve un estado de salida de 0."

#: builtins.c:1740
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Define una función de shell.\n"
"    \n"
"    Crea una función de shell llamada NOMBRE.  Cuando se invoca como una\n"
"    orden simple, NOMBRE ejecuta ORDENes en el contexto del shell\n"
"    que lo llamó.  Cuando se invoca NOMBRE, los argumentos se pasan a la\n"
"    función como $1...$n, y el nombre de la función está en $FUNCNAME.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que NOMBRE sea de sólo lectura."

#: builtins.c:1754
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Agrupa órdenes como una unidad.\n"
"    \n"
"    Ejecuta un conjunto de órdenes en un grupo.  Esta es una\n"
"    forma de redirigir un conjunto completo de órdenes.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1766
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Reinicia el trabajo en primer plano.\n"
"    \n"
"    Equivalente al argumento IDTRABAJO de la orden `fg'.  Reinicia un\n"
"    trabajo detenido o en segundo plano.  IDTRABAJO puede especificar\n"
"    un nombre de trabajo o un número de trabajo.  Un `&' a continuación\n"
"    de IDTRABAJO coloca a el trabajo en segundo plano, como si la\n"
"    especificación del trabajo se hubiera proporcionado como\n"
"    un argumento de `bg'.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado del trabajo reiniciado."

#: builtins.c:1781
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Evalúa una expresión aritmética.\n"
"    \n"
"    Se evalúa la EXPRESIÓN de acuerdo a las reglas de evaluación\n"
"    aritmética.  Equivalente a `let \"EXPRESIÓN\"'.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve 1 si la EXPRESIÓN evalúa a 0; devuelve 0 en caso contrario."

#: builtins.c:1793
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries used\n"
"    by the `test' builtin, and may be combined using the following operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Ejecuta una orden condicional.\n"
"    \n"
"    Devuelve un estado de 0 ó 1 dependiendo de la evaluación de la expresión\n"
"    condicional EXPRESIÓN.  Las expresiones se componen de los mismos\n"
"    elementos primarios usados por la orden interna `test', y se pueden\n"
"    combinar usando los siguientes operadores:\n"
"    \n"
"      ( EXPRESIÓN )\tDevuelve el valor de la EXPRESIÓN\n"
"      ! EXPRESIÓN\t\tVerdadero si la EXPRESIÓN es falsa; de otra forma es falso\n"
"      EXPR1 && EXPR2\tVerdadero si EXPR1 y EXPR2 son verdaderos; de\n"
"    \t\totra forma es falso\n"
"    \tEXPR1 || EXPR2\tVerdadero si EXPR1 o EXPR2 es verdadero; de\n"
"    \t\totra forma es falso\n"
"    \n"
"    Cuando se usan los operadores `==' y `!=', se usa la cadena a la\n"
"    derecha del operador como un patrón y se realiza una coincidencia de\n"
"    patrones.  Cuando se usa el operador `=~', la cadena a la derecha del\n"
"    operador coincide como una expresión regular.\n"
"    \n"
"    Los operadores && y || no evalúan EXPR2 si EXPR1 es suficiente para\n"
"    determinar el valor de una expresión.    \n"
"    Estado de Salida:\n"
"    0 o 1 dependiendo del valor de la EXPRESIÓN."

#: builtins.c:1819
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Nombres de variables de shell comunes y su uso.\n"
"    \n"
"    BASH_VERSION\tInformación de versión para este Bash.\n"
"    CDPATH\tUna lista de directorios separada por dos puntos\n"
"    \t\tpara buscar directorios dados como argumentos para `cd'.\n"
"    GLOBIGNORE\tUna lista de patrones separada por dos puntos\n"
"    \t\tque describe nombres de fichero a ignorar por la expansión\n"
"    \t\tde rutas de nombre.\n"
"    HISTFILE\tEl nombre del fichero donde se almacena su historia\n"
"    \t\tde órdenes.\n"
"    HISTFILESIZE\t El número máximo de líneas que puede contener\n"
"    \t\teste fichero.\n"
"    HISTSIZE\t El número máximo de líneas de historia que un shell\n"
"    \t\ten ejecución puede acceder.\n"
"    HOME\tLa ruta completa a su directorio de entrada.\n"
"    HOSTNAME\tEl nombre del anfitrión actual.\n"
"    HOSTTYPE\tEl tipo de CPU bajo el cual se ejecuta esta versión\n"
"    \t\tde Bash.\n"
"    IGNOREEOF\tControla la acción del shell al recibir un carácter\n"
"    \t\tFDL como la única entrada.  Si está definida, entonces su\n"
"    \t\tvalor es el número de caracteres FDL que se deben leer de\n"
"    \t\tforma consecutiva en una línea vacía antes de que el shell\n"
"    \t\ttermine (por defecto 10).  Cuando no está definida, EOF\n"
"    \t\tsignifica el fin de la entrada.\n"
"    MACHTYPE\tUna cadena que describe el sistema actual donde se\n"
"    \t\tejecuta Bash.\n"
"    MAILCHECK\tLa frecuencia, en segundos, que Bash busca correo nuevo.\n"
"    MAILPATH\tUna lista de nombres de ficheros separada por dos puntos\n"
"    \t\ten la cual Bash busca correo nuevo.\n"
"    OSTYPE\tla versión de Unix en la que se ejecuta esta versión\n"
"    \t\tde Bash.\n"
"    PATH\tUna lista de directorios separada por dos puntos en la que\n"
"    \t\tse buscan órdenes.\n"
"    PROMPT_COMMAND\tUna orden a ejecutar antes de mostrar cada prompt\n"
"    \t\tprimario.\n"
"    PS1\t\tLa cadena primaria de prompt.\n"
"    PS2\t\tLa cadena secundaria de prompt.\n"
"    PWD\t\tLa ruta completa del directorio actual.\n"
"    SHELLOPTS\tUna lista separada por dos puntos de las opciones\n"
"    \t\tde shell activadas.\n"
"    TERM\tEl nombre del tipo actual de terminal.\n"
"    TIMEFORMAT\tEl formato de salida para las estadísticas de tiempo\n"
"    \t\tmostradas por la palabra reservada `time'.\n"
"    auto_resume\tSi no es nulo significa que una palabra de orden\n"
"    \t\tque aparece en una línea por sí sola se busca primero en la lista\n"
"    \t\tactual de trabajos detenidos.  Si se encuentra ahí, esetrabajo\n"
"    \t\tse coloca en primer plano.  Un valor `exact' significa que la\n"
"    \t\tpalabra de orden debe coincidir exactamente con una\n"
"    \t\torden de la lista de trabajos detenidos.  Un valor\n"
"    \t\t`substring' significa que la palabra de orden debe coincidir\n"
"    \t\tcon una subcadena del trabajo.  Cualquier otro valor significa\n"
"    \t\tque la orden debe ser un prefijo de un trabajo detenido.\n"
"    histchars\tLos caracteres que controlan la expansión de historia\n"
"    \t\ty la sustitución rápida.  El primer carácter es el carácter de\n"
"    \t\tsustitución de historia, generalmente `!'.  El segundo es el\n"
"    \t\tcarácter de `sustitución rápida', generalmente `^'.  El tercero\n"
" \n"
"    \t\tes el carácter `comentario de historia', generalmente `#'.\n"
"    HISTIGNORE\tUna lista separada por dos puntos de patrones\n"
"    \t\tutilizados para decidir qué órdenes se deben guardar en\n"
"    \t\tel listado histórico.\n"

#: builtins.c:1876
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Agrega directorios a la pila.\n"
"    \n"
"    Agrega un directorio por la parte superior de la pila de directorios\n"
"    o rota la pila, haciendo que el nuevo elemento superior de la pila sea el\n"
"    directorio de trabajo actual.  Sin argumentos, intercambia\n"
"    los dos directorios de la parte superior.\n"
"    \n"
"    Opciones:\n"
"      -n\tsuprime el cambio normal de directorio cuando se agregan\n"
"    \t\tdirectorios a la pila, así sólo se manipula la pila.\n"
"    \n"
"    Argumentos:\n"
"      +N\tRota la pila para que el N-ésimo directorio (contando\n"
"    \t\tdesde la izquierda de la lista mostrada por `dirs', comenzando\n"
"    \t\tdesde cero) esté en la parte superior.\n"
"    \n"
"      -N\tRota la pila para que el N-ésimo directorio (contando desde\n"
"    \t\tla derecha de la lista mostrada por `dirs', comenzando\n"
"    \t\tdesde cero) esté en la parte superior.\n"
"    \n"
"      dir\tAgrega DIR la pila de directorios por la parte superior, haciendo\n"
"    \t\tde él el nuevo directorio de trabajo actual.\n"
"    \n"
"    La orden interna `dirs' muestra la pila de directorios.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se proporcione un argumento\n"
"    inválido o falle el cambio de directorio."

#: builtins.c:1910
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Borra directorios de la pila.\n"
"    \n"
"    Borra entradas de la pila de directorios.  Sin argumentos,\n"
"    borra el directorio del tope de la pila, y cambia al nuevo\n"
"    directorio tope.\n"
"    \n"
"    Opciones:\n"
"      -n\tSuprime el cambio normal de directorio cuando se borran\n"
"    \t\tdirectorios de la pila; así sólo se manipula la pila.\n"
"    \n"
"    Argumentos:\n"
"    \n"
"      +N\tBorra la N-ésima entrada contando desde la izquierda de\n"
"    \t\tla lista mostrada por `dirs', comenzando por cero. Por\n"
"    \t\tejemplo: `popd +0' borra el primer directorio, `popd +1'\n"
"    \t\tel segundo.\n"
"    \n"
"      -N\tBorra la N-ésima entrada contando desde la derecha de\n"
"    \t\tla lista mostrada por `dirs', comenzando por cero. Por\n"
"    \t\tejemplo: `popd -0' borra el último directorio, `popd -1'\n"
"    \t\tel penúltimo.\n"
"    \n"
"    La orden interna `dirs' muestra la pila de directorios.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se proporcione un\n"
"    argumento inválido o falle el cambio de directorio."

#: builtins.c:1940
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Muestra la pila de directorios.\n"
"    \n"
"    Muestra la lista de directorios actualmente grabados.  Los directorios\n"
"    se guardan en la lista con la orden `pushd'; pueden ir saliendo de\n"
"    la lista con la orden `popd'.\n"
"    \n"
"    Opciones:\n"
"      -c\tlimpia la pila de directorios, eliminando todos sus elementos.\n"
"      -l\tno muestra versiones con prefijo de tilde de los directorios\n"
"    \t\trelativos a su directorio inicial.\n"
"      -p\tmuestra la pila de directorios con una entrada por línea\n"
"      -v\tmuestra la pila de directorios con una entrada por línea con\n"
"    \t\tsu posición en la pila como prefijo\n"
"    \n"
"    Argumentos:\n"
"      +N\tmuestra la N-ésima entrada contando desde\n"
"    \t\tla izquierda de la lista mostrada por dirs cuando se invoca sin\n"
"    \t\topciones, empezando de cero.\n"
"    \n"
"      -N\tmuestra la N-ésima entrada contando desde la izquierda de la\n"
"    \t\tlista mostrada por dirs cuando se invoca sin opciones, empezando\n"
"    \t\tdesde cero.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto, a menos que se proporcione una opción inválida o\n"
"    suceda un error."

#: builtins.c:1971
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Activa y desactiva opciones de shell.\n"
"    \n"
"    Cambia la configuración de cada opción de shell NOMBRE_OPCIÓN. Sin\n"
"    ninguna opción como argumento, muestra cada NOMBRE_OPCIÓN\n"
"    proporcionado o todas las opciones de shell si no se especifica\n"
"    ningún NOMBRE_OPCIÓN, con una indicación de si está activa o no\n"
"    cada una.\n"
"    \n"
"    Opciones:\n"
"      -o\trestringe NOMBRE_OPCIÓN a aquellos definidos con `set -o'\n"
"      -p\tmuestra cada opción de shell con un indicador de su estado\n"
"      -q\tsuprime la salida\n"
"      -s\tactiva (establece) cada NOMBRE_OPCIÓN\n"
"      -u\tdesactiva (borra) cada NOMBRE_OPCIÓN\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto si se activa NOMBRE_OPCIÓN; falla si se proporciona\n"
"    una opción inválida o NOMBRE_OPCIÓN está desactivado."

#: builtins.c:1992
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: plain\n"
"    characters, which are simply copied to standard output; character escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format characters csndiouxXeEfFgGaA described\n"
"    in printf(3), printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or assignment\n"
"    error occurs."
msgstr ""
"Da formato y muestra ARGUMENTOS bajo el control del FORMATO.\n"
"    \n"
"    Opciones:\n"
"      -v var\tasigna la salida a la variable de shell VAR en lugar\n"
"    \t\tde mostrarla en la salida estándar\n"
"    \n"
"    FORMATO es una cadena de caracteres la cual contiene tres tipos de\n"
"    objetos: caracteres simples, los cuales solamente se copian a la salida\n"
"    salida estándar; secuencias de escape de caracteres, las cuales\n"
"    se convierten y se copian a la salida estándar; y especificaciones de\n"
"    formato, cada una de las cuales causa la muestra del siguiente argumento\n"
"    consecutivo.\n"
"    \n"
"    Además de las especificaciones de formato estándar csndiouxXeEfFgGaA\n"
"    descritas en printf(3), printf interpreta:\n"
"    \n"
"      %b\texpande las secuencias de escape de barra invertida en\n"
"    \t\tel argumento correspondiente\n"
"      %q\tentrecomilla el argumento de tal forma que se pueda reutilizar\n"
"    \t\tcomo entrada del shell.\n"
"      %Q\tigual que %q, pero aplica la precisión al argumento sin\n"
"    \t\tentrecomillar antes de entrecomillarlo\n"
"      %(fmt)T muestra la cadena fecha hora resultante de usar FMT como\n"
"            una cadena de formato para strftime(3)\n"
"    \n"
"    El formato se reutiliza según sea necesario para consumir todos los\n"
"    argumentos.  Si hay menos argumentos de los que el formato requiere,\n"
"    las especificaciones de formato adicionales se comportan como si un valor\n"
"    cero o una cadena nula, lo que sea apropiado, se hubiera proporcionado.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se proporcione una opción inválida o\n"
"    suceda un error de escritura o de asignación."

#: builtins.c:2028
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no options\n"
"    or NAMEs are supplied, display existing completion specifications in a way\n"
"    that allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Especifica cuántos argumentos deben ser completados por Readline.\n"
"    \n"
"    Para cada NOMBRE, especifica cómo completar los argumentos.  Si no se\n"
"    proporcionan opciones ni NOMBREs, muestra las especificaciones de\n"
"    completado existentes de forma que puedan reutilizarse como entrada.\n"
"    \n"
"    Opciones:\n"
"      -p\tmuestra las especificaciones de completado existentes en formato\n"
"    \t\treusable\n"
"      -r\tborra una especificación de completado para cada NOMBRE o,\n"
"    \t\tsi no se proporcionan NOMBREs, todas las especificaciones\n"
"    \t\tde completado\n"
"      -D\taplica los completados y acciones por defecto para las órdenes\n"
"    \t\tsin ninguna especificación de completado definida\n"
"      -E\taplica los completados y acciones para órdenes \"vacías\" --\n"
"    \t\tcuando se intenta completar en una línea en blanco\n"
"      -I\taplica los completados a acciones a la palabra incial (habitualmente\n"
"    \t\tla orden)\n"
"    \n"
"    Cuando se intenta el completado, las acciones se aplican en el orden\n"
"    en que se listan las opciones de letra mayúscula antes indicadas. Si se\n"
"    proporcionan varias opciones, la opción -D tiene precedencia sobre -E y,\n"
"    ambas, sobre -I.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se proporcione una opción inválida o\n"
"    suceda un error."

#: builtins.c:2058
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is present, generate matches\n"
"    against WORD.\n"
"    \n"
"    If the -V option is supplied, store the possible completions in the indexed\n"
"    array VARNAME instead of printing them to the standard output.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Muestra los posibles complementos dependiendo de las opciones.\n"
"    \n"
"    Sirve para usarse desde una función de shell que genere complementos\n"
"    posibles.  Si el argumento opcional PALABRA está presente, se generan\n"
"    las coincidencias contra PALABRA.\n"
"    \n"
"    Si se proporciona la opción -V, almacena los posibles completados en la\n"
"    matriz indexada VARNAME en lugar de imprimirlos en la salida estándar.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se proporcione una opción inválida o\n"
"    suceda un error."

#: builtins.c:2076
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, print\n"
"    the completion options for each NAME or the current completion specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Modifica o muestra las opciones de completado.\n"
"    \n"
"    Modifica las opciones de completado para cada NOMBRE, o, si no se\n"
"    proporcionan NOMBREs, el completado actualmente en ejecución.  Si no\n"
"    se proporcionan OPCIONes, muestra las opciones de completado para\n"
"    cada NOMBRE o la especificación de completado actual.\n"
"    \n"
"    Opciones:\n"
"    \t-o opción\tEstablece la opción de completado OPCIÓN para cada NOMBRE\n"
"    \t-D\t\tCambia las opciones para el completado de orden \"por defecto\"\n"
"    \t-E\t\tCambia las opciones para el completado de orden \"vacía\"\n"
"    \t-I\t\tCambia las opciones para el completado en la palabra inicial\n"
"    \n"
"    Si se usa `+o' en lugar de `-o', desactiva la opción especificada.\n"
"    \n"
"    Argumentos:\n"
"    \n"
"    Cada NOMBRE se refiere a una orden para la cual se definió previamente\n"
"    una especificación de completado usando la orden interna `complete'.\n"
"    Si no se proporcionan NOMBREs, se debe llamar a ‘compopt’ desde una\n"
"    función que genere completados actualmente y se modifican las opciones\n"
"    para ese generador de completados actualmente en ejecución.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se proporcione una opción inválida o\n"
"    NOMBRE no tenga una especificación de completado definida."

#: builtins.c:2107
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly or\n"
"    not an indexed array."
msgstr ""
"Lee líneas de un fichero y las guarda en una variable de matriz indexada.\n"
"    \n"
"    Lee líneas de la entrada estándar y las guarda en la variable de matriz\n"
"    indexada MATRIZ, o desde el descriptor de fichero DF si se proporciona\n"
"    la opción -u.  La variable MAPFILE es la MATRIZ por defecto.\n"
"    \n"
"    Opciones:\n"
"      -d delim\tUtiliza DELIM para finalizar las líneas en lugar de nueva línea\n"
"      -n cuenta\tCopia hasta CUENTA líneas.  Si CUENTA es 0, se copian todas\n"
"      -O origen\tComienza a asignar a MATRIZ en el índice ORIGEN.  El\n"
"    \t\t\tíndice por defecto es 0.\n"
"      -s cuenta\tDescarta las primeras CUENTA líneas leídas.\n"
"      -t\tBorra el DELIM final de cada línea leída (nueva línea por defecto).\n"
"      -u df\tLee líneas del descriptor de fichero DF en lugar de la\n"
"    \t\t\tentrada estándar.\n"
"      -C llamada\tEvalúa LLAMADA cada vez que se leen QUANTUM líneas.\n"
"      -c quantum\tEspecifica el número de líneas a leer entre cada\n"
"    \t\t\tllamada a LLAMADA.\n"
"    \n"
"    Argumentos:\n"
"      MATRIZ\tNombre de variable de matriz a usar para guardar datos.\n"
"    \n"
"    Si se proporciona -C sin -c, el quantum por defecto es 5000.  Cuando\n"
"    se evalúa LLAMADA, se proporciona el índice del siguiente elemento\n"
"    de la matriz a asignar como un argumento adicional.\n"
"    \n"
"    Si no se proporciona un origen explícito, mapfile borrará la MATRIZ\n"
"    antes de usarla para asignación.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve correcto a menos que se proporcione una opción inválida o\n"
"    la MATRIZ sea de sólo lectura o no sea una matriz indexada."

#: builtins.c:2143
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Lee líneas de un fichero en una variable de matriz.\n"
"    \n"
"    Sinónimo de `mapfile'."

#~ msgid ""
#~ "Returns the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
#~ "    \"$line $subroutine $filename\"; this extra information can be used to\n"
#~ "    provide a stack trace.\n"
#~ "    \n"
#~ "    The value of EXPR indicates how many call frames to go back before the\n"
#~ "    current one; the top frame is frame 0."
#~ msgstr ""
#~ "Devuelve el contexto de la llamada a subrutina actual.\n"
#~ "    \n"
#~ "    Sin EXPR, devuelve \"$linea $nombrefichero\".  Con EXPR, devuelve\n"
#~ "    \"$linea $subrutina $nombrefichero\"; esta información adicional\n"
#~ "    se puede usar para proporcionar un volcado de pila.\n"
#~ "    \n"
#~ "    El valor de EXPR indica cuántos marcos de llamada hay que retroceder\n"
#~ "    antes del actual; el marco superior es el marco 0."

#, c-format
#~ msgid "%s: cannot open: %s"
#~ msgstr "%s: no se puede abrir: %s"

#, c-format
#~ msgid "%s: inlib failed"
#~ msgstr "%s: falló inlib"

#, c-format
#~ msgid "warning: %s: %s"
#~ msgstr "aviso: %s: %s"

#, c-format
#~ msgid "%s: %s"
#~ msgstr "%s: %s"

# file=fichero. archive=archivo. Si no, es imposible traducir tar. sv
# De acuerdo. Corregido en todo el fichero. cfuga
#, c-format
#~ msgid "%s: cannot execute binary file: %s"
#~ msgstr "%s: no se puede ejecutar fichero binario: %s"

#, c-format
#~ msgid "setlocale: LC_ALL: cannot change locale (%s)"
#~ msgstr "setlocale: LC_ALL: no se puede cambiar el local (%s)"

#, c-format
#~ msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
#~ msgstr "setlocale: LC_ALL: no se puede cambiar el local (%s): %s"

#, c-format
#~ msgid "setlocale: %s: cannot change locale (%s): %s"
#~ msgstr "setlocale: %s: no se puede cambiar el local (%s): %s"

#~ msgid "%s: invalid associative array key"
#~ msgstr "%s: clave de matriz asociativa no válida"

#~ msgid ""
#~ "Returns the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns "
#~ msgstr ""
#~ "Devuelve el contexto de la llamada a subrutina actual.\n"
#~ "    \n"
#~ "    Sin EXPR, devuelve "

#~ msgid "add_process: process %5ld (%s) in the_pipeline"
#~ msgstr "add_process: el proceso %5ld (%s) en the_pipeline"

#~ msgid "Unknown Signal #"
#~ msgstr "Señal Desconocida #"
