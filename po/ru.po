# GNU Bourne Again SHell.
# Copyright (C) 2002 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Ruslan Batdalov <linnando@tolkien.ru>, 2002.
# Pavlo Marianov <acid@jack.kiev.ua>, 2014, 2018, 2020, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: bash 5.2-rc1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-11 14:50-0500\n"
"PO-Revision-Date: 2023-08-04 09:34+0300\n"
"Last-Translator: Pavlo Marianov <acid@jack.kiev.ua>\n"
"Language-Team: Russian <gnu@d07.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"X-Generator: Poedit 3.2.2\n"

#: arrayfunc.c:66
msgid "bad array subscript"
msgstr "неправильный индекс массива"

#: arrayfunc.c:471 builtins/declare.def:709 variables.c:2242 variables.c:2268
#: variables.c:3101
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: удаляется атрибут nameref"

#: arrayfunc.c:496 builtins/declare.def:868
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: не удаётся преобразовать индекс в ассоциативный массив"

#: arrayfunc.c:777
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: не удаётся присвоить значение нечисловому индексу"

#: arrayfunc.c:822
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: необходимо использовать индекс при назначении ассоциативному массиву"

#: bashhist.c:455
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: не удаётся создать файл: %s"

#: bashline.c:4479
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: не удаётся найти раскладку для команды"

#: bashline.c:4637
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: первый непробельный символ не является «\"»"

#: bashline.c:4666
#, c-format
msgid "no closing `%c' in %s"
msgstr "нет закрывающего «%c» в %s"

#: bashline.c:4697
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: отсутствует разделитель-двоеточие"

#: bashline.c:4733
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "«%s»: не удаётся отменить привязку в keymap команды"

#: braces.c:327
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "расширение скобки: не удаётся выделить память для %s"

#: braces.c:406
#, c-format
msgid "brace expansion: failed to allocate memory for %u elements"
msgstr "расширение скобки: не удалось выделить память для %u элементов"

#: braces.c:451
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "расширение скобки: не удалось выделить память для «%s»"

#: builtins/alias.def:131 variables.c:1817
#, c-format
msgid "`%s': invalid alias name"
msgstr "«%s»: недопустимый псевдоним"

#: builtins/bind.def:122 builtins/bind.def:125
msgid "line editing not enabled"
msgstr "редактирование строки не включено"

#: builtins/bind.def:212
#, c-format
msgid "`%s': invalid keymap name"
msgstr "«%s»: недопустимое название раскладки"

#: builtins/bind.def:252
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: не удаётся прочитать файл: %s"

#: builtins/bind.def:328 builtins/bind.def:358
#, c-format
msgid "`%s': unknown function name"
msgstr "«%s»: неизвестное название функции"

#: builtins/bind.def:336
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s не привязан ни к какой клавише.\n"

#: builtins/bind.def:340
#, c-format
msgid "%s can be invoked via "
msgstr "%s можно вызвать через "

#: builtins/bind.def:378 builtins/bind.def:395
#, c-format
msgid "`%s': cannot unbind"
msgstr "«%s»: не удаётся отменить привязку"

#: builtins/break.def:77 builtins/break.def:119
msgid "loop count"
msgstr "счётчик циклов"

#: builtins/break.def:139
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "имеет значение только для циклов «for», «while» или «until»"

#: builtins/caller.def:136
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
"Возвращает контекст вызова текущей подпрограммы.\n"
"    \n"
"    Если выражение не указано, возвращает «$line $filename».\n"
"    Если выражение указано, возвращает «$line $subroutine $filename».\n"
"    Эти дополнительные данные можно использовать для трассировки\n"
"    стека.\n"
"    \n"
"    Значение выражения означает количество кадров, которое нужно\n"
"    вызвать для возврата к текущему кадру. Первый кадр имеет номер 0."

#: builtins/cd.def:327
msgid "HOME not set"
msgstr "Не задана переменная HOME"

#: builtins/cd.def:335 builtins/common.c:161 test.c:916
msgid "too many arguments"
msgstr "слишком много аргументов"

#: builtins/cd.def:342
msgid "null directory"
msgstr "нулевой каталог"

#: builtins/cd.def:353
msgid "OLDPWD not set"
msgstr "Не задана переменная OLDPWD"

#: builtins/common.c:96
#, c-format
msgid "line %d: "
msgstr "строка %d: "

#: builtins/common.c:134 error.c:264
#, c-format
msgid "warning: "
msgstr "предупреждение: "

#: builtins/common.c:148
#, c-format
msgid "%s: usage: "
msgstr "%s: использование: "

#: builtins/common.c:193 shell.c:524 shell.c:866
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: для параметра требуется аргумент"

#: builtins/common.c:200
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: требуется числовой аргумент"

#: builtins/common.c:207
#, c-format
msgid "%s: not found"
msgstr "%s: не найден"

#: builtins/common.c:216 shell.c:879
#, c-format
msgid "%s: invalid option"
msgstr "%s: недопустимый параметр"

#: builtins/common.c:223
#, c-format
msgid "%s: invalid option name"
msgstr "%s: недопустимое название параметра"

#: builtins/common.c:230 execute_cmd.c:2402 general.c:368 general.c:373
#, c-format
msgid "`%s': not a valid identifier"
msgstr "«%s»: это недопустимый идентификатор"

#: builtins/common.c:240
msgid "invalid octal number"
msgstr "недопустимое восьмеричное число"

#: builtins/common.c:242
msgid "invalid hex number"
msgstr "недопустимое шестнадцатеричное число"

#: builtins/common.c:244 expr.c:1574
msgid "invalid number"
msgstr "недопустимое число"

#: builtins/common.c:252
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: недопустимое указание сигнала"

#: builtins/common.c:259
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "«%s»: это не идентификатор процесса и не допустимый указатель задания"

#: builtins/common.c:266 error.c:536
#, c-format
msgid "%s: readonly variable"
msgstr "%s: переменная только для чтения"

#: builtins/common.c:273
#, fuzzy, c-format
#| msgid "%s: cannot unset"
msgid "%s: cannot assign"
msgstr "%s: не удаётся выполнить сброс"

#: builtins/common.c:281
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s за пределами диапазона"

#: builtins/common.c:281 builtins/common.c:283
msgid "argument"
msgstr "аргумент"

#: builtins/common.c:283
#, c-format
msgid "%s out of range"
msgstr "%s за пределами диапазона"

#: builtins/common.c:291
#, c-format
msgid "%s: no such job"
msgstr "%s: нет такого задания"

#: builtins/common.c:299
#, c-format
msgid "%s: no job control"
msgstr "%s: нет управления заданиями"

#: builtins/common.c:301
msgid "no job control"
msgstr "нет управления заданиями"

#: builtins/common.c:311
#, c-format
msgid "%s: restricted"
msgstr "%s: ограниченный режим"

#: builtins/common.c:313
msgid "restricted"
msgstr "ограниченный режим"

#: builtins/common.c:321
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: это не не встроенная команда bash"

#: builtins/common.c:330
#, c-format
msgid "write error: %s"
msgstr "ошибка записи: %s"

#: builtins/common.c:338
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "ошибка назначения атрибутов терминала: %s"

#: builtins/common.c:340
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "ошибка получения атрибутов терминала: %s"

#: builtins/common.c:642
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: ошибка определения текущего каталога: %s: %s\n"

#: builtins/common.c:708 builtins/common.c:710
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: неоднозначный указатель задания"

#: builtins/common.c:971
msgid "help not available in this version"
msgstr "справка отсутствует в этой версии"

#: builtins/common.c:1038 builtins/set.def:953 variables.c:3825
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: не удаётся выполнить сброс: %s доступен только для чтения"

#: builtins/common.c:1043 builtins/set.def:932 variables.c:3830
#, c-format
msgid "%s: cannot unset"
msgstr "%s: не удаётся выполнить сброс"

#: builtins/complete.def:287
#, c-format
msgid "%s: invalid action name"
msgstr "%s: недопустимое название действия"

#: builtins/complete.def:486 builtins/complete.def:642
#: builtins/complete.def:873
#, c-format
msgid "%s: no completion specification"
msgstr "%s: нет определения завершения"

#: builtins/complete.def:696
msgid "warning: -F option may not work as you expect"
msgstr "предупреждение: параметр -F может работать не так, как ожидается"

#: builtins/complete.def:698
msgid "warning: -C option may not work as you expect"
msgstr "предупреждение: параметр -C может работать не так, как ожидается"

#: builtins/complete.def:846
msgid "not currently executing completion function"
msgstr "сейчас не выполняет функцию завершения"

#: builtins/declare.def:137
msgid "can only be used in a function"
msgstr "можно использовать только внутри функции"

#: builtins/declare.def:437
msgid "cannot use `-f' to make functions"
msgstr "«-f» нельзя использовать для создания функций"

#: builtins/declare.def:464 execute_cmd.c:6132
#, c-format
msgid "%s: readonly function"
msgstr "%s: значение функции можно только считать"

#: builtins/declare.def:521 builtins/declare.def:804
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: ссылочная переменная не может быть массивом"

#: builtins/declare.def:532 variables.c:3359
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s: переменные nameref, ссылающиеся сами на себя, не допускаются"

#: builtins/declare.def:537 variables.c:2072 variables.c:3278 variables.c:3286
#: variables.c:3356
#, c-format
msgid "%s: circular name reference"
msgstr "%s: круговая ссылка на имя"

#: builtins/declare.def:541 builtins/declare.def:811 builtins/declare.def:820
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "«%s»: недопустимое название переменной для ссылки на имя"

#: builtins/declare.def:856
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: переменные массива нельзя уничтожить таким образом"

#: builtins/declare.def:862 builtins/read.def:887
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: не удаётся преобразовать ассоциативный массив в индексированный"

#: builtins/declare.def:891
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s: присвоение составного массива в кавычках устарело"

#: builtins/enable.def:145 builtins/enable.def:153
msgid "dynamic loading not available"
msgstr "динамическая загрузка недоступна"

#: builtins/enable.def:376
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "не удаётся открыть общий объект %s: %s"

#: builtins/enable.def:405
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "не удаётся найти %s в общем объекте %s: %s"

#: builtins/enable.def:422
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: динамически встроенная команда уже загружена"

#: builtins/enable.def:426
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "загрузка функции %s завершилась ошибкой (%d): не загружена"

#: builtins/enable.def:551
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: не загружается динамически"

#: builtins/enable.def:577
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: не удаётся удалить: %s"

#: builtins/evalfile.c:138 builtins/hash.def:185 execute_cmd.c:5959
#, c-format
msgid "%s: is a directory"
msgstr "%s: это каталог"

#: builtins/evalfile.c:144
#, c-format
msgid "%s: not a regular file"
msgstr "%s: это не обычный файл"

#: builtins/evalfile.c:153
#, c-format
msgid "%s: file is too large"
msgstr "%s: файл слишком велик"

#: builtins/evalfile.c:188 builtins/evalfile.c:206 shell.c:1673
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: не удаётся запустить бинарный файл"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:246
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: не удаётся запустить: %s"

#: builtins/exit.def:64
#, c-format
msgid "logout\n"
msgstr "выход\n"

#: builtins/exit.def:89
msgid "not login shell: use `exit'"
msgstr "не командный процессор login: используйте «exit»"

#: builtins/exit.def:121
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Есть остановленные задания.\n"

#: builtins/exit.def:123
#, c-format
msgid "There are running jobs.\n"
msgstr "Есть выполняемые задания.\n"

#: builtins/fc.def:275 builtins/fc.def:373 builtins/fc.def:417
msgid "no command found"
msgstr "команда не найдена"

#: builtins/fc.def:363 builtins/fc.def:368 builtins/fc.def:407
#: builtins/fc.def:412
msgid "history specification"
msgstr "указание журнала команд"

#: builtins/fc.def:444
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: не удаётся открыть временный файл: %s"

#: builtins/fg_bg.def:152 builtins/jobs.def:284
msgid "current"
msgstr "текущий"

#: builtins/fg_bg.def:161
#, c-format
msgid "job %d started without job control"
msgstr "задание %d запущено без возможности управления"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: недопустимый параметр — %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: для параметра требуется аргумент — %c\n"

#: builtins/hash.def:91
msgid "hashing disabled"
msgstr "хэширование отключено"

#: builtins/hash.def:139
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: таблица хэшей пустая\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "вызовы\tкоманда\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Команды, соответствующие ключевому слову «"
msgstr[1] "Команды, соответствующие ключевым словам «"
msgstr[2] "Команды, соответствующие ключевым словам «"

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"'\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid "no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr "нет разделов справки, соответствующих «%s».  Попробуйте ввести «help help» или «man -k %s» или «info %s»."

#: builtins/help.def:223
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: не удаётся открыть файл: %s"

#: builtins/help.def:523
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Показанные ниже команды определены внутри командного процессора.  Чтобы вывести полный список, введите «help».\n"
"Чтобы вывести справку по функции «name», введите «help name».\n"
"Чтобы вывести справку по командному процессору, введите «info bash».\n"
"Чтобы вывести справку по командам, которые отсутствуют в этом списке, введите «man -k» или «info».\n"
"\n"
"Звёздочка (*) рядом с названием команды означает, что эта команда отключена.\n"
"\n"

#: builtins/history.def:159
msgid "cannot use more than one of -anrw"
msgstr "нельзя использовать больше одного параметра -anrw"

#: builtins/history.def:192 builtins/history.def:204 builtins/history.def:215
#: builtins/history.def:228 builtins/history.def:240 builtins/history.def:247
msgid "history position"
msgstr "положение журнала команд"

#: builtins/history.def:338
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: недопустимая метка времени"

#: builtins/history.def:449
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: не удалось расширить журнал команд"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: ошибка inlib"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "с параметром «-x» нельзя указывать другие параметры"

#: builtins/kill.def:211
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: аргументами должны быть идентификаторы процессов или заданий"

#: builtins/kill.def:274
msgid "Unknown error"
msgstr "Неизвестная ошибка"

#: builtins/let.def:97 builtins/let.def:122 expr.c:640 expr.c:658
msgid "expression expected"
msgstr "ожидается выражение"

#: builtins/mapfile.def:180
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: это не индексированный массив"

#: builtins/mapfile.def:276 builtins/read.def:336
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: недопустимое указание дескриптора файла"

#: builtins/mapfile.def:284 builtins/read.def:343
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: invalid недопустимый дескриптор файла: %s"

#: builtins/mapfile.def:293 builtins/mapfile.def:331
#, c-format
msgid "%s: invalid line count"
msgstr "%s: недопустимое число строк"

#: builtins/mapfile.def:304
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: недопустимое начало массива"

#: builtins/mapfile.def:321
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: недопустимый квант обратного вызова"

#: builtins/mapfile.def:354
msgid "empty array variable name"
msgstr "пустое имя переменной массива"

#: builtins/mapfile.def:375
msgid "array variable support required"
msgstr "требуется поддержка переменных массива"

#: builtins/printf.def:430
#, c-format
msgid "`%s': missing format character"
msgstr "«%s»: отсутствует символ форматирования"

#: builtins/printf.def:485
#, c-format
msgid "`%c': invalid time format specification"
msgstr "«%c»: недопустимое указание формата времени"

#: builtins/printf.def:708
#, c-format
msgid "`%c': invalid format character"
msgstr "«%c»: недопустимый символ форматирования"

#: builtins/printf.def:734
#, c-format
msgid "warning: %s: %s"
msgstr "предупреждение: %s: %s"

#: builtins/printf.def:822
#, c-format
msgid "format parsing problem: %s"
msgstr "ошибка анализа формата: %s"

#: builtins/printf.def:919
msgid "missing hex digit for \\x"
msgstr "отсутствует шестнадцатеричная цифра для \\x"

#: builtins/printf.def:934
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "отсутствует цифра Юникода для \\%c"

#: builtins/pushd.def:199
msgid "no other directory"
msgstr "отсутствует другой каталог"

#: builtins/pushd.def:360
#, c-format
msgid "%s: invalid argument"
msgstr "%s: недопустимый аргумент"

#: builtins/pushd.def:480
msgid "<no current directory>"
msgstr "<отсутствует текущий каталог>"

#: builtins/pushd.def:524
msgid "directory stack empty"
msgstr "стек каталогов пуст"

#: builtins/pushd.def:526
msgid "directory stack index"
msgstr "индекс стека каталогов"

#: builtins/pushd.def:701
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Выводит список запомненных на данный момент каталогов.  Каталоги\n"
"    помещаются в список командой «pushd». Для очистки\n"
"    списка используется команда «popd».\n"
"    \n"
"    Параметры:\n"
"      -c\tочистить стек каталогов, удалив из него все элементы\n"
"      -l\tне выводить каталоги, начинающиеся с тильды (~),\n"
"    \tкоторая означает домашний каталог\n"
"      -p\tпоказать стек по одному каталогу в строке\n"
"      -v\tпоказать стек по одному каталогу в строке\n"
"    \tи с номером в стеке\n"
"    \n"
"    Аргументы:\n"
"      +N\tпоказать N-ю запись слева в списке каталогов,\n"
"    \tпоказанного при вызове без параметров, начиная с нуля.\n"
"    \n"
"      -N\tпоказать N-ю запись справа в списке каталогов,\n"
"\tпоказанного при вызове без параметров, начиная с нуля."

#: builtins/pushd.def:723
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Добавляет каталог в начало стека каталогов или выполняет\n"
"    ротацию стека, помещая в начало стека текущий рабочий\n"
"    каталог.  Если аргументы не указаны, меняет местами два первых каталога.\n"
"    \n"
"    Параметры:\n"
"      -n\tпредотвращает обычное изменение каталога при добавлении\n"
"    \tкаталогов в стек, чтобы действия выполнялись только над стеком.\n"
"    \n"
"    Аргументы:\n"
"      +N\tвыполняет ротацию стека, чтобы N-й каталог (слева\n"
"    \tв списке, показанного командой «dirs», начиная с нуля)\n"
"    \tстал первым в стеке.\n"
"    \n"
"      -N\tвыполняет ротацию стека, чтобы N-й каталог (справа\n"
"    \tв списке, показанного командой «dirs», начиная с нуля)\n"
"    \tстал первым в стеке.\n"
"    \n"
"      каталог\tдобавляет каталог в начало стека каталогов, делая его\n"
"    \tновым текущим каталогом.\n"
"    \n"
"    Встроенная команда dirs показывает стек каталогов."

#: builtins/pushd.def:748
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Удаляет записи из стека каталогов.  Если аргументы не указаны,\n"
"    удаляет первый каталог из стека и назначает новый первый каталог.\n"
"    \n"
"    Параметры:\n"
"      -n\tпредотвращает обычное изменение каталога при удалении\n"
"    \tкаталогов из стека, чтобы действия выполнялись только над стеком.\n"
"    \n"
"    Аргументы:\n"
"      +N\tудаляет N-ю слева запись в списке каталогов,\n"
"    \tпоказанного командой «dirs», начиная с нуля.  Например, «popd +0»\n"
"    \tудаляет первый каталог, а «popd +1» — второй каталог.\n"
"    \n"
"      -N\tудаляет N-ю справа запись в списке каталогов,\n"
"    \tпоказанного командой «dirs», начиная с нуля.  Например, «popd -0»\n"
"    \tудаляет последний каталог, а «popd -1» — предпоследний каталог.\n"
"    \n"
"    Встроенная команда dirs показывает стек каталогов."

#: builtins/read.def:308
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: недопустимое указание тайм-аута"

#: builtins/read.def:827
#, c-format
msgid "read error: %d: %s"
msgstr "ошибка чтения: %d: %s"

#: builtins/return.def:68
msgid "can only `return' from a function or sourced script"
msgstr "возврат можно выполнить только из функции или исходного скрипта"

#: builtins/set.def:869
msgid "cannot simultaneously unset a function and a variable"
msgstr "нельзя одновременно сбросить функцию и переменную"

#: builtins/set.def:969
#, c-format
msgid "%s: not an array variable"
msgstr "%s: это не переменная массива"

#: builtins/setattr.def:189
#, c-format
msgid "%s: not a function"
msgstr "%s: это не функция"

#: builtins/setattr.def:194
#, c-format
msgid "%s: cannot export"
msgstr "%s: не удаётся экспортировать"

#: builtins/shift.def:72 builtins/shift.def:79
msgid "shift count"
msgstr "счётчик смещений"

#: builtins/shopt.def:323
msgid "cannot set and unset shell options simultaneously"
msgstr "нельзя одновременно задать и сбросить параметры командного процессора"

#: builtins/shopt.def:444
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: недопустимое название параметра командного процессора"

#: builtins/source.def:128
msgid "filename argument required"
msgstr "требуется аргумент с именем файла"

#: builtins/source.def:154
#, c-format
msgid "%s: file not found"
msgstr "%s: файл не найден"

#: builtins/suspend.def:102
msgid "cannot suspend"
msgstr "не удаётся приостановить"

#: builtins/suspend.def:112
msgid "cannot suspend a login shell"
msgstr "не удаётся приостановить командный процессор login"

#: builtins/type.def:235
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s — это псевдонимом для «%s»\n"

#: builtins/type.def:256
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s — это ключевое слово командного процессора\n"

#: builtins/type.def:275
#, c-format
msgid "%s is a function\n"
msgstr "%s — это функция\n"

#: builtins/type.def:299
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s — это специальная встроенная команда bash\n"

#: builtins/type.def:301
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s — это встроенная команда bash\n"

#: builtins/type.def:323 builtins/type.def:408
#, c-format
msgid "%s is %s\n"
msgstr "%s является %s\n"

#: builtins/type.def:343
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "для %s вычислен хэш (%s)\n"

#: builtins/ulimit.def:400
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: недопустимый аргумент ограничения"

#: builtins/ulimit.def:426
#, c-format
msgid "`%c': bad command"
msgstr "«%c»: недопустимая команда"

#: builtins/ulimit.def:464
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: не удаётся получить ограничение: %s"

#: builtins/ulimit.def:490
msgid "limit"
msgstr "ограничение"

#: builtins/ulimit.def:502 builtins/ulimit.def:802
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: не удаётся изменить ограничение: %s"

#: builtins/umask.def:115
msgid "octal number"
msgstr "восьмеричное число"

#: builtins/umask.def:232
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "«%c»: недопустимый оператор символьного режима"

#: builtins/umask.def:287
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "«%c»: недопустимый знак символьного режима"

#: error.c:89 error.c:373 error.c:375 error.c:377
msgid " line "
msgstr " строка "

#: error.c:164
#, c-format
msgid "last command: %s\n"
msgstr "последняя команда: %s\n"

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr "Прерывание..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:287
#, c-format
msgid "INFORM: "
msgstr "ИНФО: "

#: error.c:310
#, fuzzy, c-format
#| msgid "warning: "
msgid "DEBUG warning: "
msgstr "предупреждение: "

#: error.c:488
msgid "unknown command error"
msgstr "неизвестная ошибка команды"

#: error.c:489
msgid "bad command type"
msgstr "неверный тип команды"

#: error.c:490
msgid "bad connector"
msgstr "неверный соединитель"

#: error.c:491
msgid "bad jump"
msgstr "ошибка перехода"

#: error.c:529
#, c-format
msgid "%s: unbound variable"
msgstr "%s: не заданы границы переменной"

#: eval.c:243
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\aпревышено время ожидания ввода: auto-logout\n"

#: execute_cmd.c:555
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "не удаётся перенаправить стандартный ввод из /dev/null: %s"

#: execute_cmd.c:1317
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: «%c»: недопустимый символ форматирования"

#: execute_cmd.c:2391
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr "execute_coproc: coproc [%d:%s] всё ещё существует"

#: execute_cmd.c:2524
msgid "pipe error"
msgstr "ошибка конвейера"

#: execute_cmd.c:4923
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: достигнут максимальный уровень вложенности eval (%d)"

#: execute_cmd.c:4935
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: достигнут максимальный уровень вложенности source (%d)"

#: execute_cmd.c:5043
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: достигнут максимальный уровень вложенности функций (%d)"

#: execute_cmd.c:5598
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: ограниченный режим: в названиях команд нельзя использовать косую черту «/»"

#: execute_cmd.c:5715
#, c-format
msgid "%s: command not found"
msgstr "%s: команда не найдена"

#: execute_cmd.c:5957
#, c-format
msgid "%s: %s"
msgstr "%s: %s"

#: execute_cmd.c:5975
#, fuzzy, c-format
#| msgid "%s: cannot execute binary file"
msgid "%s: cannot execute: required file not found"
msgstr "%s: не удаётся запустить бинарный файл"

#: execute_cmd.c:6000
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: неверный интерпретатор"

#: execute_cmd.c:6037
#, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s: не удаётся запустить бинарный файл: %s"

#: execute_cmd.c:6123
#, c-format
msgid "`%s': is a special builtin"
msgstr "«%s»: это специальная встроенная команда"

#: execute_cmd.c:6175
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "не удаётся скопировать файловый дескриптор %d в %d"

#: expr.c:263
msgid "expression recursion level exceeded"
msgstr "слишком много вложенных выражений"

#: expr.c:291
msgid "recursion stack underflow"
msgstr "отрицательное переполнение стека вложенных выражений"

#: expr.c:478
msgid "syntax error in expression"
msgstr "синтаксическая ошибка в выражении"

#: expr.c:522
msgid "attempted assignment to non-variable"
msgstr "значение можно присвоить только переменной"

#: expr.c:531
msgid "syntax error in variable assignment"
msgstr "синтаксическая ошибка в назначении переменной"

#: expr.c:545 expr.c:912
msgid "division by 0"
msgstr "деление на 0"

#: expr.c:593
msgid "bug: bad expassign token"
msgstr "ошибка: недопустимый маркер присвоения выражения"

#: expr.c:647
msgid "`:' expected for conditional expression"
msgstr "в условном выражении должен быть символ «:»"

#: expr.c:973
msgid "exponent less than 0"
msgstr "экспонента меньше нуля"

#: expr.c:1030
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "после предварительного инкремента или декремента ожидается идентификатор"

#: expr.c:1057
msgid "missing `)'"
msgstr "отсутствует символ «)»"

#: expr.c:1108 expr.c:1492
msgid "syntax error: operand expected"
msgstr "синтаксическая ошибка: ожидается операнд"

#: expr.c:1494
msgid "syntax error: invalid arithmetic operator"
msgstr "ошибка синтаксиса: недопустимый математический оператор"

#: expr.c:1518
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (неверный маркер «%s»)"

#: expr.c:1578
msgid "invalid arithmetic base"
msgstr "недопустимое математическое основание"

#: expr.c:1587
msgid "invalid integer constant"
msgstr "недопустимая целочисленная константа"

#: expr.c:1603
msgid "value too great for base"
msgstr "слишком большое значение для основания"

#: expr.c:1652
#, c-format
msgid "%s: expression error\n"
msgstr "%s: ошибка выражения\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: нет доступа к родительским каталогам"

#: input.c:99 subst.c:6208
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "не удаётся сбросить режим nodelay для файлового дескриптора %d"

#: input.c:266
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "не удаётся выделить новый дескриптор для входных данных bash из файлового дескриптора %d"

#: input.c:274
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: у нового файлового дескриптора %d уже есть буфер"

#: jobs.c:543
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pgrp pipe"

#: jobs.c:907
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:960
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:1279
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "идентификатор дочернего процесса %d принадлежит запущенному заданию %d"

#: jobs.c:1397
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "удаление остановленного задания %d с группой процесса %ld"

#: jobs.c:1502
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: процесс с идентификатором %5ld (%s) помечен как всё ещё активный"

#: jobs.c:1839
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: нет процесса с таким идентификатором"

#: jobs.c:1854
#, c-format
msgid "Signal %d"
msgstr "Сигнал %d"

#: jobs.c:1868 jobs.c:1894
msgid "Done"
msgstr "Завершён"

#: jobs.c:1873 siglist.c:123
msgid "Stopped"
msgstr "Остановлен"

#: jobs.c:1877
#, c-format
msgid "Stopped(%s)"
msgstr "Остановлен (%s)"

#: jobs.c:1881
msgid "Running"
msgstr "Запущен"

#: jobs.c:1898
#, c-format
msgid "Done(%d)"
msgstr "Завершён (%d)"

#: jobs.c:1900
#, c-format
msgid "Exit %d"
msgstr "Выход %d"

#: jobs.c:1903
msgid "Unknown status"
msgstr "Состояние неизвестно"

#: jobs.c:1990
#, c-format
msgid "(core dumped) "
msgstr "(образ памяти сброшен на диск) "

#: jobs.c:2009
#, c-format
msgid "  (wd: %s)"
msgstr "  (рабочий каталог: %s)"

#: jobs.c:2250
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "дочерний setpgid (%ld к %ld)"

#: jobs.c:2608 nojobs.c:666
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: процесс %ld не является дочерним процессом этого командного процессора"

#: jobs.c:2884
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: нет записей процесса %ld"

#: jobs.c:3223
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: задание %d остановлено"

#: jobs.c:3551
#, c-format
msgid "%s: no current jobs"
msgstr "%s: нет текущих заданий"

#: jobs.c:3558
#, c-format
msgid "%s: job has terminated"
msgstr "%s: выполнение задания прервано"

#: jobs.c:3567
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: задание %d уже выполняется в фоновом режиме"

#: jobs.c:3793
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld: включается WNOHANG, чтобы предотвратить появление неопределённого блока"

#: jobs.c:4307
#, c-format
msgid "%s: line %d: "
msgstr "%s: строка %d: "

#: jobs.c:4321 nojobs.c:921
#, c-format
msgid " (core dumped)"
msgstr " (образ памяти сброшен на диск)"

#: jobs.c:4333 jobs.c:4346
#, c-format
msgid "(wd now: %s)\n"
msgstr "(рабочий каталог: %s)\n"

#: jobs.c:4378
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: ошибка вызова getpgrp"

#: jobs.c:4434
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: нельзя управлять заданиями в фоновом режиме"

#: jobs.c:4450
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: дисциплина строки"

#: jobs.c:4460
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:4481 jobs.c:4490
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "не удаётся задать группу процесса терминала (%d)"

#: jobs.c:4495
msgid "no job control in this shell"
msgstr "этот командный процессор не может управлять заданиями"

#: lib/malloc/malloc.c:367
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: ошибка утверждения: %s\n"

#: lib/malloc/malloc.c:383
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\\r\n"
"malloc: %s:%d: утверждение не удалось\r\n"

#: lib/malloc/malloc.c:384 lib/malloc/malloc.c:941
msgid "unknown"
msgstr "неизвестно"

#: lib/malloc/malloc.c:892
msgid "malloc: block on free list clobbered"
msgstr "malloc: блок в списке свободных затёрт"

#: lib/malloc/malloc.c:980
msgid "free: called with already freed block argument"
msgstr "free: вызван с аргументом уже освобождённого блока"

#: lib/malloc/malloc.c:983
msgid "free: called with unallocated block argument"
msgstr "free: вызван с аргументом невыделенного блока"

#: lib/malloc/malloc.c:1001
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: обнаружено отрицательное переполнение; mh_nbytes байт за пределами диапазона"

#: lib/malloc/malloc.c:1007
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: обнаружено отрицательное переполнение; magic8 повреждён"

#: lib/malloc/malloc.c:1014
msgid "free: start and end chunk sizes differ"
msgstr "free: размеры начального и конечного блока отличаются"

#: lib/malloc/malloc.c:1176
msgid "realloc: called with unallocated block argument"
msgstr "realloc: вызван с аргументом невыделенного блока"

#: lib/malloc/malloc.c:1191
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: обнаружено отрицательное переполнение; mh_nbytes байт за пределами диапазона"

#: lib/malloc/malloc.c:1197
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: обнаружено отрицательное переполнение; magic8 повреждён"

#: lib/malloc/malloc.c:1205
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: размеры начального и конечного блока отличаются"

#: lib/malloc/table.c:191
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: таблица выделения заполнена записями FIND_ALLOC?\n"

#: lib/malloc/table.c:200
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p уже есть в таблице как выделенный?\n"

#: lib/malloc/table.c:253
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p уже есть в таблице как свободный?\n"

#: lib/sh/fmtulong.c:102
msgid "invalid base"
msgstr "недопустимое основание"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: узел неизвестен"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: недопустимая служба"

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: недопустимое указание сетевого пути"

#: lib/sh/netopen.c:347
msgid "network operations not supported"
msgstr "сетевые операции не поддерживаются"

#: locale.c:219
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: не удаётся изменить язык (%s)"

#: locale.c:221
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: не удаётся изменить язык (%s): %s"

#: locale.c:294
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: не удаётся изменить язык (%s)"

#: locale.c:296
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: не удаётся изменить язык (%s): %s"

#: mailcheck.c:439
msgid "You have mail in $_"
msgstr "Для вас есть почта в $_"

#: mailcheck.c:464
msgid "You have new mail in $_"
msgstr "Для вас есть почта в $_"

#: mailcheck.c:480
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Сообщения в %s были прочитаны\n"

#: make_cmd.c:314
msgid "syntax error: arithmetic expression required"
msgstr "синтаксическая ошибка: требуется математическое выражение"

#: make_cmd.c:316
msgid "syntax error: `;' unexpected"
msgstr "синтаксическая ошибка: ожидается «;»"

#: make_cmd.c:317
#, c-format
msgid "syntax error: `((%s))'"
msgstr "синтаксическая ошибка: «((%s))»"

#: make_cmd.c:569
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: недопустимый тип инструкции %d"

#: make_cmd.c:668
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "блок here-document в строке %d разделён знаком конца файла (ожидался «%s»)"

#: make_cmd.c:769
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: инструкция перенаправления «%d» вышла за пределы диапазона"

#: parse.y:2428
#, c-format
msgid "shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line truncated"
msgstr "shell_getc: shell_input_line_size (%zu) превысил SIZE_MAX (%lu): строка обрезана"

#: parse.y:2921
msgid "maximum here-document count exceeded"
msgstr "достигнуто максимальное число переменных here-document"

#: parse.y:3684 parse.y:4244 parse.y:6148
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "неожиданный конец файла во время поиска «%c»"

#: parse.y:4452
msgid "unexpected EOF while looking for `]]'"
msgstr "неожиданный конец файла во время поиска «]]»"

#: parse.y:4457
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "синтаксическая ошибка в условном выражении: неожиданный маркер «%s»"

#: parse.y:4461
msgid "syntax error in conditional expression"
msgstr "синтаксическая ошибка в условном выражении"

#: parse.y:4539
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "неожиданный маркер «%s», ожидался «)»"

#: parse.y:4543
msgid "expected `)'"
msgstr "ожидается символ «)»"

#: parse.y:4571
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "неожиданный аргумент «%s» для условного унарного оператора"

#: parse.y:4575
msgid "unexpected argument to conditional unary operator"
msgstr "неожиданный аргумент для условного унарного оператора"

#: parse.y:4621
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "неожиданный маркер «%s», ожидается условный бинарный оператор"

#: parse.y:4625
msgid "conditional binary operator expected"
msgstr "ожидается условный бинарный оператор"

#: parse.y:4647
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "неожиданный аргумент «%s» для условного бинарного оператора"

#: parse.y:4651
msgid "unexpected argument to conditional binary operator"
msgstr "неожиданный аргумент для условного бинарного оператора"

#: parse.y:4662
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "неожиданный маркер «%c» в условной команде"

#: parse.y:4665
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "неожиданный маркер «%s» в условной команде"

#: parse.y:4669
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "неожиданный маркер %d в условной команде"

#: parse.y:6118
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "синтаксическая ошибка рядом с неожиданным маркером «%s»"

#: parse.y:6137
#, c-format
msgid "syntax error near `%s'"
msgstr "синтаксическая ошибка рядом с «%s»"

#: parse.y:6151
msgid "syntax error: unexpected end of file"
msgstr "синтаксическая ошибка: неожиданный конец файла"

#: parse.y:6151
msgid "syntax error"
msgstr "синтаксическая ошибка"

#: parse.y:6216
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Для выхода из командного процессора используйте «%s».\n"

#: parse.y:6394
msgid "unexpected EOF while looking for matching `)'"
msgstr "неожиданный конец файла во время поиска «)»"

#: pcomplete.c:1132
#, c-format
msgid "completion: function `%s' not found"
msgstr "completion: функция «%s» не найдена"

#: pcomplete.c:1722
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr "programmable_completion: %s: возможен бесконечный цикл повторов"

#: pcomplib.c:182
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: NULL COMPSPEC"

#: print_cmd.c:302
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: неверный соединитель «%d»"

#: print_cmd.c:375
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: недопустимый идентификатор файла"

#: print_cmd.c:380
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: пустой указатель на файл"

#: print_cmd.c:384
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != fileno xtrace fp (%d)"

#: print_cmd.c:1545
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: «%c»: недопустимый символ форматирования"

#: redir.c:150 redir.c:198
msgid "file descriptor out of range"
msgstr "файловый дескриптор за пределами диапазона"

#: redir.c:205
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: неоднозначное перенаправление"

#: redir.c:209
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: не удаётся перезаписать существующий файл"

#: redir.c:214
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: ограниченный режим: не удаётся перенаправить вывод"

#: redir.c:219
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "не удаётся создать временный файл для блока here-document: %s"

#: redir.c:223
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: не удаётся присвоить файловый дескриптор переменной"

#: redir.c:650
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "/dev/(tcp|udp)/host/port не поддерживается без сети"

#: redir.c:945 redir.c:1065 redir.c:1130 redir.c:1303
msgid "redirection error: cannot duplicate fd"
msgstr "ошибка перенаправления: не удаётся создать копию файлового дескриптора"

#: shell.c:353
msgid "could not find /tmp, please create!"
msgstr "не удалось найти /tmp; создайте этот каталог"

#: shell.c:357
msgid "/tmp must be a valid directory name"
msgstr "/tmp должен быть допустимым названием каталога"

#: shell.c:826
msgid "pretty-printing mode ignored in interactive shells"
msgstr "режим печати игнорируется в интерактивных командных процессорах"

#: shell.c:972
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: недопустимый параметр"

#: shell.c:1343
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "не удаётся установить UID %d: эффективный UID %d"

#: shell.c:1354
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "не удаётся установить GID %d: эффективный GID %d"

#: shell.c:1544
msgid "cannot start debugger; debugging mode disabled"
msgstr "не удаётся запустить отладчик: режим отладки отключён"

#: shell.c:1658
#, c-format
msgid "%s: Is a directory"
msgstr "%s: это каталог"

#: shell.c:1907
msgid "I have no name!"
msgstr "Не удаётся определить название"

#: shell.c:2061
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, версия %s-(%s)\n"

#: shell.c:2062
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Использование:\t%s [длинные параметры GNU] [параметры] ...\n"
"\t\t%s [длинные параметры GNU] [параметры] файл_скрипта ...\n"

#: shell.c:2064
msgid "GNU long options:\n"
msgstr "Длинные параметры GNU:\n"

#: shell.c:2068
msgid "Shell options:\n"
msgstr "Параметры командного процессора:\n"

#: shell.c:2069
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-irsD или -c команда или -O короткие_параметры\t\t(только при запуске)\n"

#: shell.c:2088
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s или -o параметр\n"

#: shell.c:2094
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "Для получения дополнительных сведений о параметрах командного процессора введите «%s -c \"help set\"».\n"

#: shell.c:2095
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "Для получения дополнительных сведений о встроенных командах введите «%s -c help».\n"

#: shell.c:2096
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Для отправки сообщений об ошибках используйте команду «bashbug».\n"

#: shell.c:2098
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "Домашняя страница bash: <http://www.gnu.org/software/bash>\n"

#: shell.c:2099
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Общая справка по использованию программ GNU: <http://www.gnu.org/gethelp/>\n"

#: sig.c:765
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: недопустимая операция"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Фиктивный сигнал"

#: siglist.c:51
msgid "Hangup"
msgstr "Отбой"

#: siglist.c:55
msgid "Interrupt"
msgstr "Прерывание"

#: siglist.c:59
msgid "Quit"
msgstr "Выход"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Недопустимая инструкция"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "Трасса/ловушка BPT"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Инструкция ABORT"

#: siglist.c:79
msgid "EMT instruction"
msgstr "Инструкция EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Исключение при обработке чисел с плавающей точкой"

#: siglist.c:87
msgid "Killed"
msgstr "Убит"

#: siglist.c:91
msgid "Bus error"
msgstr "Ошибка шины"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Ошибка сегментации"

#: siglist.c:99
msgid "Bad system call"
msgstr "Неверный системный вызов"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Конвейер не работает"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Сигнал часов"

#: siglist.c:111
msgid "Terminated"
msgstr "Прерван"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Срочное событие ввода/вывода"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Остановлен (сигналом)"

#: siglist.c:127
msgid "Continue"
msgstr "Продолжение"

#: siglist.c:135
msgid "Child death or stop"
msgstr "Смерть или остановка дочернего процесса"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Остановлен (ввод с tty)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Остановлен (вывод на tty)"

#: siglist.c:147
msgid "I/O ready"
msgstr "Готов к вводу/выводу"

#: siglist.c:151
msgid "CPU limit"
msgstr "Ограничение ЦП"

#: siglist.c:155
msgid "File limit"
msgstr "Ограничение величины файла"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Сигнал часов (виртуальный)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Сигнал часов (профиль)"

#: siglist.c:167
msgid "Window changed"
msgstr "Окно изменено"

#: siglist.c:171
msgid "Record lock"
msgstr "Запись блокирована"

#: siglist.c:175
msgid "User signal 1"
msgstr "Сигнал пользователя 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Сигнал пользователя 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "Ожидание входных данных HFT"

#: siglist.c:187
msgid "power failure imminent"
msgstr "неизбежна ошибка питания"

#: siglist.c:191
msgid "system crash imminent"
msgstr "неизбежно падение системы"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "процесс переносится на другой ЦП"

#: siglist.c:199
msgid "programming error"
msgstr "программная ошибка"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "Установлен режим монитора HFT"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "Выход из режима монитора HFT"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "Последовательность звуков HFT завершена"

#: siglist.c:215
msgid "Information request"
msgstr "Информационный запрос"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Неизвестный номер сигнала %d"

#: subst.c:1480 subst.c:1670
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "неверная подстановка: нет закрывающей «%s» в %s"

#: subst.c:3307
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: не удаётся присвоить список элементу массива"

#: subst.c:6048 subst.c:6064
msgid "cannot make pipe for process substitution"
msgstr "не удаётся создать конвейер для подстановки процесса"

#: subst.c:6124
msgid "cannot make child for process substitution"
msgstr "не удаётся создать дочерний процесс для подстановки"

#: subst.c:6198
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "не удаётся открыть именованный конвейер %s для чтения"

#: subst.c:6200
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "не удаётся открыть именованный конвейер %s для записи"

#: subst.c:6223
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "не удаётся скопировать именованный конвейер %s  в файловый дескриптор %d"

#: subst.c:6370
msgid "command substitution: ignored null byte in input"
msgstr "подстановка команды: во входных данных проигнорирован нулевой байт"

#: subst.c:6533
msgid "cannot make pipe for command substitution"
msgstr "не удаётся создать конвейер для подстановки команды"

#: subst.c:6580
msgid "cannot make child for command substitution"
msgstr "не удаётся создать дочерний процесс для подстановки команды"

#: subst.c:6613
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: не удаётся скопировать конвейер в файловый дескриптор 1"

#: subst.c:7082 subst.c:10252
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: недопустимое название переменной для ссылки на имя"

#: subst.c:7178 subst.c:7196 subst.c:7369
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: недопустимое непрямое раскрытие"

#: subst.c:7212 subst.c:7377
#, c-format
msgid "%s: invalid variable name"
msgstr "%s: недопустимое имя переменной"

#: subst.c:7478
#, c-format
msgid "%s: parameter not set"
msgstr "%s: параметр не задан"

#: subst.c:7480
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: параметр не задан или пустой"

#: subst.c:7727 subst.c:7742
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: заданное подстрокой выражение меньше нуля"

#: subst.c:9560 subst.c:9587
#, c-format
msgid "%s: bad substitution"
msgstr "%s: недопустимая подстановка"

#: subst.c:9678
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: такое присвоение невозможно"

#: subst.c:10111
msgid "future versions of the shell will force evaluation as an arithmetic substitution"
msgstr "в будущих версиях командный процессор оценка будет выполняться как математическая подстановка"

#: subst.c:10795
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "неверная подстановка: нет закрывающей «`» в %s"

#: subst.c:11874
#, c-format
msgid "no match: %s"
msgstr "нет совпадений: %s"

#: test.c:147
msgid "argument expected"
msgstr "ожидается аргумент"

#: test.c:156
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: ожидается целочисленное выражение"

#: test.c:265
msgid "`)' expected"
msgstr "ожидается символ «)»"

#: test.c:267
#, c-format
msgid "`)' expected, found %s"
msgstr "ожидается символ «)», обнаружено %s"

#: test.c:469 test.c:814
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: ожидается бинарный оператор"

#: test.c:771 test.c:774
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: ожидается унарный оператор"

#: test.c:896
msgid "missing `]'"
msgstr "отсутствует символ «]»"

#: test.c:914
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "синтаксическая ошибка: неожиданный «%s»"

#: trap.c:220
msgid "invalid signal number"
msgstr "недопустимый номер сигнала"

#: trap.c:323
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "обработка ловушек: достигнут максимальный уровень вложенности обработки ловушек (%d)"

#: trap.c:412
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: неверное значение в trap_list[%d]: %p"

#: trap.c:416
#, c-format
msgid "run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr "run_pending_traps: обработчик сигнала — SIG_DFL; повторная отправка %d (%s) самому себе"

#: trap.c:509
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: неверный сигнал %d"

#: variables.c:424
#, c-format
msgid "error importing function definition for `%s'"
msgstr "ошибка импорта определения функции для «%s»"

#: variables.c:838
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "слишком высокий уровень командного процессора (%d); сбрасывается до 1"

#: variables.c:2642
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: в текущей области отсутствует контекст функции"

#: variables.c:2661
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: переменной не может быть присвоено значение"

#: variables.c:2818 variables.c:2874
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr ""

#: variables.c:3459
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: целое числе присваивается ссылке на имя"

#: variables.c:4390
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: в текущей области отсутствует контекст функции"

#: variables.c:4757
#, c-format
msgid "%s has null exportstr"
msgstr "%s имеет пустую exportstr"

#: variables.c:4762 variables.c:4771
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "недопустимый символ %d в exportstr для %s"

#: variables.c:4777
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "отсутствует «=» в exportstr для %s"

#: variables.c:5317
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: заголовок shell_variables не является контекстом функции"

#: variables.c:5330
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: отсутствует контекст global_variables"

#: variables.c:5410
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: заголовок shell_variables не является областью временного окружения"

#: variables.c:6400
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: не удаётся открыть как ФАЙЛ"

#: variables.c:6405
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: недопустимое значение для дескриптора файла трассировки"

#: variables.c:6450
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: значение совместимости за пределами диапазона"

#: version.c:46 version2.c:46
#, fuzzy
#| msgid "Copyright (C) 2020 Free Software Foundation, Inc."
msgid "Copyright (C) 2022 Free Software Foundation, Inc."
msgstr "© Free Software Foundation, Inc, 2020."

#: version.c:47 version2.c:47
msgid "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
msgstr "Лицензия GPLv3+: GNU GPL версии 3 или более поздней <http://gnu.org/licenses/gpl.html>\n"

#: version.c:86 version2.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, версия %s (%s)\n"

#: version.c:91 version2.c:91
msgid "This is free software; you are free to change and redistribute it."
msgstr "Это свободное программное обеспечение. Вы можете изменять и распространять его."

#: version.c:92 version2.c:92
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "НИКАКАЯ ГАРАНТИЯ не предоставляется в пределах, допускаемых законом."

#: xmalloc.c:93
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: не удаётся выделить %lu байт (выделено %lu байт)"

#: xmalloc.c:95
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: не удаётся выделить %lu байт"

#: xmalloc.c:165
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: не удаётся выделить %lu байт (выделено %lu байт)"

#: xmalloc.c:167
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: не удаётся выделить %lu байт"

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [имя[=значение] ... ]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] имя [имя ...]"

#: builtins.c:53
msgid "bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr "bind [-lpvsPSVX] [-m раскладка] [-f файл] [-q имя] [-u name] [-r послед_клавиш] [-x послед_клавиш:команда_shell] [послед_клавиш:фнкц_readline или команда_readline]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [встр_команда [аргумент ...]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [выражение]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]] [-@]] [dir]"
msgstr "cd [-L|[-P [-e]] [-@]] [каталог]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] команда [аргумент ...]"

#: builtins.c:78
#, fuzzy
#| msgid "declare [-aAfFgiIlnrtux] [-p] [name[=value] ...]"
msgid "declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] [name ...]"
msgstr "declare [-aAfFgiIlnrtux] [-p] [имя[=значение] ...]"

#: builtins.c:80
#, fuzzy
#| msgid "typeset [-aAfFgiIlnrtux] [-p] name[=value] ..."
msgid "typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] [name ...]"
msgstr "typeset [-aAfFgiIlnrtux] [-p] имя[=значение] ..."

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [параметр] имя[=значение] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [аргумент ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [аргумент ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f файл] [имя ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [аргумент ...]"

#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts строка_параметров имя [аргумент ...]"

#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a имя] [команда [аргумент ...]] [перенаправление ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e редактор] [-lnr] [первая] [последняя] или fc -s [шаблон=замена] [команда]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [задание]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [задание ...]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p путь] [-dt] [имя ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [шаблон ...]"

#: builtins.c:123
msgid "history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]"
msgstr "history [-c] [-d смещение] [n] или history -anrw [файл] или history -ps аргумент [аргумент...]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [задание ...] или jobs -x команда [аргументы]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [задание ... | pid ...]"

#: builtins.c:134
msgid "kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]"
msgstr "kill [-s назв_сигнала | -n номер_сигнала | -назв_сигнала] ид_процесса | назв_задания] ... или kill -l [назв_сигнала]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let аргумент [аргумент ...]"

#: builtins.c:138
msgid "read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]"
msgstr "read [-ers] [-a массив] [-d разделитель] [-i текст] [-n число_символов] [-N число_символов] [-p приглашение] [-t тайм-аут] [-u fd] [имя ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
#, fuzzy
#| msgid "set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]"
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCHP] [-o параметр] [--] [аргумент ...]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [имя ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [имя[=значение ...] или export -p"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [имя[=значение] ...] или readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source filename [arguments]"
msgstr "source файл [аргументы]"

#: builtins.c:154
msgid ". filename [arguments]"
msgstr ". файл [аргументы]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [выражение]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ аргумент... ]"

#: builtins.c:166
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[аргумент] сигнал ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] имя [имя ...]"

#: builtins.c:171
#, fuzzy
#| msgid "ulimit [-SHabcdefiklmnpqrstuvxPT] [limit]"
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPT] [ограничение]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [режим]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p переменная] [идентификатор ...]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [идентификатор ...]"

#: builtins.c:184
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for ИМЯ [in СЛОВА... ;] do КОМАНДЫ; done"

#: builtins.c:186
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( выраж1; выраж2; выраж3 )); do КОМАНДЫ; done"

#: builtins.c:188
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select ИМЯ [in СЛОВА ... ;] do КОМАНДЫ; done"

#: builtins.c:190
msgid "time [-p] pipeline"
msgstr "time [-p] конвейер"

#: builtins.c:192
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case СЛОВО in [ШАБЛОН [| ШАБЛОН]...) КОМАНДЫ ;;]... esac"

#: builtins.c:194
msgid "if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi"
msgstr "if КОМАНДЫ; then КОМАНДЫ; [ elif КОМАНДЫ; then КОМАНДЫ; ]... [ else КОМАНДЫ; ] fi"

#: builtins.c:196
#, fuzzy
#| msgid "while COMMANDS; do COMMANDS; done"
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while КОМАНДЫ; do КОМАНДЫ; done"

#: builtins.c:198
#, fuzzy
#| msgid "until COMMANDS; do COMMANDS; done"
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until КОМАНДЫ; do КОМАНДЫ; done"

#: builtins.c:200
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [ИМЯ] команда [перенаправления]"

#: builtins.c:202
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function ИМЯ { КОМАНДЫ ; } или ИМЯ () { КОМАНДЫ ; }"

#: builtins.c:204
msgid "{ COMMANDS ; }"
msgstr "{ КОМАНДЫ ; }"

#: builtins.c:206
msgid "job_spec [&]"
msgstr "задание [&]"

#: builtins.c:208
msgid "(( expression ))"
msgstr "(( выражение ))"

#: builtins.c:210
msgid "[[ expression ]]"
msgstr "[[ выражение ]]"

#: builtins.c:212
msgid "variables - Names and meanings of some shell variables"
msgstr "переменные — имена и значения некоторых переменных командного процессора"

#: builtins.c:215
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | каталог]"

#: builtins.c:219
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:223
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:226
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [параметр ...]"

#: builtins.c:228
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v переменная] формат [аргументы]"

#: builtins.c:231
msgid "complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]"
msgstr "complete [-abcdefgjksuv] [-pr] [-DEI] [-o параметр] [-A действие] [-G глоб_шаблон] [-W список_слов] [-F функция] [-C команда] [-X фильтр_шабл] [-P префикс] [-S суффикс] [имя ...]"

#: builtins.c:235
msgid "compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr "compgen [-abcdefgjksuv] [-o параметр] [-A действие] [-G глоб_шабл] [-W список_слов] [-F функция] [-C команда] [-X фильтр_шабл] [-P префикс] [-S суффикс] [слово]"

#: builtins.c:239
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o параметр] [-DEI] [имя ...]"

#: builtins.c:242
msgid "mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "mapfile [-d разделитель] [-n число] [-O начало] [-s число] [-t] [-u fd] [-C callback] [-c quantum] [массив]"

#: builtins.c:244
msgid "readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "readarray [-d разделитель] [-n число] [-O начало] [-s число] [-t] [-u fd] [-C callback] [-c quantum] [массив]"

#: builtins.c:256
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has been\n"
"    defined."
msgstr ""
"Определение или отображение псевдонимов.\n"
"    \n"
"    Если не указать аргументы, alias выводит список псевдонимов\n"
"    в виде «alias имя=значение» на стандартный вывод.\n"
"    \n"
"    В противном случае каждому имени, для которого указано значение,\n"
"    назначается псевдоним. Если значение в конце содержит пробел,\n"
"    следующее слово будет проверяться на замену псевдонима при его\n"
"    развёртывании.\n"
"    \n"
"    Параметры:\n"
"      -p\tвыводит все определённые псевдонимы\n"
"    \n"
"    Состояние выхода:\n"
"    alias возвращает истину, если для указанного имени был задан\n"
"    псевдоним."

#: builtins.c:278
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Удаляет все имена из списка определённых псевдонимов.\n"
"    \n"
"    Параметры:\n"
"      -a\tудаляет все псевдонимы\n"
"    \n"
"    Возвращает успех, если имя связано с существующим псевдонимом."

#: builtins.c:291
#, fuzzy
#| msgid ""
#| "Set Readline key bindings and variables.\n"
#| "    \n"
#| "    Bind a key sequence to a Readline function or a macro, or set a\n"
#| "    Readline variable.  The non-option argument syntax is equivalent to\n"
#| "    that found in ~/.inputrc, but must be passed as a single argument:\n"
#| "    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
#| "    \n"
#| "    Options:\n"
#| "      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
#| "                         command.  Acceptable keymap names are emacs,\n"
#| "                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
#| "                         vi-command, and vi-insert.\n"
#| "      -l                 List names of functions.\n"
#| "      -P                 List function names and bindings.\n"
#| "      -p                 List functions and bindings in a form that can be\n"
#| "                         reused as input.\n"
#| "      -S                 List key sequences that invoke macros and their values\n"
#| "      -s                 List key sequences that invoke macros and their values\n"
#| "                         in a form that can be reused as input.\n"
#| "      -V                 List variable names and values\n"
#| "      -v                 List variable names and values in a form that can\n"
#| "                         be reused as input.\n"
#| "      -q  function-name  Query about which keys invoke the named function.\n"
#| "      -u  function-name  Unbind all keys which are bound to the named function.\n"
#| "      -r  keyseq         Remove the binding for KEYSEQ.\n"
#| "      -f  filename       Read key bindings from FILENAME.\n"
#| "      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
#| "    \t\t\t\tKEYSEQ is entered.\n"
#| "      -X\t\t     List key sequences bound with -x and associated commands\n"
#| "                         in a form that can be reused as input.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    bind returns 0 unless an unrecognized option is given or an error occurs."
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their values\n"
"      -s                 List key sequences that invoke macros and their values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Определение привязок клавиш и переменных readline.\n"
"    \n"
"    Привязывает последовательность клавиш функции readline или макросу\n"
"    или задаёт переменную readline.  Синтаксис аргументов без параметров аналогичен\n"
"    синтаксису файла ~/.inputrc, но всё должно передаваться в одном аргументе,\n"
"    например bind '\"\\C-x\\C-r\": перечитать-init-файл'.\n"
"    \n"
"    Параметры:\n"
"      -m  раскладка      использовать указанную раскладку во время выполнения\n"
"                         данной команды.  Допустимые раскладки: emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command и vi-insert.\n"
"      -l                 вывести названия функций\n"
"      -P                 вывести названия функций и их привязки\n"
"      -p                 вывести функции и их привязки в формате\n"
"                         для повторного использования\n"
"      -S                 вывести список последовательностей клавиш, которые\n"
"                   вызывают макросы, и их значения\n"
"      -s                 вывести список последовательностей клавиш, которые\n"
"                   вызывают макросы, и их значения\n"
"                         в формате для повторного использования\n"
"      -V                 вывести названия переменных и их значения\n"
"      -v                 вывести имена переменных и их значения\n"
"                         в формате для повторного использования\n"
"      -q  имя_функции\t вывести клавиши, вызывающие указанную функцию\n"
"      -u  имя_функции    отвязать все клавиши, привязанные к указанной функции\n"
"      -r  посл-клавиш    удалить привязку для последовательности клавиш\n"
"      -f  файл           прочитать привязки из файла\n"
"      -x  посл-клавиш:кмнд-shell выполнить команду bash, если введена\n"
"    \t\t\t\tпоследовательность клавиш\n"
"      -X\t\t     вывести последовательности клавиш, привязанные с помощью -x, и связанные команды\n"
"                         в формате для повторного использования\n"
"    \n"
"    Состояние выхода:\n"
"    bind возвращает 0, если был указан допустимый параметр или не возникла ошибка."

#: builtins.c:330
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Прерывание цикла for, while или until.\n"
"    \n"
"    Прерывает цикл for, while или until.  Если указано N, прерывает N вложенных\n"
"    циклов.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает 0, если N не больше или равно 1."

#: builtins.c:342
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Возобновление цикла for, while или until.\n"
"    \n"
"    Возобновляет следующую итерацию вложенного цикла for, while или until.\n"
"    Если указано N, возобновляет N-й вложенный цикл.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает 0, если N не больше или равно 1."

#: builtins.c:354
#, fuzzy
#| msgid ""
#| "Execute shell builtins.\n"
#| "    \n"
#| "    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
#| "    lookup.  This is useful when you wish to reimplement a shell builtin\n"
#| "    as a shell function, but need to execute the builtin within the function.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
#| "    not a shell builtin.."
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Выполнение встроенных команд.\n"
"    \n"
"    Выполняет встроенную команду bash с аргументами\n"
"    без поиска команды.  Это полезно, если нужно переопределить встроенную команду\n"
"    как функцию командного процессора, в этой функции нужно выполнить встроенную команду.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние выхода встроенной команды или ложь, если указанная команда bash\n"
"    не является встроенной."

#: builtins.c:369
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Возвращает контекст вызова текущей подпрограммы.\n"
"    \n"
"    Если выражение не указано, возвращает «$line $filename».  Если выражение указано, возвращает\n"
"    «$line $subroutine $filename». Эти дополнительные данные можно\n"
"    использовать для трассировки стека.\n"
"    \n"
"    Значение выражения означает количество кадров, которое нужно вызвать\n"
"    для возврата к текущему кадру. Первый кадр имеет номер 0.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает 0, если командный процессор не выполняет функцию, или выражение\n"
"    является допустимым."

#: builtins.c:387
#, fuzzy
#| msgid ""
#| "Change the shell working directory.\n"
#| "    \n"
#| "    Change the current directory to DIR.  The default DIR is the value of the\n"
#| "    HOME shell variable.\n"
#| "    \n"
#| "    The variable CDPATH defines the search path for the directory containing\n"
#| "    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n"
#| "    A null directory name is the same as the current directory.  If DIR begins\n"
#| "    with a slash (/), then CDPATH is not used.\n"
#| "    \n"
#| "    If the directory is not found, and the shell option `cdable_vars' is set,\n"
#| "    the word is assumed to be  a variable name.  If that variable has a value,\n"
#| "    its value is used for DIR.\n"
#| "    \n"
#| "    Options:\n"
#| "        -L\tforce symbolic links to be followed: resolve symbolic links in\n"
#| "    \tDIR after processing instances of `..'\n"
#| "        -P\tuse the physical directory structure without following symbolic\n"
#| "    \tlinks: resolve symbolic links in DIR before processing instances\n"
#| "    \tof `..'\n"
#| "        -e\tif the -P option is supplied, and the current working directory\n"
#| "    \tcannot be determined successfully, exit with a non-zero status\n"
#| "        -@  on systems that support it, present a file with extended attributes\n"
#| "            as a directory containing the file attributes\n"
#| "    \n"
#| "    The default is to follow symbolic links, as if `-L' were specified.\n"
#| "    `..' is processed by removing the immediately previous pathname component\n"
#| "    back to a slash or the beginning of DIR.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns 0 if the directory is changed, and if $PWD is set successfully when\n"
#| "    -P is used; non-zero otherwise."
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n"
"    A null directory name is the same as the current directory.  If DIR begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is set,\n"
"    the word is assumed to be  a variable name.  If that variable has a value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Смена рабочего каталога командного процессора.\n"
"    \n"
"    Изменяет текущий каталог на указанный каталог.  Каталог по умолчанию хранится в\n"
"    переменной $HOME командного процессора.\n"
"    \n"
"    Переменная $CDPATH определяет путь поиска каталога, содержащего\n"
"    указанный каталог.  Альтернативные каталоги в $CDPATH разделяются двоеточием (:).\n"
"    Пустое название каталога соответствует текущему каталогу.  Если каталог начинается\n"
"    с косой черты (/), переменная $CDPATH не используется.\n"
"    \n"
"    Если каталог не найден и задан параметр «cdable_vars»,\n"
"    слово считается названием переменной.  Если эта переменная содержит значение,\n"
"    оно используется для каталога.\n"
"    \n"
"    Параметры:\n"
"        -L\tпереходить по символьным ссылкам: ссылки раскрываются \n"
"    \tв каталоге после обработки экземпляров «..»\n"
"        -P\tиспользовать физическую структуру каталогов без перехода\n"
"    \tпо символьным ссылкам: ссылки раскрываются в каталоге до\n"
"    \tобработки «..»\n"
"        -e\tесли указан параметр -P, и не удаётся определить текущий\n"
"    \tрабочий каталог, команда завершается с ненулевым состоянием\n"
"        -@  на системах, которые это поддерживают, представляет файл с расширенными\n"
"            атрибутами как каталог, содержащий атрибуты файла\n"
"    \n"
"    По умолчанию выполняется переход по символьным ссылкам (как при указании параметра «-L»).\n"
"    «..» обрабатывается путём удаления первого компонента пути до косой черты\n"
"    или из начала каталога.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает 0, если каталог был изменён, и если $PWD был успешно установлен\n"
"    при использовании параметра -P. В противном случае возвращается ненулевое состояние."

#: builtins.c:425
#, fuzzy
#| msgid ""
#| "Print the name of the current working directory.\n"
#| "    \n"
#| "    Options:\n"
#| "      -L\tprint the value of $PWD if it names the current working\n"
#| "    \tdirectory\n"
#| "      -P\tprint the physical directory, without any symbolic links\n"
#| "    \n"
#| "    By default, `pwd' behaves as if `-L' were specified.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns 0 unless an invalid option is given or the current directory\n"
#| "    cannot be read."
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Вывод названия текущего рабочего каталога.\n"
"    \n"
"    Параметры:\n"
"      -L\tпоказать значение $PWD, если переменная указывает на\n"
"    \tтекущий рабочий каталог\n"
"      -P\tпоказать название физического каталога без символьных ссылок\n"
"    \n"
"    По умолчанию pwd работает, как если бы «-L» не был указан.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает 0, если был указан допустимый параметр или можно прочитать\n"
"    текущий каталог."

#: builtins.c:442
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Пустая команда.\n"
"    \n"
"    Команда не выполняет никаких действий и ни на что не влияет.\n"
"    \n"
"    Состояние выхода:\n"
"    Всегда возвращает успех."

#: builtins.c:453
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Возвращает результат успешного выполнения.\n"
"    \n"
"    Состояние выхода:\n"
"    Всегда возвращает успех."

#: builtins.c:462
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Возвращает результат неудачного выполнения.\n"
"    \n"
"    Состояние выхода:\n"
"    Всегда возвращает ошибку."

#: builtins.c:471
#, fuzzy
#| msgid ""
#| "Execute a simple command or display information about commands.\n"
#| "    \n"
#| "    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
#| "    information about the specified COMMANDs.  Can be used to invoke commands\n"
#| "    on disk when a function with the same name exists.\n"
#| "    \n"
#| "    Options:\n"
#| "      -p\tuse a default value for PATH that is guaranteed to find all of\n"
#| "    \tthe standard utilities\n"
#| "      -v\tprint a description of COMMAND similar to the `type' builtin\n"
#| "      -V\tprint a more verbose description of each COMMAND\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a description of COMMAND similar to the `type' builtin\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Выполнение простой команды или вывод информации о командах.\n"
"    \n"
"    Выполняет команду с аргументами без поиска функции командного процессора\n"
"    или выводит информацию об указанных командах.  Можно использовать для вызова команд\n"
"    с диска, когда функция с таким именем уже существует.\n"
"    \n"
"    Параметры:\n"
"      -p\tиспользовать значение по умолчанию для $PATH, чтобы гарантированно\n"
"    \tнайти все стандартные команды\n"
"      -v\tвывести описание команды аналогично встроенной команде «type»\n"
"      -V\tвывести более подробное описание каждой команды\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние выхода КОМАНДЫ или ошибку, если КОМАНДА не найдена."

#: builtins.c:490
#, fuzzy
#| msgid ""
#| "Set variable values and attributes.\n"
#| "    \n"
#| "    Declare variables and give them attributes.  If no NAMEs are given,\n"
#| "    display the attributes and values of all variables.\n"
#| "    \n"
#| "    Options:\n"
#| "      -f\trestrict action or display to function names and definitions\n"
#| "      -F\trestrict display to function names only (plus line number and\n"
#| "    \tsource file when debugging)\n"
#| "      -g\tcreate global variables when used in a shell function; otherwise\n"
#| "    \tignored\n"
#| "      -p\tdisplay the attributes and value of each NAME\n"
#| "    \n"
#| "    Options which set attributes:\n"
#| "      -a\tto make NAMEs indexed arrays (if supported)\n"
#| "      -A\tto make NAMEs associative arrays (if supported)\n"
#| "      -i\tto make NAMEs have the `integer' attribute\n"
#| "      -l\tto convert NAMEs to lower case on assignment\n"
#| "      -n\tmake NAME a reference to the variable named by its value\n"
#| "      -r\tto make NAMEs readonly\n"
#| "      -t\tto make NAMEs have the `trace' attribute\n"
#| "      -u\tto convert NAMEs to upper case on assignment\n"
#| "      -x\tto make NAMEs export\n"
#| "    \n"
#| "    Using `+' instead of `-' turns off the given attribute.\n"
#| "    \n"
#| "    Variables with the integer attribute have arithmetic evaluation (see\n"
#| "    the `let' command) performed when the variable is assigned a value.\n"
#| "    \n"
#| "    When used in a function, `declare' makes NAMEs local, as with the `local'\n"
#| "    command.  The `-g' option suppresses this behavior.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid option is supplied or a variable\n"
#| "    assignment error occurs."
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the `local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Указание значений переменных и атрибутов.\n"
"    \n"
"    Объявление переменных и назначение им атрибутов.  Если имена не указаны,\n"
"    выводит атрибуты и значения всех переменных.\n"
"    \n"
"    Параметры:\n"
"      -f\tограничить действие или вывести имена функций и их определения\n"
"      -F\tвывести только имена функций (а также номер строки\n"
"    \tв исходном файле при отладке)\n"
"      -g\tсоздать глобальные переменные при использовании в функции командного процессора; в противном случае\n"
"    \tигнорируется\n"
"      -p\tвывести атрибуты и значения каждого имени\n"
"    \n"
"    Параметры, задающие атрибуты:\n"
"      -a\tсделать имена индексированными массивами (если поддерживается)\n"
"      -A\tсделать имена ассоциативными массивами (если поддерживается)\n"
"      -i\tназначить именам атрибут «integer»\n"
"      -l\tперевести имена в нижний регистр при назначении\n"
"      -n\tсделать имя ссылкой на переменную с именем, соответствующим её значению\n"
"      -r\tотключить запись в имена\n"
"      -t\tназначить именам атрибут «trace»\n"
"      -l\tперевести имена в верхний регистр при назначении\n"
"      -x\tэкспортировать имена\n"
"    \n"
"    Знак «+» вместо «-» отключает указанный атрибут.\n"
"    \n"
"    Переменные с атрибутом «integer» содержат математическое выражение (см.\n"
"    команду «let»), которое рассчитывается при назначении значения переменной.\n"
"    \n"
"    При использовании в функции «declare» делает имена локальными как при использовании\n"
"    данной команды.  Параметр «-g» отключает это поведение.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла\n"
"    ошибка присвоения."

#: builtins.c:532
#, fuzzy
#| msgid ""
#| "Set variable values and attributes.\n"
#| "    \n"
#| "    Obsolete.  See `help declare'."
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Указание значений переменных и атрибутов.\n"
"    \n"
"    Устарел.  См. «help declare»."

#: builtins.c:540
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Определение локальных переменных.\n"
"    \n"
"    Создаёт локальную переменную с указанным именем и присваивает ей указанное значение.  Параметром может быть\n"
"    любой параметр, принимаемый командой «declare».\n"
"    \n"
"    Локальные переменные можно использовать только внутри функции. Они видны\n"
"    только той функции, в которой они определены, и её дочерним функциям.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр, не возникла\n"
"    ошибка присвоения переменной или командный процессор не выполняет функцию."

#: builtins.c:557
#, fuzzy
#| msgid ""
#| "Write arguments to the standard output.\n"
#| "    \n"
#| "    Display the ARGs, separated by a single space character and followed by a\n"
#| "    newline, on the standard output.\n"
#| "    \n"
#| "    Options:\n"
#| "      -n\tdo not append a newline\n"
#| "      -e\tenable interpretation of the following backslash escapes\n"
#| "      -E\texplicitly suppress interpretation of backslash escapes\n"
#| "    \n"
#| "    `echo' interprets the following backslash-escaped characters:\n"
#| "      \\a\talert (bell)\n"
#| "      \\b\tbackspace\n"
#| "      \\c\tsuppress further output\n"
#| "      \\e\tescape character\n"
#| "      \\E\tescape character\n"
#| "      \\f\tform feed\n"
#| "      \\n\tnew line\n"
#| "      \\r\tcarriage return\n"
#| "      \\t\thorizontal tab\n"
#| "      \\v\tvertical tab\n"
#| "      \\\\\tbackslash\n"
#| "      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
#| "    \t0 to 3 octal digits\n"
#| "      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
#| "    \tcan be one or two hex digits\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless a write error occurs."
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Вывод аргументов на стандартный вывод.\n"
"    \n"
"    Выводит аргументы, разделённые пробелом, добавляя в конце символ новой строки,\n"
"    на стандартный вывод.\n"
"    \n"
"    Параметры:\n"
"      -n\tне добавлять символ новой строки\n"
"      -e\tвключить интерпретацию символов, экранированных обратной косой чертой\n"
"      -E\tявно отключить интерпретацию символов, экранированных обратной косой чертой\n"
"    \n"
"    echo интерпретирует следующие символы, экранированные обратной косой чертой:\n"
"      \\a\tоповещение (звуковой сигнал)\n"
"      \\b\tbackspace\n"
"      \\c\tотключение дальнейшего вывода\n"
"      \\e\tсимвол escape\n"
"      \\E\tсимвол escape\n"
"      \\f\tпрогон страницы\n"
"      \\n\tновая строка\n"
"      \\r\tвозврат каретки\n"
"      \\t\tгоризонтальная табуляция\n"
"      \\v\tвертикальная табуляция\n"
"      \\\\\tобратная косая черта\n"
"      \\0nnn\tсимвол с ASCII-кодом NNN (восьмеричным)  NNN может быть длиной\n"
"    \tот 0 до 3 восьмеричных цифр\n"
"      \\xHH\tвосьмиразрядный символ, значение которого — HH (шестнадцатеричное)  HH\n"
"    \tможет быть одной или двумя шестнадцатеричными цифрами\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если не произошла ошибка записи."

#: builtins.c:597
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Вывод аргументов на стандартный вывод.\n"
"    \n"
"    Выводит аргументы на стандартный вывод, добавляя в конце символ новой строки.\n"
"    \n"
"    Параметры:\n"
"      -n\tне добавлять символ новой строки\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если не произошла ошибка записи."

#: builtins.c:612
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Включение и отключение встроенных команд командного процессора.\n"
"    \n"
"    Включает и отключает команды, встроенные в командный процессор.  Отключение позволит\n"
"    выполнить команду с диска, название которой совпадает с названием встроенной команды,\n"
"    без указания полного пути к ней.\n"
"    \n"
"    Параметры:\n"
"      -a\tпоказать список встроенных команд и их состояние\n"
"      -n\tотключить все указанные имена или вывести список отключённых команд\n"
"      -p\tпоказать список встроенных команд\n"
"      -s\tпоказать только названия встроенных команд «special» Posix\n"
"    \n"
"    Параметры, управляющие динамической загрузкой:\n"
"      -f\tзагрузить встроенную указанную команду из указанного файла\n"
"      -d\tудалить встроенную функцию, загруженную с параметром -f\n"
"    \n"
"    Без указания параметров включаются все указанные команды.\n"
"    \n"
"    Чтобы использовать команду «test», найденную в переменной $PATH,\n"
"    а не встроенную в командный процессор, введите «enable -n test».\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если указанное имя не является встроенной командой или не произошла ошибка."

#: builtins.c:640
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Выполнение аргументов как команды командного процессора.\n"
"    \n"
"    Объединяет аргументы в одну строку, результат передаётся\n"
"    в командный процессор с выполнением полученных команд.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние выхода команды или успех, если команда пустая."

#: builtins.c:652
#, fuzzy
#| msgid ""
#| "Parse option arguments.\n"
#| "    \n"
#| "    Getopts is used by shell procedures to parse positional parameters\n"
#| "    as options.\n"
#| "    \n"
#| "    OPTSTRING contains the option letters to be recognized; if a letter\n"
#| "    is followed by a colon, the option is expected to have an argument,\n"
#| "    which should be separated from it by white space.\n"
#| "    \n"
#| "    Each time it is invoked, getopts will place the next option in the\n"
#| "    shell variable $name, initializing name if it does not exist, and\n"
#| "    the index of the next argument to be processed into the shell\n"
#| "    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
#| "    a shell script is invoked.  When an option requires an argument,\n"
#| "    getopts places that argument into the shell variable OPTARG.\n"
#| "    \n"
#| "    getopts reports errors in one of two ways.  If the first character\n"
#| "    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
#| "    this mode, no error messages are printed.  If an invalid option is\n"
#| "    seen, getopts places the option character found into OPTARG.  If a\n"
#| "    required argument is not found, getopts places a ':' into NAME and\n"
#| "    sets OPTARG to the option character found.  If getopts is not in\n"
#| "    silent mode, and an invalid option is seen, getopts places '?' into\n"
#| "    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
#| "    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
#| "    printed.\n"
#| "    \n"
#| "    If the shell variable OPTERR has the value 0, getopts disables the\n"
#| "    printing of error messages, even if the first character of\n"
#| "    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
#| "    \n"
#| "    Getopts normally parses the positional parameters ($0 - $9), but if\n"
#| "    more arguments are given, they are parsed instead.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success if an option is found; fails if the end of options is\n"
#| "    encountered or an error occurs."
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Анализ аргументов параметра.\n"
"    \n"
"    getopts используется процедурами командного процессора для анализа\n"
"    позиционных параметров.\n"
"    \n"
"    «строка_параметров» содержит буквы распознаваемых параметров. Если после\n"
"    буквы идёт двоеточие, считается, что у параметра есть аргумент,\n"
"    который должен быть отделён пробелом.\n"
"    \n"
"    При каждом своём вызове getopts поместит следующий параметр в переменную\n"
"    $имя, проинициализировав это имя, если оно не существует,\n"
"    и проиндексирует следующий обрабатываемый аргумент в переменной\n"
"    $OPTIND.  Переменная $OPTIND инициализируется при каждом вызове\n"
"    командного процессора или скрипта.  Когда для параметра нужен аргумент,\n"
"    getopts помещает этот аргумент в переменную $OPTARG.\n"
"    \n"
"    getopts сообщает об ошибках двумя способами.  Если первый символ\n"
"    в «строке_параметров» является двоеточием, getopts включает режим молчания.  В этом\n"
"    режиме сообщения об ошибках не выводятся.  Если указан неверный\n"
"    параметр, getopts помещает символ параметра в переменную $OPTARG.  Если\n"
"    обязательный аргумент не найден, getopts помещает «:» в «имя»\n"
"    и задаёт для $OPTARG символ найденного параметра.  Если getopts не в режиме\n"
"    молчания, и был указан неверный параметр, getopts помещает «?»\n"
"    в НАЗВАНИЕ и удаляет переменную OPTARG.  Если обязательный аргумент не найден, в НАЗВАНИЕ\n"
"    помещается «?», переменная OPTARG удаляется и выводится диагностическое\n"
"    сообщение.\n"
"    \n"
"    Если переменная OPTERR имеет значение 0, getopts отключает\n"
"    вывод сообщений об ошибках, даже если первый символ переменной\n"
"    OPTSTRING не является двоеточием.  По умолчанию переменная OPTERR имеет значение 1.\n"
"    \n"
"    Getopts обычно анализирует позиционные параметры ($0–$9), но если\n"
"    задано больше аргументов, анализируются последние.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если найден параметр. Возвращает ошибку, если достигнут\n"
"    конец параметров или возникла ошибка."

#: builtins.c:694
#, fuzzy
#| msgid ""
#| "Replace the shell with the given command.\n"
#| "    \n"
#| "    Execute COMMAND, replacing this shell with the specified program.\n"
#| "    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\n"
#| "    any redirections take effect in the current shell.\n"
#| "    \n"
#| "    Options:\n"
#| "      -a name\tpass NAME as the zeroth argument to COMMAND\n"
#| "      -c\t\texecute COMMAND with an empty environment\n"
#| "      -l\t\tplace a dash in the zeroth argument to COMMAND\n"
#| "    \n"
#| "    If the command cannot be executed, a non-interactive shell exits, unless\n"
#| "    the shell option `execfail' is set.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless COMMAND is not found or a redirection error occurs."
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error occurs."
msgstr ""
"Замена командного процессора указанной командой.\n"
"    \n"
"    Выполняет команду, заменяя текущий командный процессор указанной программой.\n"
"    Указанные аргументы становятся аргументами для команды.  Если команда не указана,\n"
"    все перенаправления будет выполняться в текущем командном процессоре.\n"
"    \n"
"    Параметры:\n"
"      -a имя\t\tпередать имя как нулевой аргумент в команду\n"
"      -c\t\tвыполнить команду с пустым окружением\n"
"      -l\t\tпоместить тире в нулевой аргумент для команды\n"
"    \n"
"    Если команду не удаётся выполнить, неинтерактивный командный процессор\n"
"    закроется (если только на задан «execfail»).\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если команда не была найдена или не возникла ошибка перенаправления."

#: builtins.c:715
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Выход из командного процессора.\n"
"    \n"
"    Закрывает командный процессор с состоянием N. Если N не указан,\n"
"    состоянием выхода будет состояние последней выполненной команды."

#: builtins.c:724
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not executed\n"
"    in a login shell."
msgstr ""
"Выход из командного процессора login.\n"
"    \n"
"    Закрывает командный процессор login с состоянием выхода N. Возвращает\n"
"    ошибку, если выполняется не в командном процессоре login."

#: builtins.c:734
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error occurs."
msgstr ""
"Отображение или выполнение команд из журнала.\n"
"    \n"
"    fc выводит список команд из журнала или позволяет изменить и повторно выполнить их.\n"
"    Аргументы «первая» и «последняя» могут быть числами, определяющими диапазон.\n"
"    Аргумент «первая» также может быть строкой, которая означает\n"
"    последнюю команду, начинающуюся с этой строки.\n"
"    \n"
"    Параметры:\n"
"      -e редактор\tуказать редактор  По умолчанию используется $FCEDIT, \n"
"    \t\tзатем следует $EDITOR, а затем — vi\n"
"      -l \tпоказать строки вместо редактирования\n"
"      -n\tне показывать номера строк в списке\n"
"      -r\tинвертировать порядок строк (новые в начале)\n"
"    \n"
"    При запуске в формате «fc -s [шаблон=замена ...] [команда]» команда\n"
"    выполняется повторно после замены старая=новая.\n"
"    \n"
"    Полезный псевдоним для команды — r='fc -s'. Так если ввести «r cc»,\n"
"    будет выполнена последняя команда, начинающаяся с «cc», а если ввести «r»,\n"
"    будет выполнена последняя команда.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех или состояние выполненной команды. В случае ошибки возвращает ненулевое состояние."

#: builtins.c:764
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Перевод задания в интерактивный режим.\n"
"    \n"
"    Переводит указанное задание в интерактивный режим, делая\n"
"    его текущим заданием.  Если задание не указано, используется\n"
"    текущее задание.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние команды, переведённой в интерактивный режим, или ошибку, если возникла ошибка."

#: builtins.c:779
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Перевод заданий в фоновый режим.\n"
"    \n"
"    Переводит указанные задания в фоновый режим, как если бы\n"
"    они были запущены с «&».  Если задание не указано, используются данные\n"
"    текущего задания.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если не включено управление заданиями или не произошла ошибка."

#: builtins.c:793
#, fuzzy
#| msgid ""
#| "Remember or display program locations.\n"
#| "    \n"
#| "    Determine and remember the full pathname of each command NAME.  If\n"
#| "    no arguments are given, information about remembered commands is displayed.\n"
#| "    \n"
#| "    Options:\n"
#| "      -d\t\tforget the remembered location of each NAME\n"
#| "      -l\t\tdisplay in a format that may be reused as input\n"
#| "      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
#| "      -r\t\tforget all remembered locations\n"
#| "      -t\t\tprint the remembered location of each NAME, preceding\n"
#| "    \t\teach location with the corresponding NAME if multiple\n"
#| "    \t\tNAMEs are given\n"
#| "    Arguments:\n"
#| "      NAME\t\tEach NAME is searched for in $PATH and added to the list\n"
#| "    \t\tof remembered commands.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless NAME is not found or an invalid option is given."
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Запоминание или отображение местоположений программ.\n"
"    \n"
"    Определяет и запоминает полный путь для всех указанных команд.  Если\n"
"    аргументы не указаны, выводит информацию о запомненных командах.\n"
"    \n"
"    Параметры:\n"
"      -d\t\tзабыть запомненные местоположения всех указанных команд\n"
"      -l\t\tотобразить данные в формате для повторного использования\n"
"      -p путь\t\tиспользовать указанный путь как полный путь к команде\n"
"      -r\t\tзабыть все запомненные местоположения\n"
"      -t\t\tвывести запомненные местоположение всех команд,\n"
"    \t\tуказав перед каждым из них соответствующее имя команды,\n"
"    \t\tесли указано несколько команд.\n"
"    Аргументы:\n"
"      ИМЯ\t\tвсе команды ищутся в $PATH и добавляются в список\n"
"    \t\tзапомненных команд.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если команда была найдена или был указан допустимый параметр."

#: builtins.c:818
#, fuzzy
#| msgid ""
#| "Display information about builtin commands.\n"
#| "    \n"
#| "    Displays brief summaries of builtin commands.  If PATTERN is\n"
#| "    specified, gives detailed help on all commands matching PATTERN,\n"
#| "    otherwise the list of help topics is printed.\n"
#| "    \n"
#| "    Options:\n"
#| "      -d\toutput short description for each topic\n"
#| "      -m\tdisplay usage in pseudo-manpage format\n"
#| "      -s\toutput only a short usage synopsis for each topic matching\n"
#| "    \tPATTERN\n"
#| "    \n"
#| "    Arguments:\n"
#| "      PATTERN\tPattern specifiying a help topic\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless PATTERN is not found or an invalid option is given."
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is given."
msgstr ""
"Вывод информации о встроенных командах.\n"
"    \n"
"    Показывает краткую справку о встроенных командах.  Если указан\n"
"    шаблон, выводит подробную справку по всем командам, удовлетворяющим шаблону.\n"
"    В противном случае выводится список разделов справки.\n"
"    \n"
"    Параметры:\n"
"      -d\tпоказать краткое описание каждого раздела\n"
"      -m\tпоказать справку по использованию в формате man\n"
"      -s\tпоказать только краткую справку по использованию для каждого\n"
"    \tраздела, соответствующего шаблону\n"
"    \n"
"    Аргументы:\n"
"      ШАБЛОН\tшаблон, определяющий раздел справки\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был найден шаблон или был указан допустимый параметр."

#: builtins.c:842
#, fuzzy
#| msgid ""
#| "Display or manipulate the history list.\n"
#| "    \n"
#| "    Display the history list with line numbers, prefixing each modified\n"
#| "    entry with a `*'.  An argument of N lists only the last N entries.\n"
#| "    \n"
#| "    Options:\n"
#| "      -c\tclear the history list by deleting all of the entries\n"
#| "      -d offset\tdelete the history entry at offset OFFSET.\n"
#| "    \n"
#| "      -a\tappend history lines from this session to the history file\n"
#| "      -n\tread all history lines not already read from the history file\n"
#| "      -r\tread the history file and append the contents to the history\n"
#| "    \tlist\n"
#| "      -w\twrite the current history to the history file\n"
#| "    \tand append them to the history list\n"
#| "    \n"
#| "      -p\tperform history expansion on each ARG and display the result\n"
#| "    \twithout storing it in the history list\n"
#| "      -s\tappend the ARGs to the history list as a single entry\n"
#| "    \n"
#| "    If FILENAME is given, it is used as the history file.  Otherwise,\n"
#| "    if $HISTFILE has a value, that is used, else ~/.bash_history.\n"
#| "    \n"
#| "    If the $HISTTIMEFORMAT variable is set and not null, its value is used\n"
#| "    as a format string for strftime(3) to print the time stamp associated\n"
#| "    with each displayed history entry.  No time stamps are printed otherwise.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid option is given or an error occurs."
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Отображение или изменение журнала команд.\n"
"    \n"
"    Выводит журнал команд с номерами строк и звёздочками (*) перед всеми\n"
"    изменёнными записями.  С аргументом N показываются только последние N записей.\n"
"    \n"
"    Параметры:\n"
"      -c\tочистить журнал, удалив из него все записи\n"
"      -d смещение\tудалить запись журнала по указанному смещению\n"
"    \n"
"      -a\tдобавить журнал текущего сеанса в файл журнала\n"
"      -n\tпрочитать все записи, которые ещё не были прочитаны из файла журнала\n"
"      -r\tпрочитать файл журнала и добавить его содержимое\n"
"    \tв журнал\n"
"      -w\tзаписать текущий журнал в файл журнала\n"
"    \tи добавить записи в журнал\n"
"    \n"
"      -p\tдобавить в журнал указанные аргументы и показать результат,\n"
"    \tне сохраняя его в журнал\n"
"      -s\tдобавить аргументы в журнал как одну запись\n"
"    \n"
"    Если указан файл, он используется как файл журнала.  В противном случае\n"
"    если $HISTFILE содержит значение, используется этот файл, иначе — файл ~/.bash_history.\n"
"    \n"
"    Если переменная $HISTTIMEFORMAT задана и не является пустой, её значение\n"
"    используется как строка форматирования для strftime(3) для вывода метки\n"
"    времени для каждой показанной записи журнала.  В противном случае метки времени не будут показаны.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла ошибка."

#: builtins.c:879
#, fuzzy
#| msgid ""
#| "Display status of jobs.\n"
#| "    \n"
#| "    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
#| "    Without options, the status of all active jobs is displayed.\n"
#| "    \n"
#| "    Options:\n"
#| "      -l\tlists process IDs in addition to the normal information\n"
#| "      -n\tlist only processes that have changed status since the last\n"
#| "    \tnotification\n"
#| "      -p\tlists process IDs only\n"
#| "      -r\trestrict output to running jobs\n"
#| "      -s\trestrict output to stopped jobs\n"
#| "    \n"
#| "    If -x is supplied, COMMAND is run after all job specifications that\n"
#| "    appear in ARGS have been replaced with the process ID of that job's\n"
#| "    process group leader.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid option is given or an error occurs.\n"
#| "    If -x is used, returns the exit status of COMMAND."
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Отображение состояния заданий.\n"
"    \n"
"    Выводит список активных заданий.  Если указан номер задания, выводится только это задание.\n"
"    Если не указать параметры, будет показано состояние всех активных заданий.\n"
"    \n"
"    Параметры:\n"
"      -l\tпоказать идентификаторы процессов в дополнение к обычной информации\n"
"      -n\tпоказать только те процессы, у которых изменилось состояние\n"
"    \tс момента после последнего уведомления\n"
"      -p\tпоказать только идентификаторы процессов\n"
"      -r\tпоказать только запущенные задания\n"
"      -s\tпоказать только остановленные задания\n"
"    \n"
"    Если указан параметр -x, команда выполняется после замены всех номеров\n"
"    заданий, указанных в аргументах, на идентификатор процесса\n"
"    лидера группы процессов задания.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла ошибка.\n"
"    Если указан параметр -x, возвращает состояние выхода команды."

#: builtins.c:906
#, fuzzy
#| msgid ""
#| "Remove jobs from current shell.\n"
#| "    \n"
#| "    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
#| "    any JOBSPECs, the shell uses its notion of the current job.\n"
#| "    \n"
#| "    Options:\n"
#| "      -a\tremove all jobs if JOBSPEC is not supplied\n"
#| "      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
#| "    \tshell receives a SIGHUP\n"
#| "      -r\tremove only running jobs\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid option or JOBSPEC is given."
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Удаление заданий в текущем командном процессоре.\n"
"    \n"
"    Удаляет все указанные задания из списка активных заданий.  Если\n"
"    задание не указано, удаляется текущее задание.\n"
"    \n"
"    Параметры:\n"
"      -a\tудалить все задания, если не указано конкретное задание\n"
"      -h\tпометить все задания, чтобы им не отправлялся сигнал SIGHUP,\n"
"    \tесли командный процессор получает сигнал SIGHUP\n"
"      -r\tудалить только активные задания\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или задание."

#: builtins.c:925
#, fuzzy
#| msgid ""
#| "Send a signal to a job.\n"
#| "    \n"
#| "    Send the processes identified by PID or JOBSPEC the signal named by\n"
#| "    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
#| "    SIGTERM is assumed.\n"
#| "    \n"
#| "    Options:\n"
#| "      -s sig\tSIG is a signal name\n"
#| "      -n sig\tSIG is a signal number\n"
#| "      -l\tlist the signal names; if arguments follow `-l' they are\n"
#| "    \tassumed to be signal numbers for which names should be listed\n"
#| "    \n"
#| "    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
#| "    instead of process IDs, and allows processes to be killed if the limit\n"
#| "    on processes that you can create is reached.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid option is given or an error occurs."
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Отправка сигнала заданию.\n"
"    \n"
"    Отправляет процессам или заданиям сигнал с указанным названием\n"
"    или номером. Если номер или название сигнала\n"
"    не указаны, отправляется сигнал SIGTERM.\n"
"    \n"
"    Параметры:\n"
"      -s сигнал\tназвание сигнала\n"
"      -n сигнал\tномер сигнала\n"
"      -l\t\tпоказывает названия сигналов; если после аргументов указано «-l»,\n"
"    \tони считаются номерами сигналов, для которых необходимо показать названия\n"
"    \n"
"    kill — это встроенная команда, предназначенная для двух задач: использовать\n"
"    номера заданий вместо номеров процессов и убивать процессы\n"
"    при достижении предельного числа процессов.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла ошибка."

#: builtins.c:949
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Расчёт математических выражений.\n"
"    \n"
"    Выполняет расчёт всех аргументов в математическом выражении.  Расчёт выполняется\n"
"    для целых чисел фиксированной ширины с без проверки на переполнение.\n"
"    Однако деление на 0 перехватывается и выдаётся ошибка.  Указанные ниже операторы объединены\n"
"    в группы с одинаковым приоритетом.  Группы перечислены\n"
"    в порядке уменьшения приоритета.\n"
"    \n"
"    \tid++, id--\tпоследующее увеличение и уменьшение переменной\n"
"    \t++id, --id\tпредварительное увеличение и уменьшение переменной\n"
"    \t-, +\t\tунарный минус и плюс\n"
"    \t!, ~\t\tлогическое и побитовое отрицание\n"
"    \t**\t\tвозведение в степень\n"
"    \t*, /, %\t\tумножение, деление, остаток\n"
"    \t+, -\t\tсложение, вычитание\n"
"    \t<<, >>\t\tбитовые сдвиги влево или вправо\n"
"    \t<=, >=, <, >\tсравнение\n"
"    \t==, !=\t\tравенство, неравенство\n"
"    \t&\t\tпобитовое И\n"
"    \t^\t\tпобитовое исключающее ИЛИ\n"
"    \t|\t\tпобитовое ИЛИ\n"
"    \t&&\t\tлогическое И\n"
"    \t||\t\tлогические ИЛИ\n"
"    \tвыражение ? выражение : выражение\n"
"    \t\t\tусловный оператор\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tприсвоение\n"
"    \n"
"    в качестве операндов можно использовать переменные командного процессора.  Название переменной\n"
"    заменяется её значением (приводится к целому числу фиксированной ширины)\n"
"    в выражении.  У переменной не должен быть включён атрибут integer,\n"
"    чтобы её можно было использовать в выражении.\n"
"    \n"
"    Операторы вычисляются в порядке старшинства.  Вложенные выражения в\n"
"    скобках вычисляются первыми и могут переопределить указанные\n"
"    выше правила старшинства.\n"
"    \n"
"    Состояние выхода:\n"
"    Если последний АРГУМЕНТ имеет значение 0, let возвращает 1. В противном случае let возвращает 0."

#: builtins.c:994
#, fuzzy
#| msgid ""
#| "Read a line from the standard input and split it into fields.\n"
#| "    \n"
#| "    Reads a single line from the standard input, or from file descriptor FD\n"
#| "    if the -u option is supplied.  The line is split into fields as with word\n"
#| "    splitting, and the first word is assigned to the first NAME, the second\n"
#| "    word to the second NAME, and so on, with any leftover words assigned to\n"
#| "    the last NAME.  Only the characters found in $IFS are recognized as word\n"
#| "    delimiters.\n"
#| "    \n"
#| "    If no NAMEs are supplied, the line read is stored in the REPLY variable.\n"
#| "    \n"
#| "    Options:\n"
#| "      -a array\tassign the words read to sequential indices of the array\n"
#| "    \t\tvariable ARRAY, starting at zero\n"
#| "      -d delim\tcontinue until the first character of DELIM is read, rather\n"
#| "    \t\tthan newline\n"
#| "      -e\t\tuse Readline to obtain the line in an interactive shell\n"
#| "      -i text\tUse TEXT as the initial text for Readline\n"
#| "      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
#| "    \t\tfor a newline, but honor a delimiter if fewer than NCHARS\n"
#| "    \t\tcharacters are read before the delimiter\n"
#| "      -N nchars\treturn only after reading exactly NCHARS characters, unless\n"
#| "    \t\tEOF is encountered or read times out, ignoring any delimiter\n"
#| "      -p prompt\toutput the string PROMPT without a trailing newline before\n"
#| "    \t\tattempting to read\n"
#| "      -r\t\tdo not allow backslashes to escape any characters\n"
#| "      -s\t\tdo not echo input coming from a terminal\n"
#| "      -t timeout\ttime out and return failure if a complete line of input is\n"
#| "    \t\tnot read within TIMEOUT seconds.  The value of the TMOUT\n"
#| "    \t\tvariable is the default timeout.  TIMEOUT may be a\n"
#| "    \t\tfractional number.  If TIMEOUT is 0, read returns immediately,\n"
#| "    \t\twithout trying to read any data, returning success only if\n"
#| "    \t\tinput is available on the specified file descriptor.  The\n"
#| "    \t\texit status is greater than 128 if the timeout is exceeded\n"
#| "      -u fd\t\tread from file descriptor FD instead of the standard input\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    The return code is zero, unless end-of-file is encountered, read times out\n"
#| "    (in which case it's greater than 128), a variable assignment error occurs,\n"
#| "    or an invalid file descriptor is supplied as the argument to -u."
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as word\n"
"    delimiters. By default, the backslash character escapes delimiter characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times out\n"
"    (in which case it's greater than 128), a variable assignment error occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Чтение строки со стандартного ввода и разделение её на поля.\n"
"    \n"
"    Читает одну строку со стандартного ввода или из файлового дескриптора,\n"
"    если указан параметр -u.  Строка разделяется на поля по словам.\n"
"    Первое слово присваивается первому указанному имени, второе слово — второму\n"
"    имени и так далее.\n"
"    Оставшиеся слова присваиваются последнему указанному имени.  В качестве разделителей слов используются только символы\n"
"    из переменной $IFS.\n"
"    \n"
"    Если имена не указаны, прочитанная строка сохраняется в переменной $REPLY.\n"
"    \n"
"    Параметры:\n"
"      -a массив\tпоследовательно присвоить прочитанные слова указателям\n"
"    \t\tмассива, начиная с нуля\n"
"      -d разделитель\tпродолжить до первого разделителя,\n"
"    \t\tа не до символа новой строки\n"
"      -e\t\tс помощью readline получить строку в интерактивном командном процессоре\n"
"      -i текст\t\tиспользовать текст в качестве исходного для readline\n"
"      -n число_знаков\tвыполнить возврат после прочтения числа знаков, а не ждать\n"
"    \t\tсимвола новой строки; учитывать разделитель, если до него было прочитано\n"
"    \t\tменьше указанного числа знаков\n"
"      -N число_знаков\tвыполнить возврат только после прочтения указанного числа знаков,\n"
"    \t\tесли только не был получен конец строки или не истекло время ожидания, игнорируя все разделители\n"
"      -p приглашение\tпоказать приглашение без символа новой строки в конце\n"
"    \t\tперед тем как читать\n"
"      -r\t\tне выполнять экранирование символами косой черты\n"
"      -s\t\tне показывать данные, полученные из терминала\n"
"      -t тайм-аут\tпрекратить ожидание и вывести ошибку, если полная входная\n"
"    \t\tстрока не была прочитана за указанное число секунд  В переменной $TMOUT хранится\n"
"    \t\tзначение тайм-аута по умолчанию.  Время ожидания\n"
"    \t\tможет быть дробным числом.  Если тайм-аут равен 0, read немедленно выполняет возврат,\n"
"    \t\tне пытаясь прочитать никакие данные. Успех возвращается,\n"
"    \t\tтолько если входные данные доступны по указанному файловому дескриптору.   \n"
"    \t\tСостояние выхода больше 128, если время ожидания было превышено.\n"
"      -u fd\t\tчитать из файлового дескриптора, а не со стандартного входа\n"
"    \n"
"    Состояние выхода:\n"
"    Состояние выхода будет нулевым, если не был встречен конец файла, не истекло время ожидания\n"
"    (в этом случае состояние выхода будет больше 128), не возникла ошибка присвоения переменной\n"
"    или не был указан недопустимый файловый дескриптор как аргумент для -u."

#: builtins.c:1042
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Возврат из функции командного процессора.\n"
"    \n"
"    Выполняет выход из функции или исходного скрипта со значением возврата,\n"
"    указанным как N. Если N не указан, используется состояние возврата\n"
"    последней команды, выполненной в функции или скрипте.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает N или ошибку, если командный процессор не выполняет функцию или скрипт."

#: builtins.c:1055
#, fuzzy
#| msgid ""
#| "Set or unset values of shell options and positional parameters.\n"
#| "    \n"
#| "    Change the value of shell attributes and positional parameters, or\n"
#| "    display the names and values of shell variables.\n"
#| "    \n"
#| "    Options:\n"
#| "      -a  Mark variables which are modified or created for export.\n"
#| "      -b  Notify of job termination immediately.\n"
#| "      -e  Exit immediately if a command exits with a non-zero status.\n"
#| "      -f  Disable file name generation (globbing).\n"
#| "      -h  Remember the location of commands as they are looked up.\n"
#| "      -k  All assignment arguments are placed in the environment for a\n"
#| "          command, not just those that precede the command name.\n"
#| "      -m  Job control is enabled.\n"
#| "      -n  Read commands but do not execute them.\n"
#| "      -o option-name\n"
#| "          Set the variable corresponding to option-name:\n"
#| "              allexport    same as -a\n"
#| "              braceexpand  same as -B\n"
#| "              emacs        use an emacs-style line editing interface\n"
#| "              errexit      same as -e\n"
#| "              errtrace     same as -E\n"
#| "              functrace    same as -T\n"
#| "              hashall      same as -h\n"
#| "              histexpand   same as -H\n"
#| "              history      enable command history\n"
#| "              ignoreeof    the shell will not exit upon reading EOF\n"
#| "              interactive-comments\n"
#| "                           allow comments to appear in interactive commands\n"
#| "              keyword      same as -k\n"
#| "              monitor      same as -m\n"
#| "              noclobber    same as -C\n"
#| "              noexec       same as -n\n"
#| "              noglob       same as -f\n"
#| "              nolog        currently accepted but ignored\n"
#| "              notify       same as -b\n"
#| "              nounset      same as -u\n"
#| "              onecmd       same as -t\n"
#| "              physical     same as -P\n"
#| "              pipefail     the return value of a pipeline is the status of\n"
#| "                           the last command to exit with a non-zero status,\n"
#| "                           or zero if no command exited with a non-zero status\n"
#| "              posix        change the behavior of bash where the default\n"
#| "                           operation differs from the Posix standard to\n"
#| "                           match the standard\n"
#| "              privileged   same as -p\n"
#| "              verbose      same as -v\n"
#| "              vi           use a vi-style line editing interface\n"
#| "              xtrace       same as -x\n"
#| "      -p  Turned on whenever the real and effective user ids do not match.\n"
#| "          Disables processing of the $ENV file and importing of shell\n"
#| "          functions.  Turning this option off causes the effective uid and\n"
#| "          gid to be set to the real uid and gid.\n"
#| "      -t  Exit after reading and executing one command.\n"
#| "      -u  Treat unset variables as an error when substituting.\n"
#| "      -v  Print shell input lines as they are read.\n"
#| "      -x  Print commands and their arguments as they are executed.\n"
#| "      -B  the shell will perform brace expansion\n"
#| "      -C  If set, disallow existing regular files to be overwritten\n"
#| "          by redirection of output.\n"
#| "      -E  If set, the ERR trap is inherited by shell functions.\n"
#| "      -H  Enable ! style history substitution.  This flag is on\n"
#| "          by default when the shell is interactive.\n"
#| "      -P  If set, do not resolve symbolic links when executing commands\n"
#| "          such as cd which change the current directory.\n"
#| "      -T  If set, the DEBUG trap is inherited by shell functions.\n"
#| "      --  Assign any remaining arguments to the positional parameters.\n"
#| "          If there are no remaining arguments, the positional parameters\n"
#| "          are unset.\n"
#| "      -   Assign any remaining arguments to the positional parameters.\n"
#| "          The -x and -v options are turned off.\n"
#| "    \n"
#| "    Using + rather than - causes these flags to be turned off.  The\n"
#| "    flags can also be used upon invocation of the shell.  The current\n"
#| "    set of flags may be found in $-.  The remaining n ARGs are positional\n"
#| "    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
#| "    ARGs are given, all shell variables are printed.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid option is given."
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Присвоение или удаление значений параметров командного процессора и позиционных параметров.\n"
"    \n"
"    Изменяет значение атрибутов командного процессора и позиционных параметров или\n"
"    выводит названия и значения переменных командного процессора.\n"
"    \n"
"    Параметры:\n"
"      -a  пометить переменные, которые были изменены или созданы для экспорта\n"
"      -b  немедленно уведомить о завершении задания\n"
"      -e  немедленно выйти, если команда выполняет выход с ненулевым состоянием\n"
"      -f  отключить генерацию имён файлов (подстановка)\n"
"      -h  запомнить расположение команд, как они выглядели ранее\n"
"      -k  поместить в окружение для команды все аргументы присвоения,\n"
"          а не только те, что были указаны перед командой\n"
"      -m  включено управление заданиями\n"
"      -n  прочитать команды, но не выполнять их\n"
"      -o название-параметра\n"
"          Задаёт переменную, соответствующую названию параметра:\n"
"              allexport    эквивалент -a\n"
"              braceexpand  эквивалент -B\n"
"              emacs        использовать стиль emacs для редактирования строк\n"
"              errexit      эквивалент -e\n"
"              errtrace     эквивалент -E\n"
"              functrace    эквивалент -T\n"
"              hashall      эквивалент -h\n"
"              histexpand   эквивалент -H\n"
"              history      включить журнал команд\n"
"              ignoreeof    не закрывать командный процессор после получения конца файла\n"
"              interactive-comments\n"
"                           разрешить показ комментариев в интерактивных командах\n"
"              keyword      эквивалент -k\n"
"              monitor      эквивалент -m\n"
"              noclobber    эквивалент -C\n"
"              noexec       эквивалент -n\n"
"              noglob       эквивалент -f\n"
"              nolog        допускается, но игнорируется\n"
"              notify       эквивалент -b\n"
"              nounset      эквивалент -u\n"
"              onecmd       эквивалент -t\n"
"              physical     эквивалент -P\n"
"              pipefail     возвращаемое значение конвейера является состоянием\n"
"                           последней команды, завершившейся с ненулевым состоянием,\n"
"                           или нулём, если не было команды, завершившейся с ненулевым состоянием\n"
"              posix        изменить поведение bash там, где операции\n"
"                           по умолчанию отличаются от стандарта Posix, чтобы\n"
"                           соответствовать этому стандарту\n"
"              privileged   эквивалент -p\n"
"              verbose      эквивалент -v\n"
"              vi           использовать стиль vi для редактирования строк\n"
"              xtrace       эквивалент -x\n"
"      -p  Включён, когда реальный и эффективный идентификаторы пользователя не совпадают.\n"
"          Отключает обработку файла $ENV и импорт функций командного\n"
"          процессора.  Если отключить этот параметр, эффективные UID и GID\n"
"          будут назначены реальным UID и GID.\n"
"      -t  Выйти после прочтения и выполнения одной команды.\n"
"      -u  Считать незаданные переменные ошибкой при замене.\n"
"      -v  Выводить входные строки на экран после их чтения.\n"
"      -x  Выводить команды и их аргументы во время их выполнения.\n"
"      -B  Командный процессор развернёт скобки.\n"
"      -C  Если задано, запретить перезапись существующих обычных файлов\n"
"          вследствие перенаправления вывода.\n"
"      -E  Если задано, ловушка ERR наследуется функциями командного процессора.\n"
"      -H  Включить замену журнала с использованием !.  По умолчанию этот флаг\n"
"          установлен, если командный процессор интерактивный.\n"
"      -P  Если задано, не разрешать символьные ссылки при выполнении команд,\n"
"          таких как cd, которые изменяют текущий каталог.\n"
"      -T  Если задано, ловушка DEBUG наследуется функциями командного процессора.\n"
"      --  Назначить все оставшиеся аргументы позиционным параметрам.\n"
"          Если аргументов не осталось, позиционные параметры\n"
"          удаляются.\n"
"      -   Назначить все оставшиеся аргументы позиционным параметрам.\n"
"          Параметры -x и -v выключены.\n"
"    \n"
"    Если вместо - указать +, флаги будут выключены.   \n"
"    Флаги также можно использовать до вызова командного процессора.  Текущий\n"
"    набор флагов можно просмотреть в $-.  Оставшиеся n аргументов являются позиционными\n"
"    параметрами и назначаются в порядке $1, $2, .. $n.  Если\n"
"    аргументы не указаны, выводятся все переменные командного процессора.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр."

#: builtins.c:1140
#, fuzzy
#| msgid ""
#| "Unset values and attributes of shell variables and functions.\n"
#| "    \n"
#| "    For each NAME, remove the corresponding variable or function.\n"
#| "    \n"
#| "    Options:\n"
#| "      -f\ttreat each NAME as a shell function\n"
#| "      -v\ttreat each NAME as a shell variable\n"
#| "      -n\ttreat each NAME as a name reference and unset the variable itself\n"
#| "    \trather than the variable it references\n"
#| "    \n"
#| "    Without options, unset first tries to unset a variable, and if that fails,\n"
#| "    tries to unset a function.\n"
#| "    \n"
#| "    Some variables cannot be unset; also see `readonly'.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid option is given or a NAME is read-only."
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Удаление значений и атрибутов переменных и функций командного процессора.\n"
"    \n"
"    Для каждого названия удаляет соответствующую переменную или функцию.\n"
"    \n"
"    Параметры:\n"
"      -f\tсчитать каждое указанное имя функцией командного процессора\n"
"      -v\tсчитать каждое указанное имя переменной командного процессора\n"
"      -n\tсчитать каждое указанное имя ссылкой на название и удалить саму переменную,\n"
"    \tа не переменную, на которую указывает ссылка\n"
"    \n"
"    Если параметры не указаны, unset сначала пытается удалить переменную. Если это не удаётся,\n"
"    пытается удалить функцию.\n"
"    \n"
"    Некоторые переменные нельзя удалить. См. также «readonly».\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или указанное имя доступно для записи."

#: builtins.c:1162
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Установка атрибута экспорта для переменных командного процессора.\n"
"    \n"
"    Помечает все имена для автоматического экспорта в среду для\n"
"    последующих выполняемых команд.  Если указано значение, оно присваивается перед экспортом.\n"
"    \n"
"    Параметры:\n"
"      -f\tиспользовать функции командного процессора\n"
"      -n\tудалить свойство экспорта изо всех имён\n"
"      -p\tвывести список всех экспортированных переменных и функций\n"
"    \n"
"    Аргумент «--» отключает дальнейшую обработку параметров.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или имя."

#: builtins.c:1181
#, fuzzy
#| msgid ""
#| "Mark shell variables as unchangeable.\n"
#| "    \n"
#| "    Mark each NAME as read-only; the values of these NAMEs may not be\n"
#| "    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
#| "    before marking as read-only.\n"
#| "    \n"
#| "    Options:\n"
#| "      -a\trefer to indexed array variables\n"
#| "      -A\trefer to associative array variables\n"
#| "      -f\trefer to shell functions\n"
#| "      -p\tdisplay a list of all readonly variables or functions, depending on\n"
#| "            whether or not the -f option is given\n"
#| "    \n"
#| "    An argument of `--' disables further option processing.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid option is given or NAME is invalid."
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Запрет изменения переменных командного процессора.\n"
"    \n"
"    Делает каждое имя доступным только чтения. Значения этих имён нельзя\n"
"    будет изменить в будущем.  Если указано значение, присваивает это значение\n"
"    перед тем, как сделать его доступным только для чтения.\n"
"    \n"
"    Параметры:\n"
"      -a\tссылаться на переменные индексированного массива\n"
"      -A\tссылаться на переменные ассоциативного массива\n"
"      -f\tиспользовать функции командного процессора\n"
"      -p\tвывести список всех переменных или функций, доступных только для чтения,\n"
"            в зависимости от того, указан ли параметр -f\n"
"    \n"
"    Аргумент «--» отключает дальнейшую обработку параметров.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или имя."

#: builtins.c:1203
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Сдвиг позиционных параметров.\n"
"    \n"
"    Переименовывает позиционные параметры $N+1,$N+2,.. в $1,$2,..\n"
"    Если N не указан, считается, что указано 1.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если N положительный или меньше $#."

#: builtins.c:1215 builtins.c:1230
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Выполнение команд из файла в текущем командном процессоре.\n"
"    \n"
"    Читает и выполняет команды из указанного файла в текущем командном процессоре.   \n"
"    Файл ищется в каталогах, указанных в переменной $PATH.\n"
"    Если указаны аргументы, они становятся позиционными параметрами\n"
"    при выполнении файла.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды из файла. Возвращает ошибку,\n"
"    если файл не удаётся прочитать."

#: builtins.c:1246
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Приостановка работы командного процессора.\n"
"    \n"
"    Приостанавливает работу текущего командного процессора до получения сигнала SIGCONT.\n"
"    Работу командных процессоров login можно приостановить только в принудительном режиме.\n"
"    \n"
"    Параметры:\n"
"      -f\tпринудительно приостановить работу, даже если командный процессор — login\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если не включено управление заданиями или не произошла ошибка."

#: builtins.c:1262
#, fuzzy
#| msgid ""
#| "Evaluate conditional expression.\n"
#| "    \n"
#| "    Exits with a status of 0 (true) or 1 (false) depending on\n"
#| "    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
#| "    expressions are often used to examine the status of a file.  There\n"
#| "    are string operators and numeric comparison operators as well.\n"
#| "    \n"
#| "    The behavior of test depends on the number of arguments.  Read the\n"
#| "    bash manual page for the complete specification.\n"
#| "    \n"
#| "    File operators:\n"
#| "    \n"
#| "      -a FILE        True if file exists.\n"
#| "      -b FILE        True if file is block special.\n"
#| "      -c FILE        True if file is character special.\n"
#| "      -d FILE        True if file is a directory.\n"
#| "      -e FILE        True if file exists.\n"
#| "      -f FILE        True if file exists and is a regular file.\n"
#| "      -g FILE        True if file is set-group-id.\n"
#| "      -h FILE        True if file is a symbolic link.\n"
#| "      -L FILE        True if file is a symbolic link.\n"
#| "      -k FILE        True if file has its `sticky' bit set.\n"
#| "      -p FILE        True if file is a named pipe.\n"
#| "      -r FILE        True if file is readable by you.\n"
#| "      -s FILE        True if file exists and is not empty.\n"
#| "      -S FILE        True if file is a socket.\n"
#| "      -t FD          True if FD is opened on a terminal.\n"
#| "      -u FILE        True if the file is set-user-id.\n"
#| "      -w FILE        True if the file is writable by you.\n"
#| "      -x FILE        True if the file is executable by you.\n"
#| "      -O FILE        True if the file is effectively owned by you.\n"
#| "      -G FILE        True if the file is effectively owned by your group.\n"
#| "      -N FILE        True if the file has been modified since it was last read.\n"
#| "    \n"
#| "      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
#| "                       modification date).\n"
#| "    \n"
#| "      FILE1 -ot FILE2  True if file1 is older than file2.\n"
#| "    \n"
#| "      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
#| "    \n"
#| "    String operators:\n"
#| "    \n"
#| "      -z STRING      True if string is empty.\n"
#| "    \n"
#| "      -n STRING\n"
#| "         STRING      True if string is not empty.\n"
#| "    \n"
#| "      STRING1 = STRING2\n"
#| "                     True if the strings are equal.\n"
#| "      STRING1 != STRING2\n"
#| "                     True if the strings are not equal.\n"
#| "      STRING1 < STRING2\n"
#| "                     True if STRING1 sorts before STRING2 lexicographically.\n"
#| "      STRING1 > STRING2\n"
#| "                     True if STRING1 sorts after STRING2 lexicographically.\n"
#| "    \n"
#| "    Other operators:\n"
#| "    \n"
#| "      -o OPTION      True if the shell option OPTION is enabled.\n"
#| "      -v VAR\t True if the shell variable VAR is set\n"
#| "      -R VAR\t True if the shell variable VAR is set and is a name reference.\n"
#| "      ! EXPR         True if expr is false.\n"
#| "      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
#| "      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
#| "    \n"
#| "      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
#| "                     -lt, -le, -gt, or -ge.\n"
#| "    \n"
#| "    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
#| "    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
#| "    than ARG2.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
#| "    false or an invalid argument is given."
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Расчёт условного выражения.\n"
"    \n"
"    Возвращает состояние 0 (истина) или 1 (ложь) после\n"
"    расчёта выражения.  Выражения могут быть унарными или бинарными.  Унарные\n"
"    выражения часто используются для определения состояния файла.  Также\n"
"    доступны стоковые операторы и операторы сравнения чисел.\n"
"    \n"
"    Поведение команды test зависит от количества аргументов.  Полное\n"
"    описание см. в странице руководства bash.\n"
"    \n"
"    Операторы работы с файлами:\n"
"    \n"
"      -a ФАЙЛ        Истина, если файл существует.\n"
"      -b ФАЙЛ        Истина, если файл представляет блочное устройство.\n"
"      -c ФАЙЛ        Истина, если файл представляет символьное устройство.\n"
"      -d ФАЙЛ        Истина, если файл является каталогом.\n"
"      -e ФАЙЛ        Истина, если файл существует.\n"
"      -f ФАЙЛ        Истина, если файл существует и является обычным файлом.\n"
"      -g ФАЙЛ        Истина, если для файла установлен бит SGID.\n"
"      -h ФАЙЛ        Истина, если файл является символьной ссылкой.\n"
"      -L ФАЙЛ        Истина, если файл является символьной ссылкой.\n"
"      -k ФАЙЛ        Истина, если для файла установлен sticky-бит.\n"
"      -p ФАЙЛ        Истина, если файл является именованным конвейером.\n"
"      -r ФАЙЛ        Истина, если вы можете прочитать файл.\n"
"      -s ФАЙЛ        Истина, если файл существует и не является пустым.\n"
"      -S ФАЙЛ        Истина, если файл является сокетом.\n"
"      -t ФД          Истина, если файловый дескриптор ФД открыт в терминале.\n"
"      -u ФАЙЛ        Истина, если для файла установлен бит SUID.\n"
"      -w ФАЙЛ        Истина, если вы можете выполнить запись в файл.\n"
"      -x ФАЙЛ        Истина, если вы можете выполнить файл.\n"
"      -O ФАЙЛ        Истина, если вы являетесь эффективным владельцем файла.\n"
"      -G ФАЙЛ        Истина, если ваша группа является эффективным владельцем файла.\n"
"      -N ФАЙЛ        Истина, если файл был изменён после последнего чтения.\n"
"    \n"
"      ФАЙЛ1 -nt ФАЙЛ2  Истина, если файл1 новее файла2 (согласно\n"
"                       дате изменения).\n"
"    \n"
"      ФАЙЛ1 -ot ФАЙЛ2  Истина, если файл1 старее файла2.\n"
"    \n"
"      ФАЙЛ1 -ef ФАЙЛ2  Истина, если файл1 является жёсткой ссылкой на файл2.\n"
"    \n"
"    Строковые операторы:\n"
"    \n"
"      -z СТРОКА      Истина, если строка является пустой.\n"
"    \n"
"      -n СТРОКА\n"
"         СТРОКА      Истина, если строка не является пустой.\n"
"    \n"
"      СТРОКА1 = СТРОКА2\n"
"                     Истина, если строки совпадают.\n"
"      СТРОКА1 != СТРОКА2\n"
"                     Истина, если строки не совпадают.\n"
"      СТРОКА1 < СТРОКА2\n"
"                     Истина, если СТРОКА1 сортируется до СТРОКИ2 лексикографически.\n"
"      СТРОКА1 > СТРОКА2\n"
"                     Истина, если СТРОКА1 сортируется после СТРОКИ2 лексикографически.\n"
"    \n"
"    Остальные операторы:\n"
"    \n"
"      -o ПАРАМЕТР    Истина, если параметр командного процессора включён.\n"
"      -v ПЕР\t Истина, если переменная командного процессора задана\n"
"      -R ПЕР\t Истина, если переменная командного процессора задана и является именованной ссылкой.\n"
"      ! ВЫРАЖ        Истина, если выражение возвращает ложь.\n"
"      ВЫРАЖ1 -a ВЫРАЖ2 Истина, если оба выражения возвращают истину.\n"
"      ВЫРАЖ1 -o ВЫРАЖ2 Истина, если хотя бы одно из выражений возвращает истину.\n"
"    \n"
"      арг1 ОП арг2   Математические проверки.  ОП может быть одним из следующих: -eq, -ne,\n"
"                     -lt, -le, -gt или -ge.\n"
"    \n"
"    Математические бинарные операторы возвращают истину, если АРГУМЕНТ1 равен, не равен,\n"
"    меньше, меньше или равен либо больше или равен\n"
"    АРГУМЕНТУ2.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если выражение истинно, или ошибку, если выражение ложно\n"
"    или указан недопустимый аргумент."

#: builtins.c:1344
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Расчёт условного выражения.\n"
"    \n"
"    Это синоним встроенной команды test, но последним аргументом должна\n"
"    быть скобка «]», соответствующая открывающей «[»."

#: builtins.c:1353
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Отображение времени процесса.\n"
"    \n"
"    Показывает объединённые значения времени пользователя и системы для командного\n"
"    процессора и всех его дочерних процессов.\n"
"    \n"
"    Состояние выхода:\n"
"    Всегда возвращает успех."

#: builtins.c:1365
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  If\n"
"    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or a\n"
"    script run by the . or source builtins finishes executing.  A SIGNAL_SPEC\n"
"    of ERR means to execute ARG each time a command's failure would cause the\n"
"    shell to exit when the -e option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is given."
msgstr ""
"Захват сигналов и других событий.\n"
"    \n"
"    Определяет и активирует обработчики, которые будут выполняться, когда\n"
"    командный процессор получает сигналы или при других условиях.\n"
"    \n"
"    Аргумент — это команда, которая считывается и выполняется, когда\n"
"    командный процессор получает указанные сигнал(ы).  Если аргумент отсутствует (и указан один сигнал)\n"
"    или указано «-», для всех указанных сигналов восстанавливаются\n"
"    исходные значения.  Если аргумент — пустая строка, все указанные сигналы игнорируются\n"
"    командным процессором и вызываемыми им командами.\n"
"    \n"
"    Если сигнал — EXIT (0), аргумент выполняется при выходе из командного процессора.  Если\n"
"    сигнал — DEBUG, аргумент выполняется перед каждой простой командой.  Если\n"
"    сигнал — RETURN, аргумент выполняется каждый раз, когда функция\n"
"    или скрипт выполняется в . или исходные встроенные команды завершают свою работу.  Сигнал\n"
"    ERR означает выполнение аргумента каждый раз, когда ошибка команды приведёт\n"
"    к выходу из командного процессора, когда включён параметр -e.\n"
"    \n"
"    Если аргументы не указаны, trap выводит список команд, связанных\n"
"    с каждом сигналом.\n"
"    \n"
"    Параметры:\n"
"      -l\tпоказать названия сигналов и их номера\n"
"      -p\tпоказать команды trap, связанные с каждым сигналом\n"
"    \n"
"    Идентификатор сигнала — это название сигнала в <signal.h> или номер сигнала.\n"
"    Названия сигналов не зависят от регистра, а префикс SIG не является обязательным.   \n"
"    Сигнал можно отправить в командный процессор командой «kill -signal $$».\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый сигнал или параметр."

#: builtins.c:1401
#, fuzzy
#| msgid ""
#| "Display information about command type.\n"
#| "    \n"
#| "    For each NAME, indicate how it would be interpreted if used as a\n"
#| "    command name.\n"
#| "    \n"
#| "    Options:\n"
#| "      -a\tdisplay all locations containing an executable named NAME;\n"
#| "    \tincludes aliases, builtins, and functions, if and only if\n"
#| "    \tthe `-p' option is not also used\n"
#| "      -f\tsuppress shell function lookup\n"
#| "      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
#| "    \tbuiltin, or function, and returns the name of the disk file\n"
#| "    \tthat would be executed\n"
#| "      -p\treturns either the name of the disk file that would be executed,\n"
#| "    \tor nothing if `type -t NAME' would not return `file'.\n"
#| "      -t\toutput a single word which is one of `alias', `keyword',\n"
#| "    \t`function', `builtin', `file' or `', if NAME is an alias, shell\n"
#| "    \treserved word, shell function, shell builtin, disk file, or not\n"
#| "    \tfound, respectively\n"
#| "    \n"
#| "    Arguments:\n"
#| "      NAME\tCommand name to be interpreted.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success if all of the NAMEs are found; fails if any are not found."
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not found."
msgstr ""
"Вывод информации о типе команды.\n"
"    \n"
"    Для каждого указанного имени показывает, как оно будет интерпретировано при\n"
"    использовании в качестве названия команды.\n"
"    \n"
"    Параметры:\n"
"      -a\tпоказать все местоположения, где есть исполняемый файл с указанным именем,\n"
"    \tвключая псевдонимы, встроенные команды и функции, а также при условии\n"
"    \tчто не используется параметр «-p»\n"
"      -f\tне искать функции командного процессора\n"
"      -P\tпринудительно искать в $PATH все указанные имена, даже если это псевдоним,\n"
"    \tвстроенная команда или функция, и возвращать название файла на диске,\n"
"    \tкоторый будет запущен\n"
"      -p\tвозвращает название файла на диске, который будет запущен,\n"
"    \tили ничего, если «type -t имя» не возвращает «file».\n"
"      -t\tвывести одно из слов «alias», «keyword»,\n"
"    \t«function», «builtin», «file» или «», если указанное имя является, соответственно,\n"
"    \tпсевдонимом, зарезервированным словом, функцией, встроенной командой\n"
"    \tкомандного процессора, файлом на диске или имя не было найдено\n"
"    \n"
"    Аргументы:\n"
"      ИМЯ\tназвание интерпретируемой команды\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если все указанные имена были найдены, или ошибку в противном случае."

#: builtins.c:1432
#, fuzzy
#| msgid ""
#| "Modify shell resource limits.\n"
#| "    \n"
#| "    Provides control over the resources available to the shell and processes\n"
#| "    it creates, on systems that allow such control.\n"
#| "    \n"
#| "    Options:\n"
#| "      -S\tuse the `soft' resource limit\n"
#| "      -H\tuse the `hard' resource limit\n"
#| "      -a\tall current limits are reported\n"
#| "      -b\tthe socket buffer size\n"
#| "      -c\tthe maximum size of core files created\n"
#| "      -d\tthe maximum size of a process's data segment\n"
#| "      -e\tthe maximum scheduling priority (`nice')\n"
#| "      -f\tthe maximum size of files written by the shell and its children\n"
#| "      -i\tthe maximum number of pending signals\n"
#| "      -l\tthe maximum size a process may lock into memory\n"
#| "      -m\tthe maximum resident set size\n"
#| "      -n\tthe maximum number of open file descriptors\n"
#| "      -p\tthe pipe buffer size\n"
#| "      -q\tthe maximum number of bytes in POSIX message queues\n"
#| "      -r\tthe maximum real-time scheduling priority\n"
#| "      -s\tthe maximum stack size\n"
#| "      -t\tthe maximum amount of cpu time in seconds\n"
#| "      -u\tthe maximum number of user processes\n"
#| "      -v\tthe size of virtual memory\n"
#| "      -x\tthe maximum number of file locks\n"
#| "      -T    the maximum number of threads\n"
#| "    \n"
#| "    Not all options are available on all platforms.\n"
#| "    \n"
#| "    If LIMIT is given, it is the new value of the specified resource; the\n"
#| "    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
#| "    current soft limit, the current hard limit, and no limit, respectively.\n"
#| "    Otherwise, the current value of the specified resource is printed.  If\n"
#| "    no option is given, then -f is assumed.\n"
#| "    \n"
#| "    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
#| "    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
#| "    number of processes.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid option is supplied or an error occurs."
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Изменение ограничений ресурсов командного процессора.\n"
"    \n"
"    Позволяет контролировать ресурсы, доступные командному процессору и создаваемым\n"
"    им  процессам, в системах, где возможен такой контроль.\n"
"    \n"
"    Параметры:\n"
"      -S\tиспользовать «мягкое» ограничение ресурсов\n"
"      -H\tиспользовать «жёсткое» ограничение ресурсов\n"
"      -a\tпоказать все текущие ограничения\n"
"      -b\tразмер буфера сокета\n"
"      -c\tмаксимальный размер создаваемых core-файлов\n"
"      -d\tмаксимальный размер сегмента данных процесса\n"
"      -e\tмаксимальный приоритет планирования («nice»)\n"
"      -f\tмаксимальный размер файлов, записываемых командным процессором и его дочерними процессами\n"
"      -i\tмаксимальное число ожидающих сигналов\n"
"      -l\tмаксимальный объём, который процесс может заблокировать в памяти\n"
"      -m\tмаксимальный объём резидентной памяти\n"
"      -n\tмаксимальное число открытых файловых дескрипторов\n"
"      -p\tразмер буфера конвейера\n"
"      -q\tмаксимальное число байт в очередях сообщений POSIX\n"
"      -r\tмаксимальный приоритет планирования в реальном времени\n"
"      -s\tмаксимальный размер стека\n"
"      -t\tмаксимальный объём процессорного времени в секундах\n"
"      -u\tмаксимальное количество пользовательских процессов\n"
"      -v\tобъём виртуальной памяти\n"
"      -x\tмаксимальное число блокировок файлов\n"
"      -T    максимальное количество потоков\n"
"    \n"
"    Не все параметры доступны на всех платформах.\n"
"    \n"
"    Если указано ограничение, оно является новым значением для указанного ресурса.\n"
"    Специальные значения «soft», «hard» и «unlimited» означают,\n"
"    соответственно, текущее мягкое ограничение, текущее жёсткое ограничение и отсутствие ограничения.\n"
"    В противном случае выводится текущее значение указанного ресурса.  Если\n"
"    параметр не указан, подразумевается использование параметра -f.\n"
"    \n"
"    Значения задаются с шагом 1024 байт, кроме параметра -t с шагом в секундах,\n"
"    параметра -p с шагом 512 байт и параметра -u, представляющего\n"
"    количество процессов.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла ошибка."

#: builtins.c:1483
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Отображение или указание маски режима для файлов.\n"
"    \n"
"    Задаёт маску РЕЖИМ для файлов, создаваемых пользователем.  Если РЕЖИМ не указан,\n"
"    выводит текущее значение маски.\n"
"    \n"
"    Если РЕЖИМ начинается с цифры, он интерпретируется как восьмеричное число.\n"
"    В противном случае он считается символьной строкой как для команды chmod(1).\n"
"    \n"
"    Параметры:\n"
"      -p\tесли РЕЖИМ не указан, вывести маску, пригодную для повторного использования\n"
"      -S\tвывести маску в символьном виде, в противном случае выводится восьмеричное число\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый РЕЖИМ или параметр."

#: builtins.c:1503
#, fuzzy
#| msgid ""
#| "Wait for job completion and return exit status.\n"
#| "    \n"
#| "    Waits for each process identified by an ID, which may be a process ID or a\n"
#| "    job specification, and reports its termination status.  If ID is not\n"
#| "    given, waits for all currently active child processes, and the return\n"
#| "    status is zero.  If ID is a a job specification, waits for all processes\n"
#| "    in that job's pipeline.\n"
#| "    \n"
#| "    If the -n option is supplied, waits for the next job to terminate and\n"
#| "    returns its exit status.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
#| "    option is given."
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Ожидание завершения задания и возврат состояния выхода.\n"
"    \n"
"    Ожидает завершения всех процессов, заданных идентификаторами\n"
"    (идентификатор процесса или номер задания), и возвращает их состояние выхода.  Если идентификатор\n"
"    не указан, ожидает завершения всех активных дочерних процессов\n"
"    и возвращает нулевое состояние выхода.  Если идентификатор не является номером задания, ожидает завершения\n"
"    всех процессов в конвейере данного задания.\n"
"    \n"
"    Если указан параметр -n, ожидает завершения следующего задания\n"
"    возвращает его состояние выхода.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последнего идентификатора. Возвращает ошибку, если\n"
"    указан недопустимый идентификатор или параметр."

#: builtins.c:1534
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an invalid\n"
"    option is given."
msgstr ""
"Ожидание завершения процесса и возврат состояния выхода.\n"
"    \n"
"    Ожидает завершения всех процессов, заданных идентификаторами (PID), и возвращает их состояние выхода.\n"
"    Если идентификатор процесса не указан, ожидает завершения всех активных\n"
"    дочерних процессов и возвращает нулевое состояние выхода.  PID должен быть идентификатором процесса.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последнего идентификатора. Возвращает ошибку, если\n"
"    указан недопустимый идентификатор или параметр."

#: builtins.c:1549
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Выполнение команд для всех элементов списка.\n"
"    \n"
"    Цикл «for» выполняет последовательность команд для каждого элемента\n"
"    списка.  Если операнд «in СЛОВА ...;» отсутствует, подразумевается\n"
"    операнд «in \"$@\"».  Каждому элементу в списке СЛОВА присваивается ИМЯ и для него\n"
"    выполняются КОМАНДЫ.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1563
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Математические операции в циклах.\n"
"    \n"
"    Эквивалентно\n"
"    \t(( ВЫРАЖ1))\n"
"    \twhile (( ВЫРАЖ2 )); do\n"
"    \t\tКОМАНДЫ\n"
"    \t\t(( ВЫРАЖ3 ))\n"
"    \tdone\n"
"    ВЫРАЖ1, ВЫРАЖ2 и ВЫРАЖ3 — это математические выражения.  Если любое из выражений\n"
"    не указано, считается, что оно возвращает 1.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1581
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Выбор слов из списка и выполнение команд.\n"
"    \n"
"    СЛОВА разворачиваются, формируя список слов.   \n"
"    Набор развёрнутых слов выводится в поток ошибок с номерами\n"
"    в начале строк.  Если операнд «in СЛОВА ...;» отсутствует, подразумевается\n"
"    операнд «in \"$@\"».  Затем выводится приглашение $PS3 и со стандартного ввода\n"
"    считывается строка.  Если строка состоит из номера,\n"
"    соответствующего одному из показанных слов, этому слову\n"
"    присваивается указанное имя.  Если строка пустая, будут повторно показаны указанные слова\n"
"    и приглашение.  Если прочитан символ конца файла, команда завершает свою работу.  Если прочитаны\n"
"    любые другие значения, указанному имени присваивается пустое значение.  Прочитанная строка\n"
"    сохраняется в переменную $REPLY.  Команды выполняются после каждой выборки,\n"
"    пока не будет выполнена команда прерывания.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1602
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Вывод времени, потраченного на выполнение конвейера.\n"
"    \n"
"    Выполняет конвейер и выводит значения реального времени, пользовательского времени\n"
"    и системного времени ЦП, потраченного на выполнения конвейера.\n"
"    \n"
"    Параметры:\n"
"      -p\tпоказать значения времени в формате Posix\n"
"    \n"
"    Для форматирования выходных данных используется значение переменной $TIMEFORMAT.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращаемое состояние соответствует состоянию выхода конвейера."

#: builtins.c:1619
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Выполнение команд согласно шаблону.\n"
"    \n"
"    Выполняет команды, когда слово соответствует шаблону.   \n"
"    Для разделения шаблонов используется знак «|».\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1631
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of the\n"
"    entire construct is the exit status of the last command executed, or zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Выполнение команд в зависимости от условий.\n"
"    \n"
"    Сначала выполняется список «if КОМАНДЫ».  Если состояние выхода нулевое,\n"
"    выполняется список «then КОМАНДЫ».  В противном случае выполняется по очереди\n"
"    все списки «elif КОМАНДЫ», и если их состояние выхода будет нулевым,\n"
"    выполнится список «then КОМАНДЫ», и команда if завершится.  В противном случае\n"
"    выполнится список «else КОМАНДЫ», если он указан.  Состояние выхода всей\n"
"    конструкции соответствует состоянию выхода последней выполненной команды или будет нулевым,\n"
"    если ни одна проверка условия не возвратила истину.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1648
#, fuzzy
#| msgid ""
#| "Execute commands as long as a test succeeds.\n"
#| "    \n"
#| "    Expand and execute COMMANDS as long as the final command in the\n"
#| "    `while' COMMANDS has an exit status of zero.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns the status of the last command executed."
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Выполнение команд до тех пор, пока проверка условия возвращает истину.\n"
"    \n"
"    Разворачивает и выполняет команды до тех пор, пока последняя команда в\n"
"    командах «while» завершается с нулевым состоянием.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1660
#, fuzzy
#| msgid ""
#| "Execute commands as long as a test does not succeed.\n"
#| "    \n"
#| "    Expand and execute COMMANDS as long as the final command in the\n"
#| "    `until' COMMANDS has an exit status which is not zero.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns the status of the last command executed."
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Выполнение команд до тех пор, пока проверка условия не возвращает истину.\n"
"    \n"
"    Разворачивает и выполняет команды до тех пор, пока последняя команда в\n"
"    командах «until» завершается с ненулевым состоянием.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1672
#, fuzzy
#| msgid ""
#| "Create a coprocess named NAME.\n"
#| "    \n"
#| "    Execute COMMAND asynchronously, with the standard output and standard\n"
#| "    input of the command connected via a pipe to file descriptors assigned\n"
#| "    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
#| "    The default NAME is \"COPROC\".\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns the exit status of COMMAND."
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Создание дополнительного процесса с указанным именем.\n"
"    \n"
"    Выполняет команду асинхронно, когда стандартный вывод и стандартный\n"
"    вход команды подключены через конвейер к дескрипторам файлов, которые назначены\n"
"    указателям 0 и 1 массива переменных ИМЯ в активном командном процессоре.\n"
"    Имя по умолчанию — «COPROC».\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние выхода команды."

#: builtins.c:1686
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Определение функции командного процессора.\n"
"    \n"
"    Создаёт функцию командного процессора с указанным именем.  При запуске в качестве простой команды\n"
"    ИМЯ выполняет КОМАНДЫ в контексте вызывающего их командного процессора.  При вызове ИМЕНИ\n"
"    аргументы передаются в функцию как $1...$n, а функция получает\n"
"    название $FUNCNAME.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если переменная ИМЯ доступно для записи."

#: builtins.c:1700
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Группировка команд.\n"
"    \n"
"    Выполняет набор команд, объединённых в группу.  Это единственный способ перенаправления\n"
"    всего набора команд.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние последней выполненной команды."

#: builtins.c:1712
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Возобновление работы задания в интерактивном режиме.\n"
"    \n"
"    Аналогично аргументу JOB_SPEC для команды «fg».  Возобновляет\n"
"    работу остановленного или фонового задания.  Через JOB_SPEC можно задать название\n"
"    или номер задания.  Если после номера задания указать «&», задание будет переведено\n"
"    в фоновый режим, как если бы идентификатор задания был указан как\n"
"    аргумент для команды «bg».\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает состояние возобновлённого задания."

#: builtins.c:1727
#, fuzzy
#| msgid ""
#| "Evaluate arithmetic expression.\n"
#| "    \n"
#| "    The EXPRESSION is evaluated according to the rules for arithmetic\n"
#| "    evaluation.  Equivalent to \"let EXPRESSION\".\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Расчёт арифметического выражения.\n"
"    \n"
"    Выражение рассчитывается по правилам для математических\n"
"    выражений.  Аналогично «let выражение».\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает 1, если выражение равно 0, в противном случае возвращает 0."

#: builtins.c:1739
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries used\n"
"    by the `test' builtin, and may be combined using the following operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Выполнение условной команды.\n"
"    \n"
"    Возвращает состояние 0 или 1 в зависимости от результата расчёта\n"
"    условного выражения.  Выражения составляются из тех же примитивов, которые используются\n"
"    во встроенной команде «test». Их можно объединить с помощью следующих операторов:\n"
"    \n"
"      ( выражение )\tВозвращает значение выражения\n"
"      ! выражение\tВозвращает истину, если выражение ложно, в противном случае возвращает ложь\n"
"      ВЫРАЖ1 && ВЫРАЖ2\tВозвращает истину, если оба выражения истинны, в противном случае возвращает ложь\n"
"      ВЫРАЖ1 || ВЫРАЖ2\tВозвращает истину, если хотя бы одно из выражений истинно, в противном случае возвращает ложь\n"
"    \n"
"    Если используются операторы «==» и «!=», строка справа от\n"
"    оператора используется как шаблон, и выполняется сопоставление по шаблону.\n"
"    Если используется оператор «=~», строка справа от оператора\n"
"    оценивается как регулярное выражение.\n"
"    \n"
"    Операторы && и || не рассчитывают ВЫРАЖ2, если ВЫРАЖ1 достаточно для\n"
"    определения значения выражения.\n"
"    \n"
"    Состояние выхода:\n"
"    0 или 1 в зависимости от значения выражения."

#: builtins.c:1765
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Стандартные имена переменных командного процессора и их использование.\n"
"    \n"
"    BASH_VERSION\tНомер версии bash.\n"
"    CDPATH\t\tСписок каталогов, разделённых двоеточиями, для поиска\n"
"    \t\tв них каталогов, указанных как аргументы для «cd».\n"
"    GLOBIGNORE\tСписок шаблонов, разделённых двоеточиями и описывающих имена файлов,\n"
"    \t\tкоторые будут игнорироваться при развёртывании пути.\n"
"    HISTFILE\t\tИмя файла, в котором хранится журнал команд.\n"
"    HISTFILESIZE\tЧисло строк в файле журнала.\n"
"    HISTSIZE\t\tЧисло строк журнала, к которым может\n"
"    \t\tполучить доступ командный процессор.\n"
"    HOME\t\tПолный путь к вашему домашнему каталогу.\n"
"    HOSTNAME\t\tИмя данной системы.\n"
"    HOSTTYPE\t\tТип процессора, на котором работает данная версия bash.\n"
"    IGNOREEOF\tУправляет действием командного процессора при получении символа\n"
"    \t\tсимвола конца файла в качестве единственных входных данных.  Если задано, тогда значение\n"
"    \t\tявляется числом символов EOF, которые могут быть\n"
"    \t\tпрочитаны подряд в пустой строке, после чего командный процессор будет закрыт\n"
"    \t\t(по умолчанию — 10).  Если не задано, EOF означает конец входных данных.\n"
"    MACHTYPE\t\tСтрока с описанием текущей системы, в которой запущен bash.\n"
"    MAILCHECK\tКак часто (в секундах) bash проверяет наличие новой почты.\n"
"    MAILPATH\t\tСписок имён файлов, разделённых двоеточиями, в которых bash\n"
"    \t\tищет почту.\n"
"    OSTYPE\t\tВерсия Unix, в которой запущена данная версия bash.\n"
"    PATH\t\tСписок каталогов, разделённых двоеточиями, для поиска\n"
"    \t\tвыполняемых команд.\n"
"    PROMPT_COMMAND\tКоманда, выполняемая перед выводом каждого\n"
"    \t\tосновного приглашения.\n"
"    PS1\t\tОсновная строка приглашения.\n"
"    PS2\t\tДополнительная строка приглашения.\n"
"    PWD\t\tПолный путь до текущего каталога.\n"
"    SHELLOPTS\tСписок включённых параметров командного процессора, разделённых двоеточиями.\n"
"    TERM\t\tНазвание текущего типа терминала.\n"
"    TIMEFORMAT\tФормат вывода данных о времени, показываемых\n"
"    \t\tкомандой time.\n"
"    auto_resume\tНепустое значение означает слово в строке запуска команды,\n"
"    \t\tкоторое сначала ищется в списке\n"
"    \t\tостановленных заданий.  Если команда найдена, задание переводится в интерактивный режим.\n"
"    \t\tЗначение «exact» означает, что слово команды должно\n"
"    \t\tточно совпадать с командой в списке остановленных заданий.   \n"
"    \t\tЗначение «substring» означает, что слово команды\n"
"    \t\tдолжно быть частью строки задания.  Все другие значения означают,\n"
"    \t\tчто команда должна быть префиксом остановленного задания.\n"
"    histchars\tСимволы, управляющие расширением журнала\n"
"    \t\tи быстрой подстановкой.  Первый символ означает\n"
"    \t\tподстановку журнала. Обычно это «!».  Второй символ\n"
"    \t\tозначает «быструю подстановку». Обычно это «^».   \n"
"    \t\tТретий символ означает примечание журнала. Обычно это «#».\n"
"    HISTIGNORE\tСписок шаблонов, разделённых двоеточиями и описывающих команды,\n"
"    \t\tкоторые должны быть сохранены в журнале.\n"

#: builtins.c:1822
#, fuzzy
#| msgid ""
#| "Add directories to stack.\n"
#| "    \n"
#| "    Adds a directory to the top of the directory stack, or rotates\n"
#| "    the stack, making the new top of the stack the current working\n"
#| "    directory.  With no arguments, exchanges the top two directories.\n"
#| "    \n"
#| "    Options:\n"
#| "      -n\tSuppresses the normal change of directory when adding\n"
#| "    \tdirectories to the stack, so only the stack is manipulated.\n"
#| "    \n"
#| "    Arguments:\n"
#| "      +N\tRotates the stack so that the Nth directory (counting\n"
#| "    \tfrom the left of the list shown by `dirs', starting with\n"
#| "    \tzero) is at the top.\n"
#| "    \n"
#| "      -N\tRotates the stack so that the Nth directory (counting\n"
#| "    \tfrom the right of the list shown by `dirs', starting with\n"
#| "    \tzero) is at the top.\n"
#| "    \n"
#| "      dir\tAdds DIR to the directory stack at the top, making it the\n"
#| "    \tnew current working directory.\n"
#| "    \n"
#| "    The `dirs' builtin displays the directory stack.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid argument is supplied or the directory\n"
#| "    change fails."
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Добавление каталогов в стек.\n"
"    \n"
"    Добавляет каталог в начало стека каталогов или выполняет\n"
"    ротацию стека, помещая в начало стека текущий рабочий\n"
"    каталог.  Если аргументы не указаны, меняет местами два первых каталога.\n"
"    \n"
"    Параметры:\n"
"      -n\tпредотвращает обычное изменение каталога при добавлении\n"
"    \tкаталогов в стек, чтобы действия выполнялись только над стеком.\n"
"    \n"
"    Аргументы:\n"
"      +N\tвыполняет ротацию стека, чтобы N-й каталог (слева\n"
"    \tв списке, показанного командой «dirs», начиная с нуля)\n"
"    \tстал первым в стеке.\n"
"    \n"
"      -N\tвыполняет ротацию стека, чтобы N-й каталог (справа\n"
"    \tв списке, показанного командой «dirs», начиная с нуля)\n"
"    \tстал первым в стеке.\n"
"    \n"
"      каталог\tдобавляет каталог в начало стека каталогов, делая его\n"
"    \tновым текущим каталогом.\n"
"    \n"
"    Встроенная команда dirs показывает стек каталогов.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или удалось\n"
"    перейти в каталог."

#: builtins.c:1856
#, fuzzy
#| msgid ""
#| "Remove directories from stack.\n"
#| "    \n"
#| "    Removes entries from the directory stack.  With no arguments, removes\n"
#| "    the top directory from the stack, and changes to the new top directory.\n"
#| "    \n"
#| "    Options:\n"
#| "      -n\tSuppresses the normal change of directory when removing\n"
#| "    \tdirectories from the stack, so only the stack is manipulated.\n"
#| "    \n"
#| "    Arguments:\n"
#| "      +N\tRemoves the Nth entry counting from the left of the list\n"
#| "    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
#| "    \tremoves the first directory, `popd +1' the second.\n"
#| "    \n"
#| "      -N\tRemoves the Nth entry counting from the right of the list\n"
#| "    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
#| "    \tremoves the last directory, `popd -1' the next to last.\n"
#| "    \n"
#| "    The `dirs' builtin displays the directory stack.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid argument is supplied or the directory\n"
#| "    change fails."
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Удаление каталогов из стека.\n"
"    \n"
"    Удаляет записи из стека каталогов.  Если аргументы не указаны,\n"
"    удаляет первый каталог из стека и назначает новый первый каталог.\n"
"    \n"
"    Параметры:\n"
"      -n\tпредотвращает обычное изменение каталога при удалении\n"
"    \tкаталогов из стека, чтобы действия выполнялись только над стеком.\n"
"    \n"
"    Аргументы:\n"
"      +N\tудаляет N-ю слева запись в списке каталогов,\n"
"    \tпоказанного командой «dirs», начиная с нуля.  Например, «popd +0»\n"
"    \tудаляет первый каталог, а «popd +1» — второй каталог.\n"
"    \n"
"      -N\tудаляет N-ю справа запись в списке каталогов,\n"
"    \tпоказанного командой «dirs», начиная с нуля.  Например, «popd -0»\n"
"    \tудаляет последний каталог, а «popd -1» — предпоследний каталог.\n"
"    \n"
"    Встроенная команда dirs показывает стек каталогов.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или удалось\n"
"    перейти в каталог."

#: builtins.c:1886
#, fuzzy
#| msgid ""
#| "Display directory stack.\n"
#| "    \n"
#| "    Display the list of currently remembered directories.  Directories\n"
#| "    find their way onto the list with the `pushd' command; you can get\n"
#| "    back up through the list with the `popd' command.\n"
#| "    \n"
#| "    Options:\n"
#| "      -c\tclear the directory stack by deleting all of the elements\n"
#| "      -l\tdo not print tilde-prefixed versions of directories relative\n"
#| "    \tto your home directory\n"
#| "      -p\tprint the directory stack with one entry per line\n"
#| "      -v\tprint the directory stack with one entry per line prefixed\n"
#| "    \twith its position in the stack\n"
#| "    \n"
#| "    Arguments:\n"
#| "      +N\tDisplays the Nth entry counting from the left of the list shown by\n"
#| "    \tdirs when invoked without options, starting with zero.\n"
#| "    \n"
#| "      -N\tDisplays the Nth entry counting from the right of the list shown by\n"
#| "    \tdirs when invoked without options, starting with zero.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid option is supplied or an error occurs."
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Отображение стека каталогов.\n"
"    \n"
"    Выводит список запомненных на данный момент каталогов.  Каталоги\n"
"    помещаются в список командой «pushd». Для очистки\n"
"    списка используется команда «popd».\n"
"    \n"
"    Параметры:\n"
"      -c\tочистить стек каталогов, удалив из него все элементы\n"
"      -l\tне выводить каталоги, начинающиеся с тильды (~),\n"
"    \tкоторая означает домашний каталог\n"
"      -p\tпоказать стек по одному каталогу в строке\n"
"      -v\tпоказать стек по одному каталогу в строке\n"
"    \tи с номером в стеке\n"
"    \n"
"    Аргументы:\n"
"      +N\tпоказать N-ю запись слева в списке каталогов,\n"
"    \tпоказанного при вызове без параметров, начиная с нуля.\n"
"    \n"
"      -N\tпоказать N-ю справа в списке каталогов запись,\n"
"    \tпоказанного при вызове без параметров, начиная с нуля.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла ошибка."

#: builtins.c:1917
#, fuzzy
#| msgid ""
#| "Set and unset shell options.\n"
#| "    \n"
#| "    Change the setting of each shell option OPTNAME.  Without any option\n"
#| "    arguments, list all shell options with an indication of whether or not each\n"
#| "    is set.\n"
#| "    \n"
#| "    Options:\n"
#| "      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
#| "      -p\tprint each shell option with an indication of its status\n"
#| "      -q\tsuppress output\n"
#| "      -s\tenable (set) each OPTNAME\n"
#| "      -u\tdisable (unset) each OPTNAME\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
#| "    given or OPTNAME is disabled."
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Установка и удаление параметров командного процессора.\n"
"    \n"
"    Изменяет настройки указанных параметров командного процессора.  Если не указать\n"
"    аргумент с параметром, выводит все параметры командного процессора, показывая\n"
"    какой из них установлен, а какой нет.\n"
"    \n"
"    Параметры:\n"
"      -o\tограничиться до параметров, которые заданы с помощью «set -o»\n"
"      -p\tпоказать все параметры командного процессора и их состояние\n"
"      -q\tничего не выводить\n"
"      -s\tвключить (set) все указанные параметры\n"
"      -u\tотключить (unset) все указанные параметры\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если указанный параметр включён. Возвращает ошибку,\n"
"    если был указан недопустимый параметр или параметр отключён."

#: builtins.c:1938
#, fuzzy
#| msgid ""
#| "Formats and prints ARGUMENTS under control of the FORMAT.\n"
#| "    \n"
#| "    Options:\n"
#| "      -v var\tassign the output to shell variable VAR rather than\n"
#| "    \t\tdisplay it on the standard output\n"
#| "    \n"
#| "    FORMAT is a character string which contains three types of objects: plain\n"
#| "    characters, which are simply copied to standard output; character escape\n"
#| "    sequences, which are converted and copied to the standard output; and\n"
#| "    format specifications, each of which causes printing of the next successive\n"
#| "    argument.\n"
#| "    \n"
#| "    In addition to the standard format specifications described in printf(1),\n"
#| "    printf interprets:\n"
#| "    \n"
#| "      %b\texpand backslash escape sequences in the corresponding argument\n"
#| "      %q\tquote the argument in a way that can be reused as shell input\n"
#| "      %(fmt)T output the date-time string resulting from using FMT as a format\n"
#| "            string for strftime(3)\n"
#| "    \n"
#| "    The format is re-used as necessary to consume all of the arguments.  If\n"
#| "    there are fewer arguments than the format requires,  extra format\n"
#| "    specifications behave as if a zero value or null string, as appropriate,\n"
#| "    had been supplied.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid option is given or a write or assignment\n"
#| "    error occurs."
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: plain\n"
"    characters, which are simply copied to standard output; character escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in printf(1),\n"
"    printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or assignment\n"
"    error occurs."
msgstr ""
"Форматирует и выводит аргументы согласно указанному формату.\n"
"    \n"
"    Параметры:\n"
"      -v перем\tвыводить в указанную переменную bash, а не\n"
"    \t\tна стандартный вывод\n"
"    \n"
"    ФОРМАТ — это символьная строка, содержащая три типа объектов: простые\n"
"    символы, которые копируются на стандартный вывод, экранирующие\n"
"    последовательности, которые преобразовываются и копируются на стандартный\n"
"    вывод, и спецификации, которые активируют вывод следующего успешного\n"
"    аргумента.\n"
"    \n"
"    В дополнение к стандартным спецификациям формата, описанным в printf(1),\n"
"    printf интерпретирует:\n"
"    \n"
"      %b\tразвёртывание экранирующих последовательностей с обратной косой чертой в соответствующий аргумент;\n"
"      %q\tзаключение аргумента в кавычки, чтобы его можно было повторно использовать в качестве входных данных для командного процессора;\n"
"      %(fmt)T вывод строки дата-время, полученной после использования FMT в качестве\n"
"            строки форматирования для strftime(3)\n"
"    \n"
"    Если необходимо задействовать все аргументы, формат используется повторно.  Если\n"
"    аргументов меньше, чем требуется для форматирования, дополнительные\n"
"    спецификации форматирования интерпретируются как содержащие нулевое\n"
"    или пустое значение.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла ошибка\n"
"    записи или присвоения."

#: builtins.c:1974
#, fuzzy
#| msgid ""
#| "Specify how arguments are to be completed by Readline.\n"
#| "    \n"
#| "    For each NAME, specify how arguments are to be completed.  If no options\n"
#| "    are supplied, existing completion specifications are printed in a way that\n"
#| "    allows them to be reused as input.\n"
#| "    \n"
#| "    Options:\n"
#| "      -p\tprint existing completion specifications in a reusable format\n"
#| "      -r\tremove a completion specification for each NAME, or, if no\n"
#| "    \tNAMEs are supplied, all completion specifications\n"
#| "      -D\tapply the completions and actions as the default for commands\n"
#| "    \twithout any specific completion defined\n"
#| "      -E\tapply the completions and actions to \"empty\" commands --\n"
#| "    \tcompletion attempted on a blank line\n"
#| "    \n"
#| "    When completion is attempted, the actions are applied in the order the\n"
#| "    uppercase-letter options are listed above.  The -D option takes\n"
#| "    precedence over -E.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid option is supplied or an error occurs."
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no options\n"
"    are supplied, existing completion specifications are printed in a way that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Определение количества аргументов, завершаемых функцией readline.\n"
"    \n"
"    Для каждого имени нужно указать количество завершаемых аргументов.  Если параметры\n"
"    не указаны, выводятся существующие спецификации завершения формате\n"
"    для повторного использования.\n"
"    \n"
"    Параметры:\n"
"      -p\tвывести существующие спецификации завершения в формате для повторного использования\n"
"      -r\tудалить спецификации завершения для каждого имени или,\n"
"    \tесли имена не указаны, все спецификации\n"
"      -D\tприменить завершения и действия как стандартные для команд,\n"
"    \tдля которых не определены завершения\n"
"      -E\tприменить завершения и действия к «пустым» командам —\n"
"    \tзавершение применяется к пустой строке\n"
"    \n"
"    Когда применяется завершение, действия выполняются в алфавитном порядке\n"
"    перечисленных выше параметров.  Параметр -D имеет более\n"
"    высокий приоритет, чем -E.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла ошибка."

#: builtins.c:2004
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Вывод возможных завершений в зависимости от параметров.\n"
"    \n"
"    compgen предназначен для использования в функциях bash, генерирующих\n"
"    возможные завершения.  Если указан необязательный аргумент слово, выполняет\n"
"    сопоставление со сгенерированным словом.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или не возникла ошибка."

#: builtins.c:2019
#, fuzzy
#| msgid ""
#| "Modify or display completion options.\n"
#| "    \n"
#| "    Modify the completion options for each NAME, or, if no NAMEs are supplied,\n"
#| "    the completion currently being executed.  If no OPTIONs are given, print\n"
#| "    the completion options for each NAME or the current completion specification.\n"
#| "    \n"
#| "    Options:\n"
#| "    \t-o option\tSet completion option OPTION for each NAME\n"
#| "    \t-D\t\tChange options for the \"default\" command completion\n"
#| "    \t-E\t\tChange options for the \"empty\" command completion\n"
#| "    \n"
#| "    Using `+o' instead of `-o' turns off the specified option.\n"
#| "    \n"
#| "    Arguments:\n"
#| "    \n"
#| "    Each NAME refers to a command for which a completion specification must\n"
#| "    have previously been defined using the `complete' builtin.  If no NAMEs\n"
#| "    are supplied, compopt must be called by a function currently generating\n"
#| "    completions, and the options for that currently-executing completion\n"
#| "    generator are modified.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid option is supplied or NAME does not\n"
#| "    have a completion specification defined."
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, print\n"
"    the completion options for each NAME or the current completion specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Изменение или вывод параметров завершения.\n"
"    \n"
"    Изменяет параметры завершения для каждого имени или, если имена\n"
"    не указаны, для текущего завершения.  Если параметры не указаны, выводит\n"
"    параметры завершения для каждого имени или текущую спецификацию завершения.\n"
"    \n"
"    Параметры:\n"
"    \t-o параметр\tзадать параметр завершения для каждого имени\n"
"    \t-D\t\tизменить параметры для завершения команды «по умолчанию»\n"
"    \t-E\t\tизменить параметры для завершения «пустой» команды\n"
"    \n"
"    Использование «+o» вместо «-o» отключает указанный параметр.\n"
"    \n"
"    Аргументы:\n"
"    \n"
"    Каждое имя ссылается на команду, для которой уже должна быть определена\n"
"    спецификация завершения с помощью встроенной команды «complete».  Если имена\n"
"    не указаны, функция, которая сейчас генерирует завершения, должна вызвать\n"
"    compopt, и должны измениться параметры для текущего\n"
"    генератора завершения.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или для имени\n"
"    определена спецификация завершения."

#: builtins.c:2050
#, fuzzy
#| msgid ""
#| "Read lines from the standard input into an indexed array variable.\n"
#| "    \n"
#| "    Read lines from the standard input into the indexed array variable ARRAY, or\n"
#| "    from file descriptor FD if the -u option is supplied.  The variable MAPFILE\n"
#| "    is the default ARRAY.\n"
#| "    \n"
#| "    Options:\n"
#| "      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are copied.\n"
#| "      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default index is 0.\n"
#| "      -s count \tDiscard the first COUNT lines read.\n"
#| "      -t\t\tRemove a trailing newline from each line read.\n"
#| "      -u fd\t\tRead lines from file descriptor FD instead of the standard input.\n"
#| "      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read.\n"
#| "      -c quantum\tSpecify the number of lines read between each call to CALLBACK.\n"
#| "    \n"
#| "    Arguments:\n"
#| "      ARRAY\t\tArray variable name to use for file data.\n"
#| "    \n"
#| "    If -C is supplied without -c, the default quantum is 5000.  When\n"
#| "    CALLBACK is evaluated, it is supplied the index of the next array\n"
#| "    element to be assigned and the line to be assigned to that element\n"
#| "    as additional arguments.\n"
#| "    \n"
#| "    If not supplied with an explicit origin, mapfile will clear ARRAY before\n"
#| "    assigning to it.\n"
#| "    \n"
#| "    Exit Status:\n"
#| "    Returns success unless an invalid option is given or ARRAY is readonly or\n"
#| "    not an indexed array."
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly or\n"
"    not an indexed array."
msgstr ""
"Чтение строк со стандартного ввода в переменную индексированного массива.\n"
"    \n"
"    Читает строки со стандартного ввода в переменную указанного индексированного массива\n"
"    или из указанного файлового дескриптора, если указан параметр -u.  Переменная $MAPFILE\n"
"    является массивом по умолчанию.\n"
"    \n"
"    Параметры:\n"
"      -n число\tкопировать указанное число строк  Если число равно 0, копируются все строки.\n"
"      -O начало\tначать присвоение массиву, начиная с заданного указателя  По умолчанию указатель равен 0.\n"
"      -s число \tотбросить указанное число первых строк\n"
"      -t\t\tудалить завершающие переводы строки изо всех прочитанных строк\n"
"      -u fd\t\tчитать строки из файлового дескриптора, а не со стандартного входа\n"
"      -C callback\tоценивать callback при чтении каждой строки quantum\n"
"      -c quantum\tчисло строк, читаемых от каждого вызова до callback\n"
"    \n"
"    Аргументы:\n"
"      МАССИВ\t\tназвание переменной массива, используемой для данных файла.\n"
"    \n"
"    Если параметр -C указан без -c, quantum по умолчанию равен 5000.  Когда\n"
"    оценивается callback, он предоставляет указатель на следующий присваиваемый\n"
"    элемента массива и на строку, присваиваемую этому элементу,\n"
"    в качестве дополнительных аргументов.\n"
"    \n"
"    Если явно не указано начало, mapfile очистит массив до\n"
"    операции присвоения.\n"
"    \n"
"    Состояние выхода:\n"
"    Возвращает успех, если был указан допустимый параметр или массив доступен для записи\n"
"    и является индексированным."

#: builtins.c:2086
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Чтение строк из файла в переменную массива.\n"
"    \n"
"    Синоним команды «mapfile»."

#~ msgid "%s: invalid associative array key"
#~ msgstr "%s: недопустимый ключ ассоциативного массива"

#~ msgid ""
#~ "Returns the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns "
#~ msgstr ""
#~ "Возвращает контекст вызова текущей подпрограммы.\n"
#~ "    \n"
#~ "    Без EXPR выполняет возврат "

#~ msgid "add_process: process %5ld (%s) in the_pipeline"
#~ msgstr "add_process: процесс %5ld (%s) в the_pipeline"

#~ msgid "Unknown Signal #"
#~ msgstr "Неизвестный номер сигнала"

#~ msgid "Copyright (C) 2016 Free Software Foundation, Inc."
#~ msgstr "© Free Software Foundation, Inc, 2016."

#~ msgid ":"
#~ msgstr ":"

#~ msgid "true"
#~ msgstr "true"

#~ msgid "false"
#~ msgstr "false"

#~ msgid "times"
#~ msgstr "times"

#~ msgid "Missing `}'"
#~ msgstr "Пропущен символ `}'"

#~ msgid "brace_expand> "
#~ msgstr "brace_expand> "

#~ msgid "Attempt to free unknown command type `%d'.\n"
#~ msgstr "Попытка освободить память структуры команды неизвестного типа `%d'.\n"

#~ msgid "Report this to %s\n"
#~ msgstr "Сообщите об этом по адресу %s\n"

#~ msgid "Stopping myself..."
#~ msgstr "Прекращение работы..."

#~ msgid "Tell %s to fix this someday.\n"
#~ msgstr "Скажите %s, чтобы он исправил это.\n"

#~ msgid "execute_command: bad command type `%d'"
#~ msgstr "execute_command: неверный тип команды '%d'"

#~ msgid "real\t"
#~ msgstr "реальное\t"

#~ msgid "user\t"
#~ msgstr "пользователя\t"

#~ msgid "sys\t"
#~ msgstr "системное\t"

#~ msgid ""
#~ "real\t0m0.00s\n"
#~ "user\t0m0.00s\n"
#~ "sys\t0m0.00s\n"
#~ msgstr ""
#~ "реальное\t0m0.00s\n"
#~ "пользователя\t0m0.00s\n"
#~ "системное\t0m0.00s\n"

#~ msgid "cannot duplicate fd %d to fd 1: %s"
#~ msgstr "невозможно скопировать файловый дескриптор %d в 1: %s"

#~ msgid "%s: output redirection restricted"
#~ msgstr "%s: перенаправление вывода запрещено (ограниченный режим)"

#~ msgid "Out of memory!"
#~ msgstr "Недостаточно памяти!"

#~ msgid "You have already added item `%s'\n"
#~ msgstr "Элемент `%s' уже добавлен\n"

#~ msgid "You have entered %d (%d) items.  The distribution is:\n"
#~ msgstr "Создано %d (%d) элементов. Распределение:\n"

#~ msgid "slot %3d: "
#~ msgstr "слот %3d: "

#~ msgid "<unknown>"
#~ msgstr "<неизв>"

#~ msgid "%s: bg background job?"
#~ msgstr "%s: задача уже фоновая"

#~ msgid ""
#~ "Redirection instruction from yyparse () '%d' is\n"
#~ "out of range in make_redirection ()."
#~ msgstr ""
#~ "Инструкция перенаправления yyparse () `%d'\n"
#~ "не может быть обработана make_redirection ()."

#~ msgid "clean_simple_command () got a command with type %d."
#~ msgstr "функции clean_simple_command () передана команда типа %d."

#~ msgid "got errno %d while waiting for %d"
#~ msgstr "ошибка %d при ожидании %d"

#~ msgid "syntax error near unexpected token `%c'"
#~ msgstr "синтаксическая ошибка около неожиданной лексемы `%c'"

#~ msgid "print_command: bad command type `%d'"
#~ msgstr "print_command: неверный тип команды `%d'"

#~ msgid "cprintf: bad `%%' argument (%c)"
#~ msgstr "cprintf: неверный спецификатор после `%%' (%c)"

#~ msgid "option `%s' requires an argument"
#~ msgstr "параметр `%s' должен использоваться с аргументом"

#~ msgid "%s: unrecognized option"
#~ msgstr "%s: неизвестный параметр"

#~ msgid "`-c' requires an argument"
#~ msgstr "`-c' должен использоваться с аргументом"

#~ msgid "%s: cannot execute directories"
#~ msgstr "%s: каталоги не могут запускаться как исполняемые файлы"

#~ msgid "Bad code in sig.c: sigprocmask"
#~ msgstr "Неверный код в sig.c: sigprocmask"

#~ msgid "can't make pipes for process substitution: %s"
#~ msgstr "невозможно создать каналы для подстановки: %s"

#~ msgid "reading"
#~ msgstr "чтения"

#~ msgid "writing"
#~ msgstr "записи"

#~ msgid "process substitution"
#~ msgstr "подстановка процессов"

#~ msgid "command substitution"
#~ msgstr "подстановка команд"

#~ msgid "Can't reopen pipe to command substitution (fd %d): %s"
#~ msgstr "Невозможно вновь открыть канал для подстановки команд (файловый дексриптор %d): %s"

#~ msgid "$%c: unbound variable"
#~ msgstr "$%c: не заданы границы"

#~ msgid "%s: bad arithmetic substitution"
#~ msgstr "%s: неверная арифметическая подстановка"

#~ msgid "-%s: binary operator expected"
#~ msgstr "-%s: ожидается бинарная операция"

#~ msgid "%s[%s: bad subscript"
#~ msgstr "%s[%s: неверный индекс"

#~ msgid "[%s: bad subscript"
#~ msgstr "[%s: неверный индекс"

#~ msgid "xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr "xmalloc: невозможно заново выделить %lu байтов (выделено %lu байтов)"

#~ msgid "digits occur in two different argv-elements.\n"
#~ msgstr "цифры встречаются в двух разных элементах argv.\n"

#~ msgid "option %c\n"
#~ msgstr "параметр %c\n"

#~ msgid "option a\n"
#~ msgstr "параметр a\n"

#~ msgid "option b\n"
#~ msgstr "параметр b\n"

#~ msgid "option c with value `%s'\n"
#~ msgstr "параметр c со значением `%s'\n"

#~ msgid "?? sh_getopt returned character code 0%o ??\n"
#~ msgstr "?? sh_getopt вернула код символа 0%o ??\n"

#~ msgid "non-option ARGV-elements: "
#~ msgstr "элементы ARGV, не являющиеся параметрами: "

#~ msgid "%s: Unknown flag %s.\n"
#~ msgstr "%s: Неизвестный флаг %s.\n"

#~ msgid "Unknown directive `%s'"
#~ msgstr "Неизвестная директива `%s'"

#~ msgid "%s must be inside of a $BUILTIN block"
#~ msgstr "%s должно быть внутри блока $BUILTIN"

#~ msgid "%s found before $END"
#~ msgstr "%s обнаружено раньше $END"

#~ msgid "%s already has a function (%s)"
#~ msgstr "В %s уже есть функция (%s)"

#~ msgid "%s already had a docname (%s)"
#~ msgstr "В %s уже есть название документации (%s)"

#~ msgid "%s already has short documentation (%s)"
#~ msgstr "В %s уже есть короткая документация (%s)"

#~ msgid "%s already has a %s definition"
#~ msgstr "В %s уже есть определение %s"

#~ msgid "mkbuiltins: Out of virtual memory!\n"
#~ msgstr "mkbuiltins: Не хватает виртуальной памяти!\n"

#~ msgid "read [-r] [-p prompt] [-a array] [-e] [name ...]"
#~ msgstr "read [-r] [-p приглашение] [-a массив] [-e] [имя ...]"

#~ msgid "%[DIGITS | WORD] [&]"
#~ msgstr "%[ЦИФРЫ | СЛОВО] [&]"

#~ msgid "variables - Some variable names and meanings"
#~ msgstr "variables -- Имена и смысл некоторых переменных"

#~ msgid "`alias' with no arguments or with the -p option prints the list"
#~ msgstr "`alias' без аргументов или с параметром -p выводит на стандартный"

#~ msgid "of aliases in the form alias NAME=VALUE on standard output."
#~ msgstr "вывод список псевдокоманд в виде ИМЯ=ЗНАЧЕНИЕ. В противном"

#~ msgid "Otherwise, an alias is defined for each NAME whose VALUE is given."
#~ msgstr "случае, для каждого ИМЕНИ определяется псевдокоманда со ЗНАЧЕНИЕМ."

#~ msgid "A trailing space in VALUE causes the next word to be checked for"
#~ msgstr "Если на конце ЗНАЧЕНИЯ есть пробелы, при разворачивании псевдокоманды"

#~ msgid "alias substitution when the alias is expanded.  Alias returns"
#~ msgstr "следующее слово проверяется на подстановку псевдокоманд. Alias"

#~ msgid "true unless a NAME is given for which no alias has been defined."
#~ msgstr "возвращает true, если только не задано ИМЯ, для которого нет псевдокоманд."

#~ msgid "Remove NAMEs from the list of defined aliases.  If the -a option is given,"
#~ msgstr "Удаляет ИМЕНА из списка определённых псевдокоманд. Если задан параметр -a,"

#~ msgid "then remove all alias definitions."
#~ msgstr "удаляет все определения псевдокоманд."

#~ msgid "Bind a key sequence to a Readline function, or to a macro.  The"
#~ msgstr "Связывает последовательность клавиш с функцией Readline или с макросом."

#~ msgid "syntax is equivalent to that found in ~/.inputrc, but must be"
#~ msgstr "Синтаксис тот же, что и в ~/.inputrc, но должен передаваться"

#~ msgid "passed as a single argument: bind '\"\\C-x\\C-r\": re-read-init-file'."
#~ msgstr "одним аргументом: bind '\"\\C-x\\C-r\": re-read-init-file'."

#~ msgid "Arguments we accept:"
#~ msgstr "Принимаемые аргументы:"

#~ msgid "  -m  keymap         Use `keymap' as the keymap for the duration of this"
#~ msgstr "   -m раскладка      Использовать во время работы программы указанную"

#~ msgid "                     command.  Acceptable keymap names are emacs,"
#~ msgstr "                     раскладку.  Допустимые имена раскладок: emacs,"

#~ msgid "                     emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,"
#~ msgstr "                     emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,"

#~ msgid "                     vi-command, and vi-insert."
#~ msgstr "                     vi-command и vi-insert."

#~ msgid "  -l                 List names of functions."
#~ msgstr "  -l                 Вывести список имён функций."

#~ msgid "  -P                 List function names and bindings."
#~ msgstr "  -P                  Вывести список имён функций и связей."

#~ msgid "  -p                 List functions and bindings in a form that can be"
#~ msgstr "  -p                 Вывести список имён функций и связей в виде,"

#~ msgid "                     reused as input."
#~ msgstr "                     который можно использовать на входе."

#~ msgid "  -r  keyseq         Remove the binding for KEYSEQ."
#~ msgstr "  -r  послед_клавиш  Удалить связь для `послед_клавиш'."

#~ msgid "  -f  filename       Read key bindings from FILENAME."
#~ msgstr "  -f  имя_файла      Прочесть связи из файла."

#~ msgid "  -q  function-name  Query about which keys invoke the named function."
#~ msgstr "  -q  имя_функции    Запрос, какие клавиши вызовут указанную функцию."

#~ msgid "  -V                 List variable names and values"
#~ msgstr "  -V                 Вывести список имён и значений переменных."

#~ msgid "  -v                 List variable names and values in a form that can"
#~ msgstr "  -v                 Вывести список имён и значений переменных в виде,"

#~ msgid "                     be reused as input."
#~ msgstr "                     который можно использовать на входе"

#~ msgid "  -S                 List key sequences that invoke macros and their values"
#~ msgstr "  -S                 Вывести список последовательностей клавиш, вызывающих макросы и их значений."

#~ msgid "  -s                 List key sequences that invoke macros and their values in"
#~ msgstr "  -s                Вывести список последовательностей клавиш, вызывающих макросы"

#~ msgid "                     a form that can be reused as input."
#~ msgstr "                     и их значений в виде, который можно использовать на входе"

#~ msgid "Exit from within a FOR, WHILE or UNTIL loop.  If N is specified,"
#~ msgstr "Выйти из цикла FOR, WHILE или UNTIL.  Если указано N,"

#~ msgid "break N levels."
#~ msgstr "выйти из N вложенных уровней."

#~ msgid "Resume the next iteration of the enclosing FOR, WHILE or UNTIL loop."
#~ msgstr "Перейти к следующей итерации цикла FOR, WHILE или UNTIL."

#~ msgid "If N is specified, resume at the N-th enclosing loop."
#~ msgstr "Если задано N, перейти к N-му обрамляющему циклу."

#~ msgid "Run a shell builtin.  This is useful when you wish to rename a"
#~ msgstr "Выполнить встроенную команду оболочки.  Это полезно, если вы хотите"

#~ msgid "shell builtin to be a function, but need the functionality of the"
#~ msgstr "создать функцию с именем встроенной команды, но хотите сохранить"

#~ msgid "builtin within the function itself."
#~ msgstr "возможность использования команды из самой функции"

#~ msgid "Change the current directory to DIR.  The variable $HOME is the"
#~ msgstr "Изменить текущий каталог на заданный.  Переменная $HOME содержит"

#~ msgid "default DIR.  The variable $CDPATH defines the search path for"
#~ msgstr "каталог по умолчанию.  Переменная $CDPATH определяет путь, в котором"

#~ msgid "the directory containing DIR.  Alternative directory names in CDPATH"
#~ msgstr "ищется каталог, содержащий КАТАЛОГ.  Альтернативные каталоги в CDPATH"

#~ msgid "are separated by a colon (:).  A null directory name is the same as"
#~ msgstr "разделяются точкой с запятой (:).  Пустое имя каталога -- то же самое,"

#~ msgid "the current directory, i.e. `.'.  If DIR begins with a slash (/),"
#~ msgstr "что текущий каталог, т.е. `.'.  Если КАТАЛОГ начинается с дроби (/),"

#~ msgid "then $CDPATH is not used.  If the directory is not found, and the"
#~ msgstr "$CDPATh не используется.  Если каталог не найден, и установлен параметр"

#~ msgid "shell option `cdable_vars' is set, then try the word as a variable"
#~ msgstr "оболочки `cdable_vars', делается попытка интерпретировать это слово как имя"

#~ msgid "name.  If that variable has a value, then cd to the value of that"
#~ msgstr "переменной.  Если эта переменная имеет значение, каталог меняется на это"

#~ msgid "variable.  The -P option says to use the physical directory structure"
#~ msgstr "значение.  Параметр -P указывает использовать физическую структуру каталогов,"

#~ msgid "instead of following symbolic links; the -L option forces symbolic links"
#~ msgstr "а не следовать символчиеским ссылкам, параметр -L заставляет следовать"

#~ msgid "to be followed."
#~ msgstr "символическим ссылкам."

#~ msgid "Print the current working directory.  With the -P option, pwd prints"
#~ msgstr "Вывести имя текущего рабочего каталога.  С параметром -P pwd выводит"

#~ msgid "the physical directory, without any symbolic links; the -L option"
#~ msgstr "физический каталог, без символических ссылок, параметр -L заставляет"

#~ msgid "makes pwd follow symbolic links."
#~ msgstr "pwd следовать символическим ссылкам."

#~ msgid "Runs COMMAND with ARGS ignoring shell functions.  If you have a shell"
#~ msgstr "Выполняет КОМАНДУ с АРГУМЕНТАМИ, игнорируя функции оболочки. Если у вас есть"

#~ msgid "function called `ls', and you wish to call the command `ls', you can"
#~ msgstr "функция оболочки `ls', а вы хотите вызвать команду `ls', можно использовать"

#~ msgid "say \"command ls\".  If the -p option is given, a default value is used"
#~ msgstr "\"command ls\".  Если задан параметр -p, используется значение $PATH"

#~ msgid "for PATH that is guaranteed to find all of the standard utilities.  If"
#~ msgstr "по умолчанию, что гарантирует отыскание стандартных утилит.  Если"

#~ msgid "the -V or -v option is given, a string is printed describing COMMAND."
#~ msgstr "задан параметр -V или -v, выводится строка, описывающая КОМАНДУ."

#~ msgid "The -V option produces a more verbose description."
#~ msgstr "Параметр -V создаёт более подробное описание."

#~ msgid "Declare variables and/or give them attributes.  If no NAMEs are"
#~ msgstr "Объявляет переменные и/или придаёт им атрибуты.  Если не заданы ИМЕНА,"

#~ msgid "given, then display the values of variables instead.  The -p option"
#~ msgstr "выводит вместо этого значения переменных.  Параметр -p выведет"

#~ msgid "will display the attributes and values of each NAME."
#~ msgstr "атрибуты и значения каждого ИМЕНИ."

#~ msgid "The flags are:"
#~ msgstr "Флаги:"

#~ msgid "  -a\tto make NAMEs arrays (if supported)"
#~ msgstr "  -a\tсчитать ИМЕНА массивами (если поддерживаются)"

#~ msgid "  -f\tto select from among function names only"
#~ msgstr "  -f\tискать только среди имён функций"

#~ msgid "  -F\tto display function names without definitions"
#~ msgstr "  -F\tпоказать имена функций без определений"

#~ msgid "  -r\tto make NAMEs readonly"
#~ msgstr "  -r\tсделать ИМЕНА переменными только для чтения"

#~ msgid "  -x\tto make NAMEs export"
#~ msgstr "  -x\tпозволить экспорт ИМЁН"

#~ msgid "  -i\tto make NAMEs have the `integer' attribute set"
#~ msgstr "  -i\tпридать ИМЕНАМ набор атрибутов `integer' (целочисленный)"

#~ msgid "Variables with the integer attribute have arithmetic evaluation (see"
#~ msgstr "Для переменных с атрибутом `integer' арифметические вычисления (см."

#~ msgid "`let') done when the variable is assigned to."
#~ msgstr "`let') выполняются при присвоении переменной значения."

#~ msgid "When displaying values of variables, -f displays a function's name"
#~ msgstr "При выводе значений переменных -f выводит имя и определение"

#~ msgid "and definition.  The -F option restricts the display to function"
#~ msgstr "функции.  Параметр -F ограничивает вывод именем"

#~ msgid "name only."
#~ msgstr "функции."

#~ msgid "Using `+' instead of `-' turns off the given attribute instead.  When"
#~ msgstr "Использование `+' вместо `-' выключает заданный атрибут.  При"

#~ msgid "used in a function, makes NAMEs local, as with the `local' command."
#~ msgstr "использовании в функции делает ИМЕНа локальными, как команда `local'."

#~ msgid "Obsolete.  See `declare'."
#~ msgstr "Устарела.  См. `declare'."

#~ msgid "Create a local variable called NAME, and give it VALUE.  LOCAL"
#~ msgstr "Создать локальную переменную ИМЯ и придать ей ЗНАЧЕНИЕ.  LOCAL"

#~ msgid "have a visible scope restricted to that function and its children."
#~ msgstr "область видимости ИМЕНИ этой функцией и её потомками."

#~ msgid "Output the ARGs.  If -n is specified, the trailing newline is"
#~ msgstr "Выводит АРГУМЕНТЫ.  Если задано -n, подавляется завершающий переход"

#~ msgid "suppressed.  If the -e option is given, interpretation of the"
#~ msgstr "на новую строку.  Если задан параметр -e, интерпретируются следующие"

#~ msgid "following backslash-escaped characters is turned on:"
#~ msgstr "экранированные символы:"

#~ msgid "\t\\a\talert (bell)"
#~ msgstr "\t\\a\tпредупреждение (звонок)"

#~ msgid "\t\\b\tbackspace"
#~ msgstr "\t\\b\tзабой (откат)"

#~ msgid "\t\\c\tsuppress trailing newline"
#~ msgstr "\t\\c\tподавить завершающий переход на новую строку"

#~ msgid "\t\\E\tescape character"
#~ msgstr "\t\\E\tэкранировать символ"

#~ msgid "\t\\f\tform feed"
#~ msgstr "\t\\f\tсдвиг на следующую строку"

#~ msgid "\t\\n\tnew line"
#~ msgstr "\t\\n\tновая строка"

#~ msgid "\t\\r\tcarriage return"
#~ msgstr "\t\\r\tвозврат каретки"

#~ msgid "\t\\t\thorizontal tab"
#~ msgstr "\t\\t\tгоризонтальная табуляция"

#~ msgid "\t\\v\tvertical tab"
#~ msgstr "\t\\v\tвертикальная табуляция"

#~ msgid "\t\\\\\tbackslash"
#~ msgstr "\t\\\\\tобратная косая черта"

#~ msgid "\t\\num\tthe character whose ASCII code is NUM (octal)."
#~ msgstr "\t\\число\tсимвол, восьмеричный ASCII-код которого равен ЧИСЛУ"

#~ msgid "You can explicitly turn off the interpretation of the above characters"
#~ msgstr "Вы можете явно выключить интерпретацию вышеприведённых символов"

#~ msgid "with the -E option."
#~ msgstr "параметром -E."

#~ msgid "Output the ARGs.  If -n is specified, the trailing newline is suppressed."
#~ msgstr "Выводит АРГУМЕНТЫ.  Если задано -n, подавляется завершающий переход на новую строку."

#~ msgid "Enable and disable builtin shell commands.  This allows"
#~ msgstr "Включает и блокирует встроенные команды оболочки.  Это позволяет"

#~ msgid "you to use a disk command which has the same name as a shell"
#~ msgstr "использовать внешние команды с теми же именами, что команды"

#~ msgid "builtin.  If -n is used, the NAMEs become disabled; otherwise"
#~ msgstr "оболочки.  При использовании -n ИМЕНА блокируются, в противном случае"

#~ msgid "NAMEs are enabled.  For example, to use the `test' found on your"
#~ msgstr "включаются.  Например, чтобы использовать файл `test', а не встроенную"

#~ msgid "path instead of the shell builtin version, type `enable -n test'."
#~ msgstr "в оболочку версию, введите enable -n test'.  На системах,"

#~ msgid "On systems supporting dynamic loading, the -f option may be used"
#~ msgstr "поддерживающих динамическую загрузку можно использовать параметр -f"

#~ msgid "to load new builtins from the shared object FILENAME.  The -d"
#~ msgstr "чтобы загрузить новые встроенные команды из разделяемого объекта ФАЙЛ."

#~ msgid "option will delete a builtin previously loaded with -f.  If no"
#~ msgstr "Параметр -d удаляет команды, загруженные -f.  Если имена, кроме"

#~ msgid "non-option names are given, or the -p option is supplied, a list"
#~ msgstr "как в параметрах, не заданы, или если задан параметр -p, выводится"

#~ msgid "of builtins is printed.  The -a option means to print every builtin"
#~ msgstr "список встроенных команд.  Параметр -a требует вывести все встроенные"

#~ msgid "with an indication of whether or not it is enabled.  The -s option"
#~ msgstr "команды с информацией, блокированы ли они.  Параметр -s выводит"

#~ msgid "restricts the output to the Posix.2 `special' builtins.  The -n"
#~ msgstr "только `специальные' команды Posix.2.  Параметр -n выводит список"

#~ msgid "option displays a list of all disabled builtins."
#~ msgstr "всех блокированных встроенных команд."

#~ msgid "Read ARGs as input to the shell and execute the resulting command(s)."
#~ msgstr "Читает АРГУМЕНТЫ как входной текст оболочки и выполняет полученные команды."

#~ msgid "Getopts is used by shell procedures to parse positional parameters."
#~ msgstr "Getopts используется процедурами оболочки для анализа параметров командной"

#~ msgid "OPTSTRING contains the option letters to be recognized; if a letter"
#~ msgstr "строки.  СТРОКА_ПАРАМЕТРОВ содержит буквы параметров, которые нужно"

#~ msgid "is followed by a colon, the option is expected to have an argument,"
#~ msgstr "распознать.  Если за буквой следует двоеточие, параметр должен иметь"

#~ msgid "which should be separated from it by white space."
#~ msgstr "аргумент, отделённый от него промежутком."

#~ msgid "Each time it is invoked, getopts will place the next option in the"
#~ msgstr "При каждом вызове getopts помещает следующий параметр в переменную"

#~ msgid "shell variable $name, initializing name if it does not exist, and"
#~ msgstr "оболочки $имя, инициализируя имя, если оно не существует, а индекс"

#~ msgid "the index of the next argument to be processed into the shell"
#~ msgstr "следующего аргумента в переменную оболочки OPTIND.  OPTIND"

#~ msgid "variable OPTIND.  OPTIND is initialized to 1 each time the shell or"
#~ msgstr "принимает значение 1 при каждом вызове оболочки или скрипта оболочки."

#~ msgid "a shell script is invoked.  When an option requires an argument,"
#~ msgstr "Если параметр требует аргумента, getopts помещает этот аргумент"

#~ msgid "getopts places that argument into the shell variable OPTARG."
#~ msgstr "в переменную оболочки OPTARG."

#~ msgid "getopts reports errors in one of two ways.  If the first character"
#~ msgstr "getopts сообщает об ошибках одним из двух способов. Если первый символ"

#~ msgid "of OPTSTRING is a colon, getopts uses silent error reporting.  In"
#~ msgstr "OPTSTRING -- двоеточие, getopts использует бесшумный способ.  В этом"

#~ msgid "this mode, no error messages are printed.  If an illegal option is"
#~ msgstr "случае сообщения об ошибках не выводятся.  Если найден недопустимый"

#~ msgid "seen, getopts places the option character found into OPTARG.  If a"
#~ msgstr "параметр, getopts помещает найденный символ в OPTARG.  Если не найден"

#~ msgid "required argument is not found, getopts places a ':' into NAME and"
#~ msgstr "требуемый аргумент, getopts помещает в ИМЯ ':', а в OPTARG --"

#~ msgid "sets OPTARG to the option character found.  If getopts is not in"
#~ msgstr "найденный символ.  Если getopts работает не в бесшумном режиме"

#~ msgid "silent mode, and an illegal option is seen, getopts places '?' into"
#~ msgstr "и обнаружен недопустимый параметр, getopts помещает в ИМЯ '?', и"

#~ msgid "NAME and unsets OPTARG.  If a required option is not found, a '?'"
#~ msgstr "сбрасывает OPTARG.  Если не найден требуемый параметр, в ИМЯ"

#~ msgid "is placed in NAME, OPTARG is unset, and a diagnostic message is"
#~ msgstr "помещается '?', OPTARG сбрасывается, и выводится диагностическое"

#~ msgid "printed."
#~ msgstr "сообщение."

#~ msgid "If the shell variable OPTERR has the value 0, getopts disables the"
#~ msgstr "Если переменная оболочки OPTERR имеет значение 0, getopts блокирует"

#~ msgid "printing of error messages, even if the first character of"
#~ msgstr "вывод сообщений об ошибках, даже если первый символ OPTSTRING"

#~ msgid "OPTSTRING is not a colon.  OPTERR has the value 1 by default."
#~ msgstr "не двоеточие.  По умолчанию OPTERR имеет значение 1."

#~ msgid "Getopts normally parses the positional parameters ($0 - $9), but if"
#~ msgstr "Getopts обычно разбирает позиционные параметры ($0 - $9), но если"

#~ msgid "more arguments are given, they are parsed instead."
#~ msgstr "заданы дополнительные аргументы, вместо этого разбираются они"

#~ msgid "Exec FILE, replacing this shell with the specified program."
#~ msgstr "Запустить ФАЙЛ, замещая эту копию оболочки указанной программой."

#~ msgid "If FILE is not specified, the redirections take effect in this"
#~ msgstr "Если ФАЙЛ не задан, могут быть переназначены файловые дескрипторы."

#~ msgid "shell.  If the first argument is `-l', then place a dash in the"
#~ msgstr "Если первый аргумент `-l', в начало нулевого аргумента, переданного"

#~ msgid "zeroth arg passed to FILE, as login does.  If the `-c' option"
#~ msgstr "ФАЙЛУ, добавляется `-', как при работе login.  Если задан параметр"

#~ msgid "is supplied, FILE is executed with a null environment.  The `-a'"
#~ msgstr "`-c', ФАЙЛ выполняется в пустой среде.  Параметр `-a' устанавливает"

#~ msgid "option means to make set argv[0] of the executed process to NAME."
#~ msgstr "argv[0] запущенного процесса в ИМЯ."

#~ msgid "If the file cannot be executed and the shell is not interactive,"
#~ msgstr "Если файл не может быть запущен, а оболочка не интерактивна,"

#~ msgid "then the shell exits, unless the variable \"no_exit_on_failed_exec\""
#~ msgstr "производится выход из оболочки, если только не установлена переменная"

#~ msgid "is set."
#~ msgstr "\"no_exit_on_failed_exec\""

#~ msgid "is that of the last command executed."
#~ msgstr "завершения будет таким же, как у последней выполненной команды."

#~ msgid "FIRST and LAST can be numbers specifying the range, or FIRST can be a"
#~ msgstr "ПЕРВАЯ и ПОСЛЕДНЯЯ могут быть числами, ограничивающими диапазон, или"

#~ msgid "string, which means the most recent command beginning with that"
#~ msgstr "же ПЕРВАЯ может быть строкой, означающей самую недавнюю команду,"

#~ msgid "string."
#~ msgstr "начинающуюся с этой строки."

#~ msgid "   -e ENAME selects which editor to use.  Default is FCEDIT, then EDITOR,"
#~ msgstr "   -e ИМЯ_РЕДАКТОРА выбирает используемый редактор.  По умолчанию FCEDIT,"

#~ msgid "      then the editor which corresponds to the current readline editing"
#~ msgstr "      затем EDITOR, затем редактор, соответствуюший текущему режиму"

#~ msgid "      mode, then vi."
#~ msgstr "      редактирования readline, затем vi."

#~ msgid "   -l means list lines instead of editing."
#~ msgstr "   -l вывести, а не редактировать строки."

#~ msgid "   -n means no line numbers listed."
#~ msgstr "   -n не выводить номера строк."

#~ msgid "   -r means reverse the order of the lines (making it newest listed first)."
#~ msgstr "   -r вывести строки в обратном порядке (в начале самые новые)."

#~ msgid "With the `fc -s [pat=rep ...] [command]' format, the command is"
#~ msgstr "В формате `fc -s [шаблон=замена] [команда]  команда выполняется заново"

#~ msgid "re-executed after the substitution OLD=NEW is performed."
#~ msgstr "после того, как произведена подстановка."

#~ msgid "A useful alias to use with this is r='fc -s', so that typing `r cc'"
#~ msgstr "Полезная псевдокоманда -- r='fc -s', так `r cc' выполняет последнюю"

#~ msgid "runs the last command beginning with `cc' and typing `r' re-executes"
#~ msgstr "команду, начинающуюся с `cc', а `r' заново выполняет последнюю"

#~ msgid "Place JOB_SPEC in the foreground, and make it the current job.  If"
#~ msgstr "Возвращает задачу с указанным номером из фонового режима и делает её"

#~ msgid "JOB_SPEC is not present, the shell's notion of the current job is"
#~ msgstr "текущей задачей. Если номер не задан, используется представление"

#~ msgid "used."
#~ msgstr "оболочки о текущей задаче."

#~ msgid "Place JOB_SPEC in the background, as if it had been started with"
#~ msgstr "Переводит задачу с указанным номером в фоновый режим, как если бы она"

#~ msgid "`&'.  If JOB_SPEC is not present, the shell's notion of the current"
#~ msgstr "была запущена с `&'.  Если номер не задан, используется представление"

#~ msgid "job is used."
#~ msgstr "оболочки о текущей задаче."

#~ msgid "For each NAME, the full pathname of the command is determined and"
#~ msgstr "Для каждого ИМЕНИ определяются и запоминаются полные пути команды."

#~ msgid "remembered.  If the -p option is supplied, PATHNAME is used as the"
#~ msgstr "Если задан параметр -p, в качестве пути используется заданный, а"

#~ msgid "full pathname of NAME, and no path search is performed.  The -r"
#~ msgstr "поиск не выполняется.  Параметр -r заставляет оболочку очистить"

#~ msgid "option causes the shell to forget all remembered locations.  If no"
#~ msgstr "список положений в памяти.  Если аргументы не заданы, выводится"

#~ msgid "arguments are given, information about remembered commands is displayed."
#~ msgstr "информация о запомненных командах."

#~ msgid "Display helpful information about builtin commands.  If PATTERN is"
#~ msgstr "Вывести полезную информацию о встроенных командах.  Если задан ШАБЛОН,"

#~ msgid "specified, gives detailed help on all commands matching PATTERN,"
#~ msgstr "вывести подробную справку по всем командам, соответствующим ШАБЛОНУ,"

#~ msgid "otherwise a list of the builtins is printed."
#~ msgstr "в противном случае вывести список встроенных команд."

#~ msgid "Display the history list with line numbers.  Lines listed with"
#~ msgstr "Вывести историю команд в виде списка с номерами строк.  Изменённые"

#~ msgid "with a `*' have been modified.  Argument of N says to list only"
#~ msgstr "строки помечаются символом `*'.  Аргумент N указывает выводить только"

#~ msgid "the last N lines.  The -c option causes the history list to be"
#~ msgstr "последние N строк.  Параметр -c очищает историю команд, удаляя"

#~ msgid "cleared by deleting all of the entries.  The `-w' option writes out the"
#~ msgstr "все строки.  Параметр `-w' записывает текущую историю в указанный"

#~ msgid "current history to the history file;  `-r' means to read the file and"
#~ msgstr "файл; `-r' читает такой файл и дополняет его содержимым историю"

#~ msgid "append the contents to the history list instead.  `-a' means"
#~ msgstr "команд.  `-a' добавляет историю этой сессии к файлу истории"

#~ msgid "to append history lines from this session to the history file."
#~ msgstr "команд.  Аргумент `-n' читает из файла истории все строки, не"

#~ msgid "Argument `-n' means to read all history lines not already read"
#~ msgstr "прочитанные ранее, и добавляет их к истории.  Если задан ФАЙЛ,"

#~ msgid "from the history file and append them to the history list.  If"
#~ msgstr "в качестве файла истории команд используется он, иначе, если"

#~ msgid "FILENAME is given, then that is used as the history file else"
#~ msgstr "переменной $HISTFILE присвоено значение, используется оно, иначе"

#~ msgid "if $HISTFILE has a value, that is used, else ~/.bash_history."
#~ msgstr "используется ~/.bash_history.  Если задан параметр -s, АРГУМЕНТЫ,"

#~ msgid "If the -s option is supplied, the non-option ARGs are appended to"
#~ msgstr "являющиеся параметрами, добавляются к истории как один элемент."

#~ msgid "the history list as a single entry.  The -p option means to perform"
#~ msgstr "Параметр -p выполняет развёртывание каждого АРГУМЕНТА и выводит"

#~ msgid "history expansion on each ARG and display the result, without storing"
#~ msgstr "результат, не сохраняя ничего в списке истории команд."

#~ msgid "anything in the history list."
#~ msgstr " "

#~ msgid "Lists the active jobs.  The -l option lists process id's in addition"
#~ msgstr "Выводит список активных задач.  Параметр -l выводит, кроме того,"

#~ msgid "to the normal information; the -p option lists process id's only."
#~ msgstr "идентификаторы процессов: параметр -p выодит только идентификаторы."

#~ msgid "If -n is given, only processes that have changed status since the last"
#~ msgstr "Если задано -n, выводятся только процессы, статус которых изменился"

#~ msgid "notification are printed.  JOBSPEC restricts output to that job.  The"
#~ msgstr "со времени последнего уведомления.  Если задан номер задачи, выводится"

#~ msgid "-r and -s options restrict output to running and stopped jobs only,"
#~ msgstr "только она.  Параметры -r и -s выводит только работающие или только"

#~ msgid "respectively.  Without options, the status of all active jobs is"
#~ msgstr "остановленные задачи соответственно.  Без параметров выодится статус"

#~ msgid "printed.  If -x is given, COMMAND is run after all job specifications"
#~ msgstr "всех активных задач.  Если задано -x, в КОМАНДЕ вместо всех АРГУМЕНТОВ"

#~ msgid "that appear in ARGS have been replaced with the process ID of that job's"
#~ msgstr "(номеров задач) подставляется идентификатор лидера соответствующей"

#~ msgid "process group leader."
#~ msgstr "группы процессов, и КОМАНДА выполняется."

#~ msgid "Removes each JOBSPEC argument from the table of active jobs."
#~ msgstr "Удаляет все задачи, заданные спецификациями в аргументе, из таблицы задач."

#~ msgid "Send the processes named by PID (or JOB) the signal SIGSPEC.  If"
#~ msgstr "Посылает указанным процессам (заданным PID или спецификацией) сигнал"

#~ msgid "SIGSPEC is not present, then SIGTERM is assumed.  An argument of `-l'"
#~ msgstr "SIGSPEC. Если отсутствует SIGSPEC, посылается SIGTERM. Аргументом"

#~ msgid "lists the signal names; if arguments follow `-l' they are assumed to"
#~ msgstr "параметра `-l' служит список сигналов. Если он присутствует, выводятся"

#~ msgid "be signal numbers for which names should be listed.  Kill is a shell"
#~ msgstr "названия сигналов с этими номерами. Kill является встроенной командой"

#~ msgid "builtin for two reasons: it allows job IDs to be used instead of"
#~ msgstr "оболочки по двум причинам: она позволяет использовать номера задач,"

#~ msgid "process IDs, and, if you have reached the limit on processes that"
#~ msgstr "а не процессов, и если вы исчерпаете лимит созданных процессов,"

#~ msgid "you can create, you don't have to start a process to kill another one."
#~ msgstr "вы не сможете запустить новый процесс, уничтожающий один из старых."

#~ msgid "Each ARG is an arithmetic expression to be evaluated.  Evaluation"
#~ msgstr "Каждый аргумент рассматривается как арифметическое выражение."

#~ msgid "is done in long integers with no check for overflow, though division"
#~ msgstr "Вычисление производится над длинными целыми без контроля переполнения,"

#~ msgid "by 0 is trapped and flagged as an error.  The following list of"
#~ msgstr "хотя деление на ноль отслеживается и считается ошибкой. Операции в"

#~ msgid "operators is grouped into levels of equal-precedence operators."
#~ msgstr "следующем списке сгруппированы по уровням равного приоритета."

#~ msgid "The levels are listed in order of decreasing precedence."
#~ msgstr "Уровни перечислены в порядке уменьшения приоритета."

#~ msgid "\t-, +\t\tunary minus, plus"
#~ msgstr "\t-, +\t\tунарный минус, унарный плюс"

#~ msgid "\t!, ~\t\tlogical and bitwise negation"
#~ msgstr "\t!, ~\t\tлогическое и побитовое отрицание"

#~ msgid "\t*, /, %\t\tmultiplication, division, remainder"
#~ msgstr "\t*, /, %\t\tумножение, деление, взятие остатка"

#~ msgid "\t+, -\t\taddition, subtraction"
#~ msgstr "\t+, -\t\tсложение, вычитание"

#~ msgid "\t<<, >>\t\tleft and right bitwise shifts"
#~ msgstr "\t<<, >>\t\tлевый и правый побитовый сдвиг"

#~ msgid "\t<=, >=, <, >\tcomparison"
#~ msgstr "\t<=, >=, <, >\tсравнение"

#~ msgid "\t==, !=\t\tequality, inequality"
#~ msgstr "\t==, !=\t\tравенство, неравенство"

#~ msgid "\t&\t\tbitwise AND"
#~ msgstr "\t&\t\tпобитовое И"

#~ msgid "\t^\t\tbitwise XOR"
#~ msgstr "\t^\t\tпобитовое ИСКЛЮЧАЮЩЕЕ ИЛИ"

#~ msgid "\t|\t\tbitwise OR"
#~ msgstr "\t|\t\tпобитовое ИЛИ"

#~ msgid "\t&&\t\tlogical AND"
#~ msgstr "\t&&\t\tлогическое И"

#~ msgid "\t||\t\tlogical OR"
#~ msgstr "\t||\t\tлогическое ИЛИ"

#~ msgid "\texpr ? expr : expr"
#~ msgstr "\texpt ? expr : expr"

#~ msgid "\t\t\tconditional expression"
#~ msgstr "\t\t\tусловное выражение"

#~ msgid "\t=, *=, /=, %=,"
#~ msgstr "\t=, *=, /=, %=,"

#~ msgid "\t+=, -=, <<=, >>=,"
#~ msgstr "\t+=, -=, <<=, >>=,"

#~ msgid "\t&=, ^=, |=\tassignment"
#~ msgstr "\t&=, ^=, |=\tприсваивание"

#~ msgid "is replaced by its value (coerced to a long integer) within"
#~ msgstr "переменной заменяется её значение (преобразованным в длинное"

#~ msgid "an expression.  The variable need not have its integer attribute"
#~ msgstr "целое). Для использования в выражении переменная не обязана иметь"

#~ msgid "turned on to be used in an expression."
#~ msgstr "установленный целочисленный атрибут."

#~ msgid "Operators are evaluated in order of precedence.  Sub-expressions in"
#~ msgstr "Операции обрабатываются в порядке приоритета. Подвыражения в"

#~ msgid "parentheses are evaluated first and may override the precedence"
#~ msgstr "скобках вычисляются вначале, что может не соответствовать правилам"

#~ msgid "rules above."
#~ msgstr "приоритета."

#~ msgid "If the last ARG evaluates to 0, let returns 1; 0 is returned"
#~ msgstr "Если вычисление последнего аргумента дало 0, let возвращает 1,"

#~ msgid "otherwise."
#~ msgstr "иначе 0."

#~ msgid "One line is read from the standard input, and the first word is"
#~ msgstr "Со стандартного ввода считывается одна строка, первое её слово"

#~ msgid "assigned to the first NAME, the second word to the second NAME, and so"
#~ msgstr "становится значением первого ИМЕНИ, второе -- второго ИМЕНИ и т.д."

#~ msgid "on, with leftover words assigned to the last NAME.  Only the characters"
#~ msgstr "Последнему ИМЕНИ присваивается весь остаток строки. Разделителями слов"

#~ msgid "found in $IFS are recognized as word delimiters.  The return code is"
#~ msgstr "считаются только символы, входящие в $IFS. Код возврата равен нулю,"

#~ msgid "zero, unless end-of-file is encountered.  If no NAMEs are supplied, the"
#~ msgstr "за исключением случая, если встретился конец файла. Если ИМЕНА не"

#~ msgid "line read is stored in the REPLY variable.  If the -r option is given,"
#~ msgstr "заданы, прочитанная строка помещается в переменную REPLY. Если задан"

#~ msgid "this signifies `raw' input, and backslash escaping is disabled.  If"
#~ msgstr "параметр -r, это означает `сырой' ввод, т.е. символ \\ не экранирует"

#~ msgid "the `-p' option is supplied, the string supplied as an argument is"
#~ msgstr "символы. Если задано `-p', перед чтением на вывод в качестве аргумента"

#~ msgid "output without a trailing newline before attempting to read.  If -a is"
#~ msgstr "подаётся заданная строка (без завершающего символа перевода строки)."

#~ msgid "supplied, the words read are assigned to sequential indices of ARRAY,"
#~ msgstr "Если задано -a, прочитанные слова становятся значениями элементов"

#~ msgid "starting at zero.  If -e is supplied and the shell is interactive,"
#~ msgstr "МАССИВА, начиная с нулевого. Если задано -c и оболочка интерактивна,"

#~ msgid "readline is used to obtain the line."
#~ msgstr "чтобы получить строку используется readline."

#~ msgid "Causes a function to exit with the return value specified by N.  If N"
#~ msgstr "Заставляет функцию завершить работу с кодом возврата, заданным N."

#~ msgid "is omitted, the return status is that of the last command."
#~ msgstr "Если N опущено, им становится код возврата последней команды."

#~ msgid "    -a  Mark variables which are modified or created for export."
#~ msgstr "    -a  Экспортировать переменные, которые изменялись или создавались."

#~ msgid "    -b  Notify of job termination immediately."
#~ msgstr "    -b  Немедленно выводить сообщения о завершении задач."

#~ msgid "    -e  Exit immediately if a command exits with a non-zero status."
#~ msgstr "    -e  Завершить работу, если команд возврата команды не равен 0."

#~ msgid "    -f  Disable file name generation (globbing)."
#~ msgstr "    -f  Прекратить расширение имён файлов (globbing)."

#~ msgid "    -h  Remember the location of commands as they are looked up."
#~ msgstr "    -h  Запоминать расположение обработанных команд."

#~ msgid "    -i  Force the shell to be an \"interactive\" one.  Interactive shells"
#~ msgstr "    -i  Сделать оболочку \"интерактивной\". Интерактивные оболочки"

#~ msgid "        always read `~/.bashrc' on startup."
#~ msgstr "        читают `~/.bashrc' при каждом запуске."

#~ msgid "    -k  All assignment arguments are placed in the environment for a"
#~ msgstr "    -k  В среду команды помещаются все аргументы присваивания,"

#~ msgid "        command, not just those that precede the command name."
#~ msgstr "        а не только предшествующие её имени."

#~ msgid "    -m  Job control is enabled."
#~ msgstr "    -m  Включить управление задачами."

#~ msgid "    -n  Read commands but do not execute them."
#~ msgstr "    -n  Считывать команды, но не выполнять их."

#~ msgid "    -o option-name"
#~ msgstr "    -o имя_параметра"

#~ msgid "        Set the variable corresponding to option-name:"
#~ msgstr "        Установить режим в соответствии с заданным именем:"

#~ msgid "            allexport    same as -a"
#~ msgstr "            allexport    то же, что -a"

#~ msgid "            braceexpand  same as -B"
#~ msgstr "            braceexpand  то же, что -B"

#~ msgid "            emacs        use an emacs-style line editing interface"
#~ msgstr "            emacs        использовать стиль редактирования строк emacs"

#~ msgid "            errexit      same as -e"
#~ msgstr "            errexit      то же, что -e"

#~ msgid "            hashall      same as -h"
#~ msgstr "            hashall      то же, что -h"

#~ msgid "            histexpand   same as -H"
#~ msgstr "            histexpand   то же, что -H"

#~ msgid "            ignoreeof    the shell will not exit upon reading EOF"
#~ msgstr "            ignoreeof    при чтении EOF оболочка не завершит работу"

#~ msgid "            interactive-comments"
#~ msgstr "            interactive-comments"

#~ msgid "                         allow comments to appear in interactive commands"
#~ msgstr "                        допускает комментарии в интерактивных командах"

#~ msgid "            keyword      same as -k"
#~ msgstr "            keyword      то же, что -k"

#~ msgid "            monitor      same as -m"
#~ msgstr "            monitor      то же, что -m"

#~ msgid "            noclobber    same as -C"
#~ msgstr "            noclobber    то же, что -C"

#~ msgid "            noexec       same as -n"
#~ msgstr "            noexec       то же, что -n"

#~ msgid "            noglob       same as -f"
#~ msgstr "            noglob       то же, что -f"

#~ msgid "            notify       save as -b"
#~ msgstr "            notify       то же, что -b"

#~ msgid "            nounset      same as -u"
#~ msgstr "            nounset      то же, что -u"

#~ msgid "            onecmd       same as -t"
#~ msgstr "            onecmd       то же, что -t"

#~ msgid "            physical     same as -P"
#~ msgstr "            physical     то же, что -P"

#~ msgid "            posix        change the behavior of bash where the default"
#~ msgstr "            posix        привести поведение bash, по умолчанию не"

#~ msgid "                         operation differs from the 1003.2 standard to"
#~ msgstr "                        соответствующее стандарту 1003.2, в"

#~ msgid "                         match the standard"
#~ msgstr "                        соответствие с ним"

#~ msgid "            privileged   same as -p"
#~ msgstr "            privileged   то же, что -p"

#~ msgid "            verbose      same as -v"
#~ msgstr "            verbose      то же, что -v"

#~ msgid "            vi           use a vi-style line editing interface"
#~ msgstr "            vi           использовать стиль редактирования строк vi"

#~ msgid "            xtrace       same as -x"
#~ msgstr "            xtrace       то же, что -x"

#~ msgid "    -p  Turned on whenever the real and effective user ids do not match."
#~ msgstr "    -p  Если реальный и эффективный uid не совпадают, включается всегда."

#~ msgid "        Disables processing of the $ENV file and importing of shell"
#~ msgstr "        Отключает обработку файла $ENV и импорт функций оболочки."

#~ msgid "        functions.  Turning this option off causes the effective uid and"
#~ msgstr "        При выключении этого параметра эффективные uid и gid становятся"

#~ msgid "        gid to be set to the real uid and gid."
#~ msgstr "        равными реальным."

#~ msgid "    -t  Exit after reading and executing one command."
#~ msgstr "    -t  Завершить работу после чтения и выполнения одной команды."

#~ msgid "    -u  Treat unset variables as an error when substituting."
#~ msgstr "    -u  При подстановке считать не установленные переменные ошибками."

#~ msgid "    -v  Print shell input lines as they are read."
#~ msgstr "    -v  Выводить прочитанные строки входного текста оболочки."

#~ msgid "    -x  Print commands and their arguments as they are executed."
#~ msgstr "    -x  Выводить по мере исполнения команд и их аргументы."

#~ msgid "    -B  the shell will perform brace expansion"
#~ msgstr "    -B  оболочка будет производить подстановку скобок"

#~ msgid "    -H  Enable ! style history substitution.  This flag is on"
#~ msgstr "    -H  Включить !-стиль подстановки истории. Включено"

#~ msgid "        by default."
#~ msgstr "        по умолчанию."

#~ msgid "    -C  If set, disallow existing regular files to be overwritten"
#~ msgstr "    -C  Если установлен, запретить перезапись существующих"

#~ msgid "        by redirection of output."
#~ msgstr "        обычных файлов при перенаправлении вывода."

#~ msgid "    -P  If set, do not follow symbolic links when executing commands"
#~ msgstr "    -P  Не следовать символическим ссылкам при выполнении таких команд,"

#~ msgid "        such as cd which change the current directory."
#~ msgstr "        как cd, т.е. изменяющих текущий каталог."

#~ msgid "Using + rather than - causes these flags to be turned off.  The"
#~ msgstr "Использование + вместо - отключает флаг. Эти флаги могут также"

#~ msgid "flags can also be used upon invocation of the shell.  The current"
#~ msgstr "использоваться при запуске оболочки. Текущий набор флагов содержится"

#~ msgid "set of flags may be found in $-.  The remaining n ARGs are positional"
#~ msgstr "в $-. Остальные n аргументов -- позиционные параметры, и им, по"

#~ msgid "parameters and are assigned, in order, to $1, $2, .. $n.  If no"
#~ msgstr "порядку, присваиваются значения $1, $2, ..., $n. Если аргументы"

#~ msgid "ARGs are given, all shell variables are printed."
#~ msgstr "не заданы, выводятся все переменные оболочки."

#~ msgid "For each NAME, remove the corresponding variable or function.  Given"
#~ msgstr "Для каждого ИМЕНИ удаляет соответствующую переменную или функцию."

#~ msgid "the `-v', unset will only act on variables.  Given the `-f' flag,"
#~ msgstr "Если задано -v, unset влияет только на переменные, если -f -- только"

#~ msgid "unset will only act on functions.  With neither flag, unset first"
#~ msgstr "на функции. Без флагов unset в первую очередь пытается удалить"

#~ msgid "tries to unset a variable, and if that fails, then tries to unset a"
#~ msgstr "переменную, если это не удаётся -- функцию. Некоторые переменные"

#~ msgid "function.  Some variables (such as PATH and IFS) cannot be unset; also"
#~ msgstr "(такие как PATH и IFS) не могут быть удалены. См."

#~ msgid "see readonly."
#~ msgstr "также readonly."

#~ msgid "NAMEs are marked for automatic export to the environment of"
#~ msgstr "ИМЕНА автоматически экспортируются в среду выполняемых"

#~ msgid "subsequently executed commands.  If the -f option is given,"
#~ msgstr "впоследствии команд. Если задан параметр -f, ИМЕНА"

#~ msgid "the NAMEs refer to functions.  If no NAMEs are given, or if `-p'"
#~ msgstr "обозначают функции. Если ИМЕНа не заданы, или если задано -p,"

#~ msgid "is given, a list of all names that are exported in this shell is"
#~ msgstr "выводится список всех имён, экспортированных в эту оболочку."

#~ msgid "printed.  An argument of `-n' says to remove the export property"
#~ msgstr "Аргумент -n указывает убрать заданные имена из списка"

#~ msgid "from subsequent NAMEs.  An argument of `--' disables further option"
#~ msgstr "экспортируемых.  Аргумент -- отключает дальнейшую обработку"

#~ msgid "processing."
#~ msgstr "параметров."

#~ msgid "The given NAMEs are marked readonly and the values of these NAMEs may"
#~ msgstr "Заданные ИМЕНА помечаются только для чтения, и значения этих ИМЁН не"

#~ msgid "not be changed by subsequent assignment.  If the -f option is given,"
#~ msgstr "могут изменяться в последующих присваиваниях. Если задан параметр -f,"

#~ msgid "then functions corresponding to the NAMEs are so marked.  If no"
#~ msgstr "так помечаются функции с соответствующими ИМЕНАМИ. Если аргументы"

#~ msgid "arguments are given, or if `-p' is given, a list of all readonly names"
#~ msgstr "не заданы, или если задано `-p', выводится список имён только для"

#~ msgid "is printed.  An argument of `-n' says to remove the readonly property"
#~ msgstr "чтения.  Аргумент `-n' указывает снять свойство `только для чтения'"

#~ msgid "from subsequent NAMEs.  The `-a' option means to treat each NAME as"
#~ msgstr "с указанных ИМЁН. Параметр `-a' заставляет рассматривать каждое ИМЯ"

#~ msgid "an array variable.  An argument of `--' disables further option"
#~ msgstr "как массив.  Аргумент `--' прекращает дальнейшую обработку"

#~ msgid "The positional parameters from $N+1 ... are renamed to $1 ...  If N is"
#~ msgstr "Позиционные параметры начиная с $N+1 переобозначаются как $1,... Если"

#~ msgid "not given, it is assumed to be 1."
#~ msgstr "N не задано, оно предполагается равным 1."

#~ msgid "Read and execute commands from FILENAME and return.  The pathnames"
#~ msgstr "Читает и выполняет команды из файла с заданным именем и завершает"

#~ msgid "in $PATH are used to find the directory containing FILENAME."
#~ msgstr "работу. Файл ищется в каталогах, перечисленных в $PATH."

#~ msgid "Suspend the execution of this shell until it receives a SIGCONT"
#~ msgstr "Приостанавливает работу оболочки до получения сигнала"

#~ msgid "signal.  The `-f' if specified says not to complain about this"
#~ msgstr "SIGCONT.  `-f', если задан, указывает приостановить работу, даже"

#~ msgid "being a login shell if it is; just suspend anyway."
#~ msgstr "если это оболочка сессии"

#~ msgid "Exits with a status of 0 (trueness) or 1 (falseness) depending on"
#~ msgstr "Завершает работу со статусом 0 (истина) или 1 (ложь) в зависимости"

#~ msgid "the evaluation of EXPR.  Expressions may be unary or binary.  Unary"
#~ msgstr "от значения ВЫРАЖЕНИЯ. Выражения могут быть унарными или бинарными."

#~ msgid "expressions are often used to examine the status of a file.  There"
#~ msgstr "Унарные выражения часто используются для проверки состояния файла."

#~ msgid "are string operators as well, and numeric comparison operators."
#~ msgstr "Допустимы операции как строкового, так и численного сравнения."

#~ msgid "File operators:"
#~ msgstr "Файловые операции:"

#~ msgid "    -b FILE        True if file is block special."
#~ msgstr "    -b ФАЙЛ        Истина, если файл -- специальный блочный файл."

#~ msgid "    -c FILE        True if file is character special."
#~ msgstr "    -c ФАЙл        Истина, если файл -- специальный символьный файл."

#~ msgid "    -d FILE        True if file is a directory."
#~ msgstr "    -d ФАЙЛ        Истина, если файл -- каталог."

#~ msgid "    -e FILE        True if file exists."
#~ msgstr "    -e ФАЙЛ        Истина, если файл существует."

#~ msgid "    -f FILE        True if file exists and is a regular file."
#~ msgstr "    -f ФАЙЛ        Истина, если файл существует и является обычным файлом."

#~ msgid "    -g FILE        True if file is set-group-id."
#~ msgstr "    -g ФАЙЛ        Истина, если у файла установлен атрибут SGID."

#~ msgid "    -h FILE        True if file is a symbolic link.  Use \"-L\"."
#~ msgstr "    -h ФАЙЛ        Истина, если файл -- символическая ссылка. Используйте \"-L\"."

#~ msgid "    -L FILE        True if file is a symbolic link."
#~ msgstr "    -L ФАЙЛ        Истина, если файл -- символическая ссылка."

#~ msgid "    -k FILE        True if file has its \"sticky\" bit set."
#~ msgstr "    -k ФАЙЛ        Истина, если у файла устанолвен \"бит привязчивости\"."

#~ msgid "    -p FILE        True if file is a named pipe."
#~ msgstr "    -p ФАЙЛ        Истина, если файл -- именованный канал."

#~ msgid "    -r FILE        True if file is readable by you."
#~ msgstr "    -r ФАЙЛ        Истина, если файл доступен вам для чтения."

#~ msgid "    -s FILE        True if file exists and is not empty."
#~ msgstr "    -s ФАЙЛ        Истина, если файл существует и не пуст."

#~ msgid "    -S FILE        True if file is a socket."
#~ msgstr "    -S ФАЙЛ        Истина, если файл -- сокет."

#~ msgid "    -t FD          True if FD is opened on a terminal."
#~ msgstr "    -t FD          Истина, если файл с дескриптором FD связан с терминалом."

#~ msgid "    -u FILE        True if the file is set-user-id."
#~ msgstr "    -u ФАЙЛ        Истина, если у файла установлен атрибут SUID."

#~ msgid "    -w FILE        True if the file is writable by you."
#~ msgstr "    -w ФАЙЛ        Истина, если файл доступен вам для записи"

#~ msgid "    -x FILE        True if the file is executable by you."
#~ msgstr "    -x ФАЙЛ        Истина, если файл доступен вам для выполнения."

#~ msgid "    -O FILE        True if the file is effectively owned by you."
#~ msgstr "    -O ФАЙЛ        Истина, если вы -- эффективный владелец файла."

#~ msgid "    -G FILE        True if the file is effectively owned by your group."
#~ msgstr "    -G ФАЙЛ        Истина, если ваша группа -- эффективная группа файла."

#~ msgid "  FILE1 -nt FILE2  True if file1 is newer than (according to"
#~ msgstr "  ФАЙЛ1 -nt ФАЙЛ2  Истина, если файл1 более новый (по дате последнего"

#~ msgid "                   modification date) file2."
#~ msgstr "                   изменения), чем файл2."

#~ msgid "  FILE1 -ot FILE2  True if file1 is older than file2."
#~ msgstr "  ФАЙЛ1 -ot ФАЙЛ2  Истина, если файл1 более старый, чем файл2."

#~ msgid "  FILE1 -ef FILE2  True if file1 is a hard link to file2."
#~ msgstr "  ФАЙЛ1 -ef ФАЙЛ2  Истина, если файл1 -- жёсткая ссылка на файл2."

#~ msgid "String operators:"
#~ msgstr "Строковые операции:"

#~ msgid "    -z STRING      True if string is empty."
#~ msgstr "    -z СТРОКА      Истина, если строка пуста."

#~ msgid "    -n STRING"
#~ msgstr "    -n СТРОКА"

#~ msgid "    STRING         True if string is not empty."
#~ msgstr "    СТРОКА         Истина, если стркоа не пуста."

#~ msgid "    STRING1 = STRING2"
#~ msgstr "    СТРОКА1 = СТРОКА2"

#~ msgid "                   True if the strings are equal."
#~ msgstr "                   Истина, если строки равны."

#~ msgid "    STRING1 != STRING2"
#~ msgstr "    СТРОКА1 != СТРОКА2"

#~ msgid "                   True if the strings are not equal."
#~ msgstr "                   Истина, если строки не равны."

#~ msgid "    STRING1 < STRING2"
#~ msgstr "    СТРОКА1 < СТРОКА2"

#~ msgid "                   True if STRING1 sorts before STRING2 lexicographically"
#~ msgstr "                   Истина, если СТРОКА1 лексикографически стоит раньше СТРОКИ2"

#~ msgid "    STRING1 > STRING2"
#~ msgstr "    СТРОКА1 > СТРОКА2"

#~ msgid "                   True if STRING1 sorts after STRING2 lexicographically"
#~ msgstr "                   Истина, если СТРОКА1 лексикографически стоит позже СТРОКИ2"

#~ msgid "Other operators:"
#~ msgstr "Прочие операции:"

#~ msgid "    ! EXPR         True if expr is false."
#~ msgstr "    ! ВЫРАЖЕНИЕ    Истина, если выражение ложно."

#~ msgid "    EXPR1 -a EXPR2 True if both expr1 AND expr2 are true."
#~ msgstr "    ВЫР1 -a ВЫР2   Истина, если истинны оба выражения."

#~ msgid "    EXPR1 -o EXPR2 True if either expr1 OR expr2 is true."
#~ msgstr "    ВЫР1 -o ВЫР2   Истина, если истинно хотя бы одно из выражений."

#~ msgid "    arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,"
#~ msgstr "    арг1 ОП арг2   Арифметическая проверка. ОП -- один из -eq, -ne,"

#~ msgid "                   -lt, -le, -gt, or -ge."
#~ msgstr "                   -lt, -le, -gt или -ge."

#~ msgid "Arithmetic binary operators return true if ARG1 is equal, not-equal,"
#~ msgstr "Бинарные арифметические операции возвращают истину, если АРГ1 равен,"

#~ msgid "less-than, less-than-or-equal, greater-than, or greater-than-or-equal"
#~ msgstr "не равен, меньше, меньше или равен, больше или больше или равен"

#~ msgid "than ARG2."
#~ msgstr "АРГ2."

#~ msgid "This is a synonym for the \"test\" builtin, but the last"
#~ msgstr "Это синоним встроенной команды \"test\", но последним аргументом"

#~ msgid "argument must be a literal `]', to match the opening `['."
#~ msgstr "должен быть литерал ']'. соответствующий открывающей `['."

#~ msgid "Print the accumulated user and system times for processes run from"
#~ msgstr "Вывести пользовательское и системное время работы процессов,"

#~ msgid "the shell."
#~ msgstr "запущенных из оболочки."

#~ msgid "The command ARG is to be read and executed when the shell receives"
#~ msgstr "Команда АРГ должна быть прочитана и выполнена при получении оболочкой"

#~ msgid "signal(s) SIGNAL_SPEC.  If ARG is absent all specified signals are"
#~ msgstr "указанного(ых) сигнала(ов). Если АРГ не задан, все указанные сигналы"

#~ msgid "reset to their original values.  If ARG is the null string each"
#~ msgstr "обрабатываются обработчиками по умолчанию. Если АРГ -- пустая строка,"

#~ msgid "SIGNAL_SPEC is ignored by the shell and by the commands it invokes."
#~ msgstr "все указанные сигналы будут игнорироваться оболочкой и вызываемыми ей"

#~ msgid "If SIGNAL_SPEC is EXIT (0) the command ARG is executed on exit from"
#~ msgstr "командами. Если задан сигнал EXIT (0), команда АРГ выполняется при"

#~ msgid "the shell.  If SIGNAL_SPEC is DEBUG, ARG is executed after every"
#~ msgstr "выходе из оболочки, если DEBUG, АРГ выполняется при выполнении каждой"

#~ msgid "command.  If ARG is `-p' then the trap commands associated with"
#~ msgstr "команды. Если АРГ -- `-p', выводятся команды, связанные с заданными"

#~ msgid "each SIGNAL_SPEC are displayed.  If no arguments are supplied or if"
#~ msgstr "сигналами. Если аргументы не заданы или если задано только `-p',"

#~ msgid "only `-p' is given, trap prints the list of commands associated with"
#~ msgstr "trap выводит список команд, связанных со всеми сигналами. Сигнал"

#~ msgid "each signal number.  SIGNAL_SPEC is either a signal name in <signal.h>"
#~ msgstr "задаётся либо своим именем в <signal.h>, либо номером. `trap -l'"

#~ msgid "or a signal number.  `trap -l' prints a list of signal names and their"
#~ msgstr "выводит список имён сигналов и соответствующих им номеров."

#~ msgid "corresponding numbers.  Note that a signal can be sent to the shell"
#~ msgstr "Заметьте, что оболочке можно послать сигнал командой"

#~ msgid "with \"kill -signal $$\"."
#~ msgstr "\"kill -signal $$\"."

#~ msgid "For each NAME, indicate how it would be interpreted if used as a"
#~ msgstr "Для каждого ИМЕНИ определяет, как оно будет обрабатываться"

#~ msgid "If the -t option is used, returns a single word which is one of"
#~ msgstr "Если задан параметр -t, возвращает слово -- `alias', `keyword',"

#~ msgid "`alias', `keyword', `function', `builtin', `file' or `', if NAME is an"
#~ msgstr "`function', `builtin', `file' или `' -- если, соответственно, ИМЯ"

#~ msgid "alias, shell reserved word, shell function, shell builtin, disk file,"
#~ msgstr "является псевдокомандой, зарезервированным словом, функцией, или"

#~ msgid "or unfound, respectively."
#~ msgstr "встроенной командой оболочки, дисковым файлом или не найдено."

#~ msgid "If the -p flag is used, either returns the name of the disk file"
#~ msgstr "При использовании флага -p либо возвращается имя выполняемого дискового файла,"

#~ msgid "that would be executed, or nothing if -t would not return `file'."
#~ msgstr "либо ничего, если -t вернуло бы значение, отличное от  `file'"

#~ msgid "If the -a flag is used, displays all of the places that contain an"
#~ msgstr "При использовании флага -a выводится расположение всех исполняемых файлов"

#~ msgid "executable named `file'.  This includes aliases and functions, if and"
#~ msgstr "с указанным именем. Если одновременно не используется флаг -p и только"

#~ msgid "only if the -p flag is not also used."
#~ msgstr "тогда, выводятся также псевдокоманды и функции."

#~ msgid "Type accepts -all, -path, and -type in place of -a, -p, and -t,"
#~ msgstr "Вместо -a, -p и -t можно использовать, соответственно, -all,"

#~ msgid "respectively."
#~ msgstr "-path и -type."

#~ msgid "Ulimit provides control over the resources available to processes"
#~ msgstr "ulimit позволяет управлять ресурсами, доступными запущенным"

#~ msgid "started by the shell, on systems that allow such control.  If an"
#~ msgstr "оболочкой процессам (на системах, допускающих такое управление)."

#~ msgid "option is given, it is interpreted as follows:"
#~ msgstr "Параметры интерпретируются следующим образом:"

#~ msgid "    -S\tuse the `soft' resource limit"
#~ msgstr "    -S\tиспользовать `мягкое' ограничение ресурсов"

#~ msgid "    -H\tuse the `hard' resource limit"
#~ msgstr "    -H\tиспользовать `жёсткое' ограничение ресурсов"

#~ msgid "    -a\tall current limits are reported"
#~ msgstr "    -a\tвывести информацию о всех текущих ограничениях"

#~ msgid "    -c\tthe maximum size of core files created"
#~ msgstr "    -c\tмаксимальный размер создаваемых файлов слепков памяти"

#~ msgid "    -d\tthe maximum size of a process's data segment"
#~ msgstr "    -d\tмаксимальный размер сегмента данных процесса"

#~ msgid "    -m\tthe maximum resident set size"
#~ msgstr "    -m\tмаксимальный размер резидентной части процесса"

#~ msgid "    -s\tthe maximum stack size"
#~ msgstr "    -s\tмаксимальный размер стека"

#~ msgid "    -t\tthe maximum amount of cpu time in seconds"
#~ msgstr "    -t\tмаксимальное процессорное время (в секундах)"

#~ msgid "    -f\tthe maximum size of files created by the shell"
#~ msgstr "    -f\tмаксимальный размер создаваемых оболочкой файлов"

#~ msgid "    -p\tthe pipe buffer size"
#~ msgstr "    -p\tразмер буфера конвейера"

#~ msgid "    -n\tthe maximum number of open file descriptors"
#~ msgstr "    -n\tмаксимальное количество открытых файловых дексрипторов"

#~ msgid "    -u\tthe maximum number of user processes"
#~ msgstr "    -u\tмаксимальное число процессов одного пользователя"

#~ msgid "    -v\tthe size of virtual memory"
#~ msgstr "    -v\tразмер виртуальной памяти"

#~ msgid "If LIMIT is given, it is the new value of the specified resource."
#~ msgstr "Если задано ОГРАНИЧЕНИЕ, оно задёт новое значение для указанного ресурса."

#~ msgid "Otherwise, the current value of the specified resource is printed."
#~ msgstr "В противном случае выводится текущее значение для указанного ресурса."

#~ msgid "If no option is given, then -f is assumed.  Values are in 1k"
#~ msgstr "Если параметры не заданы, предполагается, что задано -f. Значения"

#~ msgid "increments, except for -t, which is in seconds, -p, which is in"
#~ msgstr "измеряются в КБ, кроме -t, измеряемого в секундах, -p, единица измерения"

#~ msgid "increments of 512 bytes, and -u, which is an unscaled number of"
#~ msgstr "которого -- 512 байтов, и -u, задающего безразмерное число"

#~ msgid "processes."
#~ msgstr "процессов."

#~ msgid "The user file-creation mask is set to MODE.  If MODE is omitted, or if"
#~ msgstr "Устанавливает маску создания пользователем файлов в РЕЖИМ. Если опущен"

#~ msgid "`-S' is supplied, the current value of the mask is printed.  The `-S'"
#~ msgstr "РЕЖИМ или задан параметр -S выводится текущее значение маски. Параметр"

#~ msgid "option makes the output symbolic; otherwise an octal number is output."
#~ msgstr "-S делает вывод символическим, в противном случае используется"

#~ msgid "If MODE begins with a digit, it is interpreted as an octal number,"
#~ msgstr "восьмеричое число. Если РЕЖИм начинается с цифры, он интерпретируется"

#~ msgid "otherwise it is a symbolic mode string like that accepted by chmod(1)."
#~ msgstr "как восьмеричное число, в противном случае как строка, принимаемая chmod(1)."

#~ msgid "Wait for the specified process and report its termination status.  If"
#~ msgstr "Подождать завершения указанного процесса и сообщить код завершения. Если"

#~ msgid "N is not given, all currently active child processes are waited for,"
#~ msgstr "N не задано, ожидается завершение работы всех активных дочерних процессов"

#~ msgid "and the return code is zero.  N may be a process ID or a job"
#~ msgstr "и код возврата равен 0. N может быть идентификатором процесса"

#~ msgid "specification; if a job spec is given, all processes in the job's"
#~ msgstr "или спецификацией задачи, если задана спецификация задачи, ожидается"

#~ msgid "pipeline are waited for."
#~ msgstr "завершение работы всех процессов конвейера задачи."

#~ msgid "and the return code is zero.  N is a process ID; if it is not given,"
#~ msgstr "и код возврата равен 0. N -- идентификатор процесса, если он не задан,"

#~ msgid "all child processes of the shell are waited for."
#~ msgstr "ожидается завершение работы всех дочерних процессов оболочки."

#~ msgid "The `for' loop executes a sequence of commands for each member in a"
#~ msgstr "Цикл `for' выполняет последовательность команд для каждого члена"

#~ msgid "list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is"
#~ msgstr "списка. Если отсутствует `in СЛОВА ...;', предполагается, что задано"

#~ msgid "assumed.  For each element in WORDS, NAME is set to that element, and"
#~ msgstr "`in \"$@\"'. Для каждого из СЛОВ ИМЕНИ присваивается его значение"

#~ msgid "the COMMANDS are executed."
#~ msgstr "и затем выполняются КОМАНДЫ."

#~ msgid "The WORDS are expanded, generating a list of words.  The"
#~ msgstr "СЛОВА разворачиваются и образуют список слов. Полученный список"

#~ msgid "set of expanded words is printed on the standard error, each"
#~ msgstr "выводится на стандартный поток ошибок, каждому приписывается спереди"

#~ msgid "preceded by a number.  If `in WORDS' is not present, `in \"$@\"'"
#~ msgstr "число. Если `in СЛОВА' отсутствует, предполагается заданным"

#~ msgid "is assumed.  The PS3 prompt is then displayed and a line read"
#~ msgstr "`in \"$@\"'. Затем выводится приглашение PS3 и со стандартного ввода"

#~ msgid "from the standard input.  If the line consists of the number"
#~ msgstr "считывается строка. Если строка состоит из числа, соответствующего"

#~ msgid "corresponding to one of the displayed words, then NAME is set"
#~ msgstr "одному из выведенных слов, ИМЯ устанавливается равным этому"

#~ msgid "to that word.  If the line is empty, WORDS and the prompt are"
#~ msgstr "слову. Если строка пуста, слова и приглашение выводятся ещё раз."

#~ msgid "redisplayed.  If EOF is read, the command completes.  Any other"
#~ msgstr "Если прочитан символ конца файла, выполнение команды завершается."

#~ msgid "value read causes NAME to be set to null.  The line read is saved"
#~ msgstr "любое другое значение устанавливает ИМЯ в NULL. Прочитанная строка"

#~ msgid "in the variable REPLY.  COMMANDS are executed after each selection"
#~ msgstr "сохраняется в переменной REPLY. После каждого выбора выполняются"

#~ msgid "until a break or return command is executed."
#~ msgstr "КОМАНДЫ до тех пор, пока не будет выполнена команда break или return."

#~ msgid "Selectively execute COMMANDS based upon WORD matching PATTERN.  The"
#~ msgstr "Выполняет КОМАНДЫ в зависимости от того, какому ШАБЛОНУ соответствует"

#~ msgid "`|' is used to separate multiple patterns."
#~ msgstr "СЛОВО. Для разделения нескольких допустимых шаблонов используется `|'."

#~ msgid "The if COMMANDS are executed.  If the exit status is zero, then the then"
#~ msgstr "Выполняются КОМАНДЫ, заданные в if. Если код возврата нулевой, выполняются"

#~ msgid "COMMANDS are executed.  Otherwise, each of the elif COMMANDS are executed"
#~ msgstr "КОМАНДЫ then, иначе по очереди выполняются КОМАНДЫ elif, и если код"

#~ msgid "in turn, and if the exit status is zero, the corresponding then COMMANDS"
#~ msgstr "возврата нулевой, выполняются соответствующие КОМАНДЫ then и выполнение"

#~ msgid "are executed and the if command completes.  Otherwise, the else COMMANDS"
#~ msgstr "команды if завершается. В противном случае выполняются КОМАНДЫ else,"

#~ msgid "are executed, if present.  The exit status is the exit status of the last"
#~ msgstr "если они присутствуют. Код возврата равен коду возврата последней"

#~ msgid "command executed, or zero if no condition tested true."
#~ msgstr "выполненной команды, либо нулю, если ни одно условие не было истинным."

#~ msgid "Expand and execute COMMANDS as long as the final command in the"
#~ msgstr "Разворачивает и выполняет КОМАНДЫ до тех пор, пока последняя команда"

#~ msgid "`while' COMMANDS has an exit status of zero."
#~ msgstr "предложения `while' не завершит работу с нулевым кодом возврата."

#~ msgid "`until' COMMANDS has an exit status which is not zero."
#~ msgstr "предложения `until' не завершит работу с ненулевым кодом возврата."

#~ msgid "Create a simple command invoked by NAME which runs COMMANDS."
#~ msgstr "Создаёт простую команду, вызываемую по ИМЕНИ и выполняющую КОМАНДЫ."

#~ msgid "Arguments on the command line along with NAME are passed to the"
#~ msgstr "Аргументы командной строки, переданные ИМЕНИ, передаются в функцию"

#~ msgid "function as $0 .. $n."
#~ msgstr "как $0 .. $n."

#~ msgid "Run a set of commands in a group.  This is one way to redirect an"
#~ msgstr "Выполняет набор команд. Это один из способов осуществить"

#~ msgid "entire set of commands."
#~ msgstr "перенаправление для целого набора команд."

#~ msgid "This is similar to the `fg' command.  Resume a stopped or background"
#~ msgstr "Похоже на команду `fg'. Продолжает выполнение остановленной или фоновой"

#~ msgid "job.  If you specifiy DIGITS, then that job is used.  If you specify"
#~ msgstr "задачи. Если заданы ЦИФРЫ, использяется задача с этим номером, а если"

#~ msgid "WORD, then the job whose name begins with WORD is used.  Following the"
#~ msgstr "СЛОВО -- задача, имя которой начинается с этого слова. Завершение"

#~ msgid "job specification with a `&' places the job in the background."
#~ msgstr "спецификации задачи символом & переводит задачу в фоновый режим."

#~ msgid "BASH_VERSION    The version numbers of this Bash."
#~ msgstr "BASH_VERSION    Номер версии Bash."

#~ msgid "CDPATH          A colon separated list of directories to search"
#~ msgstr "CDPATH          Разделённый запятыми список каталогов, где ищется"

#~ msgid "\t\twhen the argument to `cd' is not found in the current"
#~ msgstr "\t\tаргумент команды `cd', если он не найден в текущем"

#~ msgid "HISTFILE        The name of the file where your command history is stored."
#~ msgstr "HISTFILE        Имя файла, где сохраняется история команд."

#~ msgid "HISTFILESIZE    The maximum number of lines this file can contain."
#~ msgstr "HISTFILESIZE    Максимальное число строк в этом файле."

#~ msgid "HISTSIZE        The maximum number of history lines that a running"
#~ msgstr "HISTSIZE        Максимальное число строк истории команд, к которым"

#~ msgid "\t\tshell can access."
#~ msgstr "\t\tимеет доступ оболочка."

#~ msgid "HOME            The complete pathname to your login directory."
#~ msgstr "HOME            Полный путь к домашнему каталогу."

#~ msgid "HOSTTYPE        The type of CPU this version of Bash is running under."
#~ msgstr "HOSTTYPE        Тип процессора, на котором работает эта версия Bash."

#~ msgid "IGNOREEOF       Controls the action of the shell on receipt of an EOF"
#~ msgstr "IGNOREEOF       Управляет действиями, совершаемыми оболочкой при вводе"

#~ msgid "\t\tcharacter as the sole input.  If set, then the value"
#~ msgstr "\t\tсимвола конца файла. Если установлена, её значение -- число"

#~ msgid "\t\tof it is the number of EOF characters that can be seen"
#~ msgstr "\t\tсимволов конца файла, которые могут быть встречены подряд,"

#~ msgid "\t\tin a row on an empty line before the shell will exit"
#~ msgstr "\t\tв пустой строке, после чего оболочка завершит работу"

#~ msgid "\t\t(default 10).  When unset, EOF signifies the end of input."
#~ msgstr "\t\t(по умолчанию 10). Если не установлена, EOF обозначает конец ввода."

#~ msgid "MAILCHECK\tHow often, in seconds, Bash checks for new mail."
#~ msgstr "MAILCHECK\tКак часто, в секундах, Bash проверяет наличие новой почты."

#~ msgid "MAILPATH\tA colon-separated list of filenames which Bash checks"
#~ msgstr "MAILPATH\tРазделённый запятыми список имён файлов, где Bash"

#~ msgid "\t\tfor new mail."
#~ msgstr "\t\tпроверяет наличие новой почты."

#~ msgid "OSTYPE\t\tThe version of Unix this version of Bash is running on."
#~ msgstr "OSTYPE\t\tВерсия Unix, под которой работает эта версия Bash."

#~ msgid "PATH            A colon-separated list of directories to search when"
#~ msgstr "PATH            Разделённый запятыми список каталогов, где ищутся"

#~ msgid "\t\tlooking for commands."
#~ msgstr "\t\tкоманды."

#~ msgid "PROMPT_COMMAND  A command to be executed before the printing of each"
#~ msgstr "PROMPT_COMMAND  Команда, выполняемая перед выводом каждого"

#~ msgid "\t\tprimary prompt."
#~ msgstr "\t\tпервичного приглашения."

#~ msgid "PS1             The primary prompt string."
#~ msgstr "PS1             Строка первичного приглашения."

#~ msgid "PS2             The secondary prompt string."
#~ msgstr "PS2             Строка вторичного приглашения."

#~ msgid "TERM            The name of the current terminal type."
#~ msgstr "TERM            Имя типа текущего терминала."

#~ msgid "auto_resume     Non-null means a command word appearing on a line by"
#~ msgstr "auto_resume     Ненулевые значения слов команд, встречающиеся в строке"

#~ msgid "\t\titself is first looked for in the list of currently"
#~ msgstr "\t\tотдельно, сначала ищутся в списке остановленных"

#~ msgid "\t\tstopped jobs.  If found there, that job is foregrounded."
#~ msgstr "\t\tв данный момент задач. Если найдено, задача активируется."

#~ msgid "\t\tA value of `exact' means that the command word must"
#~ msgstr "\t\t`exact' значит, что команда должна в точности"

#~ msgid "\t\texactly match a command in the list of stopped jobs.  A"
#~ msgstr "\t\tсоответствовать команде в списке остановленных задач."

#~ msgid "\t\tvalue of `substring' means that the command word must"
#~ msgstr "\t\t`substring' значит, что команда должна быть подстрокой"

#~ msgid "\t\tmatch a substring of the job.  Any other value means that"
#~ msgstr "\t\tзадачи. Любые другие значения означают, что"

#~ msgid "\t\tthe command must be a prefix of a stopped job."
#~ msgstr "\t\tкоманда должна быть префиксом остановленной задачи."

#~ msgid "command_oriented_history"
#~ msgstr "command_oriented_history"

#~ msgid "                Non-null means to save multiple-line commands together on"
#~ msgstr "                Ненулевое значение означает, что многострочные команды"

#~ msgid "                a single history line."
#~ msgstr "                будут сохраняться в одной строке истории."

#~ msgid "histchars       Characters controlling history expansion and quick"
#~ msgstr "histchars       Управляющие символы расширения истории и быстрой"

#~ msgid "\t\tsubstitution.  The first character is the history"
#~ msgstr "\t\tподстановки. Первый символ -- символ подстановки"

#~ msgid "\t\tsubstitution character, usually `!'.  The second is"
#~ msgstr "\t\tистории, обычно `!'. Второй -- символ `быстрой"

#~ msgid "\t\tthe `quick substitution' character, usually `^'.  The"
#~ msgstr "\t\tподстановки', обычно `^'. Третий -- символ `комментария"

#~ msgid "\t\tthird is the `history comment' character, usually `#'."
#~ msgstr "\t\tистории', обычно `#'."

#~ msgid "HISTCONTROL\tSet to a value of `ignorespace', it means don't enter"
#~ msgstr "HISTCONTROL\tЕсли равен `ignorespace', это означает, что строки,"

#~ msgid "\t\tlines which begin with a space or tab on the history"
#~ msgstr "\t\tначинающиеся с пробела или знака табуляции, не попадают"

#~ msgid "\t\tlist.  Set to a value of `ignoredups', it means don't"
#~ msgstr "\t\tв историю. `ignoredups' означает, что строки, сопадающие"

#~ msgid "\t\tenter lines which match the last entered line.  Set to"
#~ msgstr "\t\tс предыдущей, не попадают в историю. `ignoreboth' --"

#~ msgid "\t\t`ignoreboth' means to combine the two options.  Unset,"
#~ msgstr "\t\tодновременное действие обоих параметров. Если не"

#~ msgid "\t\tor set to any other value than those above means to save"
#~ msgstr "\t\tустановлено, или равно другому значению, то в историю"

#~ msgid "\t\tall lines on the history list."
#~ msgstr "\t\tкоманд попадают все строки."

#~ msgid "Adds a directory to the top of the directory stack, or rotates"
#~ msgstr "Помещает каталог на вершину стека каталогов или вращает"

#~ msgid "the stack, making the new top of the stack the current working"
#~ msgstr "стек так, чтобы на вершине находился текущий каталог. Без"

#~ msgid "directory.  With no arguments, exchanges the top two directories."
#~ msgstr "аргументов меняет местами два верхних каталога."

#~ msgid "+N\tRotates the stack so that the Nth directory (counting"
#~ msgstr "+N\tВращает стек так, чтобы N-й каталог (считая с левой стороны "

#~ msgid "\tfrom the left of the list shown by `dirs') is at the top."
#~ msgstr "\tсписка, выводимого `dirs') оказался на вершине стека."

#~ msgid "-N\tRotates the stack so that the Nth directory (counting"
#~ msgstr "-N\tВращает стек так, чтобы N-й каталог (считая с правой"

#~ msgid "\tfrom the right) is at the top."
#~ msgstr "\tстороны) оказался на вершине стека."

#~ msgid "-n\tsuppress the normal change of directory when adding directories"
#~ msgstr "-n\tподавляет обычную смену каталога при добавлении каталога"

#~ msgid "\tto the stack, so only the stack is manipulated."
#~ msgstr "\tв стек, так что меняется только содержимое стека."

#~ msgid "dir\tadds DIR to the directory stack at the top, making it the"
#~ msgstr "dir\tпомещает DIR на вершину стека и делает его новым"

#~ msgid "You can see the directory stack with the `dirs' command."
#~ msgstr "Просматривать стек каталогов можно командой `dirs'."

#~ msgid "Removes entries from the directory stack.  With no arguments,"
#~ msgstr "Удаляет значения из стека каталогов. Без аргументов"

#~ msgid "removes the top directory from the stack, and cd's to the new"
#~ msgstr "удаляет из стека каталог на вершине и делает рабочим каталог,"

#~ msgid "+N\tremoves the Nth entry counting from the left of the list"
#~ msgstr "+N\tудаляет N-й каталог, считая с левой стороны списка,"

#~ msgid "\tshown by `dirs', starting with zero.  For example: `popd +0'"
#~ msgstr "\tвыводимого `dirs', начиная с нуля. Например, `popd +0'"

#~ msgid "\tremoves the first directory, `popd +1' the second."
#~ msgstr "\tудаляет первый каталог, `popd +1' -- второй."

#~ msgid "-N\tremoves the Nth entry counting from the right of the list"
#~ msgstr "-N\tудаляет N-й каталог, считая с правой стороны списка,"

#~ msgid "\tshown by `dirs', starting with zero.  For example: `popd -0'"
#~ msgstr "\tвыводимого `dirs', начиная с нуля. Например, `popd -0'"

#~ msgid "\tremoves the last directory, `popd -1' the next to last."
#~ msgstr "\tудаляет последний каталог, `popd -1' -- предпоследний."

#~ msgid "-n\tsuppress the normal change of directory when removing directories"
#~ msgstr "-n\tподавляет обычную смену каталога при удалении каталогов из"

#~ msgid "\tfrom the stack, so only the stack is manipulated."
#~ msgstr "\tстека, так что меняется только содержимое стека."

#~ msgid "Display the list of currently remembered directories.  Directories"
#~ msgstr "Выводит список запомненных на данный момент каталогов. Каталоги"

#~ msgid "find their way onto the list with the `pushd' command; you can get"
#~ msgstr "попадают в список при использовании команды `pushd', вы можете забрать"

#~ msgid "back up through the list with the `popd' command."
#~ msgstr "их из списка командой `popd'."

#~ msgid "The -l flag specifies that `dirs' should not print shorthand versions"
#~ msgstr "Флаг -l указывает, что `dirs' не должна выводит сокращённые варианты"

#~ msgid "of directories which are relative to your home directory.  This means"
#~ msgstr "каталогов, заданных относительно домашнего. Это означает, что"

#~ msgid "that `~/bin' might be displayed as `/homes/bfox/bin'.  The -v flag"
#~ msgstr "`~/bin' будет отображаться как `/homes/bfox/bin'. Флаг -v"

#~ msgid "causes `dirs' to print the directory stack with one entry per line,"
#~ msgstr "заставляет `dirs' выводить каталоги по одному в строке, предваряя"

#~ msgid "prepending the directory name with its position in the stack.  The -p"
#~ msgstr "имя каталога номером его позиции в стеке. Флаг -p делает то же самое,"

#~ msgid "flag does the same thing, but the stack position is not prepended."
#~ msgstr "но не добавляются номера позиций. Флаг -c очищает стек каталогов,"

#~ msgid "The -c flag clears the directory stack by deleting all of the elements."
#~ msgstr "удаляя все его элементы."

#~ msgid "+N\tdisplays the Nth entry counting from the left of the list shown by"
#~ msgstr "+N\tвыводит N-й каталог, считая с левой стороны списка, выводимого"

#~ msgid "\tdirs when invoked without options, starting with zero."
#~ msgstr "\tdirs при вызове без параметров, начиная с нуля."

#~ msgid "-N\tdisplays the Nth entry counting from the right of the list shown by"
#~ msgstr "-N\tвыводит N-й каталог, считая с правой стороны списка, выводимого"

#~ msgid "Toggle the values of variables controlling optional behavior."
#~ msgstr "Меняет значение переменных, управляющих поведением оболочки."

#~ msgid "The -s flag means to enable (set) each OPTNAME; the -u flag"
#~ msgstr "Флаг -s означает включить (установить) каждое ИМЯ_ПАРАМЕТРА,"

#~ msgid "unsets each OPTNAME.  The -q flag suppresses output; the exit"
#~ msgstr "флаг -u сбрасывает. Флаг -q подавляет вывод, установлен или"

#~ msgid "status indicates whether each OPTNAME is set or unset.  The -o"
#~ msgstr "сброшен параметр определяется по коду возврата. Параметр -o"

#~ msgid "option restricts the OPTNAMEs to those defined for use with"
#~ msgstr "ограничивает работу параметрами, определёнными с помощью"

#~ msgid "`set -o'.  With no options, or with the -p option, a list of all"
#~ msgstr "`set -o'. Без параметров или при заданном параметре -p, выводится"

#~ msgid "settable options is displayed, with an indication of whether or"
#~ msgstr "список всех установленных параметров и информация, установлены"

#~ msgid "not each is set."
#~ msgstr "они или нет."
