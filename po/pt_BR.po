# Brazilian Portuguese translation for bash
# Copyright (C) 2023 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Halley Pacheco de Oliveira <halleypo@ig.com.br>, 2002.
# Rafael Fontenelle <rafaelff@gnome.org>, 2015-2023.
#
msgid ""
msgstr ""
"Project-Id-Version: bash 5.2-rc1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-11 14:50-0500\n"
"PO-Revision-Date: 2023-01-12 14:27-0300\n"
"Last-Translator: Rafael Fontenelle <rafaelff@gnome.org>\n"
"Language-Team: Brazilian Portuguese <ldpbr-translation@lists.sourceforge.net>\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1)\n"
"X-Generator: Gtranslator 42.0\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"

#: arrayfunc.c:66
msgid "bad array subscript"
msgstr "subscript de array incorreto"

#: arrayfunc.c:471 builtins/declare.def:709 variables.c:2242 variables.c:2268
#: variables.c:3101
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: removendo o atributo nameref"

#: arrayfunc.c:496 builtins/declare.def:868
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: impossível converter array indexado para associativo"

#: arrayfunc.c:777
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: impossível atribuir a índice não numérico"

#: arrayfunc.c:822
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: deve-se usar subscript ao atribuir um array associativo"

#: bashhist.c:455
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: impossível criar: %s"

#: bashline.c:4479
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: impossível localizar mapa de teclas para comando"

#: bashline.c:4637
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: primeiro caractere não-espaço em branco não é `\"'"

#: bashline.c:4666
#, c-format
msgid "no closing `%c' in %s"
msgstr "sem `%c' de fechamento em %s"

#: bashline.c:4697
#, c-format
msgid "%s: missing colon separator"
msgstr "%s faltando separador dois-pontos"

#: bashline.c:4733
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "`%s': não foi desassociar no comando keymap"

#: braces.c:327
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "expansão de chaves: impossível alocar memória para %s"

#: braces.c:406
#, c-format
msgid "brace expansion: failed to allocate memory for %u elements"
msgstr "expansão de chaves: falha ao alocar memória para %u elementos"

#: braces.c:451
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "expansão de chaves: falha ao alocar memória para `%s'"

#: builtins/alias.def:131 variables.c:1817
#, c-format
msgid "`%s': invalid alias name"
msgstr "`%s': nome de apelido (alias) inválido"

#: builtins/bind.def:122 builtins/bind.def:125
msgid "line editing not enabled"
msgstr "edição de linha não habilitada"

#: builtins/bind.def:212
#, c-format
msgid "`%s': invalid keymap name"
msgstr "`%s': nome de mapa de teclas inválido"

#: builtins/bind.def:252
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: impossível ler: %s"

#: builtins/bind.def:328 builtins/bind.def:358
#, c-format
msgid "`%s': unknown function name"
msgstr "`%s': nome de função desconhecida"

#: builtins/bind.def:336
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s não está associada a qualquer tecla.\n"

#: builtins/bind.def:340
#, c-format
msgid "%s can be invoked via "
msgstr "%s pode ser chamado via "

#: builtins/bind.def:378 builtins/bind.def:395
#, c-format
msgid "`%s': cannot unbind"
msgstr "`%s': impossível desassociar (unbind)"

#: builtins/break.def:77 builtins/break.def:119
msgid "loop count"
msgstr "número de loops"

#: builtins/break.def:139
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "significativo apenas em um loop de `for', `while' ou `until'"

# help caller
#: builtins/caller.def:136
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
"Retorna o contexto da chamada de sub-rotina atual.\n"
"    \n"
"    Sem EXPR, retorna \"$linha $arquivo\".  Com EXPR, retorna\n"
"    \"$linha $sub-rotina $arquivo\"; essa informação extra pode ser usada para\n"
"    fornecer um rastro da pilha.\n"
"    \n"
"    O valor de EXPR indica quantos quadros de chamada deve voltar antes do\n"
"    atual; o quadro do topo é o quadro 0."

#: builtins/cd.def:327
msgid "HOME not set"
msgstr "HOME não definida"

#: builtins/cd.def:335 builtins/common.c:161 test.c:916
msgid "too many arguments"
msgstr "número excessivo de argumentos"

#: builtins/cd.def:342
msgid "null directory"
msgstr "diretório nulo"

#: builtins/cd.def:353
msgid "OLDPWD not set"
msgstr "OLDPWD não definida"

#: builtins/common.c:96
#, c-format
msgid "line %d: "
msgstr "linha %d: "

#: builtins/common.c:134 error.c:264
#, c-format
msgid "warning: "
msgstr "aviso: "

#: builtins/common.c:148
#, c-format
msgid "%s: usage: "
msgstr "%s: uso: "

#: builtins/common.c:193 shell.c:524 shell.c:866
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: a opção requer um argumento"

#: builtins/common.c:200
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: requer argumento numérico"

#: builtins/common.c:207
#, c-format
msgid "%s: not found"
msgstr "%s: não encontrado"

#: builtins/common.c:216 shell.c:879
#, c-format
msgid "%s: invalid option"
msgstr "%s: opção inválida"

#: builtins/common.c:223
#, c-format
msgid "%s: invalid option name"
msgstr "%s: nome de opção inválido"

#: builtins/common.c:230 execute_cmd.c:2402 general.c:368 general.c:373
#, c-format
msgid "`%s': not a valid identifier"
msgstr "`%s': não é um identificador válido"

#: builtins/common.c:240
msgid "invalid octal number"
msgstr "número octal inválido"

#: builtins/common.c:242
msgid "invalid hex number"
msgstr "número do hexa inválido"

#: builtins/common.c:244 expr.c:1574
msgid "invalid number"
msgstr "número inválido"

#: builtins/common.c:252
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: especificação de sinal inválida"

#: builtins/common.c:259
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "`%s': não é um identificador de processo (pid) nem é uma especificação de trabalho válida"

#: builtins/common.c:266 error.c:536
#, c-format
msgid "%s: readonly variable"
msgstr "%s: a variável permite somente leitura"

#: builtins/common.c:273
#, c-format
msgid "%s: cannot assign"
msgstr "%s: impossível atribuir"

#: builtins/common.c:281
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s fora dos limites"

#: builtins/common.c:281 builtins/common.c:283
msgid "argument"
msgstr "argumento"

#: builtins/common.c:283
#, c-format
msgid "%s out of range"
msgstr "%s fora dos limites"

#: builtins/common.c:291
#, c-format
msgid "%s: no such job"
msgstr "%s: trabalho não existe"

#: builtins/common.c:299
#, c-format
msgid "%s: no job control"
msgstr "%s: nenhum controle de trabalho"

#: builtins/common.c:301
msgid "no job control"
msgstr "nenhum controle de trabalho"

#: builtins/common.c:311
#, c-format
msgid "%s: restricted"
msgstr "%s: restrição"

#: builtins/common.c:313
msgid "restricted"
msgstr "restrição"

#: builtins/common.c:321
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: não é um comando interno do shell"

#: builtins/common.c:330
#, c-format
msgid "write error: %s"
msgstr "erro de escrita: %s"

#: builtins/common.c:338
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "erro ao definir atributos do terminal: %s"

#: builtins/common.c:340
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "erro ao obter atributos do terminal: %s"

#: builtins/common.c:642
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: erro ao obter o diretório atual: %s: %s\n"

#: builtins/common.c:708 builtins/common.c:710
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: especificação de trabalho ambígua"

#: builtins/common.c:971
msgid "help not available in this version"
msgstr "ajuda não disponível nesta versão"

#: builtins/common.c:1038 builtins/set.def:953 variables.c:3825
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: impossível remover definição: %s somente-leitura"

#: builtins/common.c:1043 builtins/set.def:932 variables.c:3830
#, c-format
msgid "%s: cannot unset"
msgstr "%s: impossível remover definição"

#: builtins/complete.def:287
#, c-format
msgid "%s: invalid action name"
msgstr "%s: nome de ação inválido"

#: builtins/complete.def:486 builtins/complete.def:642
#: builtins/complete.def:873
#, c-format
msgid "%s: no completion specification"
msgstr "%s: nenhuma especificação de completação"

#: builtins/complete.def:696
msgid "warning: -F option may not work as you expect"
msgstr "aviso: a opção -F pode não funcionar como esperado"

#: builtins/complete.def:698
msgid "warning: -C option may not work as you expect"
msgstr "aviso: a opção -C pode não funcionar como esperado"

#: builtins/complete.def:846
msgid "not currently executing completion function"
msgstr "não se está executando atualmente função de completação"

#: builtins/declare.def:137
msgid "can only be used in a function"
msgstr "somente pode ser usado em uma função"

#: builtins/declare.def:437
msgid "cannot use `-f' to make functions"
msgstr "impossível usar `-f' para criar funções"

#: builtins/declare.def:464 execute_cmd.c:6132
#, c-format
msgid "%s: readonly function"
msgstr "%s: função somente para leitura"

#: builtins/declare.def:521 builtins/declare.def:804
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: variável de referência não pode ser um array"

#: builtins/declare.def:532 variables.c:3359
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s: referência a si próprio da variável nameref não é permitido"

#: builtins/declare.def:537 variables.c:2072 variables.c:3278 variables.c:3286
#: variables.c:3356
#, c-format
msgid "%s: circular name reference"
msgstr "%s referência circular de nome"

#: builtins/declare.def:541 builtins/declare.def:811 builtins/declare.def:820
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "\"%s\": nome de variável inválido para referência de nome"

#: builtins/declare.def:856
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: impossível destruir variáveis de array desta maneira"

#: builtins/declare.def:862 builtins/read.def:887
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: impossível converter array associativo para indexado"

#: builtins/declare.def:891
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s: atribuição de array composto com aspas está obsoleto"

#: builtins/enable.def:145 builtins/enable.def:153
msgid "dynamic loading not available"
msgstr "carregamento dinâmico não está disponível"

#: builtins/enable.def:376
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "impossível abrir objeto compartilhado %s: %s"

#: builtins/enable.def:405
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "impossível localizar %s no objeto compartilhado %s: %s"

#: builtins/enable.def:422
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: comando dinâmico já foi carregado"

#: builtins/enable.def:426
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "função de carregamento para %s retorna falha (%d): não foi carregada"

#: builtins/enable.def:551
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: não foi carregado dinamicamente"

#: builtins/enable.def:577
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: impossível excluir: %s"

#: builtins/evalfile.c:138 builtins/hash.def:185 execute_cmd.c:5959
#, c-format
msgid "%s: is a directory"
msgstr "%s: é um diretório"

#: builtins/evalfile.c:144
#, c-format
msgid "%s: not a regular file"
msgstr "%s: não é um arquivo irregular"

#: builtins/evalfile.c:153
#, c-format
msgid "%s: file is too large"
msgstr "%s: arquivo é muito grande"

#: builtins/evalfile.c:188 builtins/evalfile.c:206 shell.c:1673
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: impossível executar o arquivo binário"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:246
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: impossível executar: %s"

#: builtins/exit.def:64
#, c-format
msgid "logout\n"
msgstr "sair\n"

#: builtins/exit.def:89
msgid "not login shell: use `exit'"
msgstr "não é um shell de login: use `exit'"

#: builtins/exit.def:121
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Há trabalhos parados.\n"

#: builtins/exit.def:123
#, c-format
msgid "There are running jobs.\n"
msgstr "Há trabalhos em execução.\n"

#: builtins/fc.def:275 builtins/fc.def:373 builtins/fc.def:417
msgid "no command found"
msgstr "nenhum comando encontrado"

#: builtins/fc.def:363 builtins/fc.def:368 builtins/fc.def:407
#: builtins/fc.def:412
msgid "history specification"
msgstr "especificação do histórico"

#: builtins/fc.def:444
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: impossível abrir arquivo temporário: %s"

#: builtins/fg_bg.def:152 builtins/jobs.def:284
msgid "current"
msgstr "atual"

#: builtins/fg_bg.def:161
#, c-format
msgid "job %d started without job control"
msgstr "o trabalho %d iniciou sem controle de trabalho"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opção ilegal -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: a opção requer um argumento: -- %c\n"

#: builtins/hash.def:91
msgid "hashing disabled"
msgstr "hashing está desabilitado"

#: builtins/hash.def:139
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: tabela de hash está vazia\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "número\tcomando\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Comandos shell correspondendo à palavra-chave `"
msgstr[1] "Comandos shell correspondendo às palavras-chave `"

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"'\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid "no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr "nenhum tópico de ajuda corresponde a `%s'.  Tente `help help' ou `man -k %s' ou `info %s'."

#: builtins/help.def:223
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: impossível abrir: %s"

#: builtins/help.def:523
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Esses comandos shell são definidos internamente. Digite `help' para ver essa\n"
"lista. Digite `help NOME' para descobrir mais sobre a função `NOME'.\n"
"Use `info bash' para descobrir mais sobre o shell em geral.\n"
"Use `man -k' ou `info' para descobrir mais sobre comandos que não estão nesta\n"
"lista.\n"
"\n"
"Um asterisco (*) próximo ao nome significa que o comando está desabilitado.\n"
"\n"

#: builtins/history.def:159
msgid "cannot use more than one of -anrw"
msgstr "impossível usar mais de um dentre -anrw"

#: builtins/history.def:192 builtins/history.def:204 builtins/history.def:215
#: builtins/history.def:228 builtins/history.def:240 builtins/history.def:247
msgid "history position"
msgstr "posição no histórico"

#: builtins/history.def:338
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: marca de tempo inválida"

#: builtins/history.def:449
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: expansão do histórico falhou"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: inlib falhou"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "nenhuma outra opção permitida com `-x'"

#: builtins/kill.def:211
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: argumentos devem ser IDs de trabalhos ou processo"

#: builtins/kill.def:274
msgid "Unknown error"
msgstr "Erro desconhecido"

#: builtins/let.def:97 builtins/let.def:122 expr.c:640 expr.c:658
msgid "expression expected"
msgstr "esperava uma expressão"

#: builtins/mapfile.def:180
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: não é um array indexado"

#: builtins/mapfile.def:276 builtins/read.def:336
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: especificação de descritor de arquivo inválida"

#: builtins/mapfile.def:284 builtins/read.def:343
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: descritor de arquivo inválido: %s"

#: builtins/mapfile.def:293 builtins/mapfile.def:331
#, c-format
msgid "%s: invalid line count"
msgstr "%s: número de linhas inválido"

#: builtins/mapfile.def:304
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: origem do array inválido"

#: builtins/mapfile.def:321
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: quantidade de chamadas inválida"

#: builtins/mapfile.def:354
msgid "empty array variable name"
msgstr "nome de variável array vazio"

#: builtins/mapfile.def:375
msgid "array variable support required"
msgstr "requer suporte a variável de array"

#: builtins/printf.def:430
#, c-format
msgid "`%s': missing format character"
msgstr "`%s': faltando caractere de formato"

#: builtins/printf.def:485
#, c-format
msgid "`%c': invalid time format specification"
msgstr "`%c': especificação de formato de tempo inválida"

#: builtins/printf.def:708
#, c-format
msgid "`%c': invalid format character"
msgstr "`%c': caractere de formato inválido"

#: builtins/printf.def:734
#, c-format
msgid "warning: %s: %s"
msgstr "aviso: %s: %s"

#: builtins/printf.def:822
#, c-format
msgid "format parsing problem: %s"
msgstr "problema ao analisar formato: %s"

#: builtins/printf.def:919
msgid "missing hex digit for \\x"
msgstr "faltando dígito hexa para \\x"

#: builtins/printf.def:934
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "faltando dígito unicode para \\%c"

#: builtins/pushd.def:199
msgid "no other directory"
msgstr "nenhum outro diretório"

#: builtins/pushd.def:360
#, c-format
msgid "%s: invalid argument"
msgstr "%s argumento inválido"

#: builtins/pushd.def:480
msgid "<no current directory>"
msgstr "<nenhum diretório atual>"

#: builtins/pushd.def:524
msgid "directory stack empty"
msgstr "pilha de diretórios está vazia"

#: builtins/pushd.def:526
msgid "directory stack index"
msgstr "índice de pilha de diretórios"

#: builtins/pushd.def:701
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Exibe a lista de diretórios atualmente memorizados. Diretórios são\n"
"    inseridos na lista por meio do comando `pushd'; você pode obter\n"
"    de volta da lista com o comando `popd'.\n"
"    \n"
"    Opções:\n"
"      -c\tlimpa a pilha de diretórios excluindo todos os elementos\n"
"      -l\tnão mostra versões de diretórios prefixadas por til,\n"
"      \t\trelativos ao seu diretório HOME\n"
"      -p\texibe a pilha de diretório com uma entrada por linha\n"
"      -v\texibe a pilha de diretório com uma entrada por linha,\n"
"      \t\tprefixada com sua posição na pilha\n"
"    \n"
"    Argumentos:\n"
"      +N\tExibe a n-ésima entrada a partir da esquerda da linha\n"
"      \t\tmostrada por `dirs' chamado sem opções, iniciando com zero.\n"
"    \n"
"      -N\tExibe a n-ésima entrada a partir da esquerda da linha\n"
"      \t\tmostrada por `dirs' chamado sem opções, iniciando com zero."

#: builtins/pushd.def:723
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Adiciona um diretório ao topo da pilha de diretórios ou movimenta\n"
"    a pilha, fazendo o novo topo da pilha ser o diretório atual de\n"
"    trabalho. Com nenhum argumento, efetua troca do topo entre dois\n"
"    diretórios.\n"
"    \n"
"    Opções:\n"
"      -n\tSuprime a alteração normal de diretório ao adicionar\n"
"      \t\tdiretórios à pilha, de forma que apenas a pilha é manipulada.\n"
"    \n"
"    Argumentos:\n"
"      +N\tMovimenta a pilha de forma que o n-ésimo diretório (a contar\n"
"      \t\tda esquerda da lista mostrada por `dirs', iniciando com zero)\n"
"      \t\testá no topo.\n"
"    \n"
"      -N\tMovimenta a pilha de forma que o n-ésimo diretório (a contar\n"
"      \t\tda direita da lista mostrada por `dirs', iniciando com zero)\n"
"      \t\testá no topo.\n"
"    \n"
"      dir\tAdiciona DIR à pilha de diretórios no topo, fazendo dele o\n"
"      \t\tnovo diretório de trabalho atual.\n"
"    \n"
"     O comando interno `dirs' exibe a pilha de diretórios."

#: builtins/pushd.def:748
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Remove entradas da pilha de diretórios. Com nenhum argumento, remove\n"
"    o diretório do topo da pilha e altera o novo diretório do topo.\n"
"    \n"
"    Opções:\n"
"      -n\tSuprime a alteração normal de diretório ao remover\n"
"      \t\tdiretórios da pilha, de forma que apenas a pilha é manipulada.\n"
"    \n"
"    Argumentos:\n"
"      +N\tRemove a n-ésima entrada a contar da esquerda da lista\n"
"      \t\tmostrada por `dirs', iniciando com zero. Ex.: `popd +0'\n"
"      \t\tremove o primeiro diretório e `popd +1', o segundo.\n"
"    \n"
"      -N\tRemove a n-ésima entrada a contar da direita da lista\n"
"      \t\tmostrada por `dirs', iniciando com zero. Ex.: `popd +0'\n"
"      \t\tremove o último diretório e `popd -1', o penúltimo.\n"
"    \n"
"    O comando interno `dirs' exibe a pilha de diretório."

#: builtins/read.def:308
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: especificação de tempo limite inválida"

#: builtins/read.def:827
#, c-format
msgid "read error: %d: %s"
msgstr "erro de leitura: %d: %s"

#: builtins/return.def:68
msgid "can only `return' from a function or sourced script"
msgstr "possível retornar (`return') apenas de uma função ou script carregado (com `source')"

#: builtins/set.def:869
msgid "cannot simultaneously unset a function and a variable"
msgstr "impossível simultaneamente remover definição de uma função e uma variável"

#: builtins/set.def:969
#, c-format
msgid "%s: not an array variable"
msgstr "%s: não é uma variável array"

#: builtins/setattr.def:189
#, c-format
msgid "%s: not a function"
msgstr "%s: não é uma função"

#: builtins/setattr.def:194
#, c-format
msgid "%s: cannot export"
msgstr "%s: impossível exportar"

#: builtins/shift.def:72 builtins/shift.def:79
msgid "shift count"
msgstr "número de shift"

#: builtins/shopt.def:323
msgid "cannot set and unset shell options simultaneously"
msgstr "impossível simultaneamente definir e remover definição de opções do shell"

#: builtins/shopt.def:444
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: nome de opção de shell inválido"

#: builtins/source.def:128
msgid "filename argument required"
msgstr "requer argumento arquivo"

#: builtins/source.def:154
#, c-format
msgid "%s: file not found"
msgstr "%s: arquivo não encontrado"

#: builtins/suspend.def:102
msgid "cannot suspend"
msgstr "impossível suspender"

#: builtins/suspend.def:112
msgid "cannot suspend a login shell"
msgstr "impossível suspender um shell de login."

#: builtins/type.def:235
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s está apelidada para `%s'\n"

#: builtins/type.def:256
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s é uma palavra-chave do shell\n"

#: builtins/type.def:275
#, c-format
msgid "%s is a function\n"
msgstr "%s é uma função\n"

#: builtins/type.def:299
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s é um comando interno especial do shell\n"

#: builtins/type.def:301
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s é um comando interno do shell\n"

#: builtins/type.def:323 builtins/type.def:408
#, c-format
msgid "%s is %s\n"
msgstr "%s é %s\n"

#: builtins/type.def:343
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s está na tabela hash (%s)\n"

#: builtins/ulimit.def:400
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: argumento limite inválido"

#: builtins/ulimit.def:426
#, c-format
msgid "`%c': bad command"
msgstr "`%c': comando incorreto"

#: builtins/ulimit.def:464
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: impossível obter limite: %s"

#: builtins/ulimit.def:490
msgid "limit"
msgstr "limite"

#: builtins/ulimit.def:502 builtins/ulimit.def:802
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: impossível modificar limite: %s"

#: builtins/umask.def:115
msgid "octal number"
msgstr "número octal"

#: builtins/umask.def:232
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "`%c': operador de modo simbólico inválido"

#: builtins/umask.def:287
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "`%c': caractere de modo simbólico inválido"

#: error.c:89 error.c:373 error.c:375 error.c:377
msgid " line "
msgstr " linha "

#: error.c:164
#, c-format
msgid "last command: %s\n"
msgstr "último comando: %s\n"

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr "Abortando..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:287
#, c-format
msgid "INFORM: "
msgstr "INFORM: "

#: error.c:310
#, c-format
msgid "DEBUG warning: "
msgstr "DEBUG aviso: "

#: error.c:488
msgid "unknown command error"
msgstr "erro de comando desconhecido"

#: error.c:489
msgid "bad command type"
msgstr "tipo de comando incorreto"

#: error.c:490
msgid "bad connector"
msgstr "conector incorreto"

#: error.c:491
msgid "bad jump"
msgstr "desvio incorreto"

#: error.c:529
#, c-format
msgid "%s: unbound variable"
msgstr "%s: variável não associada"

#: eval.c:243
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\atempo limite de espera excedido aguardando entrada: fim automático da sessão\n"

#: execute_cmd.c:555
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "impossível redirecionar a entrada padrão para /dev/null: %s"

#: execute_cmd.c:1317
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: `%c': caractere de formato inválido"

#: execute_cmd.c:2391
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr "execute_coproc: coproc [%d:%s] ainda existe"

#: execute_cmd.c:2524
msgid "pipe error"
msgstr "erro de `pipe'"

#: execute_cmd.c:4923
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: excedido o nível máximo de aninhamento de `eval' (%d)"

#: execute_cmd.c:4935
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: excedido o nível máximo de aninhamento de `function' (%d)"

#: execute_cmd.c:5043
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: excedido o nível máximo de aninhamento de avaliação (%d)"

#: execute_cmd.c:5598
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: restrição: não é permitido especificar `/' em nomes de comandos"

#: execute_cmd.c:5715
#, c-format
msgid "%s: command not found"
msgstr "%s: comando não encontrado"

#: execute_cmd.c:5957
#, c-format
msgid "%s: %s"
msgstr "%s: %s"

#: execute_cmd.c:5975
#, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: impossível: o arquivo requerido não encontrado"

#: execute_cmd.c:6000
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: interpretador incorreto"

#: execute_cmd.c:6037
#, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s: impossível executar o arquivo binário: %s"

#: execute_cmd.c:6123
#, c-format
msgid "`%s': is a special builtin"
msgstr "`%s': é um comando interno especial"

#: execute_cmd.c:6175
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "impossível duplicar fd (descritor de arquivo) %d para fd %d"

#: expr.c:263
msgid "expression recursion level exceeded"
msgstr "excedido o nível de recursividade da expressão"

#: expr.c:291
msgid "recursion stack underflow"
msgstr "esvaziamento de pilha de recursão"

#: expr.c:478
msgid "syntax error in expression"
msgstr "erro de sintaxe na expressão"

#: expr.c:522
msgid "attempted assignment to non-variable"
msgstr "tentativa de atribuição para algo que não é uma variável"

#: expr.c:531
msgid "syntax error in variable assignment"
msgstr "erro de sintaxe na atribuição de variável"

#: expr.c:545 expr.c:912
msgid "division by 0"
msgstr "divisão por 0"

#: expr.c:593
msgid "bug: bad expassign token"
msgstr "erro de programação: token incorreto passado para expassign()"

#: expr.c:647
msgid "`:' expected for conditional expression"
msgstr "esperava `:' para expressão condicional"

#: expr.c:973
msgid "exponent less than 0"
msgstr "exponente menor que 0"

#: expr.c:1030
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "esperava identificador após pré-acréscimo ou pré-decréscimo"

#: expr.c:1057
msgid "missing `)'"
msgstr "faltando `)'"

#: expr.c:1108 expr.c:1492
msgid "syntax error: operand expected"
msgstr "erro de sintaxe: esperava operando"

#: expr.c:1494
msgid "syntax error: invalid arithmetic operator"
msgstr "erro de sintaxe: operador aritmético inválido"

#: expr.c:1518
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (token de erro é \"%s\")"

#: expr.c:1578
msgid "invalid arithmetic base"
msgstr "base aritmética inválida"

#: expr.c:1587
msgid "invalid integer constant"
msgstr "contante inteira inválida"

#: expr.c:1603
msgid "value too great for base"
msgstr "valor muito grande para esta base de numeração"

#: expr.c:1652
#, c-format
msgid "%s: expression error\n"
msgstr "%s: erro de expressão\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: impossível acessar os diretórios pais (anteriores)"

#: input.c:99 subst.c:6208
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "impossível redefinir modo `nodelay' para o descritor de arquivo (fd) %d"

#: input.c:266
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "impossível alocar novo descritor de arquivo (fd) para a entrada do `bash' a partir do fd %d"

#: input.c:274
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: buffer já existe para o novo descritor de arquivo (fd) %d"

#: jobs.c:543
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: `pipe' de pgrp"

#: jobs.c:907
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:960
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:1279
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "identificador de processo (pid) %d bifurcado (fork) aparece no trabalho em execução %d"

#: jobs.c:1397
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "excluindo trabalho parado %d com grupo de processo %ld"

#: jobs.c:1502
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: pid %5ld (%s) marcado como ainda vivo"

#: jobs.c:1839
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: o identificador do processo (pid) não existe"

#: jobs.c:1854
#, c-format
msgid "Signal %d"
msgstr "Sinal %d"

#: jobs.c:1868 jobs.c:1894
msgid "Done"
msgstr "Concluído"

#: jobs.c:1873 siglist.c:123
msgid "Stopped"
msgstr "Parado"

#: jobs.c:1877
#, c-format
msgid "Stopped(%s)"
msgstr "Parado(%s)"

#: jobs.c:1881
msgid "Running"
msgstr "Executando"

#: jobs.c:1898
#, c-format
msgid "Done(%d)"
msgstr "Concluído(%d)"

#: jobs.c:1900
#, c-format
msgid "Exit %d"
msgstr "Fim da execução com status %d"

#: jobs.c:1903
msgid "Unknown status"
msgstr "Status desconhecido"

#: jobs.c:1990
#, c-format
msgid "(core dumped) "
msgstr "(imagem do núcleo gravada)"

#: jobs.c:2009
#, c-format
msgid "  (wd: %s)"
msgstr "  (wd: %s)"

#: jobs.c:2250
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "`setpgid' filho (%ld para %ld)"

#: jobs.c:2608 nojobs.c:666
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: o pid %ld não é um processo filho deste shell"

#: jobs.c:2884
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: Sem registro do processo %ld"

#: jobs.c:3223
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: trabalho %d está parado"

#: jobs.c:3551
#, c-format
msgid "%s: no current jobs"
msgstr "%s: nenhum trabalho atual"

#: jobs.c:3558
#, c-format
msgid "%s: job has terminated"
msgstr "%s: o trabalho terminou"

#: jobs.c:3567
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: o trabalho %d já está em plano de fundo"

#: jobs.c:3793
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld: ativando WNOHANG para evitar bloqueio indefinido"

#: jobs.c:4307
#, c-format
msgid "%s: line %d: "
msgstr "%s, linha %d: "

#: jobs.c:4321 nojobs.c:921
#, c-format
msgid " (core dumped)"
msgstr " (imagem do núcleo gravada)"

#: jobs.c:4333 jobs.c:4346
#, c-format
msgid "(wd now: %s)\n"
msgstr "(wd agora: %s)\n"

#: jobs.c:4378
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp falhou"

#: jobs.c:4434
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: nenhum controle de trabalho em plano de fundo"

#: jobs.c:4450
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: disciplina da linha"

#: jobs.c:4460
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:4481 jobs.c:4490
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "impossível definir grupo do processo do terminal (%d)"

#: jobs.c:4495
msgid "no job control in this shell"
msgstr "nenhum controle de trabalho neste shell"

#: lib/malloc/malloc.c:367
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: asserção falhou: %s\n"

#: lib/malloc/malloc.c:383
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: asserção remendada\r\n"

#: lib/malloc/malloc.c:384 lib/malloc/malloc.c:941
msgid "unknown"
msgstr "desconhecido"

#: lib/malloc/malloc.c:892
msgid "malloc: block on free list clobbered"
msgstr "malloc: bloco socado em lista livre"

#: lib/malloc/malloc.c:980
msgid "free: called with already freed block argument"
msgstr "free: chamado com argumento de bloco já liberado"

#: lib/malloc/malloc.c:983
msgid "free: called with unallocated block argument"
msgstr "free: chamado com argumento de bloco não alocado"

#: lib/malloc/malloc.c:1001
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: esvaziamento de pilha detectado; mh_nbytes fora do limite"

#: lib/malloc/malloc.c:1007
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: esvaziamento de pilha detectado; magic8 corrompido"

#: lib/malloc/malloc.c:1014
msgid "free: start and end chunk sizes differ"
msgstr "free: tamanhos de porções do início e do fim são diferentes"

#: lib/malloc/malloc.c:1176
msgid "realloc: called with unallocated block argument"
msgstr "realloc: chamado com argumento de bloco não alocado"

#: lib/malloc/malloc.c:1191
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: esvaziamento de pilha detectado; mh_nbytes fora do limite"

#: lib/malloc/malloc.c:1197
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: esvaziamento de pilha detectado; magic8 corrompido"

#: lib/malloc/malloc.c:1205
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: tamanhos de porções do início e do fim são diferentes"

#: lib/malloc/table.c:191
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: tabela de `alloc' está cheia com FIND_ALLOC?\n"

#: lib/malloc/table.c:200
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p já na tabela como alocado?\n"

#: lib/malloc/table.c:253
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p já na tabela como livre?\n"

#: lib/sh/fmtulong.c:102
msgid "invalid base"
msgstr "base inválida"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: máquina desconhecida"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: serviço inválido"

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: especificação de caminho de rede inválida"

#: lib/sh/netopen.c:347
msgid "network operations not supported"
msgstr "sem suporte a operações de rede"

#: locale.c:219
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: impossível alterar locale (%s)"

#: locale.c:221
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: impossível alterar locale (%s): %s"

#: locale.c:294
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: impossível alterar locale (%s)"

#: locale.c:296
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: impossível alterar locale (%s): %s"

#: mailcheck.c:439
msgid "You have mail in $_"
msgstr "Você tem mensagem de correio em $_"

#: mailcheck.c:464
msgid "You have new mail in $_"
msgstr "Você tem mensagem nova de correio em $_"

#: mailcheck.c:480
#, c-format
msgid "The mail in %s has been read\n"
msgstr "As mensagens de correio em %s foram lidas\n"

#: make_cmd.c:314
msgid "syntax error: arithmetic expression required"
msgstr "erro de sintaxe: requer expressão aritmética"

#: make_cmd.c:316
msgid "syntax error: `;' unexpected"
msgstr "erro de sintaxe: `;' inesperado"

#: make_cmd.c:317
#, c-format
msgid "syntax error: `((%s))'"
msgstr "erro de sintaxe: `((%s))'"

#: make_cmd.c:569
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: tipo da instrução incorreto %d"

#: make_cmd.c:668
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "here-document na linha %d delimitado pelo fim do arquivo (desejava `%s')"

#: make_cmd.c:769
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: instrução de redirecionamento `%d' fora do limite"

#: parse.y:2428
#, c-format
msgid "shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line truncated"
msgstr "shell_getc: shell_input_line_size (%zu) excede SIZE_MAX (%lu): linha truncada"

#: parse.y:2921
msgid "maximum here-document count exceeded"
msgstr "excedido o número máximo de here-document"

#: parse.y:3684 parse.y:4244 parse.y:6148
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "encontrado EOF inesperado enquanto procurava por `%c' correspondente"

#: parse.y:4452
msgid "unexpected EOF while looking for `]]'"
msgstr "encontrado EOF inesperado enquanto procurava por `]]'"

#: parse.y:4457
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "erro de sintaxe na expressão condicional: token inesperado `%s'"

#: parse.y:4461
msgid "syntax error in conditional expression"
msgstr "erro de sintaxe na expressão condicional"

#: parse.y:4539
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "token inesperado `%s', esperava`)'"

#: parse.y:4543
msgid "expected `)'"
msgstr "esperava `)'"

#: parse.y:4571
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "argumento inesperado `%s' para operador unário condicional"

#: parse.y:4575
msgid "unexpected argument to conditional unary operator"
msgstr "argumento inesperado para operador unário condicional"

#: parse.y:4621
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "token inesperado `%s', esperava operador binário condicional"

#: parse.y:4625
msgid "conditional binary operator expected"
msgstr "esperava operador binário condicional"

#: parse.y:4647
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "argumento inesperado `%s' para operador binário condicional"

#: parse.y:4651
msgid "unexpected argument to conditional binary operator"
msgstr "argumento inesperado para operador binário condicional"

#: parse.y:4662
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "token inesperado `%c' em comando condicional"

#: parse.y:4665
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "token inesperado `%s' em comando condicional"

#: parse.y:4669
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "token inesperado %d em comando condicional"

#: parse.y:6118
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "erro de sintaxe próximo ao token inesperado `%s'"

#: parse.y:6137
#, c-format
msgid "syntax error near `%s'"
msgstr "erro de sintaxe próximo a `%s'"

#: parse.y:6151
msgid "syntax error: unexpected end of file"
msgstr "erro de sintaxe: fim prematuro do arquivo"

#: parse.y:6151
msgid "syntax error"
msgstr "erro de sintaxe"

#: parse.y:6216
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Use \"%s\" para sair do shell.\n"

#: parse.y:6394
msgid "unexpected EOF while looking for matching `)'"
msgstr "encontrado EOF inesperado enquanto procurava por `)' correspondente"

#: pcomplete.c:1132
#, c-format
msgid "completion: function `%s' not found"
msgstr "completion: função `%s' não encontrada"

#: pcomplete.c:1722
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr "programmable_completion: %s: possível loop de nova tentativa"

# COMPSPEC é variável no código fonte, manter sem tradução para português.
#: pcomplib.c:182
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: COMPSPEC NULO"

#: print_cmd.c:302
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: conector incorreto `%d'"

#: print_cmd.c:375
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: descritor de arquivo inválido"

#: print_cmd.c:380
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: ponteiro de arquivo NULO"

#: print_cmd.c:384
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != fileno xtrace fp (%d)"

#: print_cmd.c:1545
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: `%c': caractere de formato inválido"

#: redir.c:150 redir.c:198
msgid "file descriptor out of range"
msgstr "descritor de arquivo fora dos limites"

#: redir.c:205
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: redirecionamento ambíguo"

#: redir.c:209
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: impossível sobrescrever arquivo existente"

#: redir.c:214
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: restrição: impossível redirecionar saída"

#: redir.c:219
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "impossível criar arquivo temporário para here-document: %s"

#: redir.c:223
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: impossível atribuir fd a variável"

#: redir.c:650
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "sem suporte a /dev/(tcp|udp)/máquina/porta sem rede"

#: redir.c:945 redir.c:1065 redir.c:1130 redir.c:1303
msgid "redirection error: cannot duplicate fd"
msgstr "erro de redirecionamento: impossível duplicar fd"

#: shell.c:353
msgid "could not find /tmp, please create!"
msgstr "impossível localizar /tmp, por favor crie!"

#: shell.c:357
msgid "/tmp must be a valid directory name"
msgstr "/tmp deve ser um nome de diretório válido"

#: shell.c:826
msgid "pretty-printing mode ignored in interactive shells"
msgstr "modo de impressão bonita ignorada em shells interativos"

#: shell.c:972
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: opção inválida"

#: shell.c:1343
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "impossível definir uid para %d: uid efetivo %d"

#: shell.c:1354
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "impossível definir gid para %d: gid efetivo %d"

#: shell.c:1544
msgid "cannot start debugger; debugging mode disabled"
msgstr "possível iniciar o depurador; modo de depuração desabilitado"

#: shell.c:1658
#, c-format
msgid "%s: Is a directory"
msgstr "%s: É um diretório"

#: shell.c:1907
msgid "I have no name!"
msgstr "Eu não tenho nome!"

#: shell.c:2061
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, versão %s-(%s)\n"

#: shell.c:2062
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Utilização:\t%s [opção-longa-GNU] [opção] ...\n"
"\t%s [opção-longa-GNU] [opção] arquivo-de-script ...\n"

#: shell.c:2064
msgid "GNU long options:\n"
msgstr "opções-longas-GNU:\n"

#: shell.c:2068
msgid "Shell options:\n"
msgstr "Opções do shell:\n"

#: shell.c:2069
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-ilrsD or -c comando ou -O opção-shopt\t\t(somente para chamada)\n"

#: shell.c:2088
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s ou -o opção\n"

#: shell.c:2094
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "Digite `%s -c \"help set\"' para mais informações sobre as opções do shell.\n"

#: shell.c:2095
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "Digite `%s -c help' para mais informações sobre os comandos internos do shell.\n"

#: shell.c:2096
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Uso o comando `bashbug' para relatar erros.\n"

#: shell.c:2098
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "página do bash: <http://www.gnu.org/software/bash>\n"

#: shell.c:2099
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Ajuda geral sobre uso de software GNU: <http://www.gnu.org/gethelp/>\n"

#: sig.c:765
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: operação inválida"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Sinal falso"

#: siglist.c:51
msgid "Hangup"
msgstr "Hangup"

#: siglist.c:55
msgid "Interrupt"
msgstr "Interromper"

#: siglist.c:59
msgid "Quit"
msgstr "Sair"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Instrução ilegal"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "BPT Rastreamento/Captura (BPT trace/trap)"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Instrução ABORT"

#: siglist.c:79
msgid "EMT instruction"
msgstr "Instrução EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Exceção de ponto flutuante"

#: siglist.c:87
msgid "Killed"
msgstr "Morto (Killed)"

#: siglist.c:91
msgid "Bus error"
msgstr "Erro do barramento"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Falha de segmentação"

#: siglist.c:99
msgid "Bad system call"
msgstr "Chamada incorreta do sistema"

#: siglist.c:103
msgid "Broken pipe"
msgstr "`Pipe' partido (escrita sem leitura)"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Relógio de alarme"

#: siglist.c:111
msgid "Terminated"
msgstr "Terminado"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Condição urgente de Entrada/Saída"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Parado (sinal)"

#: siglist.c:127
msgid "Continue"
msgstr "Continuar"

#: siglist.c:135
msgid "Child death or stop"
msgstr "Processo filho parado ou terminado"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Parado (entrada tty)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Parado (saída tty)"

#: siglist.c:147
msgid "I/O ready"
msgstr "Entrada/Saída pronta"

#: siglist.c:151
msgid "CPU limit"
msgstr "Tempo limite de CPU excedido"

#: siglist.c:155
msgid "File limit"
msgstr "Tamanho limite do arquivo excedido"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Alarme (virtual)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Alarme (perfil)"

#: siglist.c:167
msgid "Window changed"
msgstr "Janela mudada"

#: siglist.c:171
msgid "Record lock"
msgstr "Registro bloqueado (lock)"

#: siglist.c:175
msgid "User signal 1"
msgstr "Sinal 1 definido pelo usuário"

#: siglist.c:179
msgid "User signal 2"
msgstr "Sinal 2 definido pelo usuário"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "entrada de dados HFT pendente"

#: siglist.c:187
msgid "power failure imminent"
msgstr "falha iminente de energia"

#: siglist.c:191
msgid "system crash imminent"
msgstr "falha iminente do sistema"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "migrar o processo para outra CPU"

#: siglist.c:199
msgid "programming error"
msgstr "erro de programação"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "modo monitor HFT autorizado"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "modo monitor HFT rescindido"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "a sequência de som HFT foi completada"

#: siglist.c:215
msgid "Information request"
msgstr "Requisição de informação"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Sinal desconhecido #%d"

#: subst.c:1480 subst.c:1670
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "substituição incorreta: sem `%s' de fechamento em %s"

#: subst.c:3307
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: impossível atribuir uma lista a um membro de um array"

#: subst.c:6048 subst.c:6064
msgid "cannot make pipe for process substitution"
msgstr "impossível criar `pipe' para a substituição do processo"

#: subst.c:6124
msgid "cannot make child for process substitution"
msgstr "impossível criar um processo filho para a substituição do processo"

#: subst.c:6198
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "impossível abrir `pipe' %s para leitura"

#: subst.c:6200
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "impossível abrir `pipe' %s para escrita"

#: subst.c:6223
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "impossível duplicar `pipe' %s como descritor de arquivo (fd) %d"

#: subst.c:6370
msgid "command substitution: ignored null byte in input"
msgstr "substituição de comando: byte nulo ignorado na entrada"

#: subst.c:6533
msgid "cannot make pipe for command substitution"
msgstr "impossível criar um `pipe' para substituição do comando"

#: subst.c:6580
msgid "cannot make child for command substitution"
msgstr "impossível criar um processo filho para substituição do comando"

#: subst.c:6613
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: impossível duplicar o `pipe' como descritor de arquivo (fd) 1"

#: subst.c:7082 subst.c:10252
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: nome de variável inválido para referência de nome"

#: subst.c:7178 subst.c:7196 subst.c:7369
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: expansão indireta inválida"

#: subst.c:7212 subst.c:7377
#, c-format
msgid "%s: invalid variable name"
msgstr "%s: nome de variável inválido"

#: subst.c:7478
#, c-format
msgid "%s: parameter not set"
msgstr "%s: parâmetro não inicializado"

#: subst.c:7480
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: parâmetro nulo ou não inicializado"

#: subst.c:7727 subst.c:7742
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: expressão de substring < 0"

#: subst.c:9560 subst.c:9587
#, c-format
msgid "%s: bad substitution"
msgstr "%s: substituição incorreta"

#: subst.c:9678
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: impossível atribuir desta maneira"

#: subst.c:10111
msgid "future versions of the shell will force evaluation as an arithmetic substitution"
msgstr "versões futuras do shell vão forçar avaliação como um substituto aritmético"

#: subst.c:10795
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "substituição incorreta: sem \"`\" de fechamento em %s"

#: subst.c:11874
#, c-format
msgid "no match: %s"
msgstr "sem correspondência: %s"

#: test.c:147
msgid "argument expected"
msgstr "esperava argumento"

#: test.c:156
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: esperava expressão de número inteiro"

#: test.c:265
msgid "`)' expected"
msgstr "esperava `)'"

#: test.c:267
#, c-format
msgid "`)' expected, found %s"
msgstr "esperava `)', encontrado %s"

#: test.c:469 test.c:814
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: esperava operador binário"

#: test.c:771 test.c:774
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: esperava operador unário"

#: test.c:896
msgid "missing `]'"
msgstr "faltando `]'"

#: test.c:914
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "erro de sintaxe: `%s' inesperado"

#: trap.c:220
msgid "invalid signal number"
msgstr "número de sinal inválido"

#: trap.c:323
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "manipulador de trap: excedido o nível máximo de manipulador de captura (%d)"

#: trap.c:412
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: valor incorreto em trap_list[%d]: %p"

#: trap.c:416
#, c-format
msgid "run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr "run_pending_traps: manipulador de sinal é SIG_DFL, enviando novamente %d (%s) para mim mesmo"

#: trap.c:509
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: sinal incorreto %d"

#: variables.c:424
#, c-format
msgid "error importing function definition for `%s'"
msgstr "erro ao importar a definição da função para `%s'"

#: variables.c:838
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "nível do shell (%d) muito grande, redefinindo para 1"

#: variables.c:2642
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: nenhum contexto de função no atual escopo"

#: variables.c:2661
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: a variável pode não ter um valor atribuído"

#: variables.c:2818 variables.c:2874
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr "%s: impossível herdar valor de tipo incompatível"

#: variables.c:3459
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: atribuindo inteiro para referência de nome"

#: variables.c:4390
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: nenhum contexto de função no escopo atual"

#: variables.c:4757
#, c-format
msgid "%s has null exportstr"
msgstr "%s possui a string de exportação nula"

# exportstr é uma variável no código fonte do bash (arquivo variiables.c)
#: variables.c:4762 variables.c:4771
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "caractere inválido na %d na exportstr para %s"

# exportstr é uma variável no código fonte do bash (arquivo variiables.c)
#: variables.c:4777
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "Sem `=' na exportstr para %s"

#: variables.c:5317
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: cabeça de shell_variables não é um contexto de função"

#: variables.c:5330
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: nenhum contexto em no global_variables"

#: variables.c:5410
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: cabeça de shell_variables não é um escopo de ambiente temporário"

#: variables.c:6400
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: impossível abrir como ARQUIVO"

#: variables.c:6405
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: valor inválido para rastrear descritor de arquivo"

#: variables.c:6450
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: valor de compatibilidade fora dos limites"

#: version.c:46 version2.c:46
msgid "Copyright (C) 2022 Free Software Foundation, Inc."
msgstr "Copyright (C) 2022 Free Software Foundation, Inc."

#: version.c:47 version2.c:47
msgid "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
msgstr "Licença GPLv3+: GNU GPL versão 3 ou posterior <http://gnu.org/licenses/gpl.html>.\n"

#: version.c:86 version2.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, versão %s (%s)\n"

#: version.c:91 version2.c:91
msgid "This is free software; you are free to change and redistribute it."
msgstr "Este é um software livre; você é livre para alterar e redistribuí-lo."

#: version.c:92 version2.c:92
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "Há NENHUMA GARANTIA, na extensão permitida pela lei."

#: xmalloc.c:93
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: impossível alocar %lu bytes (%lu bytes alocados)"

#: xmalloc.c:95
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: impossível alocar %lu bytes"

#: xmalloc.c:165
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: impossível alocar %lu bytes (%lu bytes alocados)"

#: xmalloc.c:167
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: impossível alocar %lu bytes"

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [nome[=valor] ... ]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] nome [nome ...]"

#: builtins.c:53
msgid "bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr "bind [-lpsvPSVX] [-m mapa-teclas] [-f arquivo] [-q nome] [-u nome] [-r seq-teclas]  [-x seq-teclas:comando-shell] [seq-teclas:função-de-readline ou comando-readline]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [COMANDO-INTERNO-SHELL [ARG ...]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [EXPR]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]] [-@]] [dir]"
msgstr "cd [-L|[-P [-e]] [-@]] [DIR]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] COMANDO [ARG ...]"

#: builtins.c:78
msgid "declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] [name ...]"
msgstr "declare [-aAfFgiIlnrtux] [NOME[=VALOR] ...] ou declare -p [-aAfFilnrtux] [NOME ...]"

#: builtins.c:80
msgid "typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] [name ...]"
msgstr "typeset [-aAfFgiIlnrtux] nome[=valor] ... ou typeset -p [-aAfFilnrtux] [nome ...]"

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [OPÇÃO] NOME[=VALOR] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [ARG ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [ARG ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-DnPs] [-f ARQUIVO] [NOME ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [ARG ...]"

#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts optstring nome [arg ...]"

#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a nome] [comando [argumento ...]] [redirecionamento ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e EDITOR] [-lnr] [PRIMEIRO] [ÚLTIMO] ou fc -s [ANTIGO=NOVO] [COMANDO]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [ESPEC-JOB]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [ESPEC-JOB ...]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p CAMINHO] [-dt] [NOME ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [PADRÃO ...]"

#: builtins.c:123
msgid "history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]"
msgstr "history [-c] [-d POSIÇÃO] [n] ou history -anrw [ARQUIVO] ou history -ps ARG [ARG...]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [ESPEC-JOB ...] ou jobs -x COMANDO [ARGS]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [ESPEC-JOB ... | pid ...]"

#: builtins.c:134
msgid "kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]"
msgstr "kill [-s SIGSPEC | -n SIGNUM | -SIGSPEC] PID | ESPEC-JOB ... ou kill -l [SIGSPEC]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let ARG [ARG ...]"

#: builtins.c:138
msgid "read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]"
msgstr "read [-ers] [-a ARRAY] [-d DELIM] [-i TEXTO] [-n NCHARS] [-N NCHARS] [-p CONFIRMAR ] [-t TEMPO] [-u FD] [NOME ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCEHPT] [-o OPÇÃO-NOME] [--] [-] [arg ...]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [NOME ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [NOME[=VALOR] ...] ou export -p"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [NOME[=VALOR] ...] ou readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source filename [arguments]"
msgstr "source arquivo [argumentos]"

#: builtins.c:154
msgid ". filename [arguments]"
msgstr ". arquivo [argumentos]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [expr]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ arg... ]"

#: builtins.c:166
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[arg] espec-sinal ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-apt] nome [nome ...]"

#: builtins.c:171
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limite]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [modo]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p var] [id ...]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [PID ...]"

#: builtins.c:184
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NOME [in PALAVRAs ...] ; do COMANDOS; done"

#: builtins.c:186
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( exp1; exp2; exp3 )); do COMANDOS; done"

#: builtins.c:188
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NOME [in PALAVRAS ... ;] do COMANDOS; done"

#: builtins.c:190
msgid "time [-p] pipeline"
msgstr "time [-p] linha-comandos"

#: builtins.c:192
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case PALAVRA in [PADRÃO [| PADRÃO]...) COMANDOS ;;]... esac"

#: builtins.c:194
msgid "if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi"
msgstr "if COMANDOS; then COMANDOS; [ elif COMANDOS; then COMANDOS; ]... [ else COMANDOS; ] fi"

#: builtins.c:196
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while COMANDOS; do COMANDOS-2; done"

#: builtins.c:198
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until COMANDOS; do COMANDOS-2; done"

#: builtins.c:200
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [NOME] comando [redirecionamentos]"

#: builtins.c:202
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function NOME { COMANDOS ; } ou NOME () { COMANDOS ; }"

#: builtins.c:204
msgid "{ COMMANDS ; }"
msgstr "{ COMANDOS ; }"

#: builtins.c:206
msgid "job_spec [&]"
msgstr "escpec-job [&]"

#: builtins.c:208
msgid "(( expression ))"
msgstr "(( expressão ))"

#: builtins.c:210
msgid "[[ expression ]]"
msgstr "[[ expressão ]]"

# Não traduzir "variables", esta é uma opção "builtin" do "bash" que é exibida ao executar "help" e acessível com "help variables".
#: builtins.c:212
msgid "variables - Names and meanings of some shell variables"
msgstr "variables - Nomes e significados de algumas variáveis do shell"

#: builtins.c:215
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | dir]"

#: builtins.c:219
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:223
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:226
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [nome-opção ...]"

#: builtins.c:228
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] formato [argumentos]"

#: builtins.c:231
msgid "complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]"
msgstr "complete [-abcdefgjksuv] [-pr] [-DEI] [-o opção] [-A ação] [-G global] [-W lista-palavras]  [-F função] [-C comando] [-X filtro] [-P prefixo] [-S sufixo] [nome ...]"

#: builtins.c:235
msgid "compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr "compgen [-abcdefgjksuv] [-o opção] [-A ação] [-G global] [-W lista-palavras]  [-F função] [-C comando] [-X filtro] [-P prefixo] [-S sufixo] [palavra]"

#: builtins.c:239
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o opção] [-DEI] [nome ...]"

#: builtins.c:242
msgid "mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "mapfile [-d delim] [-n número] [-O origem] [-s número] [-t] [-u fd] [-C chamada] [-c quantidade] [array]"

#: builtins.c:244
msgid "readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "readarray [-d delim] [-n número] [-O origem] [-s número] [-t] [-u fd] [-C chamada] [-c quantidade] [array]"

# help alias
#: builtins.c:256
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has been\n"
"    defined."
msgstr ""
"Define ou exibe apelidos (aliases).\n"
"    \n"
"    Sem argumentos, `alias' mostra a lista de apelidos no formato usável\n"
"    `alias NOME=VALOR' na saída padrão.\n"
"    \n"
"    Do contrário, um apelido é definido para cada NOME cujo VALOR é dado.\n"
"    Um espaço ao final em VALOR resulta na próxima palavra ser verificada\n"
"    por substituição de apelido quando o apelido for expandido.\n"
"    \n"
"    Opções:\n"
"      -p\tmostra todos os apelidos definidos em uma formato usável\n"
"    \n"
"    Status de saída:\n"
"    `alias' retorna verdadeiro, a menos que seja fornecido um NOME para\n"
"    o qual não se tenha definido um apelido"

# help unalias
#: builtins.c:278
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Remove cada NOME da lista de apelidos definidos.\n"
"    \n"
"    Opções:\n"
"      -a\tremove todas as definições de apelidos\n"
"    \n"
"    Retorna sucesso, a menos que NOME não seja um apelido existente."

# help bind
#: builtins.c:291
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their values\n"
"      -s                 List key sequences that invoke macros and their values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Define variáveis e associações de teclas para Readline.\n"
"    \n"
"    Associa uma sequência de teclas para uma função Readline ou uma macro\n"
"    ou define uma variável de Readline. A sintaxe de argumento sem opção é\n"
"    equivalente àquela encontrada em ~/.inputrc, mas deve ser passada como\n"
"    um argumento singular.\n"
"    \n"
"    Opções:\n"
"      -m  mapa-teclas    Usa MAPA-TECLAS como mapa de teclas para a duração\n"
"                         deste comando. Nomes de mapa de teclas aceitáveis\n"
"                         são emacs, emacs-standard, emacs-meta, emacs-ctlx,\n"
"                         vi, vi-move, vi-command e vi-insert.\n"
"      -l                 Lista nomes de funções.\n"
"      -P                 Lista nomes e associações de função.\n"
"      -p                 Lista funções e associações em uma forma que pode ser\n"
"                         usada como entrada.\n"
"      -S                 Lista sequências de teclas que chamam macros e seus\n"
"                         valores\n"
"      -s                 Lista sequências de teclas que chamam macros e seus\n"
"                         valores em uma forma que pode ser usada como entrada.\n"
"      -V                 Lista nomes e valores de variáveis\n"
"      -v                 Lista nomes e valores de variáveis em uma forma que\n"
"                         pode ser usada como entrada.\n"
"      -q  nome-função    Consulta sobre quais teclas chamam a função informada.\n"
"      -u  nome-função    Desassocia todas teclas que estão associadas à função\n"
"                         informada.\n"
"      -r  seq-teclas     Remove a associação para SEQ-TECLAS.\n"
"      -f  arquivo        Lê associações de tecla de ARQUIVO.\n"
"      -x  seq-teclas:comando-shell\n"
"                         Faz com que COMANDO-SHELL seja executado ao inserir\n"
"                         SEQ-TECLAS.\n"
"      -X                 Lista sequência de teclas associadas com -x e comandos\n"
"                         associados em uma forma que pode ser usada como\n"
"                         entrada.\n"
"    \n"
"    Status de saída:\n"
"    `bind' retorna 0 a mesmo que uma opção desconhecida seja fornecida ou\n"
"    um erro ocorrer."

# help break
#: builtins.c:330
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Sai de loops de for, while ou until.\n"
"    \n"
"    Sai de um loop de FOR, WHILE ou UNTIL. Se N for especificado, quebra N \n"
"    blocos de declaração de loops.\n"
"    \n"
"    Status de saída:\n"
"    O status de saída é 0, a menos que N não seja maior ou igual a 1."

# help continue
#: builtins.c:342
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Resume loops de for, while ou until.\n"
"    \n"
"    Resume a próxima iteração do bloco de declaração de loop de FOR, WHILE\n"
"    ou UNTIL.\n"
"    Se N for especificado, resume o N-ésimo bloco de declaração de loop.\n"
"    \n"
"    Status de saída:\n"
"    O status de saída é 0, a menos que N não seja maior ou igual a 1."

# help builtin
#: builtins.c:354
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Executa comandos internos (builtin) do shell.\n"
"    \n"
"    Executa COMANDO-INTERNO-SHELL com argumentos ARGs sem realizar procura\n"
"    por comandos. Isso é útil quando você deseja reimplementar um comando\n"
"    interno como uma função shell, mas precisa executar o comando interno\n"
"    dentro de uma função.\n"
"    \n"
"    Status de saída:\n"
"    Retorna o status de saída de COMANDO-INTERNO-SHELL ou falso, se\n"
"    COMANDO-INTERNO-SHELL não for de fato um comando interno de shell."

# help caller
#: builtins.c:369
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Retorna o contexto da chamada de sub-rotina atual.\n"
"    \n"
"    Sem EXPR, retorna \"$linha $arquivo\".  Com EXPR, retorna\n"
"    \"$linha $sub-rotina $arquivo\"; essa informação extra pode ser usada para\n"
"    fornecer um rastro da pilha.\n"
"    \n"
"    O valor de EXPR indica quantos quadros de chamada deve voltar antes do\n"
"    atual; o quadro do topo é o quadro 0.\n"
"    \n"
"    Status de saída:\n"
"    Retorna 0, a menos que o shell não esteja executando uma função de\n"
"    shell ou EXPR seja inválida."

# help cd
#: builtins.c:387
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n"
"    A null directory name is the same as the current directory.  If DIR begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is set,\n"
"    the word is assumed to be  a variable name.  If that variable has a value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Altera o diretório de trabalho do shell.\n"
"    \n"
"    Altera o diretório atual para DIR, sendo o padrão de DIR o mesmo valor\n"
"    da variável HOME.\n"
"    \n"
"    A variável CDPATH define o caminho de pesquisa para o diretório contendo\n"
"    DIR. Nomes de diretórios alternativos em CDPATH são separados por\n"
"    dois-pontos (:). Um nome de diretório nulo é o mesmo que o diretório\n"
"    atual. Se DIR inicia com uma barra (/), então CDPATH não é usada.\n"
"    \n"
"    Se o diretório não for encontrado e a opção `cdable_vars` estiver definida\n"
"    no shell, a palavra é presumida como sendo o nome de uma variável. Se\n"
"    tal variável possuir um valor, este valor é usado para DIR.\n"
"    \n"
"    Opções:\n"
"      -L\tforça links simbólicos a serem seguidos: resolver links simbólicos\n"
"      \t\tem DIR após processar instâncias de `..'\n"
"      -P\tusa a estrutura do diretório físico sem seguir links\n"
"    \t\tsimbólicos: resolve links simbólicos em DIR antes de processar\n"
"    \t\tinstâncias de `..'\n"
"      -e\tse a opção -P for fornecida e o diretório de trabalho atual não\n"
"    \t\tpuder ser determinado com sucesso, sai com um status não-zero\n"
"      -@\tem sistemas nos quais haja suporte, apresenta um arquivo com\n"
"    \t\tatributos estendidos como um diretório contendo os atributos de\n"
"    \t\tarquivo\n"
"    \n"
"    O padrão é seguir links simbólicos, como se `-L' tivesse sido especificada.\n"
"    `..' é processada removendo o componente de caminho imediatamente anterior\n"
"    de volta para uma barra ou para o início de DIR.\n"
"    \n"
"    Status de saída:\n"
"    Retorna 0, se o diretório tiver sido alterado e se $PWD está definida com\n"
"    sucesso quando a opção -P for usada; do contrário, retorna não-zero."

# help pwd
#: builtins.c:425
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Mostra o nome do diretório de trabalho atual.\n"
"    \n"
"    Opções:\n"
"      -L\tmostra o valor de $PWD se ele tiver o nome do diretório de\n"
"      \t\ttrabalho atual\n"
"      -P\tmostra o diretório físico, sem quaisquer links simbólicos\n"
"    \n"
"    Por padrão, `pwd' se comporta como se a opção `-L' foi especificada.\n"
"    \n"
"    Status de saída:\n"
"    Retorna 0, a menos que uma opção inválida seja fornecida ou o diretório\n"
"    atual não possa ser lido."

# help :
#: builtins.c:442
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Comando nulo.\n"
"    \n"
"    Nenhum efeito; o comando não faz nada.\n"
"    \n"
"    Status de saída:\n"
"    Sempre com sucesso."

# help true
#: builtins.c:453
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Retorna um resultado de sucesso.\n"
"    \n"
"    Status de saída:\n"
"    Sempre sucesso."

# help false
#: builtins.c:462
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Retorna um resultado de insucesso.\n"
"    \n"
"    Status de saída:\n"
"    Sempre falha."

# help command
#: builtins.c:471
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a description of COMMAND similar to the `type' builtin\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Executa um comando simples ou exibe informação sobre comandos.\n"
"    \n"
"    Executa COMANDO com ARG suprimindo a procura por função do shell ou\n"
"    exibe informação sobre os COMANDOs especificados. Pode ser usado para\n"
"    chamar comandos no disco quando um função com o mesmo nome existe.\n"
"    \n"
"    Opções:\n"
"      -p\tusa um valor padrão como variável PATH no qual garantidamente\n"
"      \t\tse encontram todas os utilitários padrão\n"
"      -v\tmostra uma descrição de COMANDO similar ao comando `type'\n"
"      -V\tmostra uma descrição detalhada (verboso) para cada COMANDO\n"
"    \n"
"    Status de saída:\n"
"    Retorna status de saída de COMANDO ou falha, se COMANDO não for \n"
"    encontrado."

# help declare
#: builtins.c:490
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the `local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Define valores e atributos de variável.\n"
"    \n"
"    Declara variáveis e a elas fornece atributos. Se nenhum NOME for fornecido,\n"
"    exibe os atributos e valores de todas as variáveis.\n"
"    \n"
"    Opções:\n"
"      -f\trestringe ação ou exibição dos nomes e definições de funções\n"
"      -F\trestringe exibição a nomes de função apenas (mais número de linha\n"
"      \t\te arquivo fonte, na depuração)\n"
"      -g\tcria variáveis globais quando usado em uma função do shell;\n"
"      \t\tdo contrário, ignorado\n"
"      -p\texibe os atributos e valores de cada NOME\n"
"    \n"
"    Opções que definem atributos:\n"
"      -a\tpara fazer NOMEs serem arrrays indexados (se houver suporte)\n"
"      -A\tpara fazer NOMEs serem arrrays associativos (se houver suporte)\n"
"      -i\tpara fazer NOMEs terem o atributo `integer'\n"
"      -l\tpara converter o valor de cada NOME para minúsculo em sua atribuição\n"
"      -n\tfazer de NOME uma referência à variável chamada por seu valor\n"
"      -r\tpara fazer de NOMEs somente leitura\n"
"      -t\tpara fazer NOMEs terem o atributo `trace'\n"
"      -u\tpara converter o valor de cada NOME para maiúsculo em sua atribuição\n"
"      -x\tpra fazer NOMEs exportar\n"
"    \n"
"    Usar `+' ao invés de `-' desliga o atributo dado.\n"
"    \n"
"    Variáveis com o atributo `integer' têm sua avaliação aritmética (veja o\n"
"    comando `let') realizada quando é atribuído um valor à variável.\n"
"    \n"
"    Quando usado em uma função, `declare' torna NOMEs local, da mesma forma\n"
"    que o comando `local'. A opção `-g' suprime este comportamento.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida tenha sido fornecida ou\n"
"    ocorrer um erro de atribuição de variável."

#: builtins.c:532
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Define valores e atributos de variável.\n"
"    \n"
"    Um sinônimo para `declare'. Veja `help declare'."

# help local
#: builtins.c:540
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Define variáveis locais.\n"
"    \n"
"    Cria uma variável local chamada NOME e lhe dá VALOR. OPÇÃO pode ser\n"
"    qualquer opção aceita pelo `declare'.\n"
"    \n"
"    Variáveis locais podem ser usadas apenas em uma função; elas são visíveis\n"
"    apenas para a função na qual elas foram definidas, bem como para seus\n"
"    filhos.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida seja fornecida, ocorrer\n"
"    um erro de atribuição de uma variável ou o shell não estiver executando\n"
"    uma função."

# help echo
#: builtins.c:557
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Escreve argumentos para a saída padrão.\n"
"    \n"
"    Exibe os ARGs, separados por um único caractere de espaço e seguido\n"
"    por uma nova linha, na saída padrão.\n"
"    \n"
"    Opções:\n"
"      -n\tnão anexa uma nova linha\n"
"      -e\thabilita interpretação de escapes de contrabarra a seguir\n"
"      -E\texplicitação suprime interpretação de escapes de contrabarra\n"
"    \n"
"    `echo' interpreta os caracteres escapados por contrabarra:\n"
"      \\a\talerta (bipe)\n"
"      \\b\tbackspace\n"
"      \\c\tsuprime futuras saídas\n"
"      \\e\tcaractere de escape\n"
"      \\E\tcaractere de escape\n"
"      \\f\talimentação de formulário (form feed)\n"
"      \\n\tnova linha\n"
"      \\r\tretorno de carro (carrier return)\n"
"      \\t\tTAB horizontal\n"
"      \\v\tTAB vertical\n"
"      \\\\\tcontrabarra\n"
"      \\0nnn\to caractere cujo código ASCII é NNN (octal).  NNN pode\n"
"      \t\tter 0 a 3 dígitos octais\n"
"      \\xHH\to caractere de 8 bits cujo valor é HH (hexadecimal).  HH\n"
"      \t\tpode ter um ou dois dígitos hexa\n"
"      \\uHHHH\to caractere Unicode cujo valor é o valor hexadecimal HHHH.\n"
"    \t\tHHHH pode ter um a quatro dígitos hexa.\n"
"      \\UHHHHHHHH o caractere Unicode cujo valor é o valor hexadecimal\n"
"    \t\tHHHHHHHH. HHHHHHHH pode ter um a oito dígitos hexa.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que ocorra um erro de escrita."

# help echo
#: builtins.c:597
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Escreve argumentos para a saída padrão.\n"
"    \n"
"    Exibe os ARGs na saída padrão seguido por uma nova linha.\n"
"    \n"
"    Opções:\n"
"      -n\tnão anexa uma nova linha\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que ocorra um erro de escrita."

# help enable
#: builtins.c:612
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Habilita e desabilita comandos internos do shell.\n"
"    \n"
"    Habilita e desabilita comandos internos do shell. Desabilitar\n"
"    permite que você executa um comando do disco que possui o mesmo\n"
"    nome que um outro comando interno sem usar um caminho completo.\n"
"    \n"
"    Opções:\n"
"      -a\tmostra uma lista de comandos internos mostrando se cada\n"
"      \t\tum está habilitado\n"
"      -n\tdesabilita cada NOME ou exibe uma lista de comandos\n"
"      \t\tinternos desabilitados\n"
"      -p\texibe a lista de comandos internos em um formato usável\n"
"      -s\texibe apenas nomes dos comandos internos 'especial' Posix\n"
"    \n"
"    Opções de controle de carregamento dinâmico:\n"
"      -f\tcarrega comando interno NOME do objeto compartilhado ARQUIVO\n"
"      -d\tremove um comando interno carregado com -f\n"
"    \n"
"    Não sendo informado uma opção, cada NOME é habilitado.\n"
"    \n"
"    Para usar o `test' encontrado em $PATH, ao invés da versão de comando\n"
"    interno do shell, digite `enable -n test'.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que NOME não seja um comando interno de shell\n"
"    ou ocorrer um erro."

# help eval
#: builtins.c:640
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Executa argumentos como um comando de shell.\n"
"    \n"
"    Combina ARGs em uma única string, usa o resultado como entrada para o\n"
"    shell, e executa os comandos resultantes.\n"
"    \n"
"    Status de saída:\n"
"    Retorna status de saída do comando ou sucesso, se o comando for nulo."

# help getopts
#: builtins.c:652
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Analisa argumentos de opções.\n"
"    \n"
"    Getopts é usado pelos procedimentos do shell para analisar parâmetros\n"
"    posicionais como opções.\n"
"    \n"
"    OPÇÕES é uma string que contém as letras de opções a ser reconhecidas;\n"
"    se uma letra é seguida por dois-pontos, é esperado que a opção tenha\n"
"    um argumento, o que deveria ser separado dela por um espaço em branco.\n"
"    \n"
"    A cada vez que ele é chamado, getopts coloca a próxima opção\n"
"    na variável shell $NOME, inicializando NOME se ela não existir,\n"
"    e o índice do próximo argumento a ser processado para dentro da\n"
"    variável OPTIND. OPTIND é inicializado para 1 a cada vez que o\n"
"    shell ou um script shell é chamado. Quando uma opção requer\n"
"    um argumento, getopts coloca aquele argumento em uma variável\n"
"    shell chamada OPTARG.\n"
"    \n"
"    getopts relata erros em um de duas formas. Se o primeiro caractere\n"
"    de OPÇÕES for caractere dois-pontos, getopts usa sistema silencioso de\n"
"    relatório de erro. Neste modo, nenhuma mensagem de erro é mostrada.\n"
"    Se uma opção inválida é vista, getopts coloca o caractere de opção\n"
"    encontrada dentro do OPTARG. Se um argumento obrigatório não for\n"
"    encontrado, getopts coloca um ':' em NOME e define OPTARG para o\n"
"    caractere de opção encontrada. Se getopts não estiver no modo\n"
"    silencioso, uma opção inválida é vista, getopts coloca um '?' em\n"
"    NOME e remove definição de OPTARG. Se um argumento obrigatório não\n"
"    for encontrado, um '?' é colocado em NOME, OPTARG tem sua definição\n"
"    removida e uma mensagem de diagnóstico é mostrada.\n"
"    \n"
"    Se a variável shell OPTERR possuir o valor 0, getopts desabilita a\n"
"    exibição de mensagens de erro, mesmo se o primeiro caractere de\n"
"    OPÇÕES não for dois-pontos.  OPTERR tem o valor por padrão.\n"
"    \n"
"    Getopts normalmente analisa os parâmetros posicionais, mas se mais\n"
"    argumentos forem fornecidos, eles serão analisados.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, se uma opção for encontrada; falha se o fim das opções\n"
"    for encontrado ou ocorrer um erro."

# help exec
#: builtins.c:694
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error occurs."
msgstr ""
"Substitui o shell com o comando fornecido.\n"
"    \n"
"    Executa COMANDO, substituindo o shell com o programa especificado.\n"
"    ARGUMENTOS se tornam os argumentos para COMANDO. Se COMANDO não for\n"
"    especificado, quaisquer redirecionamentos surtem efeito no shell\n"
"    atual.\n"
"    \n"
"    Opções:\n"
"      -a nome\tpassa NOME como argumento zero para COMANDO\n"
"      -c\texecuta COMANDO com um ambiente vazio\n"
"      -l\tcoloca um traço no argumento zero para COMANDO\n"
"    \n"
"    Se o comando não puder ser executado, um shell não-interativo sai,\n"
"    a menos que a opção `execfail' esteja definida.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que COMANDO não seja encontrado ou ocorrer um\n"
"    erro no redirecionamento."

# help exit
#: builtins.c:715
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Sai do shell.\n"
"    \n"
"    Sai do shell com status igual a N.  Se N for omitido, o status\n"
"    de saída é o mesmo do último comando executado."

# help exit
#: builtins.c:724
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not executed\n"
"    in a login shell."
msgstr ""
"Sai de um shell de login.\n"
"    \n"
"    Sai de um shell de login com o status de saída N. Retorna um erro\n"
"    se não for executada em um shell de login."

# help fc
#: builtins.c:734
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error occurs."
msgstr ""
"Exibe ou executa comandos da lista do histórico.\n"
"    \n"
"    fc é usado para listar ou editar e re-executar comandos da lista de\n"
"    histórico. PRIMEIRO e ÚLTIMO podem ser números especificando o intervalo\n"
"    ou PRIMEIRO pode ser uma string, o que significa o comando mais recente\n"
"    iniciando com aquela string.\n"
"    \n"
"    Opções:\n"
"      -e EDITOR\tseleciona qual editor usar. O padrão é FCEDIT,\n"
"      \t\t\tentão EDITOR, então vi\n"
"      -l\t\tlista linhas ao invés de editar\n"
"      -n\t\tomite números de linhas ao listar\n"
"      -r\t\tordem reversa de linhas (mais novos listados primeiro)\n"
"    \n"
"    Com o formato `fc -s [ANTIGO=NOVO ...] [COMANDO]', COMANDO é\n"
"    re-executado após a substituição ANTIGO=NOVO ser realizada.\n"
"    \n"
"    Um apelido útil para usar isso é r='fc -s', de forma que digitar `r cc'\n"
"    executa o último comando iniciando com `cc' e digitar `r' re-executa\n"
"    o último comando.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso ou status do comando executado; ocorrendo um erro,\n"
"    retorna não-zero."

# help fg
#: builtins.c:764
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Move um trabalho para o primeiro plano.\n"
"    \n"
"    Coloca o trabalho identificado por ESPEC-JOB em primeiro plano,\n"
"    tornando o trabalho atual. Se ESPEC-JOB não estiver presente,\n"
"    a noção do shell de trabalho atual é usada.\n"
"    \n"
"    Status de saída:\n"
"    Status do comando colocado em primeiro plano ou falha, se ocorrer um erro."

# help bg
#: builtins.c:779
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Move trabalhos para o plano de fundo.\n"
"\n"
"    Coloca os trabalhos identificados por ESPEC-JOB em plano de fundo,\n"
"    como se eles tivessem sido iniciado com `&'. Se ESPEC-JOB não\n"
"    estiver presente, a noção do shell de trabalho atual é usada.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que controle de trabalho não esteja\n"
"    habilitado ou ocorra um erro."

# help hash
#: builtins.c:793
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Memoriza ou exibe localizações de programas.\n"
"    \n"
"    Determina e memoriza do caminho completo de cada comando NOME. Se nenhum\n"
"    argumento for fornecido, exibe informação sobre comandos memorizados.\n"
"    \n"
"    Opções:\n"
"      -d\t\tesquece a localização memorizada de cada NOME\n"
"      -l\t\texibe em um formato que pode ser usado como entrada\n"
"      -p caminho\tusa CAMINHO como o caminho completo de NOME\n"
"      -r\t\tesquece de todas as localizações memorizadas\n"
"      -t\t\tmostra a localização memorizada de cada NOME, iniciando\n"
"      \t\t\tcada localização com o NOME correspondente, se múltiplos\n"
"      \t\t\tNOMEs forem fornecidos\n"
"    Argumentos:\n"
"      NOME\t\tCada NOME é pesquisado em $PATH e adicionado à lista de\n"
"      \t\t\tcomandos memorizados.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que NOME não seja encontrado ou uma opção\n"
"    inválida seja fornecida."

# help help
#: builtins.c:818
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is given."
msgstr ""
"Exibe informação sobre comandos internos (builtin).\n"
"    \n"
"    Exibe resumos de comandos internos. Se PADRÃO for especificado,\n"
"    fornece ajuda detalhada sobre todos os comandos correspondendo\n"
"    a PADRÃO; do contrário, a lista de tópicos de ajuda é mostrada.\n"
"    \n"
"    Opções:\n"
"      -d\texibe uma descrição breve para cada tópico\n"
"      -m\texibe o uso em formato de pseudo página man\n"
"      -s\texibe apenas uma breve sinopse de uso para cada tópico\n"
"      \t\tcorrespondendo a PADRÃO\n"
"    \n"
"    Argumentos:\n"
"      PADRÃO\tPadrão especificando um tópico de ajuda\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que PADRÃO não seja encontrado ou uma opção\n"
"    inválida seja fornecida."

#: builtins.c:842
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Exibe ou manipula a lista de histórico.\n"
"    \n"
"    Exibe a lista de histórico com números de linhas, prefixando cada\n"
"    entrada modificada com um `*'.  Um argumento de N lista apenas as\n"
"    últimas N entradas.\n"
"    \n"
"    Opções:\n"
"      -c\t\tlimpa a lista de histórico ao excluir todas as entradas\n"
"      -d posição\texclui a entrada de histórico na posição POSIÇÃO. Posições\n"
"    \t\t\tnegativas contam a partir do fim da lista de histórico\n"
"    \n"
"      -a\t\tanexa linhas de histórico desta sessão no arquivo de\n"
"      \t\t\thistórico\n"
"      -n\t\tlê todas as linhas de histórico ainda não lidas do\n"
"      \t\t\tarquivo de histórico e anexa-os à lista de histórico\n"
"      -r\t\tlê o histórico e anexa os conteúdos à lista de histórico\n"
"      -w\t\tescreve o histórico atual para o arquivo de histórico\n"
"    \n"
"      -p\t\texecuta expansão de histórico em cada ARG e exibe o\n"
"      \t\t\tresultado sem armazená-lo na lista de histórico\n"
"      -s\t\tanexa os ARGs à lista de histórico como uma única entrada\n"
"    \n"
"    Se ARQUIVO for fornecido, ele é usado como o arquivo de histórico.\n"
"    Do contrário, se a variável HISTFILE tiver um valor, este será usado;\n"
"    senão, usa de ~/.bash_history.\n"
"    \n"
"    Se a variável HISTTIMEFORMAT for definida e não for nula, seu valor é\n"
"    usado como uma string de formato para strftime(3) para mostrar a marca\n"
"    de tempo associada com cada entrada de histórico exibida. Do contrário,\n"
"    nenhuma marca de tempo é mostrada.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida seja fornecida ou\n"
"    ocorra um erro."

# help jobs
#: builtins.c:879
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Exibe status de trabalhos.\n"
"    \n"
"    Lista os trabalhos ativos. ESPEC-JOB restringe a saída àquele trabalho.\n"
"    Não sendo informado qualquer opção, o status de todos os trabalhos\n"
"    ativos é exibido.\n"
"    \n"
"    Opções:\n"
"      -l\tlista IDs de processo junto com a informação normal\n"
"      -n\tlista apenas processos que tiverem seu status alterado desde\n"
"      \t\ta última notificação\n"
"      -p\tlista apenas IDs de processo\n"
"      -r\trestringe a saída apenas a trabalhos em execução\n"
"      -s\trestringe a saída apenas a trabalhos parados\n"
"    \n"
"    Se -x for fornecido, COMANDO é executado após as demais especificações\n"
"    de trabalho que aparecerem em ARGs terem sido substituídas com o ID de\n"
"    processo daquele líder de grupo de processos do trabalhos.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida seja fornecida ou\n"
"    ocorra um erro. Se -x for usado, retorna o status de saída do COMANDO."

# help disown
#: builtins.c:906
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Remove trabalhos do shell atual.\n"
"    \n"
"    Remove cada argumento ESPEC-JOB da tabela de trabalhos ativos. Sem\n"
"    qualquer ESPEC-JOB, o shell usa sua noção de trabalho atual.\n"
"    \n"
"    Opções:\n"
"      -a\tremove todos os trabalhos se ESPEC-JOB não for fornecido\n"
"      -h\tmarca cada ESPEC-JOB, de forma que SIGHUP não seja fornecido\n"
"      \t\tao trabalho, caso o shell receba um SIGHUP\n"
"      -r\tremove apenas trabalhos em execução\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida ou ESPEC-JOB inválido\n"
"    sejam fornecidos."

# help kill
#: builtins.c:925
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Envia um sinal para um trabalho.\n"
"\n"
"    Envia aos processos identificados pelo PID ou pelo ESPEC-JOB o sinal\n"
"    informado por SIGSPEC ou SIGNUM. Se SIGSPEC e SIGNUM\n"
"    não estiverem presentes, então, SIGTERM é presumido.\n"
"    \n"
"    Opções:\n"
"      -s sinal\tSINAL especifica o nome do sinal\n"
"      -n sinal\tSINAL representa um número de sinal\n"
"      -l\tlista os nomes dos sinais; se `-l' for acompanhado por\n"
"    \t\toutros argumentos, presume-se estes sejam números de\n"
"    \t\tsinais para os quais nomes deveriam ser listados\n"
"      -L\tsinônimo de -l\n"
"    \n"
"    `Kill' é um comando interno do shell por duas razões: ele permite\n"
"    IDs de trabalho serem usados ao invés de IDs de processo e permite\n"
"    que processos sejam matados caso o limite de processos que você pode\n"
"    criar seja atingido.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida seja fornecida ou\n"
"    ocorra um erro."

# help let
#: builtins.c:949
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Avalia expressões aritméticas.\n"
"    \n"
"    Avalia cada ARG como uma expressão aritmética. A avaliação é feita\n"
"    em inteiros com largura fixa com nenhuma verificação de estouro de\n"
"    pilha. A lista de operadores a seguir está agrupada em níveis de\n"
"    operadores de igual precedência. Os níveis estão listados em ordem\n"
"    de precedência decrescente.\n"
"    \n"
"    \tid++, id--          pós-acréscimo, pós-decréscimo de variável\n"
"    \t++id, --id          pré-acréscimo, pré-decréscimo de variável\n"
"    \t-, +                menos, mais unário\n"
"    \t!, ~                negação lógica e bit-a-bit\n"
"    \t**                  exponenciação\n"
"    \t*, /, %             multiplicação, divisão, resto de divisão\n"
"    \t+, -                adição, subtração\n"
"    \t<<, >>              deslocamento bit-a-bit para esquerda, direita\n"
"    \t<=, >=, <, >        comparação\n"
"    \t==, !=              igualdade, desigualdade\n"
"    \t&                   E (AND) bit-a-bit\n"
"    \t^                   OU eXclusivo (XOR) bit-a-bit\n"
"    \t|                   OU (OR) bit-a-bit\n"
"    \t&&                  E lógico\n"
"    \t||                  OU lógico\n"
"    \texpr ? expr : expr  operador condicional\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=          atribuição\n"
"    \n"
"    As variáveis de shell são permitidas como operandos. O nome da\n"
"    variável é substituída pelo seu valor (coagida a um inteiro com\n"
"    largura fixa) dentro de uma expressão. A variável não precisa ter\n"
"    seu atributo de `inteiro' ligado para ser usada em uma expressão.\n"
"   \n"
"    Operadores são avaliados em ordem de precedência. Sub-expressões em\n"
"    parênteses são avaliados primeiro e podem sobrescrever as regras de\n"
"    precedência acima.\n"
"    \n"
"    Status de saída:\n"
"    Se o último ARG for avaliado como 0, let retorna 1; do contrário,\n"
"    let retorna 0."

# help read
#: builtins.c:994
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as word\n"
"    delimiters. By default, the backslash character escapes delimiter characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times out\n"
"    (in which case it's greater than 128), a variable assignment error occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Lê uma linha da entrada padrão e separa em campos.\n"
"\n"
"    Lê uma linha da entrada padrão ou do descritor de arquivo FD, caso a\n"
"    opção -u seja fornecida. A linha é separada em campos, na mesma forma de\n"
"    separação de palavras, e a primeira palavra é atribuída ao primeiro NOME,\n"
"    o segundo ao segundo NOME e por aí vai, com qualquer palavras restantes\n"
"    atribuídas para o último NOME. Apenas os caracteres encontrados em $IFS\n"
"    são reconhecidos como delimitadores de palavras. Por padrão, o caractere\n"
"    de barra invertida escapa caracteres delimitadores e de nova linha.\n"
"    \n"
"    Se nenhum NOME for fornecido, a linha lida é armazenada na variável\n"
"    REPLY (resposta).\n"
"    \n"
"    Opções:\n"
"      -a array      atribui as palavras lidas a índices sequenciais da\n"
"                    variável array ARRAY, iniciando em zero\n"
"      -d delim      continua até o primeiro caractere de DELIM ser lido, ao\n"
"                    invés de nova linha\n"
"      -e            usa Readline para obter a linha\n"
"      -i texto      usa TEXTO como o texto inicial para Readline\n"
"      -n nchars     retorna após ler NCHARS caracteres, ao invés de esperar\n"
"                    por uma nova linha, mas respeita um delimitador se número\n"
"                    de caracteres menor que NCHARS sejam lidos antes do\n"
"                    delimitador\n"
"      -N nchars     retorna apenas após ler exatamente NCHARS caracteres, a\n"
"                    menos que EOF (fim do arquivo) seja encontrado ou `read'\n"
"                    esgote o tempo limite, ignorando qualquer delimitador\n"
"      -p prompt     mostra a string PROMPT sem remover nova linha antes de\n"
"                    tentar ler\n"
"      -r            não permite que barra invertida escape quaisquer\n"
"                    caracteres\n"
"      -s            não ecoa entrada vindo de um terminal\n"
"      -t tempo      esgota-se o tempo limite e retorna falha, caso uma toda\n"
"                    uma linha não seja lida em TEMPO segundos. O valor da\n"
"                    variável TMOUT é o tempo limite padrão. TEMPO pode ser um\n"
"                    número fracionado. SE TEMPO for 0, `read' retorna sucesso\n"
"                    apenas se a entrada estiver disponível no descritor de\n"
"                    arquivo especificado. O status de saída é maior que 128,\n"
"                    se o tempo limite for excedido\n"
"      -u fd         lê do descritor de arquivo FD, ao invés da entrada padrão\n"
"    \n"
"    Status de saída:\n"
"    O código de retorno é zero, a menos que o EOF (fim do arquivo) seja\n"
"    encontrado, `read' esgote o tempo limite (caso em que o código de retorno\n"
"    será 128), ocorra erro de atribuição de uma variável ou um descritor de\n"
"    arquivo inválido seja fornecido como argumento para -u."

# help return
#: builtins.c:1042
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Retorna de uma função de shell.\n"
"    \n"
"    Causa uma função ou script carregado (source) a sair retornando o valor\n"
"    especificado por N. Se N for omitido, o status de retorno é do último\n"
"    comando executado dentro da função ou script.\n"
"    \n"
"    Status de saída:\n"
"    Retorna N ou falha se o shell não estiver executando uma função ou\n"
"    script."

# help set
#: builtins.c:1055
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Define ou remove definição de valores das opções e dos parâmetros posicionais\n"
"do shell:\n"
"    \n"
"    Altera o valor de opções e de parâmetros posicionais do shell ou mostra\n"
"    os nomes ou valores de variáveis shell.\n"
"    \n"
"    Opções:\n"
"      -a  Marca variáveis, que foram modificadas ou criadas, para exportação.\n"
"      -b  Notifica sobre terminação de trabalho imediatamente.\n"
"      -e  Sai imediatamente se um comando sai com um status não-zero.\n"
"      -f  Desabilita a geração de nome de arquivo (\"globbing\").\n"
"      -h  Memoriza a localização de comandos à medida em que são procurados.\n"
"      -k  Todos argumentos de atribuição são colocados no ambiente para um\n"
"          comando, e não apenas aqueles que precedem o nome do comando.\n"
"      -m  Controle de trabalho está habilitado.\n"
"      -n  Lê comandos, mas não os executa.\n"
"      -o nome-opção\n"
"          Define a variável correspondendo a nome-opção:\n"
"              allexport    mesmo que -a\n"
"              braceexpand  mesmo que -B\n"
"              emacs        usa interface de edição de linha estilo Emacs\n"
"              errexit      mesmo que -e\n"
"              errtrace     mesmo que -E\n"
"              functrace    mesmo que -T\n"
"              hashall      mesmo que -h\n"
"              histexpand   mesmo que -H\n"
"              history      habilita histórico de comandos\n"
"              ignoreeof    shell não vai sair após leitura de EOF\n"
"              interactive-comments\n"
"                           permite mostrar comentários em comandos interativos\n"
"              keyword      mesmo que -k\n"
"              monitor      mesmo que -m\n"
"              noclobber    mesmo que -C\n"
"              noexec       mesmo que -n\n"
"              noglob       mesmo que -f\n"
"              nolog        atualmente aceito, mas ignorado\n"
"              notify       mesmo que -b\n"
"              nounset      mesmo que -u\n"
"              onecmd       mesmo que -t\n"
"              physical     mesmo que -P\n"
"              pipefail     o valor de retorno de uma linha de comandos é o\n"
"                           status do último comando a sair com status não-zero,\n"
"                           ou zero se nenhum comando saiu com status não zero\n"
"              posix        altera o comportamento do bash, onde a operação\n"
"                           padrão diverge dos padrões do Posix para\n"
"                           corresponder a estes padrões\n"
"              privileged   mesmo que -p\n"
"              verbose      mesmo que -v\n"
"              vi           usa interface de edição de linha estilo vi\n"
"              xtrace       mesmo que -x\n"
"      -p  Ligado sempre que IDs de usuário real e efetivo não corresponderem.\n"
"          Desabilita processamento do arquivo $ENV e importação de funções da\n"
"          shell. Ao desligar essa opção, causa o uid e o gid efetivo serem\n"
"          os uid e gid reais.\n"
"      -t  Sai após a leitura e execução de um comando.\n"
"      -u  Trata limpeza (unset) de variáveis como um erro quando substituindo.\n"
"      -v  Mostra linhas de entrada do shell na medida em que forem lidas.\n"
"      -x  Mostra comandos e seus argumentos na medida em que forem executados.\n"
"      -B  o shell vai realizar expansão de chaves\n"
"      -C  Se definido, não permite arquivos normais existentes serem\n"
"          sobrescritos por redirecionamento da saída.\n"
"      -E  Se definido, a armadilha ERR é herdada por funções do shell.\n"
"      -H  Habilita substituição de histórico estilo \"!\". Essa sinalização está\n"
"          habilitada por padrão quando  shell é interativa.\n"
"      -P  Se definida, não resolve links simbólicos ao sair de comandos, tais\n"
"          como `cd' (que altera o diretório atual).\n"
"      -T  Se definido, a armadilha DEBUG e RETURN são herdadas por funções do shell.\n"
"      --  Atribui quaisquer argumentos restantes aos parâmetros posicionais.\n"
"          Se não houver argumentos restantes, os parâmetros posicionais são\n"
"          limpos (unset).\n"
"      -   Atribui quaisquer argumentos restantes aos parâmetros posicionais.\n"
"          As opções -x e -v são desligadas.\n"
"    \n"
"    Usar +, ao invés de -, causa essas sinalizações serem desligadas. As\n"
"    sinalizações também podem ser usadas por meio de chamada do shell. As\n"
"    sinalizações atualmente definidas podem ser encontradas em $-. Os n ARGs\n"
"    restantes são parâmetros posicionais e são atribuídos, em ordem, a $1, $2,\n"
"    .. $n. Se nenhuma ARG for fornecido, todas as variáveis shell são\n"
"    mostradas.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida seja fornecida."

# help unset
#: builtins.c:1140
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Remove valores e atributos de variáveis e funções do shell.\n"
"    \n"
"    Para cada NOME, remove a variável ou função correspondente.\n"
"    \n"
"    Opções:\n"
"      -f    trata cada NOME como uma função de shell\n"
"      -v    trata cada NOME como uma variável de shell\n"
"      -n    trata cada NOME como um nome referência e remove o valor em si\n"
"            ao invés da variável a qual ele se refere\n"
"    \n"
"    Se opções, `unset' primeiro tenta remover uma variável e, se falhar,\n"
"    tenta remover uma função.\n"
"    \n"
"    Algumas variáveis não podem ser removida; veja também `readonly'.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida seja fornecida ou\n"
"    um NOME seja somente-leitura."

# help export
#: builtins.c:1162
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Define atributo de exportação para variáveis shell.\n"
"    \n"
"    Marca cada NOME para exportação automática para o ambiente dos comandos\n"
"    executados subsequentemente. Se VALOR for fornecido, atribui VALOR antes\n"
"    de exportar.\n"
"    \n"
"    Opções:\n"
"      -f\tfaz referência a funções do shell\n"
"      -n\tremove a propriedade de exportação para cada NOME\n"
"      -p\texibe uma lista de todas as variáveis e funções exportadas\n"
"    \n"
"    Um argumento de `--' desabilita processamento de opções posteriores.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida seja fornecida ou\n"
"    NOME seja inválido."

# help readonly
#: builtins.c:1181
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Marca variáveis shell como inalteráveis.\n"
"    \n"
"    Marca cada NOME como somente-leitura; os valores desses NOMEs pode não\n"
"    ser alterados por atribuídos subsequentes. Se VALOR for fornecido,\n"
"    atribui VALOR antes de marcar como somente-leitura.\n"
"    \n"
"    Opções:\n"
"      -a\tfaz referência a variáveis array indexados\n"
"      -A\tfaz referência a variáveis array associativos\n"
"      -f\tfaz referência a funções de shell\n"
"      -p\texibe uma lista de todas as variáveis ou funções somente-leitura,\n"
"    \t\tdependendo da opção -f ser informada ou não\n"
"    \n"
"    Um argumento de `--' desabilita processamento de opções posteriores.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida seja fornecida ou\n"
"    NOME seja inválido."

# help shift
#: builtins.c:1203
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Desloca parâmetros posicionais.\n"
"    \n"
"    Renomeia os parâmetros posicionais $N+1,$N+2 ... até $1,$2 ...  Se N não\n"
"    for fornecido, presume-se que ele seja 1.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que N seja negativo ou maior que $#."

# help source
#: builtins.c:1215 builtins.c:1230
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Executa comandos de um arquivo no shell atual.\n"
"    \n"
"    Lê e executa comandos de ARQUIVO no shell atual. As entradas em\n"
"    $PATH são usadas para localizar o diretório contendo ARQUIVO. Se\n"
"    quaisquer ARGUMENTOS forem fornecidos, eles se tornam parâmetros\n"
"    posicionais quando ARQUIVO é executado.\n"
"    \n"
"    Status de saída:\n"
"    Retorna o status do último comando executado em ARQUIVO; falha se\n"
"    ARQUIVO não puder ser lido."

# help suspend
#: builtins.c:1246
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Suspende execução do shell.\n"
"    \n"
"    Suspende a execução deste shell até que receba um sinal SIGCONT.\n"
"    A menos que seja forçado, `shells` de login não podem ser suspensas.\n"
"    \n"
"    Opções:\n"
"      -f\tforça a suspensão, ainda que o shell seja um de login\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que controle de trabalho não esteja habilitado\n"
"    ou ocorra um erro."

# help test
#: builtins.c:1262
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Avalia expressão condicional.\n"
"    \n"
"    Sai com um status de 0 (verdadeiro) ou 1 (falso) dependendo da avaliação\n"
"    de EXPR. As expressões podem ser unárias ou binárias. Expressões unárias\n"
"    são normalmente usadas para examinar o status de um arquivo. Há\n"
"    operadores de strings e também há operadores de comparação numérica.\n"
"    \n"
"    O comportamento do teste depende do número de argumentos. Leia a página\n"
"    de manual do `bash' para a especificação completa.\n"
"    \n"
"    Operadores de arquivos:\n"
"    \n"
"      -a ARQUIVO     Verdadeiro, se arquivo existir.\n"
"      -b ARQUIVO     Verdadeiro, se arquivo for um bloco especial.\n"
"      -c ARQUIVO     Verdadeiro, se arquivo for um caractere especial.\n"
"      -d ARQUIVO     Verdadeiro, se arquivo for um diretório.\n"
"      -e ARQUIVO     Verdadeiro, se arquivo existir.\n"
"      -f ARQUIVO     Verdadeiro, se arquivo existir e for um arquivo normal.\n"
"      -g ARQUIVO     Verdadeiro, se arquivo for set-group-id.\n"
"      -h ARQUIVO     Verdadeiro, se arquivo for um link simbólico.\n"
"      -L ARQUIVO     Verdadeiro, se arquivo for um link simbólico.\n"
"      -k ARQUIVO     Verdadeiro, se arquivo tiver o bit `sticky' definido.\n"
"      -p ARQUIVO     Verdadeiro, se arquivo for um `pipe' dado.\n"
"      -r ARQUIVO     Verdadeiro, se arquivo for um legível por você.\n"
"      -s ARQUIVO     Verdadeiro, se arquivo existir e não estiver vazio.\n"
"      -S ARQUIVO     Verdadeiro, se arquivo for um socket.\n"
"      -t FD          Verdadeiro, se FD estiver aberto em um terminal.\n"
"      -u ARQUIVO     Verdadeiro, se arquivo estiver com set-user-id.\n"
"      -w ARQUIVO     Verdadeiro, se arquivo puder ser escrito por você.\n"
"      -x ARQUIVO     Verdadeiro, se arquivo puder ser executado por você.\n"
"      -O ARQUIVO     Verdadeiro, se arquivo efetivamente for seu (owned).\n"
"      -G ARQUIVO     Verdadeiro, se arquivo efetivamente for do seu grupo.\n"
"      -N ARQUIVO     Verdadeiro, se arquivo foi modificado desde a última\n"
"                     leitura.\n"
"    \n"
"      ARQ1 -nt ARQ2  Verdadeiro se ARQ1 for mais novo que ARQ2, conforme\n"
"                     última data de modificação.\n"
"    \n"
"      ARQ1 -ot ARQ2  Verdadeiro, se ARQ1 for mais velho que ARQ2.\n"
"    \n"
"      ARQ1 -ef ARQ2  Verdadeiro, se ARQ1 for um link rígido para ARQ2.\n"
"    \n"
"    Operadores de string:\n"
"    \n"
"      -z STRING      Verdadeiro, se string estiver vazia.\n"
"    \n"
"      -n STRING\n"
"         STRING      Verdadeiro, se string não estiver vazia.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     Verdadeiro, se strings forem iguais.\n"
"      STRING1 != STRING2\n"
"                     Verdadeiro, se strings não forem iguais.\n"
"      STRING1 < STRING2\n"
"                     Verdadeiro, se STRING1 estiver antes de STRING2, de\n"
"                     acordo com a ordem alfabética.\n"
"      STRING1 > STRING2\n"
"                     Verdadeiro, se STRING1 estiver depois de STRING2, de\n"
"                     acordo com a ordem alfabética.\n"
"    \n"
"    Outros operadores:\n"
"    \n"
"      -o OPÇÃO       Verdadeiro, se a opção shell OPÇÃO estiver habilitada.\n"
"      -v VAR         Verdadeiro, se a variável shell VAR estiver definida.\n"
"      -R VAR         Verdadeiro, se a variável shell VAR estiver definida\n"
"                     e for uma referência de nome.\n"
"      ! EXPR         Verdadeiro, se a expressão EXPR for falsa.\n"
"      EXPR1 -a EXPR2 Verdadeiro, se ambas EXPR1 e EXPR2 forem verdadeiras.\n"
"      EXPR1 -o EXPR2 Verdadeiro, se ao menos uma das expressões for verdadeira.\n"
"    \n"
"      arg1 OP arg2   Testes aritméticos.  OP é um dentre -eq, -ne, -lt, -le,\n"
"                     -gt, or -ge.\n"
"    \n"
"    Operadores binários de aritmética retornam verdadeiro se ARG1 for igual,\n"
"    não-igual, menor-que, menor-ou-igual-a ou maior-ou-igual-a ARG2.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, se EXPR for avaliada como verdadeira; falha, se EXPR for\n"
"    avaliada como falsa ou um argumento inválido for informado."

# help [
#: builtins.c:1344
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Avalia expressões condicionais.\n"
"    \n"
"    Esse é um sinônimo para o comando interno `test', mas o último\n"
"    argumento deve ser um `]' literal, para corresponder ao `[' que abriu."

# help times
#: builtins.c:1353
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Exibe tempos de processos.\n"
"    \n"
"    Imprime os tempos de sistema e de usuário acumulados pelo shell e\n"
"    todos seus processo filhos.\n"
"    \n"
"    Status de saída:\n"
"    Sempre com sucesso."

# help trap
#: builtins.c:1365
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  If\n"
"    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or a\n"
"    script run by the . or source builtins finishes executing.  A SIGNAL_SPEC\n"
"    of ERR means to execute ARG each time a command's failure would cause the\n"
"    shell to exit when the -e option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is given."
msgstr ""
"Tratamento de sinais e outros eventos.\n"
"    \n"
"    Define e ativa manipuladores a serem executados quando o shell recebe\n"
"    sinais ou outras condições.\n"
"    \n"
"    ARG é um comando a ser lido e executado quando o shell recebe o\n"
"    ESPEC-SINAL do(s) sinal(is). Se ARG for vazio (e um único ESPEC-SINAL\n"
"    for informado) ou `-', cada sinal especificado é redefinido para seu\n"
"    valor original. Se ARG for uma string nula, cada ESPEC-SINAL é ignorado\n"
"    pela seu shell e pelos comados chamados por ela.\n"
"    \n"
"    Se um ESPEC-SINAL for EXIT (0), ARG é executado na saída do shell.\n"
"    Se ESPEC-SINAL for DEBUG, ARG é executado antes de todo comando.\n"
"    Se ESPEC-SINAL for RETURN, ARG é executado toda vez que uma função ou\n"
"    um script shell executados pelos comandos internos `.' ou `source'\n"
"    finalizarem suas execuções. Um ESPEC-SINAL sendo ERR significa executar\n"
"    ARG toda vez que uma falha do comando poderia causar o shell sair,\n"
"    quando a opção -e está habilitada.\n"
"    \n"
"    Se nenhum argumento for fornecido, `trap' imprime a lista de comandos\n"
"    associados a cada sinal.\n"
"    \n"
"    Opções:\n"
"      -l\timprime uma lista de nomes de sinais e seus números\n"
"      \t\tcorrespondentes\n"
"      -p\texibe os comandos associados ao tratamento com cada\n"
"      \t\tESPEC-SINAL\n"
"    \n"
"    Cada ESPEC-SINAL é um nome de sinal em <signal.h> ou um número\n"
"    de sinal. Nomes de sinais são sensíveis a caracteres maiúsculo e\n"
"    minúsculo e o prefixo SIG (sinal) é opcional. Um SINAL pode ser enviado\n"
"    para o shell com \"kill -SINAL $$\".\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que um ESPEC-SINAL seja inválido ou\n"
"    uma opção inválida seja fornecida."

# help type
#: builtins.c:1401
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not found."
msgstr ""
"Exibe informação sobre o tipo de comando.\n"
"    \n"
"    Para cada NOME, indica como ele seria interpretado se fosse usado como\n"
"    um nome de comando.\n"
"    \n"
"    Opções:\n"
"      -a\texibe todas as localizações contendo um executável chamado NOME;\n"
"    \t\tinclui apelidos (alias), comandos internos e funções,\n"
"    \t\tse, e somente se, a opção `-p' não for usada em conjunto\n"
"      -f\tsuprime a procura por função do shell\n"
"      -P\tforça uma pesquisa em PATH por cada  NOME, mesmo se ele for\n"
"    \t\tum apelido, um comando interno ou uma função, e retorna o nome\n"
"    \t\tdo arquivo de disco que seria executado\n"
"      -p\tretorna o nome do arquivo de disco que seria executado ou nada,\n"
"    \t\tse `type -t NOME' não retornasse `file'\n"
"      -t\tmostra uma única palavra que é uma dentre `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' ou `', se NOME for um apelido,\n"
"    \t\tpalavra reservada da shell, comando interno do shell,\n"
"    \t\tarquivo de disco ou não encontrado, respectivamente\n"
"    \n"
"    Argumentos:\n"
"      NOME\tNome de comando a ser interpretado.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, se todos os NOMEs forem encontrados; falha, se algum\n"
"    deles não for encontrado."

# help ulimit
#: builtins.c:1432
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Modifica limites de recursos do shell.\n"
"    \n"
"    Fornece controle sobre os recursos disponíveis para o shell e\n"
"    os processos que ele cria, em sistemas que permitem tal controle.\n"
"    \n"
"    Opções:\n"
"      -S\tusa um limite `soft' de recursos\n"
"      -H\tusa um limite `hard' de recursos\n"
"      -a\ttodos os limites atuais são relatados\n"
"      -b\to tamanho do buffer do socket\n"
"      -c\to tamanho máximo dos arquivos centrais criados\n"
"      -d\to tamanho máximo de um segmento de dados do processo\n"
"      -e\ta prioridade máxima de agendamento (`nice')\n"
"      -f\to tamanho máximo de arquivos escritos pelo shell e seus filhos\n"
"      -i\to número máximo de sinais pendentes\n"
"      -k\to número máximo de kqueues alocadas para este processo\n"
"      -l\to tamanho máximo que um processo pode alocar da memória\n"
"      -m\to tamanho máximo de conjunto residente\n"
"      -n\to número máximo de descritores de arquivo abertos\n"
"      -p\to tamanho de buffer de `pipe'\n"
"      -q\to número máximo de bytes em files de mensagem POSIX\n"
"      -r\to tempo real máximo de prioridade de agendamento\n"
"      -s\to tamanho máximo de pilha\n"
"      -t\ta quantidade máxima de tempo de CPU em segundos\n"
"      -u\to número máximo de processos de usuário\n"
"      -v\to tamanho de memória virtual\n"
"      -x\to número máximo de travas de arquivos\n"
"      -P\to número máximo de pseudoterminais\n"
"      -R\to tempo máximo que um processo de tempo real pode executar\n"
"              antes de ser bloqueado\n"
"      -T\to número máximo de fluxos (threads)\n"
"    \n"
"    Nem todas as opções estão disponíveis em todas as plataformas.\n"
"    \n"
"    Se LIMITE for fornecido, ele é o novo valor do recurso especificado;\n"
"    os valores especiais de LIMITE `soft', `hard' e `unlimited' referem-se\n"
"    ao atual limite suave, o atual limite rígido e nenhum limite,\n"
"    respectivamente. Do contrário, o valor atual do recurso especificado\n"
"    é impresso. Se nenhuma opção for fornecida, então -f é presumida.\n"
"    \n"
"    Valores estão em acréscimos de 1024 bytes, exceto para -t, que está\n"
"    em segundos; -p, que é em 512 bytes; e -u, que é um número sem\n"
"    escala de processos.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida seja fornecida ou\n"
"    ocorra um erro."

# help umask
#: builtins.c:1483
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Exibe ou define máscara de modo de arquivo.\n"
"    \n"
"    Define a máscara de criação de arquivos do usuário para MODO. Se MODO\n"
"    for omitido, imprime o valor atual da máscara.\n"
"    \n"
"    Se MODO inicia com um dígito, ele é interpretado como um número octal;\n"
"    do contrário, ele é uma string de modo simbólico como a que é aceita\n"
"    pelo chmod(1).\n"
"    \n"
"    Opções:\n"
"      -p\tse MODO for omitido, exibe em um formulário que pode ser usado\n"
"      \t\tcomo entrada\n"
"      -S\ttorna a saída simbólica; do contrário, um número octal é mostrado\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que MODO seja inválido ou uma opção\n"
"    inválida seja fornecida."

# help wait
#: builtins.c:1503
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Espera por conclusão de trabalho e retorna o status de saída.\n"
"    \n"
"    Espera por cada processo identificado por um ID, o que pode ser um ID\n"
"    de processo ou uma especificação de trabalho, e relata seu status de\n"
"    término. Se ID não for fornecido, espera por todos os processos filhos\n"
"    ativos e o status de retorno é zero. Se ID é uma especificação de\n"
"    trabalho, espera por todos os processos naquela sequência de comandos\n"
"    dos trabalhos.\n"
"    \n"
"    Se a opção -n for fornecida, espera pelo próximo trabalho terminar e\n"
"    retorna seu status de trabalho.\n"
"    \n"
"    Se a opção -p for fornecida, o identificador de processo ou trabalho do\n"
"    trabalho, ao qual o status de saída é retornado, é atribuído à variável\n"
"    VAR nomeada pelo argumento da opção.A variável terá sua definição\n"
"    removida inicialmente, antes de qualquer atribuição.Isso é útil quando.\n"
"    \n"
"    Status de saída:\n"
"    Retorna o status do último ID; falha, se ID for inválido ou uma opção\n"
"    inválida for fornecida, ou se -n é fornecida e o shell possui nenhum\n"
"    filho inesperado."

# help wait
#: builtins.c:1534
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an invalid\n"
"    option is given."
msgstr ""
"Espera por conclusão de processo e retorna o status de saída.\n"
"    \n"
"    Espera por cada processo especificado por um PID e relata seu status\n"
"    de término. SE PID não for fornecido, espera por todos os processos\n"
"    filhos atualmente ativos e o status de retorno é zero. PID deve ser\n"
"    um ID de processo.\n"
"    \n"
"    Status de saída:\n"
"    Retorna o status do último ID; falha, se ID for inválido ou uma opção\n"
"    inválida for fornecida."

# help for
#: builtins.c:1549
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Executa comandos para cada membro em uma lista.\n"
"    \n"
"    O loop `for' executa uma sequência de comandos para cada membro em\n"
"    uma lista de itens. Se `in PALAVRAS ...;' não estiver presente, então\n"
"    `in \"$@\"' é presumido. Para cada elemento em PALAVRAS, NOME é definido\n"
"    com aquele elemento e os COMANDOS são executados.\n"
"    \n"
"    Status de saída:\n"
"    Retorna o status do último comando executado."

# help for ((    (?)
#: builtins.c:1563
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Loop `for' aritmético.\n"
"    \n"
"    Equivalente a\n"
"    \t(( EXPR1 ))\n"
"    \twhile (( EXPR2 )); do\n"
"    \t\tCOMANDOS\n"
"    \t\t(( EXPR3 ))\n"
"    \tdone\n"
"    EXPR1, EXPR2 e EXPR3 são expressões aritméticas. Se alguma expressão\n"
"    for omitida, ele se comporta como se a avaliação resultasse em 1.\n"
"    \n"
"    Status de saída:\n"
"    Retorna o status do último comando executado."

# help select
#: builtins.c:1581
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Seleciona palavras de uma lista e executa comandos.\n"
"    \n"
"    As PALAVRAS são expandidas, gerando uma lista de palavras.\n"
"    O conjunto de palavras expandidas é exibido no erro padrão,\n"
"    cada um precedido por um número. Se `in PALAVRAS' não estiver\n"
"    presente, `in \"$@\"' é presumido. Então, o prompt PS3 é exibido\n"
"    e uma linha é lida da entrada padrão. Se a linha consiste\n"
"    do número correspondendo àquele nas palavras exibidas, então\n"
"    NOME é definido para aquela palavra. Se a linha estiver vazia,\n"
"    PALAVRAS e o prompt são exibidos novamente. Se EOF (fim do\n"
"    arquivo) for lido, o comando conclui. Qualquer outro valor\n"
"    lido causa NOME ser definido como nulo. A linha lida é salva\n"
"    na variável REPLY. COMANDOS são executados após cada seleção\n"
"    até um comando `break' ser executado.\n"
"    \n"
"    Status de saída:\n"
"    Retorna o status do último comando executado."

# help time
#: builtins.c:1602
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Relata o tempo consumido pela execução da linha de comandos.\n"
"    \n"
"    Executa LINHA-COMANDOS e imprime um resumo do tempo real,\n"
"    tempo de CPU do usuário e do sistema, gastos executando\n"
"    LINHA-COMANDOS, quando este terminar.\n"
"    \n"
"    Opções:\n"
"      -p\timprime o resumo do tempo no formato portátil do Posix\n"
"    \n"
"    O valor da variável TIMEFORMAT é usada como formato de saída.\n"
"    \n"
"    Status de saída:\n"
"    O status de retorno é o status retornado por LINHA-COMANDOS."

# help case
#: builtins.c:1619
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Executa comandos baseados em correspondência de padrão.\n"
"    \n"
"    Seletivamente executa COMANDOS baseados na PALAVRA correspondendo\n"
"    a PADRÃO. O `|' é usado para separar múltiplos padrões.\n"
"    \n"
"    Status de saída:\n"
"    Retorna o status do último comando executado."

# help if
#: builtins.c:1631
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of the\n"
"    entire construct is the exit status of the last command executed, or zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Executa comandos baseados em condicional.\n"
"    \n"
"    A lista `if COMANDOS' é executada. Se seu status de saída for zero,\n"
"    então a lista `then COMANDOS' é executada. Do contrário, cada lista\n"
"    `elif COMANDOS' é executada em turnos e, se seu status de saída for\n"
"    zero, a lista `then COMANDOS' correspondente é executada e o comando\n"
"    `if' conclui. Do contrário, a lista `else COMANDOS' é executada, se\n"
"    presente. O status de saída de toda construção é o status de saída do\n"
"    último comando executado, ou zero, se nenhuma condição testada\n"
"    resultou em verdadeiro.\n"
"    \n"
"    Status de saída:\n"
"    Retorna o status do último comando executado."

# help while
#: builtins.c:1648
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Executa comandos desde que se obtenha sucesso nos testes.\n"
"    \n"
"    Expande e executa COMANDOS-2 desde que o comando final em\n"
"    COMANDOS tenha um status de saída zero.\n"
"    \n"
"    Status de saída:\n"
"    Retorna o status do último comando executado."

# help until
#: builtins.c:1660
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Executa comandos desde que não se obtenha sucesso nos testes.\n"
"    \n"
"    Expande e executa COMANDOS-2 desde que o comando final em\n"
"    COMANDOS tenha um status de saída que seja não-zero.\n"
"    \n"
"    Status de saída:\n"
"    Retorna o status do último comando executado."

#: builtins.c:1672
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Cria um coprocesso chamado NOME.\n"
"    \n"
"    Executa COMANDO assincronamente, com a saída padrão e entrada padrão\n"
"    do comando conectados via um `pipe' (redirecionamento) para descritores\n"
"    de arquivo atribuídos para índices 0 e 1 de uma variável array NOME\n"
"    no shell em execução. O NOME padrão é \"COPROC\".\n"
"    \n"
"    Status de saída:\n"
"    O comando coproc retorna um status de saída de 0."

# help function
#: builtins.c:1686
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Define uma função de shell.\n"
"    \n"
"    Cria uma função de shell chamada NOME. Quando chamado como um comando\n"
"    simples, NOME executa COMANDOs no contexto de chamada shell.  Quando\n"
"    NOME é chamado, os argumentos são passados para a função como $1..$n\n"
"    e o nome da função está em $FUNCNAME.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que NOME seja somente-leitura."

# help -m {
#: builtins.c:1700
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Agrupa comandos como uma unidade.\n"
"    \n"
"    Executa um conjunto de comandos em um grupo. Essa é uma\n"
"    forma de redirecionar um todo um conjunto de comandos.\n"
"    \n"
"    Status de saída:\n"
"    Retorna o status do último comando executado."

#: builtins.c:1712
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Resume trabalho em primeiro plano.\n"
"    \n"
"    Equivalente ao argumento ESPEC-JOB para comando `fg'. Resume um\n"
"    trabalho parado ou enviado para plano de fundo. ESPEC-JOB pode\n"
"    especificar tanto um nome de trabalho quanto um número de trabalho.\n"
"    ESPEC-JOB seguido de um `&' coloca o trabalho em plano de fundo,\n"
"    como se a especificação do trabalho tivesse sido fornecida como um\n"
"    argumento para `bg'.\n"
"    \n"
"    Status de saída:\n"
"    Retorna o status de um trabalho resumido."

# help '(('
#: builtins.c:1727
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Avalia expressões aritméticas.\n"
"    \n"
"    A EXPRESSÃO é avaliada de acordo com as regras de avaliação aritmética.\n"
"    Equivalente a `let \"EXPRESSÃO\"'.\n"
"    \n"
"    Status de saída:\n"
"    Retorna 1, se EXPRESSÃO for avaliada como 0; do contrário, retorna 0."

# help '['
#: builtins.c:1739
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries used\n"
"    by the `test' builtin, and may be combined using the following operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Executa comando condicional.\n"
"    \n"
"    Retorna um status de 0 ou 1 dependendo da avaliação da expressão\n"
"    condicional EXPRESSÃO. Expressões são compostas dos mesmos primários\n"
"    usados pelo comando interno `test' e pode ser combinado usando os\n"
"    seguintes operadores:\n"
"    \n"
"      ( EXPRESSÃO )\tRetorna o valor de EXPRESSÃO\n"
"      ! EXPRESSÃO\tVerdadeiro, se EXPRESSÃO for falsa; senão, falso\n"
"      EXPR1 && EXPR2\tVerdadeiro, se ambas EXPR1 e EXPR2 forem verdadeiras;\n"
"      \t\t\tsenão, falso\n"
"      EXPR1 || EXPR2\tVerdadeiro, se EXPR1 ou EXPR2 for verdadeira;\n"
"      \t\t\tsenão, falso\n"
"    \n"
"    Quando os operadores `==' e `!=' forem usados, a string à direita do\n"
"    operador é usado como um padrão e uma correspondência de padrão é\n"
"    realizada. Quando o operador `=~' é usado, a string à direita do\n"
"    operador é correspondida como uma expressão regular.\n"
"    \n"
"    Os operadores && e || não avaliam EXPR2, se EXPR1 for suficiente para\n"
"    determinar o valor da expressão.\n"
"    \n"
"    Status de saída:\n"
"    0 ou 1 dependendo do valor de EXPRESSÃO."

# help variables
#: builtins.c:1765
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Nomes e uso de variáveis comuns do shell.\n"
"    \n"
"    BASH_VERSION\tInformação da versão deste Bash.\n"
"    CDPATH\t\tUma lista separada por dois-pontos de diretórios para\n"
"    \t\t\tpesquisar por diretórios fornecidos como argumentos a `cd'.\n"
"    GLOBIGNORE\t\tUma lista separada por dois-pontos de padrões descrevendo\n"
"    \t\t\tarquivos a serem ignorados pela expansão de caminho.\n"
"    HISTFILE\t\tO nome do arquivo no qual o histórico de comandos é\n"
"    \t\t\tarmazenado.\n"
"    HISTFILESIZE\tO número máximo de linhas que esse arquivo pode conter.\n"
"    HISTSIZE\t\tO número máximo de linhas de histórico que um shell\n"
"    \t\t\tpode acessar.\n"
"    HOME\t\t\tO caminho completo para seu diretório de login.\n"
"    HOSTNAME\t\tO nome da sua máquina.\n"
"    HOSTTYPE\t\tO tipo de CPU sob a qual esta versão do Bash está\n"
"    \t\t\tfuncionando.\n"
"    IGNOREEOF\t\tControla a ação do shell na recepção de um caractere\n"
"    \t\t\tde fim de arquivo (EOF) como uma entrada única. Se\n"
"    \t\t\tdefinida, então seu valor é o número de caracteres de EOF\n"
"    \t\t\tque podem ser vistos numa leva em uma linha vazia antes\n"
"    \t\t\tdo shell sair (padrão 10). Do contrário, EOF significa\n"
"    \t\t\to fim da entrada.\n"
"    MACHTYPE\t\tUma string descrevendo o sistema no qual Bash está sendo\n"
"    \t\t\texecutado.\n"
"    MAILCHECK\t\tCom qual frequência, em segundos, Bash verifica por novo\n"
"    \t\t\tcorreio.\n"
"    MAILPATH\t\tUma lista separada por dois-pontos de arquivos que Bash\n"
"    \t\t\tverifica por novo correio.\n"
"    OSTYPE\t\t\tA versão do Unix no qual Bash está sendo executado.\n"
"    PATH\t\t\tUma lista separada por dois-pontos de diretórios para\n"
"    \t\t\tpesquisar ao se procurar por comandos.\n"
"    PROMPT_COMMAND\tUm comando a ser executado antes de imprimir cada prompt\n"
"    \t\t\tprimário.\n"
"    PS1\t\t\t\tA string de prompt primário.\n"
"    PS2\t\t\t\tA string de prompt secundária.\n"
"    PWD\t\t\t\tO caminho completo do diretório atual.\n"
"    SHELLOPTS\t\tUma lista separada por dois-pontos de opções shell\n"
"    \t\t\t\thabilitadas.\n"
"    TERM\t\t\tO nome do tipo de terminal atual.\n"
"    TIMEFORMAT\t\tO formato de saída para estatísticas de tempo exibidas\n"
"    \t\t\t\tpela palavra reservada `time'.\n"
"    auto_resume\t\tNão-nulo significa que uma palavra de comando aparecendo\n"
"    \t\t\t\tem uma linha, por si só, é procurada primeiro na lista de\n"
"    \t\t\t\ttrabalhos atualmente parados. Se encontrado lá, aquele\n"
"    \t\t\t\ttrabalho é levado para primeiro plano. Um valor de `exact'\n"
"    \t\t\t\tsignifica que a palavra de comando deve corresponder\n"
"    \t\t\t\texatamente um comando na lista de trabalhos parados. Um\n"
"    \t\t\t\tvalor de `substring' significa que a palavra de comando\n"
"    \t\t\t\tdeve corresponder a uma substring do trabalho. Qualquer\n"
"    \t\t\t\toutro valor significa que o comando deve ser um prefixo\n"
"    \t\t\t\tde um trabalho parado.\n"
"    histchars\t\tCaracteres controlando expansão de histórico e\n"
"    \t\t\t\tsubstituição rápida. O primeiro caractere é o de\n"
"    \t\t\t\tsubstituição de histórico, normalmente `!'. O segundo\n"
"    \t\t\t\té o caractere `quick substitution', normalmente `^'.\n"
"    \t\t\t\tO terceiro é o caractere `quick sbustitution',\n"
"    \t\t\t\tnormalmente `#'\n"
"    HISTIGNORE\t\tUma lista separada por dois-pontos de padrões usados para\n"
"    \t\t\t\tdecidir quais comandos deveriam ser salvos na lista de\n"
"    \t\t\t\thistórico.\n"

# help pushd
#: builtins.c:1822
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Adiciona diretórios a uma pilha.\n"
"    \n"
"    Adiciona um diretório ao topo da pilha de diretórios ou movimenta\n"
"    a pilha, fazendo o novo topo da pilha ser o diretório atual de\n"
"    trabalho. Com nenhum argumento, efetua troca do topo entre dois\n"
"    diretórios.\n"
"    \n"
"    Opções:\n"
"      -n\tSuprime a alteração normal de diretório ao adicionar\n"
"      \t\tdiretórios à pilha, de forma que apenas a pilha é manipulada.\n"
"    \n"
"    Argumentos:\n"
"      +N\tMovimenta a pilha de forma que o n-ésimo diretório (a contar\n"
"      \t\tda esquerda da lista mostrada por `dirs', iniciando com zero)\n"
"      \t\testá no topo.\n"
"    \n"
"      -N\tMovimenta a pilha de forma que o n-ésimo diretório (a contar\n"
"      \t\tda direita da lista mostrada por `dirs', iniciando com zero)\n"
"      \t\testá no topo.\n"
"    \n"
"      dir\tAdiciona DIR à pilha de diretórios no topo, fazendo dele o\n"
"      \t\tnovo diretório de trabalho atual.\n"
"    \n"
"     O comando interno `dirs' exibe a pilha de diretórios.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que um argumento inválido seja fornecido ou\n"
"    a alteração de diretório falhar."

# help popd
#: builtins.c:1856
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Remove diretórios de uma pilha.\n"
"\n"
"    Remove entradas da pilha de diretórios. Com nenhum argumento, remove\n"
"    o diretório do topo da pilha e altera o novo diretório do topo.\n"
"    \n"
"    Opções:\n"
"      -n\tSuprime a alteração normal de diretório ao remover\n"
"      \t\tdiretórios da pilha, de forma que apenas a pilha é manipulada.\n"
"    \n"
"    Argumentos:\n"
"      +N\tRemove a n-ésima entrada a contar da esquerda da lista\n"
"      \t\tmostrada por `dirs', iniciando com zero. Ex.: `popd +0'\n"
"      \t\tremove o primeiro diretório e `popd +1', o segundo.\n"
"    \n"
"      -N\tRemove a n-ésima entrada a contar da direita da lista\n"
"      \t\tmostrada por `dirs', iniciando com zero. Ex.: `popd +0'\n"
"      \t\tremove o último diretório e `popd -1', o penúltimo.\n"
"    \n"
"    O comando interno `dirs' exibe a pilha de diretório.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que um argumento inválido seja fornecido ou\n"
"    a alteração de diretório falhar."

# help dirs
#: builtins.c:1886
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Exibe pilha de diretórios.\n"
"    \n"
"    Exibe a lista de diretórios atualmente memorizados. Diretórios são\n"
"    inseridos na lista por meio do comando `pushd'; você pode obter\n"
"    de volta da lista com o comando `popd'.\n"
"    \n"
"    Opções:\n"
"      -c\tlimpa a pilha de diretórios excluindo todos os elementos\n"
"      -l\tnão mostra versões de diretórios prefixadas por til,\n"
"      \t\trelativos ao seu diretório HOME\n"
"      -p\texibe a pilha de diretório com uma entrada por linha\n"
"      -v\texibe a pilha de diretório com uma entrada por linha,\n"
"      \t\tprefixada com sua posição na pilha\n"
"    \n"
"    Argumentos:\n"
"      +N\tExibe a n-ésima entrada a partir da esquerda da linha\n"
"      \t\tmostrada por `dirs' chamado sem opções, iniciando com zero.\n"
"    \n"
"      -N\tExibe a n-ésima entrada a partir da esquerda da linha\n"
"      \t\tmostrada por `dirs' chamado sem opções, iniciando com zero.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida seja fornecida ou\n"
"    ocorrer um erro."

# help shopt
#: builtins.c:1917
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Define e remove definições de opções de shell.\n"
"    \n"
"    Altera a configuração de cada opção shell NOME-OPÇÃO. Sem qualquer\n"
"    argumento de opção, lista cada OPTNAME fornecido com uma indicação\n"
"    de se cada uma está definida ou não.\n"
"    \n"
"    Opções:\n"
"      -o\trestringe NOME-OPÇÃO àqueles definidos para usar com `set -o'\n"
"      -p\timprime cada opção shell com uma indicação de seu status\n"
"      -q\tsuprime a saída\n"
"      -s\thabilita (set) com NOME-OPÇÃO\n"
"      -u\tdesabilita (unset) com NOME-OPÇÃO\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, se NOME-OPÇÃO estiver habilitado; falha, se uma\n"
"    opção inválida for fornecida ou NOME-OPÇÃO estiver desabilitado."

# help printf
#: builtins.c:1938
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: plain\n"
"    characters, which are simply copied to standard output; character escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in printf(1),\n"
"    printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or assignment\n"
"    error occurs."
msgstr ""
"Formata e imprime ARGUMENTOS sob controle de FORMATO.\n"
"    \n"
"    Options:\n"
"      -v var\tatribui a saída à variável shell VAR, ao invés de exibi-la\n"
"      \t\t\tna saída padrão\n"
"    \n"
"    FORMATO é uma string de caractere que contém três tipos de objetos;\n"
"    caracteres planos, que são simplesmente copiados para a saída padrão;\n"
"    sequências de escape de caracteres, que são convertidas e copiadas\n"
"    para a saída padrão; e especificações de formatos, cada um que causa\n"
"    impressão do próximo argumento sucessivo.\n"
"    \n"
"    Além das especificações de formato padrão descritas em printf(1),\n"
"    printf interpreta:\n"
"    \n"
"      %b\texpande sequências de escape com contrabarras no argumento\n"
"      \t\tcorrespondente\n"
"      %q\tcita o argumento de uma forma que pode ser usado como entrada\n"
"      \t\tno shell\n"
"      %Q\tcomo %q, mas aplica qualquer precisão ao argumento sem aspas\n"
"    \t\tantes de adicionar aspas\n"
"      %(fmt)T\texibe a string de data-hora resultante do uso de FMT como\n"
"      \t\t\tuma string de formato para strftime(3)\n"
"    \n"
"    O formato é usado como necessário para consumir todos os argumentos.\n"
"    Se houver menos argumentos que o formato requer, especificações de\n"
"    formato extras se comportam como se uma string com valor zero ou nula,\n"
"    como apropriado, tivesse sido fornecida.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida seja fornecida ou\n"
"    ocorra um erro de escrita ou atribuição."

# help complete
#: builtins.c:1974
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no options\n"
"    are supplied, existing completion specifications are printed in a way that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Especifica como argumentos são completados por Readline.\n"
"    \n"
"    Para cada NOME, especifica como argumentos são completados. Se nenhuma\n"
"    opção for fornecida, especificações existente para completar são\n"
"    impressas em uma forma que permite-as serem usadas como entrada.\n"
"    \n"
"    Opções:\n"
"      -p\timprime especificações existentes de completar em um formato usável\n"
"      -r\tremove uma especificação de completar para cada NOME ou, se nenhum\n"
"    \t\tNOME for fornecido, todas as especificações de completar\n"
"      -D\taplica as completações e ações como sendo o padrão para comandos\n"
"    \t\tsem qualquer especificação definida\n"
"      -E\taplica as completações e ações para tentativa de completar\n"
"    \t\tcomandos -- \"vazios\" em uma linha vazia\n"
"      -I\taplica completações e ações para a palavra inicial (geralmente o\n"
"    \t\tcomando)\n"
"    \n"
"    Ao tentar completar, as ações são fornecidas na ordem em que as opções\n"
"    de letras de caixa alta são listadas acima. Se várias opções forem fornecidas,\n"
"    a opção -D tem precedência sobre -E, e ambos têm precedência sobre -I.\n"
"    sobre -E.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida seja fornecida ou\n"
"    ocorra um erro."

# help compgen
#: builtins.c:2004
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Exibe possibilidades de completação dependendo das opções.\n"
"    \n"
"    Tem a intenção de ser usado de dentro de uma função shell gerando\n"
"    completações possíveis. Se o argumento opcional PALAVRA for fornecido,\n"
"    comparações entre PALAVRA é gerada.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida seja fornecida ou\n"
"    ocorra um erro."

# help compopt
#: builtins.c:2019
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, print\n"
"    the completion options for each NAME or the current completion specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Modifica ou exibe opções de completação.\n"
"    \n"
"    Modifica as opções de completação para cada NOME ou, se nenhum NOME for\n"
"    fornecido, a completação sendo executada atualmente. Se nenhuma OPÇÃO\n"
"    for fornecida, imprime as opções de completação para cada NOME ou a\n"
"    especificação de completação atual.\n"
"    \n"
"    Opções:\n"
"    \t-o opção\tDefine a opção de completação OPÇÃO para cada NOME\n"
"    \t-D\t\tAltera opções para a completação de comando \"padrão\"\n"
"    \t-E\t\tAltera opções para a completação de comando \"vazio\"\n"
"    \t-I\t\tAltera as opções para completação na palavra inicial\n"
"    \n"
"    Ao usar `+o', ao invés de `-o', desliga a opção especificada.\n"
"    \n"
"    Argumentos:\n"
"    \n"
"    Cada NOME se refere a um comando para o qual uma especificação de\n"
"    completação deve ter sido definida anteriormente usando o comando\n"
"    interno `complete'. Se nenhum NOME for fornecido, `compopt` deve\n"
"    ser chamado por uma função atualmente gerando completações e as\n"
"    opções para aquele gerador de completações atualmente em execução\n"
"    são modificados.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválido seja fornecido ou\n"
"    NOME não tem uma especificação de completação definida."

# help mapfile
#: builtins.c:2050
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly or\n"
"    not an indexed array."
msgstr ""
"Lê linhas da entrada padrão para uma variável array indexado.\n"
"    \n"
"    Lê linhas da entrada padrão para a variável array indexado ARRAY ou\n"
"    do descritor de arquivo FD, se a opção -u for fornecida. A variável\n"
"    MAPFILE é o ARRAY padrão.\n"
"    \n"
"    Opções:\n"
"      -d dlim      Usa DELIM para terminar linhas, ao invés de nova linha\n"
"      -n número     Copia no máximo NÚMERO linhas. Se NÚMERO for 0, todas as\n"
"                    linhas são copiadas\n"
"      -O origem     Inicia atribuição de ARRAY no índice ORIGEM. O índice\n"
"                    padrão é 0\n"
"      -s número     Descarta as primeiras NÚMERO linhas lidas\n"
"      -t            Remove uma DELIM ao final para cada linha lida\n"
"                    (padrão: nova linha)\n"
"      -u fd         Lê linhas do descritor de arquivos FD, ao invés da entrada\n"
"                    padrão\n"
"      -C chamada    Avalia CHAMADA a cada vez que QUANTIDADE linhas foram lidas\n"
"      -c quantidade Especifica o número de linhas lidas entre cada chamada para\n"
"                    CHAMADA\n"
"    \n"
"    Argumentos:\n"
"      ARRAY         Nome da variável array para usar para arquivos de dados\n"
"    \n"
"    Se -C for fornecido sem -c, a quantidade padrão é 5000. Quando CHAMADA é\n"
"    avaliada, é fornecido o índice para o próximo elemento da array ser\n"
"    atribuído e a linha para ser atribuída àquele elemento como argumentos\n"
"    adicionais\n"
"    \n"
"    Se não for fornecido com uma origem explícita, mapfile vai limpar ARRAY\n"
"    antes de lhe atribuir.\n"
"    \n"
"    Status de saída:\n"
"    Retorna sucesso, a menos que uma opção inválida seja dada ou ARRAY for\n"
"    somente leitura ou não for um array indexado."

# help readarray
#: builtins.c:2086
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Lê linhas de um arquivo para uma variável array.\n"
"    \n"
"    Um sinônimo para `mapfile'."

#~ msgid "%s: invalid associative array key"
#~ msgstr "%s: chave de array associativo inválida"

#~ msgid ""
#~ "Returns the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns "
#~ msgstr ""
#~ "Retorna o contexto da chamada de sub-rotina atual.\n"
#~ "    \n"
#~ "    Sem EXPR, retorna "

#~ msgid "add_process: process %5ld (%s) in the_pipeline"
#~ msgstr "add_process: processo %5ld (%s) em the_pipeline"

#~ msgid "Unknown Signal #"
#~ msgstr "Sinal desconhecido #"

#~ msgid "Copyright (C) 2015 Free Software Foundation, Inc."
#~ msgstr "Copyright (C) 2015 Free Software Foundation, Inc."

#~ msgid "Copyright (C) 2014 Free Software Foundation, Inc."
#~ msgstr "Copyright (C) 2014 Free Software Foundation, Inc."

#~ msgid ":"
#~ msgstr ":"

# Não traduzir "true", esta é uma opção "builtin" do "bash" que é exibida ao executar "help" e acessível com "help true".
#~ msgid "true"
#~ msgstr "true"

# Não traduzir "false", esta é uma opção "builtin" do "bash" que é exibida ao executar "help" e acessível com "help false".
#~ msgid "false"
#~ msgstr "false"

#~ msgid "disown [-h] [-ar] [jobspec ...]"
#~ msgstr "disown [-h] [-ar] [ESPEC-JOB ...]"

# não traduzir, este é um comando
#~ msgid "times"
#~ msgstr "times"

# help typeset
#~ msgid ""
#~ "Set variable values and attributes.\n"
#~ "    \n"
#~ "    Obsolete.  See `help declare'."
#~ msgstr ""
#~ "Define valores e atributos de variável.\n"
#~ "    \n"
#~ "    Obsoleto.  Veja `help declare'."

# help history
#~ msgid ""
#~ "Display or manipulate the history list.\n"
#~ "    \n"
#~ "    Display the history list with line numbers, prefixing each modified\n"
#~ "    entry with a `*'.  An argument of N lists only the last N entries.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -c\tclear the history list by deleting all of the entries\n"
#~ "      -d offset\tdelete the history entry at offset OFFSET.\n"
#~ "    \n"
#~ "      -a\tappend history lines from this session to the history file\n"
#~ "      -n\tread all history lines not already read from the history file\n"
#~ "      -r\tread the history file and append the contents to the history\n"
#~ "    \t\tlist\n"
#~ "      -w\twrite the current history to the history file\n"
#~ "    \t\tand append them to the history list\n"
#~ "    \n"
#~ "      -p\tperform history expansion on each ARG and display the result\n"
#~ "    \t\twithout storing it in the history list\n"
#~ "      -s\tappend the ARGs to the history list as a single entry\n"
#~ "    \n"
#~ "    If FILENAME is given, it is used as the history file.  Otherwise,\n"
#~ "    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
#~ "    \n"
#~ "    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
#~ "    as a format string for strftime(3) to print the time stamp associated\n"
#~ "    with each displayed history entry.  No time stamps are printed otherwise.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is given or an error occurs."
#~ msgstr ""
#~ "Exibe ou manipula a lista de histórico.\n"
#~ "    \n"
#~ "    Exibe a lista de histórico com números de linhas, prefixando cada\n"
#~ "    entrada modificada com um `*'.  Um argumento de N lista apenas as\n"
#~ "    últimas N entradas.\n"
#~ "    \n"
#~ "    Opções:\n"
#~ "      -c\t\t\tlimpa a lista de histórico ao excluir todas as entradas\n"
#~ "      -d POSIÇÃO\texclui a entrada de histórico na posição POSIÇÃO.\n"
#~ "      -a\t\t\tanexa linhas de histórico desta sessão no arquivo de\n"
#~ "      \t\t\t\thistórico\n"
#~ "      -n\t\t\tlê todas as linhas de histórico ainda não lidas do\n"
#~ "      \t\t\t\tarquivo de histórico\n"
#~ "      -r\t\t\tlê o histórico e anexa os conteúdos à lista de histórico\n"
#~ "      -w\t\t\tescreve o histórico atual para o arquivo de histórico e\n"
#~ "      \t\t\t\tanexa-os à lista de histórico    \n"
#~ "      -p\t\t\texecuta expansão de histórico em cada ARG e exibe o\n"
#~ "      \t\t\t\tresultado sem armazená-lo na lista de histórico\n"
#~ "      -s\t\t\tanexa os ARGs à lista de histórico como uma única entrada\n"
#~ "    \n"
#~ "    Se ARQUIVO for fornecido, ele é usado como o arquivo de histórico.\n"
#~ "    Do contrário, se a variável HISTFILE tiver um valor, este será usado;\n"
#~ "    senão, usa de ~/.bash_history.\n"
#~ "    \n"
#~ "    Se a variável HISTTIMEFORMAT for definida e não for nula, seu valor é\n"
#~ "    usado como uma string de formato para strftime(3) para mostrar a marca\n"
#~ "    de tempo associada com cada entrada de histórico exibida. Do contrário,\n"
#~ "    nenhuma marca de tempo é mostrada.\n"
#~ "    \n"
#~ "    Status de saída:\n"
#~ "    Retorna sucesso, a menos que uma opção inválida seja fornecida ou\n"
#~ "    ocorra um erro."

# help kill
#~ msgid ""
#~ "Send a signal to a job.\n"
#~ "    \n"
#~ "    Send the processes identified by PID or JOBSPEC the signal named by\n"
#~ "    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
#~ "    SIGTERM is assumed.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -s sig\tSIG is a signal name\n"
#~ "      -n sig\tSIG is a signal number\n"
#~ "      -l\tlist the signal names; if arguments follow `-l' they are\n"
#~ "    \t\tassumed to be signal numbers for which names should be listed\n"
#~ "    \n"
#~ "    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
#~ "    instead of process IDs, and allows processes to be killed if the limit\n"
#~ "    on processes that you can create is reached.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is given or an error occurs."
#~ msgstr ""
#~ "Envia um sinal para um trabalho.\n"
#~ "\n"
#~ "    Envia aos processos identificados pelo PID ou pelo ESPEC-JOB o sinal\n"
#~ "    informado por SIGSPEC ou SIGNUM. Se SIGSPEC e SIGNUM\n"
#~ "    não estiverem presentes, então, SIGTERM é presumido.\n"
#~ "    \n"
#~ "    Opções:\n"
#~ "      -s SIGSPEC\tSIGSPEC especifica o nome do sinal\n"
#~ "      -n SIGNUM\t\tSIGNUM representa um número de sinal\n"
#~ "      -l\t\t\tlista os nomes dos sinais; se `-l' for acompanhado por\n"
#~ "      \t\t\t\toutros argumentos, presume-se estes sejam números de\n"
#~ "      \t\t\t\tsinais para os quais nomes deveriam ser listados\n"
#~ "    \n"
#~ "    `Kill' é um comando interno do shell por duas razões: ele permite\n"
#~ "    IDs de trabalho serem usados ao invés de IDs de processo e permite\n"
#~ "    que processos sejam matados caso o limite de processos que você pode\n"
#~ "    criar seja atingido.\n"
#~ "    \n"
#~ "    Status de saída:\n"
#~ "    Retorna sucesso, a menos que uma opção inválida seja fornecida ou\n"
#~ "    ocorra um erro."

# help set
#~ msgid ""
#~ "Set or unset values of shell options and positional parameters.\n"
#~ "    \n"
#~ "    Change the value of shell attributes and positional parameters, or\n"
#~ "    display the names and values of shell variables.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -a  Mark variables which are modified or created for export.\n"
#~ "      -b  Notify of job termination immediately.\n"
#~ "      -e  Exit immediately if a command exits with a non-zero status.\n"
#~ "      -f  Disable file name generation (globbing).\n"
#~ "      -h  Remember the location of commands as they are looked up.\n"
#~ "      -k  All assignment arguments are placed in the environment for a\n"
#~ "          command, not just those that precede the command name.\n"
#~ "      -m  Job control is enabled.\n"
#~ "      -n  Read commands but do not execute them.\n"
#~ "      -o option-name\n"
#~ "          Set the variable corresponding to option-name:\n"
#~ "              allexport    same as -a\n"
#~ "              braceexpand  same as -B\n"
#~ "              emacs        use an emacs-style line editing interface\n"
#~ "              errexit      same as -e\n"
#~ "              errtrace     same as -E\n"
#~ "              functrace    same as -T\n"
#~ "              hashall      same as -h\n"
#~ "              histexpand   same as -H\n"
#~ "              history      enable command history\n"
#~ "              ignoreeof    the shell will not exit upon reading EOF\n"
#~ "              interactive-comments\n"
#~ "                           allow comments to appear in interactive commands\n"
#~ "              keyword      same as -k\n"
#~ "              monitor      same as -m\n"
#~ "              noclobber    same as -C\n"
#~ "              noexec       same as -n\n"
#~ "              noglob       same as -f\n"
#~ "              nolog        currently accepted but ignored\n"
#~ "              notify       same as -b\n"
#~ "              nounset      same as -u\n"
#~ "              onecmd       same as -t\n"
#~ "              physical     same as -P\n"
#~ "              pipefail     the return value of a pipeline is the status of\n"
#~ "                           the last command to exit with a non-zero status,\n"
#~ "                           or zero if no command exited with a non-zero status\n"
#~ "              posix        change the behavior of bash where the default\n"
#~ "                           operation differs from the Posix standard to\n"
#~ "                           match the standard\n"
#~ "              privileged   same as -p\n"
#~ "              verbose      same as -v\n"
#~ "              vi           use a vi-style line editing interface\n"
#~ "              xtrace       same as -x\n"
#~ "      -p  Turned on whenever the real and effective user ids do not match.\n"
#~ "          Disables processing of the $ENV file and importing of shell\n"
#~ "          functions.  Turning this option off causes the effective uid and\n"
#~ "          gid to be set to the real uid and gid.\n"
#~ "      -t  Exit after reading and executing one command.\n"
#~ "      -u  Treat unset variables as an error when substituting.\n"
#~ "      -v  Print shell input lines as they are read.\n"
#~ "      -x  Print commands and their arguments as they are executed.\n"
#~ "      -B  the shell will perform brace expansion\n"
#~ "      -C  If set, disallow existing regular files to be overwritten\n"
#~ "          by redirection of output.\n"
#~ "      -E  If set, the ERR trap is inherited by shell functions.\n"
#~ "      -H  Enable ! style history substitution.  This flag is on\n"
#~ "          by default when the shell is interactive.\n"
#~ "      -P  If set, do not resolve symbolic links when executing commands\n"
#~ "          such as cd which change the current directory.\n"
#~ "      -T  If set, the DEBUG trap is inherited by shell functions.\n"
#~ "      --  Assign any remaining arguments to the positional parameters.\n"
#~ "          If there are no remaining arguments, the positional parameters\n"
#~ "          are unset.\n"
#~ "      -   Assign any remaining arguments to the positional parameters.\n"
#~ "          The -x and -v options are turned off.\n"
#~ "    \n"
#~ "    Using + rather than - causes these flags to be turned off.  The\n"
#~ "    flags can also be used upon invocation of the shell.  The current\n"
#~ "    set of flags may be found in $-.  The remaining n ARGs are positional\n"
#~ "    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
#~ "    ARGs are given, all shell variables are printed.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is given."
#~ msgstr ""
#~ "Define ou remove definição de valores das opções e dos parâmetros posicionais\n"
#~ "do shell:\n"
#~ "    \n"
#~ "    Altera o valor de opções e de parâmetros posicionais do shell ou mostra\n"
#~ "    os nomes ou valores de variáveis shell.\n"
#~ "    \n"
#~ "    Opções:\n"
#~ "      -a  Marca variáveis, que foram modificadas ou criadas, para exportação.\n"
#~ "      -b  Notifica sobre terminação de trabalho imediatamente.\n"
#~ "      -e  Sai imediatamente se um comando sai com um status não-zero.\n"
#~ "      -f  Desabilita a geração de nome de arquivo (\"globbing\").\n"
#~ "      -h  Memoriza a localização de comandos à medida em que são procurados.\n"
#~ "      -k  Todos argumentos de atribuição são colocados no ambiente para um\n"
#~ "          comando, e não apenas aqueles que precedem o nome do comando.\n"
#~ "      -m  Controle de trabalho está habilitado.\n"
#~ "      -n  Lê comandos, mas não os executa.\n"
#~ "      -o NOME-OPÇÃO\n"
#~ "          Define a variável correspondendo a NOME-OPÇÃO:\n"
#~ "              allexport    mesmo que -a\n"
#~ "              braceexpand  mesmo que -B\n"
#~ "              emacs        usa interface de edição de linha estilo Emacs\n"
#~ "              errexit      mesmo que -e\n"
#~ "              errtrace     mesmo que -E\n"
#~ "              functrace    mesmo que -T\n"
#~ "              hashall      mesmo que -h\n"
#~ "              histexpand   mesmo que -H\n"
#~ "              history      habilita histórico de comandos\n"
#~ "              ignoreeof    shell não vai sair após leitura de EOF\n"
#~ "              interactive-comments\n"
#~ "                           permite mostrar comentários em comandos interativos\n"
#~ "              keyword      mesmo que -k\n"
#~ "              monitor      mesmo que -m\n"
#~ "              noclobber    mesmo que -C\n"
#~ "              noexec       mesmo que -n\n"
#~ "              noglob       mesmo que -f\n"
#~ "              nolog        atualmente aceito, mas ignorado\n"
#~ "              notify       mesmo que -b\n"
#~ "              nounset      mesmo que -u\n"
#~ "              onecmd       mesmo que -t\n"
#~ "              physical     mesmo que -P\n"
#~ "              pipefail     o valor de retorno de uma linha de comandos é o\n"
#~ "                           status do último comando a sair com status não-zero,\n"
#~ "                           ou zero se nenhum comando saiu com status não zero\n"
#~ "              posix        altera o comportamento do bash, onde a operação\n"
#~ "                           padrão diverge dos padrões do Posix para\n"
#~ "                           corresponder a estes padrões\n"
#~ "              privileged   mesmo que -p\n"
#~ "              verbose      mesmo que -v\n"
#~ "              vi           usa interface de edição de linha estilo vi\n"
#~ "              xtrace       mesmo que -x\n"
#~ "      -p  Ligado sempre que IDs de usuário real e efetivo não corresponderem.\n"
#~ "          Desabilita processamento do arquivo $ENV e importação de funções da\n"
#~ "          shell. Ao desligar essa opção, causa o uid e o gid efetivo serem\n"
#~ "          os uid e gid reais.\n"
#~ "      -t  Sai após a leitura e execução de um comando.\n"
#~ "      -u  Trata limpeza (unset) de variáveis como um erro quando substituindo.\n"
#~ "      -v  Mostra linhas de entrada do shell na medida em que forem lidas.\n"
#~ "      -x  Mostra comandos e seus argumentos na medida em que forme executados.\n"
#~ "      -B  o shell vai realizar expansão de chaves\n"
#~ "      -C  Se definido, não permite arquivos normais existentes serem\n"
#~ "          sobrescritos por redirecionamento da saída.\n"
#~ "      -E  Se definido, a armadilha ERR é herdada por funções do shell.\n"
#~ "      -H  Habilita substituição de histórico estilo \"!\". Essa sinalização está\n"
#~ "          habilitada por padrão quando  shell é interativa.\n"
#~ "      -P  Se definida, não resolve links simbólicos ao sair de comandos, tais\n"
#~ "          como `cd' (que altera o diretório atual).\n"
#~ "      -T  Se definido, a armadilha DEBUG é herdada por funções do shell.\n"
#~ "      --  Atribui quaisquer argumentos restantes aos parâmetros posicionais.\n"
#~ "          Se não houver argumentos restantes, os parâmetros posicionais são\n"
#~ "          limpos (unset).\n"
#~ "      -   Atribui quaisquer argumentos restantes aos parâmetros posicionais.\n"
#~ "          As opções -x e -v são desligadas.\n"
#~ "    \n"
#~ "    Usar +, ao invés de -, causa essas sinalizações serem desligadas. As\n"
#~ "    sinalizações também podem ser usadas por meio de chamada do shell. As\n"
#~ "    sinalizações atualmente definidas podem ser encontradas em $-. Os n ARGs\n"
#~ "    restantes são parâmetros posicionais e são atribuídos, em ordem, a $1, $2,\n"
#~ "    .. $n. Se nenhuma ARG for fornecido, todas as variáveis shell são\n"
#~ "    mostradas.\n"
#~ "    \n"
#~ "    Status de saída:\n"
#~ "    Retorna sucesso, a menos que uma opção inválida seja fornecida."

# help coproc
#~ msgid ""
#~ "Create a coprocess named NAME.\n"
#~ "    \n"
#~ "    Execute COMMAND asynchronously, with the standard output and standard\n"
#~ "    input of the command connected via a pipe to file descriptors assigned\n"
#~ "    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
#~ "    The default NAME is \"COPROC\".\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns the exit status of COMMAND."
#~ msgstr ""
#~ "Cria um coprocesso chamado NOME.\n"
#~ "    \n"
#~ "    Executa COMANDO assincronamente, com a saída padrão e entrada padrão\n"
#~ "    do comando conectados via um `pipe' (redirecionamento) para descritores\n"
#~ "    de arquivo atribuídos para índices 0 e 1 de uma variável array NOME\n"
#~ "    no shell em execução. O NOME padrão é \"COPROC\".\n"
#~ "    \n"
#~ "    Status de saída:\n"
#~ "    Retorna o status de saída de COMANDO."

#~ msgid "Missing `}'"
#~ msgstr "Faltando `}'"

#~ msgid "brace_expand> "
#~ msgstr "brace_expand> "

#~ msgid "Attempt to free unknown command type `%d'.\n"
#~ msgstr "Tentativa de liberar um tipo de comando desconhecido `%d'.\n"

#~ msgid "Report this to %s\n"
#~ msgstr "Informar o ocorrido para %s\n"

#~ msgid "Stopping myself..."
#~ msgstr "Parando-me..."

#~ msgid "Tell %s to fix this someday.\n"
#~ msgstr "Informar %s para corrigir o ocorrido.\n"

#~ msgid "execute_command: bad command type `%d'"
#~ msgstr "execute_command: `%d' é um tipo incorreto de comando "

#~ msgid "real\t"
#~ msgstr "real\t"

#~ msgid "user\t"
#~ msgstr "usuário\t"

#~ msgid "sys\t"
#~ msgstr "sistema\t"

#~ msgid ""
#~ "real\t0m0.00s\n"
#~ "user\t0m0.00s\n"
#~ "sys\t0m0.00s\n"
#~ msgstr ""
#~ "real   \t0m0.00s\n"
#~ "usuário\t0m0.00s\n"
#~ "sistema\t0m0.00s\n"

#~ msgid "cannot duplicate fd %d to fd 1: %s"
#~ msgstr "impossível duplicar fd (descritor de arquivo) %d para fd 1: %s"

#~ msgid "%s: output redirection restricted"
#~ msgstr "%s: redirecionamento da saída restringido"

#~ msgid "Out of memory!"
#~ msgstr "Memória esgotada!"

#~ msgid "You have already added item `%s'\n"
#~ msgstr "Você já adicionou o item `%s'\n"

#~ msgid "You have entered %d (%d) items.  The distribution is:\n"
#~ msgstr "Entrados %d (%d) itens.  A distribuição é:\n"

#~ msgid "slot %3d: "
#~ msgstr "encaixe (slot) %3d: "

#~ msgid "<unknown>"
#~ msgstr "<desconhecido>"

#~ msgid "%s: bg background job?"
#~ msgstr "%s: bg trabalho no segundo plano?"

#~ msgid ""
#~ "Redirection instruction from yyparse () '%d' is\n"
#~ "out of range in make_redirection ()."
#~ msgstr ""
#~ "A instrução de redirecionamento do yyparse () '%d' está\n"
#~ "fora do intervalo em make_redirection ()."

#~ msgid "clean_simple_command () got a command with type %d."
#~ msgstr "clean_simple_command () recebeu um comando do tipo %d."

#~ msgid "got errno %d while waiting for %d"
#~ msgstr "recebido erro número %d enquanto aguardava por %d"

#~ msgid "syntax error near unexpected token `%c'"
#~ msgstr "erro de sintaxe próximo do `token' não esperado `%c'"

#~ msgid "print_command: bad command type `%d'"
#~ msgstr "print_command: tipo de comando incorreto `%d'"

#~ msgid "cprintf: bad `%%' argument (%c)"
#~ msgstr "cprintf: argumento `%%' incorreto (%c)"

#~ msgid "option `%s' requires an argument"
#~ msgstr "a opção `%s' requer um argumento"

#~ msgid "%s: unrecognized option"
#~ msgstr "%s: a opção não é reconhecida"

#~ msgid "`-c' requires an argument"
#~ msgstr "A opção `-c' requer um argumento"

#~ msgid "%s: cannot execute directories"
#~ msgstr "%s: impossível executar diretórios"

#~ msgid "Bad code in sig.c: sigprocmask"
#~ msgstr "Código incorreto em sig.c: sigprocmask"

#~ msgid "can't make pipes for process substitution: %s"
#~ msgstr "impossível criar `pipes' para a substituição do processo: %s"

#~ msgid "reading"
#~ msgstr "lendo"

#~ msgid "writing"
#~ msgstr "escrevendo"

#~ msgid "process substitution"
#~ msgstr "substituição de processo"

#~ msgid "command substitution"
#~ msgstr "substituição de comando"

#~ msgid "Can't reopen pipe to command substitution (fd %d): %s"
#~ msgstr "Impossível reabrir o `pipe' para substituição de comando (fd %d): %s"

#~ msgid "$%c: unbound variable"
#~ msgstr "$%c: variável não associada"

#~ msgid "%s: bad arithmetic substitution"
#~ msgstr "%s: substituição aritmética incorreta"

#~ msgid "-%s: binary operator expected"
#~ msgstr "-%s: esperado operador binário"

#~ msgid "%s[%s: bad subscript"
#~ msgstr "%s[%s: índice incorreto"

#~ msgid "[%s: bad subscript"
#~ msgstr "[%s: índice incorreto"

#~ msgid "xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr "xrealloc: impossível realocar %lu bytes (%lu bytes alocados)"

#~ msgid "digits occur in two different argv-elements.\n"
#~ msgstr "os dígitos aparecem em dois elementos argv diferentes.\n"

#~ msgid "option %c\n"
#~ msgstr "opção %c\n"

#~ msgid "option a\n"
#~ msgstr "opção a\n"

#~ msgid "option b\n"
#~ msgstr "opção b\n"

#~ msgid "option c with value `%s'\n"
#~ msgstr "opção c com o valor `%s'\n"

#~ msgid "?? sh_getopt returned character code 0%o ??\n"
#~ msgstr "?? sh_getopt retornou o código de caracter 0%o ??\n"

#~ msgid "non-option ARGV-elements: "
#~ msgstr "elementos de ARGV que não são opção:"

#~ msgid "%s: Unknown flag %s.\n"
#~ msgstr "%s: Opção %s desconhecida.\n"

#~ msgid "Unknown directive `%s'"
#~ msgstr "Diretiva desconhecida `%s'"

#~ msgid "%s must be inside of a $BUILTIN block"
#~ msgstr "%s deve estar dentro de um bloco $BUILTIN"

#~ msgid "%s found before $END"
#~ msgstr "%s encontrado antes de $END"

#~ msgid "%s already has a function (%s)"
#~ msgstr "%s já possui uma função (%s)"

#~ msgid "%s already had a docname (%s)"
#~ msgstr "%s já possui um nome de documento (%s)"

#~ msgid "%s already has short documentation (%s)"
#~ msgstr "%s já possui uma documentação curta (%s)"

#~ msgid "%s already has a %s definition"
#~ msgstr "%s já possui a definição %s"

#~ msgid "mkbuiltins: Out of virtual memory!\n"
#~ msgstr "mkbuiltins: Memória virtual esgotada!\n"

#~ msgid "read [-r] [-p prompt] [-a array] [-e] [name ...]"
#~ msgstr "read [-r] [-p MENSAGEM] [-a ARRAY] [-e] [NOME ...]"

#~ msgid "%[DIGITS | WORD] [&]"
#~ msgstr "%[DÍGITOS | PALAVRA] [&]"

#~ msgid "variables - Some variable names and meanings"
#~ msgstr "variáveis - Alguns nomes de variáveis e suas descrições"

#~ msgid "`alias' with no arguments or with the -p option prints the list"
#~ msgstr "`alias' sem nenhum argumento, ou com a opção -p, exibe a lista"

#~ msgid "of aliases in the form alias NAME=VALUE on standard output."
#~ msgstr "de aliases na forma `alias NOME=VALOR' na saída padrão."

#~ msgid "Otherwise, an alias is defined for each NAME whose VALUE is given."
#~ msgstr "Ou então, um alias é definido para cada NOME cujo VALOR for fornecido."

#~ msgid "A trailing space in VALUE causes the next word to be checked for"
#~ msgstr "Um espaço após VALOR faz a próxima palavra ser verificada para"

#~ msgid "alias substitution when the alias is expanded.  Alias returns"
#~ msgstr "substituição do alias quando o alias é expandido. Alias retorna"

#~ msgid "true unless a NAME is given for which no alias has been defined."
#~ msgstr "verdadeiro, a não ser que seja fornecido um NOME sem alias definido."

#~ msgid "Remove NAMEs from the list of defined aliases.  If the -a option is given,"
#~ msgstr "Remove NOMEs da lista de aliases definidos. Se a opção -a for fornecida,"

#~ msgid "then remove all alias definitions."
#~ msgstr "então todas as definições de alias são removidas."

#~ msgid "Bind a key sequence to a Readline function, or to a macro.  The"
#~ msgstr "Víncula uma sequência de teclas a uma função de leitura de linha, ou a uma"

#~ msgid "syntax is equivalent to that found in ~/.inputrc, but must be"
#~ msgstr "macro.  A sintaxe é equivalente à encontrada em ~/.inputrc, mas deve ser"

#~ msgid "passed as a single argument: bind '\"\\C-x\\C-r\": re-read-init-file'."
#~ msgstr "passada como um único argumento: bind '\"\\C-x\\C-r\": re-read-init-file'."

#~ msgid "Arguments we accept:"
#~ msgstr "Argumentos permitidos:"

#~ msgid "  -m  keymap         Use `keymap' as the keymap for the duration of this"
#~ msgstr "  -m  MAPA-TECLAS    Usar `MAPA-TECLAS' como mapa das teclas pela duração"

#~ msgid "                     command.  Acceptable keymap names are emacs,"
#~ msgstr "                     deste comando.  Os nomes aceitos são emacs,"

#~ msgid "                     emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,"
#~ msgstr "                     emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,"

#~ msgid "                     vi-command, and vi-insert."
#~ msgstr "                     vi-command, and vi-insert."

#~ msgid "  -l                 List names of functions."
#~ msgstr "  -l                 Listar os nomes das funções."

#~ msgid "  -P                 List function names and bindings."
#~ msgstr "  -P                 Listar nomes e associações das funções."

#~ msgid "  -p                 List functions and bindings in a form that can be"
#~ msgstr "  -p                 Listar nomes e associações das funções de uma forma"

#~ msgid "                     reused as input."
#~ msgstr "                     que pode ser reutilizada como entrada."

#~ msgid "  -r  keyseq         Remove the binding for KEYSEQ."
#~ msgstr "  -r  SEQ-TECLAS     Remove o vínculo para SEQ-TECLAS."

#~ msgid "  -f  filename       Read key bindings from FILENAME."
#~ msgstr "  -f  ARQUIVO        Ler os vínculos das teclas em ARQUIVO."

#~ msgid "  -q  function-name  Query about which keys invoke the named function."
#~ msgstr "  -q  NOME-FUNÇÃO    Consultar quais teclas chamam esta função."

#~ msgid "  -V                 List variable names and values"
#~ msgstr "  -V                 Listar os nomes e os valores das variáveis."

#~ msgid "  -v                 List variable names and values in a form that can"
#~ msgstr "  -v                 Listar os nomes e os valores das variáveis de uma"

#~ msgid "                     be reused as input."
#~ msgstr "                     forma que pode ser reutilizada como entrada."

#~ msgid "  -S                 List key sequences that invoke macros and their values"
#~ msgstr ""
#~ "  -S                 Listar as sequências de teclas que chamam macros\n"
#~ "                         e seus valores."

#~ msgid "  -s                 List key sequences that invoke macros and their values in"
#~ msgstr "  -s                 Listar sequências de teclas que chamam macros"

#~ msgid "                     a form that can be reused as input."
#~ msgstr ""
#~ "                     e seus valores de uma forma que pode ser\n"
#~ "                         reutilizada como entrada."

#~ msgid "Exit from within a FOR, WHILE or UNTIL loop.  If N is specified,"
#~ msgstr "Sair de um laço FOR, WHILE ou UNTIL."

#~ msgid "break N levels."
#~ msgstr "Se N for especificado, sai de N níveis."

#~ msgid "Resume the next iteration of the enclosing FOR, WHILE or UNTIL loop."
#~ msgstr "Prossegue no próximo ciclo do laço FOR, WHILE ou UNTIL envolvente."

#~ msgid "If N is specified, resume at the N-th enclosing loop."
#~ msgstr "Se N for especificado, prossegue no N-ésimo laço envolvente."

#~ msgid "Run a shell builtin.  This is useful when you wish to rename a"
#~ msgstr "Executa um comando interno do shell.  Útil quando desejamos substituir"

#~ msgid "shell builtin to be a function, but need the functionality of the"
#~ msgstr "um comando interno do shell por uma função, mas necessitamos da"

#~ msgid "builtin within the function itself."
#~ msgstr "funcionalidade do comando interno dentro da própria função."

#~ msgid "Change the current directory to DIR.  The variable $HOME is the"
#~ msgstr "Troca o diretório atual para DIR.  A variável $HOME é o padrão"

#~ msgid "default DIR.  The variable $CDPATH defines the search path for"
#~ msgstr "para DIR.  A variável $CDPATH define o caminho de procura para"

#~ msgid "the directory containing DIR.  Alternative directory names in CDPATH"
#~ msgstr "o diretório que contém DIR.  Nomes de diretórios alternativos em CDPATH"

#~ msgid "are separated by a colon (:).  A null directory name is the same as"
#~ msgstr "são separados por dois pontos (:).  Um nome de diretório nulo é o mesmo"

#~ msgid "the current directory, i.e. `.'.  If DIR begins with a slash (/),"
#~ msgstr "que o diretório atual, i.e. `.'.  Se DIR inicia com uma barra (/),"

#~ msgid "then $CDPATH is not used.  If the directory is not found, and the"
#~ msgstr "então $CDPATH não é usado.  Se o diretório não for encontrado, e a"

#~ msgid "shell option `cdable_vars' is set, then try the word as a variable"
#~ msgstr "opção `cdable_vars' estiver definida, tentar usar DIR como um nome de"

#~ msgid "name.  If that variable has a value, then cd to the value of that"
#~ msgstr "variável.  Se esta variável tiver valor, então `cd' para o valor desta"

#~ msgid "variable.  The -P option says to use the physical directory structure"
#~ msgstr "variável.  A opção -P indica para usar a estrutura física do diretório"

#~ msgid "instead of following symbolic links; the -L option forces symbolic links"
#~ msgstr "em vez de seguir os vínculos simbólicos; a opção -L força seguir os"

#~ msgid "to be followed."
#~ msgstr "vínculos simbólicos."

#~ msgid "Print the current working directory.  With the -P option, pwd prints"
#~ msgstr "Exibe o diretório atual de trabalho.  Com a opção -P, `pwd' exibe"

#~ msgid "the physical directory, without any symbolic links; the -L option"
#~ msgstr "o diretório físico, sem nenhum vínculo simbólico; a opção -L faz"

#~ msgid "makes pwd follow symbolic links."
#~ msgstr "com que `pwd' siga os vínculos simbólicos."

#~ msgid "Runs COMMAND with ARGS ignoring shell functions.  If you have a shell"
#~ msgstr "Executa COMANDO com ARGs ignorando as funções da shell.  Ex: Havendo"

#~ msgid "function called `ls', and you wish to call the command `ls', you can"
#~ msgstr "uma função `ls', e se for necessário executar o comando `ls', executa-se"

#~ msgid "say \"command ls\".  If the -p option is given, a default value is used"
#~ msgstr "\"command ls\".  Se a opção -p for fornecida, o valor padrão é utilizado"

#~ msgid "for PATH that is guaranteed to find all of the standard utilities.  If"
#~ msgstr "para PATH, garantindo-se o encontro de todos os utilitários padrão. Se"

#~ msgid "the -V or -v option is given, a string is printed describing COMMAND."
#~ msgstr "a opção -V ou -v for fornecida, é exibida a descrição do COMANDO."

#~ msgid "The -V option produces a more verbose description."
#~ msgstr "A opção -V produz uma descrição mais extensa."

#~ msgid "Declare variables and/or give them attributes.  If no NAMEs are"
#~ msgstr "Declara variáveis e/ou dá-lhes atributos.  Se nenhum nome for"

#~ msgid "given, then display the values of variables instead.  The -p option"
#~ msgstr "fornecido, então são exibidos os valores das variáveis.  A opção -p"

#~ msgid "will display the attributes and values of each NAME."
#~ msgstr "exibe os atributos e valores para cada NOME."

#~ msgid "The flags are:"
#~ msgstr "As opções são:"

#~ msgid "  -a\tto make NAMEs arrays (if supported)"
#~ msgstr "  -a\tpara tornar NOMEs arrays, se houver suporte"

#~ msgid "  -f\tto select from among function names only"
#~ msgstr "  -f\tpara selecionar somente entre nomes de funções"

#~ msgid "  -F\tto display function names without definitions"
#~ msgstr "  -F\tpara exibir os nomes das funções omitindo suas definições"

#~ msgid "  -r\tto make NAMEs readonly"
#~ msgstr "  -r\tpara tornar NOMEs somente para leitura"

#~ msgid "  -x\tto make NAMEs export"
#~ msgstr "  -x\tpara fazer a exportação de NOMEs"

#~ msgid "  -i\tto make NAMEs have the `integer' attribute set"
#~ msgstr "  -i\tpara ativar o atributo `inteiro' em NOMEs "

#~ msgid "Variables with the integer attribute have arithmetic evaluation (see"
#~ msgstr "Variáveis com atributo inteiro são avaliadas aritmeticamente (veja"

#~ msgid "`let') done when the variable is assigned to."
#~ msgstr "`let') quando é feita uma atribuição de valor."

#~ msgid "When displaying values of variables, -f displays a function's name"
#~ msgstr "Ao exibir os valores das variáveis, -f exibe o nome da função e"

#~ msgid "and definition.  The -F option restricts the display to function"
#~ msgstr "sua definição.  A opção -F restringe a exibição ao nome da função"

#~ msgid "name only."
#~ msgstr "somente."

#~ msgid "Using `+' instead of `-' turns off the given attribute instead.  When"
#~ msgstr "Usando `+' em vez de `-' faz o atributo ser desabilitado.  Quando"

#~ msgid "used in a function, makes NAMEs local, as with the `local' command."
#~ msgstr "usado em uma função, torna NOMEs local, como no comando `local'."

#~ msgid "Obsolete.  See `declare'."
#~ msgstr "Obsoleta.  Veja `declare'."

#~ msgid "Create a local variable called NAME, and give it VALUE.  LOCAL"
#~ msgstr "Cria uma variável local chamada NOME, e atribui VALOR.  LOCAL"

#~ msgid "have a visible scope restricted to that function and its children."
#~ msgstr "da variável NOME fique restrito à própria função e às suas filhas."

#~ msgid "Output the ARGs.  If -n is specified, the trailing newline is"
#~ msgstr "Exibe ARGs.  Se -n for fornecido, o caracter final de nova linha é"

#~ msgid "suppressed.  If the -e option is given, interpretation of the"
#~ msgstr "suprimido.  Se a opção -e for fornecida, a interpretação dos seguintes"

#~ msgid "following backslash-escaped characters is turned on:"
#~ msgstr "caracteres após a contrabarra é ativada:"

#~ msgid "\t\\a\talert (bell)"
#~ msgstr "\t\\a\talerta (bell)"

#~ msgid "\t\\b\tbackspace"
#~ msgstr "\t\\b\tbackspace"

#~ msgid "\t\\c\tsuppress trailing newline"
#~ msgstr "\t\\c\tsuprimir o caracter final de nova linha"

#~ msgid "\t\\E\tescape character"
#~ msgstr "\t\\E\to caracter de escape"

#~ msgid "\t\\f\tform feed"
#~ msgstr "\t\\f\talimentação de formulário (form feed)"

#~ msgid "\t\\n\tnew line"
#~ msgstr "\t\\n\tnova linha"

#~ msgid "\t\\r\tcarriage return"
#~ msgstr "\t\\r\tretorno de carro (cr)"

#~ msgid "\t\\t\thorizontal tab"
#~ msgstr "\t\\t\ttabulação horizontal (ht)"

#~ msgid "\t\\v\tvertical tab"
#~ msgstr "\t\\v\ttabulação vertical (vt)"

#~ msgid "\t\\\\\tbackslash"
#~ msgstr "\t\\\\\tcontrabarra"

#~ msgid "\t\\num\tthe character whose ASCII code is NUM (octal)."
#~ msgstr "\t\\num\to caracter com código ASCII igual a NUM (octal)."

#~ msgid "You can explicitly turn off the interpretation of the above characters"
#~ msgstr "Pode-se explicitamente desabilitar a interpretação dos caracteres acima"

#~ msgid "with the -E option."
#~ msgstr "através da opção -E."

#~ msgid "Output the ARGs.  If -n is specified, the trailing newline is suppressed."
#~ msgstr "Exibe ARGS.  Se -n for fornecido, o caracter final de nova linha é suprimido."

#~ msgid "Enable and disable builtin shell commands.  This allows"
#~ msgstr "Habilita e desabilita os comandos internos do shell, permitindo usar"

#~ msgid "you to use a disk command which has the same name as a shell"
#~ msgstr "um comando de disco que tenha o mesmo nome do comando interno do shell."

#~ msgid "builtin.  If -n is used, the NAMEs become disabled; otherwise"
#~ msgstr "Se -n for especificado, os NOMEs são desabilitados, senão os nomes são"

#~ msgid "NAMEs are enabled.  For example, to use the `test' found on your"
#~ msgstr "habilitados. Por exemplo, para usar `test' encontrado pelo PATH em vez"

#~ msgid "path instead of the shell builtin version, type `enable -n test'."
#~ msgstr "da versão interna do comando, digite `enable -n test'. Em sistemas que"

#~ msgid "On systems supporting dynamic loading, the -f option may be used"
#~ msgstr "suportam carregamento dinâmico, pode-se usar a opção -f para carregar"

#~ msgid "to load new builtins from the shared object FILENAME.  The -d"
#~ msgstr "novos comandos internos do objeto compartilhado ARQUIVO.  A opção -d"

#~ msgid "option will delete a builtin previously loaded with -f.  If no"
#~ msgstr "elimina os comandos internos previamente carregados com -f.  Se nenhum"

#~ msgid "non-option names are given, or the -p option is supplied, a list"
#~ msgstr "nome for fornecido, ou se a opção -p for fornecida, uma lista de comandos"

#~ msgid "of builtins is printed.  The -a option means to print every builtin"
#~ msgstr "internos é exibida.  A opção -a faz com que todos os comandos internos"

#~ msgid "with an indication of whether or not it is enabled.  The -s option"
#~ msgstr "sejam exibidos indicando se estão habilitados ou não.  A opção -s"

#~ msgid "restricts the output to the Posix.2 `special' builtins.  The -n"
#~ msgstr "restringe a saída aos comandos internos `especiais' Posix.2.  A opção"

#~ msgid "option displays a list of all disabled builtins."
#~ msgstr "-n exibe a lista de todos os comandos internos desabilitados."

#~ msgid "Read ARGs as input to the shell and execute the resulting command(s)."
#~ msgstr "Ler ARGs como entrada do shell e executar o(s) comando(s) resultante(s)."

#~ msgid "Getopts is used by shell procedures to parse positional parameters."
#~ msgstr ""
#~ "Getopts é utilizado pelos procedimentos do shell para fazer a leitura\n"
#~ "    (parse) dos parâmetros posicionais."

#~ msgid "OPTSTRING contains the option letters to be recognized; if a letter"
#~ msgstr "OPÇÕES contém as letras das opções a serem reconhecidas; Se uma"

#~ msgid "is followed by a colon, the option is expected to have an argument,"
#~ msgstr "letra é seguida por dois pontos, a opção espera a presença de um"

#~ msgid "which should be separated from it by white space."
#~ msgstr "argumento que deve ser separado dela por espaço em branco."

#~ msgid "Each time it is invoked, getopts will place the next option in the"
#~ msgstr "Cada vez que for chamada, `getopts' irá colocar a próxima opção na"

#~ msgid "shell variable $name, initializing name if it does not exist, and"
#~ msgstr "variável do shell $NOME, inicializando NOME caso não exista, e o"

#~ msgid "the index of the next argument to be processed into the shell"
#~ msgstr "índice do próximo argumento a ser processado dentro da variável da"

#~ msgid "variable OPTIND.  OPTIND is initialized to 1 each time the shell or"
#~ msgstr "shell OPTIND.  OPTIND é inicializado com 1 cada vez que o script"

#~ msgid "a shell script is invoked.  When an option requires an argument,"
#~ msgstr "do shell é chamado.  Quando uma opção requer um argumento, `getopts'"

#~ msgid "getopts places that argument into the shell variable OPTARG."
#~ msgstr "coloca este argumento dentro da variável do shell OPTARG."

#~ msgid "getopts reports errors in one of two ways.  If the first character"
#~ msgstr "`getopts' informa os erros de duas maneiras.  Se o primeiro caracter de"

#~ msgid "of OPTSTRING is a colon, getopts uses silent error reporting.  In"
#~ msgstr "OPÇÕES for dois pontos, `getopts' usa o modo silencioso.  Neste"

#~ msgid "this mode, no error messages are printed.  If an illegal option is"
#~ msgstr "modo, nenhuma mensagem de erro é exibida.  Se uma opção ilegal for"

#~ msgid "seen, getopts places the option character found into OPTARG.  If a"
#~ msgstr "encontrada, `getopts' coloca o caracter da opção em OPTARG.  Se um"

#~ msgid "required argument is not found, getopts places a ':' into NAME and"
#~ msgstr "argumento requerido não for encontrado, `getopts' coloca ':' em  NOME e"

#~ msgid "sets OPTARG to the option character found.  If getopts is not in"
#~ msgstr "atribui a OPTARG o caracter de opção encontrado. Se `getopts' não está em"

#~ msgid "silent mode, and an illegal option is seen, getopts places '?' into"
#~ msgstr "modo silencioso, e uma opção ilegal é encontrada, `getopts' coloca '?' em"

#~ msgid "NAME and unsets OPTARG.  If a required option is not found, a '?'"
#~ msgstr "NOME e desativa OPTARG.  Se uma opção requerida não é encontrada, uma '?'"

#~ msgid "is placed in NAME, OPTARG is unset, and a diagnostic message is"
#~ msgstr "é colocada em NOME, OPTARG é desativado, e uma mensagem de diagnóstico é"

#~ msgid "printed."
#~ msgstr "exibida."

#~ msgid "If the shell variable OPTERR has the value 0, getopts disables the"
#~ msgstr "Se a variável do shell OPTERR tem o valor 0, `getopts' desabilita a"

#~ msgid "printing of error messages, even if the first character of"
#~ msgstr "exibição de mensagens de erro, mesmo que o primeiro caracter de"

#~ msgid "OPTSTRING is not a colon.  OPTERR has the value 1 by default."
#~ msgstr "OPTSTRING não seja dois pontos.  OPTERR tem o valor 1 por padrão."

#~ msgid "Getopts normally parses the positional parameters ($0 - $9), but if"
#~ msgstr "`getopts' normalmente faz a leitura dos parãmetros posicionais ($0 - $9),"

#~ msgid "more arguments are given, they are parsed instead."
#~ msgstr "mas, se mais argumentos forem fornecidos, então estes são lidos."

#~ msgid "Exec FILE, replacing this shell with the specified program."
#~ msgstr "Executa ARQUIVO, substituindo esta shell pelo programa especificado."

#~ msgid "If FILE is not specified, the redirections take effect in this"
#~ msgstr "Se ARQUIVO não for especificado, os redirecionamentos são efetivados"

#~ msgid "shell.  If the first argument is `-l', then place a dash in the"
#~ msgstr "neste shell.  Se o primeiro argumento for `-l', coloca um hífen no"

#~ msgid "zeroth arg passed to FILE, as login does.  If the `-c' option"
#~ msgstr "argumento `0' passado para ARQUIVO, como no login.  Se a opção `-c'"

#~ msgid "is supplied, FILE is executed with a null environment.  The `-a'"
#~ msgstr "for fornecida, ARQUIVO é executado com um ambiente nulo.  A opção"

#~ msgid "option means to make set argv[0] of the executed process to NAME."
#~ msgstr "`-a' significa atribuir NOME para argv[0] do processo executado."

#~ msgid "If the file cannot be executed and the shell is not interactive,"
#~ msgstr "Se o arquivo não puder ser executado e o shell não for interativa,"

#~ msgid "then the shell exits, unless the variable \"no_exit_on_failed_exec\""
#~ msgstr "então o shell termina, a menos que a variável \"no_exit_on_failed_exec\""

#~ msgid "is set."
#~ msgstr "esteja inicializada."

#~ msgid "is that of the last command executed."
#~ msgstr "de saída é igual ao do último comando executado."

#~ msgid "FIRST and LAST can be numbers specifying the range, or FIRST can be a"
#~ msgstr "PRIMEIRO e ÚLTIMO podem ser números especificando o intervalo, ou"

#~ msgid "string, which means the most recent command beginning with that"
#~ msgstr "PRIMEIRO pode ser uma cadeia de caracteres, representando o comando"

#~ msgid "string."
#~ msgstr "mais recente começado por estes caracteres."

#~ msgid "   -e ENAME selects which editor to use.  Default is FCEDIT, then EDITOR,"
#~ msgstr "   -e EDITOR seleciona qual editor usar.  O padrão é FCEDIT, depois EDITOR,"

#~ msgid "      then the editor which corresponds to the current readline editing"
#~ msgstr "      depois o editor correspondente ao modo de edição atual da leitura"

#~ msgid "      mode, then vi."
#~ msgstr "      de linha, e depois o vi."

#~ msgid "   -l means list lines instead of editing."
#~ msgstr "   -l indica para listar as linha em vez de editá-las."

#~ msgid "   -n means no line numbers listed."
#~ msgstr "   -n indica para não listar os números das linhas."

#~ msgid "   -r means reverse the order of the lines (making it newest listed first)."
#~ msgstr "   -r faz reverter a ordem das linhas (a última torna-se a primeira)."

#~ msgid "With the `fc -s [pat=rep ...] [command]' format, the command is"
#~ msgstr "No formato `fc -s [ANTIGO=NOVO ...] [COMANDO]', o comando é executado"

#~ msgid "re-executed after the substitution OLD=NEW is performed."
#~ msgstr "novamente após a substituição de ANTIGO por NOVO ser realizada."

#~ msgid "A useful alias to use with this is r='fc -s', so that typing `r cc'"
#~ msgstr "Um alias útil a ser usado é r='fc -s' para que, ao se digitar `r cc',"

#~ msgid "runs the last command beginning with `cc' and typing `r' re-executes"
#~ msgstr "seja executado o último comando começado por `cc' e, ao se digitar"

#~ msgid "Place JOB_SPEC in the foreground, and make it the current job.  If"
#~ msgstr "Colocar JOB-ESPECIFICADO no primeiro plano, e torná-lo o trabalho atual."

#~ msgid "JOB_SPEC is not present, the shell's notion of the current job is"
#~ msgstr "Se JOB-ESPECIFICADO não estiver presente, a noção do shell do trabalho"

#~ msgid "used."
#~ msgstr "atual é utilizada."

#~ msgid "Place JOB_SPEC in the background, as if it had been started with"
#~ msgstr "Colocar JOB-ESPECIFICADO no segundo plano, como se tivesse sido ativado"

#~ msgid "`&'.  If JOB_SPEC is not present, the shell's notion of the current"
#~ msgstr "com `&'. Se JOB-ESPECIFICADO não estiver presente, a noção do shell"

#~ msgid "job is used."
#~ msgstr "do trabalho atual é utilizada."

#~ msgid "For each NAME, the full pathname of the command is determined and"
#~ msgstr "Para cada NOME, o caminho completo do comando é determinado e lembrado."

#~ msgid "remembered.  If the -p option is supplied, PATHNAME is used as the"
#~ msgstr "Se a opção -p for fornecida, CAMINHO é utilizado como o caminho completo"

#~ msgid "full pathname of NAME, and no path search is performed.  The -r"
#~ msgstr "para NOME, e nenhuma procura de caminho é realizada.  A opção -r"

#~ msgid "option causes the shell to forget all remembered locations.  If no"
#~ msgstr "faz com que a shell esqueça todas as localizações lembradas.  Sem nenhum"

#~ msgid "arguments are given, information about remembered commands is displayed."
#~ msgstr "argumento, as informações sobre os comandos lembrados são exibidas."

#~ msgid "Display helpful information about builtin commands.  If PATTERN is"
#~ msgstr "Exibe informações úteis sobre os comandos internos. Se PADRÃO for"

#~ msgid "specified, gives detailed help on all commands matching PATTERN,"
#~ msgstr "especificado, fornece ajuda detalhada para todos os comandos que"

#~ msgid "otherwise a list of the builtins is printed."
#~ msgstr "correspondem ao PADRÃO, senão a lista dos comandos internos é exibida."

#~ msgid "Display the history list with line numbers.  Lines listed with"
#~ msgstr "Exibe a lista histórica com os números das linhas. Linhas contendo um"

#~ msgid "with a `*' have been modified.  Argument of N says to list only"
#~ msgstr "`*' foram modificadas.  O argumento N faz listar somente as últimas"

#~ msgid "the last N lines.  The -c option causes the history list to be"
#~ msgstr "N linhas.  A opção -c faz com que a lista histórica seja apagada"

#~ msgid "cleared by deleting all of the entries.  The `-w' option writes out the"
#~ msgstr "removendo todas as entradas.  A opção `-w' escreve o histórico atual no"

#~ msgid "current history to the history file;  `-r' means to read the file and"
#~ msgstr "arquivo de histórico;  A opção `-r' significa ler o arquivo e apensar seu"

#~ msgid "append the contents to the history list instead.  `-a' means"
#~ msgstr "conteúdo à lista histórica.  A opção `-a' significa apensar as linhas de"

#~ msgid "to append history lines from this session to the history file."
#~ msgstr "histórico desta sessão ao arquivo de histórico."

#~ msgid "Argument `-n' means to read all history lines not already read"
#~ msgstr "A opção `-n' faz ler todas as linhas de histórico ainda não lidas"

#~ msgid "from the history file and append them to the history list.  If"
#~ msgstr "do arquivo histórico, e apensá-las à lista de histórico.  Se ARQUIVO"

#~ msgid "FILENAME is given, then that is used as the history file else"
#~ msgstr "for fornecido, então este é usado como arquivo de histórico, senão"

#~ msgid "if $HISTFILE has a value, that is used, else ~/.bash_history."
#~ msgstr "se $HISTFILE possui valor, este é usado, senão ~/.bash_history.  Se a"

#~ msgid "If the -s option is supplied, the non-option ARGs are appended to"
#~ msgstr "opção -s for fornecida, os ARGs, que não forem opções, são apensados à"

#~ msgid "the history list as a single entry.  The -p option means to perform"
#~ msgstr "lista histórica como uma única entrada. A opção -p significa realizar a"

#~ msgid "history expansion on each ARG and display the result, without storing"
#~ msgstr "expansão da história em cada ARG e exibir o resultado, sem armazenar"

#~ msgid "anything in the history list."
#~ msgstr "nada na lista de histórico."

#~ msgid "Lists the active jobs.  The -l option lists process id's in addition"
#~ msgstr "Lista os trabalhos ativos.  A opção -l lista os ID's dos processos além"

#~ msgid "to the normal information; the -p option lists process id's only."
#~ msgstr "das informações usuais;  a opção -p lista somente os ID's dos processos."

#~ msgid "If -n is given, only processes that have changed status since the last"
#~ msgstr "Se -n for fornecido, somente os processos que mudaram de status desde a"

#~ msgid "notification are printed.  JOBSPEC restricts output to that job.  The"
#~ msgstr "última notificação são exibidos.  JOB-ESPECIFICADO restringe a saída a este"

#~ msgid "-r and -s options restrict output to running and stopped jobs only,"
#~ msgstr "trabalho.  As opções -r e -s restringem a saída apenas aos trabalhos"

#~ msgid "respectively.  Without options, the status of all active jobs is"
#~ msgstr "executando e parados, respectivamente.  Sem opções, o status de todos os"

#~ msgid "printed.  If -x is given, COMMAND is run after all job specifications"
#~ msgstr "trabalhos ativos são exibidos.  Se -x for fornecido, COMANDO é executado"

#~ msgid "that appear in ARGS have been replaced with the process ID of that job's"
#~ msgstr "após todas as especificações de trabalho que aparecem em ARGS terem sido"

#~ msgid "process group leader."
#~ msgstr "substituídas pelo ID do processo líder deste grupo de processos."

#~ msgid "Removes each JOBSPEC argument from the table of active jobs."
#~ msgstr "Remove cada argumento JOB-ESPECIFICADO da tabela de trabalhos ativos."

#~ msgid "Send the processes named by PID (or JOB) the signal SIGSPEC.  If"
#~ msgstr "Envia ao processo identificado pelo PID (ou JOB) o sinal SIGSPEC.  Se"

#~ msgid "SIGSPEC is not present, then SIGTERM is assumed.  An argument of `-l'"
#~ msgstr "SIGSPEC não estiver presente, então SIGTERM é assumido.  A opção `-l'"

#~ msgid "lists the signal names; if arguments follow `-l' they are assumed to"
#~ msgstr "lista os nomes dos sinais;  havendo argumentos após `-l', são assumidos"

#~ msgid "be signal numbers for which names should be listed.  Kill is a shell"
#~ msgstr "como sendo os números dos sinais cujos nomes devem ser exibidos.  Kill"

#~ msgid "builtin for two reasons: it allows job IDs to be used instead of"
#~ msgstr "é um comando interno por duas razões: permite o uso do ID do trabalho em"

#~ msgid "process IDs, and, if you have reached the limit on processes that"
#~ msgstr "vez do ID do processo e, caso tenha sido atingido o limite de processos que"

#~ msgid "you can create, you don't have to start a process to kill another one."
#~ msgstr "podem ser criados, não é necessário um novo processo para remover outro."

#~ msgid "Each ARG is an arithmetic expression to be evaluated.  Evaluation"
#~ msgstr "Cada ARG é uma expressão aritmética a ser avaliada.  A avaliação é"

#~ msgid "is done in long integers with no check for overflow, though division"
#~ msgstr "feita usando inteiros longos sem verificar estouro, embora a divisão"

#~ msgid "by 0 is trapped and flagged as an error.  The following list of"
#~ msgstr "por 0 seja capturada e indicada como erro.  A lista abaixo está"

#~ msgid "operators is grouped into levels of equal-precedence operators."
#~ msgstr "grupada em níveis de igual de precedência dos operadores."

#~ msgid "The levels are listed in order of decreasing precedence."
#~ msgstr "Os níveis estão listados em ordem decrescente de precedência."

#~ msgid "\t-, +\t\tunary minus, plus"
#~ msgstr "\t-, +\t\tmenos, mais unários"

#~ msgid "\t!, ~\t\tlogical and bitwise negation"
#~ msgstr "\t!, ~\t\tnegação lógica e bit a bit"

#~ msgid "\t*, /, %\t\tmultiplication, division, remainder"
#~ msgstr "\t*, /, %\t\tmultiplicação, divisão, resto"

#~ msgid "\t+, -\t\taddition, subtraction"
#~ msgstr "\t+, -\t\tadição, subtração"

#~ msgid "\t<<, >>\t\tleft and right bitwise shifts"
#~ msgstr "\t<<, >>\t\tdeslocamento à esquerda e à direita bit a bit"

#~ msgid "\t<=, >=, <, >\tcomparison"
#~ msgstr "\t<=, >=, <, >\tcomparação"

#~ msgid "\t==, !=\t\tequality, inequality"
#~ msgstr "\t==, !=\t\tigualdade, desigualdade"

#~ msgid "\t&\t\tbitwise AND"
#~ msgstr "\t&\t\tE bit a bit"

#~ msgid "\t^\t\tbitwise XOR"
#~ msgstr "\t^\t\tOU Exclusivo (XOR) bit a bit"

#~ msgid "\t|\t\tbitwise OR"
#~ msgstr "\t|\t\tOU Inclusivo (OR) bit a bit"

#~ msgid "\t&&\t\tlogical AND"
#~ msgstr "\t&&\t\tE lógico"

#~ msgid "\t||\t\tlogical OR"
#~ msgstr "\t||\t\tOU lógico"

#~ msgid "\texpr ? expr : expr"
#~ msgstr "\texpr ? expr : expr"

#~ msgid "\t\t\tconditional expression"
#~ msgstr "\t\t\texpressão condicional"

#~ msgid "\t=, *=, /=, %=,"
#~ msgstr "\t=, *=, /=, %=,"

#~ msgid "\t+=, -=, <<=, >>=,"
#~ msgstr "\t+=, -=, <<=, >>=,"

#~ msgid "\t&=, ^=, |=\tassignment"
#~ msgstr "\t&=, ^=, |=\tatribuição"

#~ msgid "is replaced by its value (coerced to a long integer) within"
#~ msgstr "substituído pelo seu valor (convertido em inteiro longo) dentro"

#~ msgid "an expression.  The variable need not have its integer attribute"
#~ msgstr "da expressão.  A variável não precisa ter seu atributo inteiro"

#~ msgid "turned on to be used in an expression."
#~ msgstr "ativo para ser usada em uma expressão."

#~ msgid "Operators are evaluated in order of precedence.  Sub-expressions in"
#~ msgstr "Os operadores são avaliados em ordem de precedência.  Sub-expressões"

#~ msgid "parentheses are evaluated first and may override the precedence"
#~ msgstr "entre parênteses são avaliadas primeiro e podem prevalecer sobre as"

#~ msgid "rules above."
#~ msgstr "regras de precedência anteriores."

#~ msgid "If the last ARG evaluates to 0, let returns 1; 0 is returned"
#~ msgstr "Se o último argumento for avaliado como 0, `let' retorna 1, caso"

#~ msgid "otherwise."
#~ msgstr "contrário, retorna 0."

#~ msgid "One line is read from the standard input, and the first word is"
#~ msgstr "Uma linha é lida a partir da entrada padrão, e a primeira palavra é"

#~ msgid "assigned to the first NAME, the second word to the second NAME, and so"
#~ msgstr "atribuída ao primeiro NOME, a segunda ao segundo NOME, e assim por diante,"

#~ msgid "on, with leftover words assigned to the last NAME.  Only the characters"
#~ msgstr "com as palavras restantes atribuídas ao último NOME.  Somente os caracteres"

#~ msgid "found in $IFS are recognized as word delimiters.  The return code is"
#~ msgstr "encontrados em $IFS são reconhecidos como delimitadores. O código de retorno"

#~ msgid "zero, unless end-of-file is encountered.  If no NAMEs are supplied, the"
#~ msgstr "é zero, a menos que EOF seja encontrado.  Se nenhum NOME for fornecido,"

#~ msgid "line read is stored in the REPLY variable.  If the -r option is given,"
#~ msgstr "a linha lida é armazenada na variável REPLY.  Se a opção -r for fornecida,"

#~ msgid "this signifies `raw' input, and backslash escaping is disabled.  If"
#~ msgstr "significa entrada `textual', desabilitando a interpretação da contrabarra."

#~ msgid "the `-p' option is supplied, the string supplied as an argument is"
#~ msgstr "Se a opção `-p' for fornecida a MENSAGEM fornecida como argumento é exibida,"

#~ msgid "output without a trailing newline before attempting to read.  If -a is"
#~ msgstr "sem o caracter de nova linha, antes de efetuar a leitura.  Se a opção -a"

#~ msgid "supplied, the words read are assigned to sequential indices of ARRAY,"
#~ msgstr "for fornecida, as palavras lidas são atribuídas aos índices sequenciais"

#~ msgid "starting at zero.  If -e is supplied and the shell is interactive,"
#~ msgstr "do ARRAY, começando por zero.  Se a opção -e for fornecida, e a shell for"

#~ msgid "readline is used to obtain the line."
#~ msgstr "interativa, `readline' é utilizado para ler a linha."

#~ msgid "Causes a function to exit with the return value specified by N.  If N"
#~ msgstr "Faz a função terminar com o valor de retorno especificado por N."

#~ msgid "is omitted, the return status is that of the last command."
#~ msgstr "Se N for omitido, retorna o status do último comando executado."

#~ msgid "    -a  Mark variables which are modified or created for export."
#~ msgstr "    -a  Marcar para exportação as variáveis que são criadas ou modificadas."

#~ msgid "    -b  Notify of job termination immediately."
#~ msgstr "    -b  Notificar imediatamente o término do trabalho."

#~ msgid "    -e  Exit immediately if a command exits with a non-zero status."
#~ msgstr "    -e  Terminar imediatamente se um comando terminar com status != 0."

#~ msgid "    -f  Disable file name generation (globbing)."
#~ msgstr "    -f  Desabilitar a geração de nome de arquivo (metacaracteres)."

#~ msgid "    -h  Remember the location of commands as they are looked up."
#~ msgstr "    -h  Lembrar da localização dos comandos ao procurá-los."

#~ msgid "    -i  Force the shell to be an \"interactive\" one.  Interactive shells"
#~ msgstr "    -i  Forçar a shell ser do tipo \"interativa\".  `Shells'"

#~ msgid "        always read `~/.bashrc' on startup."
#~ msgstr "        interativas sempre lêem `~/.bashrc' ao iniciar."

#~ msgid "    -k  All assignment arguments are placed in the environment for a"
#~ msgstr "    -k  Todos os argumentos de atribuição são colocados no ambiente,"

#~ msgid "        command, not just those that precede the command name."
#~ msgstr "        e não somente os que precedem o nome do comando."

#~ msgid "    -m  Job control is enabled."
#~ msgstr "    -m  O controle de trabalho está habilitado."

#~ msgid "    -n  Read commands but do not execute them."
#~ msgstr "    -n  Ler os comandos, mas não executá-los."

#~ msgid "    -o option-name"
#~ msgstr "    -o NOME-DA-OPÇÃO"

#~ msgid "        Set the variable corresponding to option-name:"
#~ msgstr "        Inicializar a variável correspondente ao nome da opção:"

#~ msgid "            allexport    same as -a"
#~ msgstr "            allexport    o mesmo que -a"

#~ msgid "            braceexpand  same as -B"
#~ msgstr "            braceexpand  o mesmo que -B"

#~ msgid "            emacs        use an emacs-style line editing interface"
#~ msgstr "            emacs        usar interface de edição de linha estilo emacs"

#~ msgid "            errexit      same as -e"
#~ msgstr "            errexit      o mesmo que -e"

#~ msgid "            hashall      same as -h"
#~ msgstr "            hashall      o mesmo que -h"

#~ msgid "            histexpand   same as -H"
#~ msgstr "            histexpand   o mesmo que -H"

#~ msgid "            ignoreeof    the shell will not exit upon reading EOF"
#~ msgstr "            ignoreeof    a shell não termina após ler EOF"

#~ msgid "            interactive-comments"
#~ msgstr "            interactive-comments"

#~ msgid "                         allow comments to appear in interactive commands"
#~ msgstr "                         permite comentários em comandos interativos"

#~ msgid "            keyword      same as -k"
#~ msgstr "            keyword      o mesmo que -k"

#~ msgid "            monitor      same as -m"
#~ msgstr "            monitor      o mesmo que -m"

#~ msgid "            noclobber    same as -C"
#~ msgstr "            noclobber    o mesmo que -C"

#~ msgid "            noexec       same as -n"
#~ msgstr "            noexec       o mesmo que -n"

#~ msgid "            noglob       same as -f"
#~ msgstr "            noglob       o mesmo que -f"

#~ msgid "            notify       save as -b"
#~ msgstr "            notify       o mesmo que -b"

#~ msgid "            nounset      same as -u"
#~ msgstr "            nounset      o mesmo que -u"

#~ msgid "            onecmd       same as -t"
#~ msgstr "            onecmd       o mesmo que -t"

#~ msgid "            physical     same as -P"
#~ msgstr "            physical     o mesmo que -P"

#~ msgid "            posix        change the behavior of bash where the default"
#~ msgstr "            posix        mudar o comportamento do `bash' onde o padrão"

#~ msgid "                         operation differs from the 1003.2 standard to"
#~ msgstr "                         for diferente do padrão 1003.2, para tornar"

#~ msgid "                         match the standard"
#~ msgstr "                         igual ao padrão"

#~ msgid "            privileged   same as -p"
#~ msgstr "            privileged   o mesmo que -p"

#~ msgid "            verbose      same as -v"
#~ msgstr "            verbose      o mesmo que -v"

#~ msgid "            vi           use a vi-style line editing interface"
#~ msgstr "            vi           usar interface de edição de linha estilo vi"

#~ msgid "            xtrace       same as -x"
#~ msgstr "            xtrace       o mesmo que -x"

#~ msgid "    -p  Turned on whenever the real and effective user ids do not match."
#~ msgstr "    -p  Habilitado sempre que o usuário real e efetivo forem diferentes."

#~ msgid "        Disables processing of the $ENV file and importing of shell"
#~ msgstr "        Desabilita o processamento do arquivo $ENV e importação das funções"

#~ msgid "        functions.  Turning this option off causes the effective uid and"
#~ msgstr "        da shell.  Desabilitando esta opção faz com que o `uid' e `gid'"

#~ msgid "        gid to be set to the real uid and gid."
#~ msgstr "        efetivos sejam feitos o mesmo que o `uid' e `gid' reais."

#~ msgid "    -t  Exit after reading and executing one command."
#~ msgstr "    -t  Sair após ler e executar um comando."

#~ msgid "    -u  Treat unset variables as an error when substituting."
#~ msgstr "    -u  Tratar como erro as variáveis não inicializadas na substituição."

#~ msgid "    -v  Print shell input lines as they are read."
#~ msgstr "    -v  Exibir as linhas de entrada da shell ao lê-las."

#~ msgid "    -x  Print commands and their arguments as they are executed."
#~ msgstr "    -x  Exibir os comandos e seus argumentos ao executá-los."

#~ msgid "    -B  the shell will perform brace expansion"
#~ msgstr "    -B  a shell irá realizar a expansão das chaves {}"

#~ msgid "    -H  Enable ! style history substitution.  This flag is on"
#~ msgstr "    -H  Habilitar o estilo ! para substituição do histórico."

#~ msgid "        by default."
#~ msgstr "        Esta opção está ativa por padrão."

#~ msgid "    -C  If set, disallow existing regular files to be overwritten"
#~ msgstr "    -C  Não permite que arquivos regulares existentes sejam"

#~ msgid "        by redirection of output."
#~ msgstr "        sobrescritos pelo redirecionamento da saída."

#~ msgid "    -P  If set, do not follow symbolic links when executing commands"
#~ msgstr "    -P  Não seguir os vínculos simbólicos ao executar comandos,"

#~ msgid "        such as cd which change the current directory."
#~ msgstr "        tais como `cd', que troca o diretório atual."

#~ msgid "Using + rather than - causes these flags to be turned off.  The"
#~ msgstr "Usando + em vez de - faz com que as opções sejam desabilitadas. As"

#~ msgid "flags can also be used upon invocation of the shell.  The current"
#~ msgstr "opções também podem ser usadas na chamada da shell.  O conjunto atual"

#~ msgid "set of flags may be found in $-.  The remaining n ARGs are positional"
#~ msgstr "de opções pode ser encontrado em $-. Os n ARGs restantes são parâmetros"

#~ msgid "parameters and are assigned, in order, to $1, $2, .. $n.  If no"
#~ msgstr "posicionais e são atribuídos, em ordem, a $1, $2, .. $n.  Se nenhum"

#~ msgid "ARGs are given, all shell variables are printed."
#~ msgstr "ARG for fornecido, todas as variáveis da shell são exibidas."

#~ msgid "For each NAME, remove the corresponding variable or function.  Given"
#~ msgstr "Para cada NOME, remove a variável ou a função correspondente.  Usando-se a"

#~ msgid "the `-v', unset will only act on variables.  Given the `-f' flag,"
#~ msgstr "opção `-v', `unset' atua somente nas variáveis.  Usando-se a opção `-f'"

#~ msgid "unset will only act on functions.  With neither flag, unset first"
#~ msgstr "`unset' atua somente nas funções.  Sem nenhuma opção, inicialmente"

#~ msgid "tries to unset a variable, and if that fails, then tries to unset a"
#~ msgstr "`unset' tenta remover uma variável e, se falhar, tenta remover uma"

#~ msgid "function.  Some variables (such as PATH and IFS) cannot be unset; also"
#~ msgstr "função.  Algumas variáveis (como PATH e IFS) não podem ser removidas."

#~ msgid "see readonly."
#~ msgstr "Veja também o comando `readonly'."

#~ msgid "NAMEs are marked for automatic export to the environment of"
#~ msgstr "NOMEs são marcados para serem automaticamente exportados para o ambiente"

#~ msgid "subsequently executed commands.  If the -f option is given,"
#~ msgstr "dos comando executados a seguir.  Se a opção -f for fornecida,"

#~ msgid "the NAMEs refer to functions.  If no NAMEs are given, or if `-p'"
#~ msgstr "os NOMEs se referem a funções.  Se nenhum nome for fornecido, ou se `-p'"

#~ msgid "is given, a list of all names that are exported in this shell is"
#~ msgstr "for usado, uma lista com todos os nomes que são exportados nesta shell é"

#~ msgid "printed.  An argument of `-n' says to remove the export property"
#~ msgstr "exibida.  O argumento `-n' faz remover a propriedade de exportação dos"

#~ msgid "from subsequent NAMEs.  An argument of `--' disables further option"
#~ msgstr "NOMEs subsequentes.  O argumento `--' desabilita o processamento de"

#~ msgid "processing."
#~ msgstr "opções posteriores."

#~ msgid "The given NAMEs are marked readonly and the values of these NAMEs may"
#~ msgstr "Os NOMEs são marcados como somente para leitura, e os valores destes"

#~ msgid "not be changed by subsequent assignment.  If the -f option is given,"
#~ msgstr "NOMEs não poderão ser alterados por novas atribuições.  Se a opção -f for"

#~ msgid "then functions corresponding to the NAMEs are so marked.  If no"
#~ msgstr "fornecida, as funções correspondentes a NOMEs também são marcadas.  Sem"

#~ msgid "arguments are given, or if `-p' is given, a list of all readonly names"
#~ msgstr "nenhum argumento, ou se `-p' for usado, uma lista com todos os nomes"

#~ msgid "is printed.  An argument of `-n' says to remove the readonly property"
#~ msgstr "somente para leitura é exibida.  O argumento `-n' remove a propriedade"

#~ msgid "from subsequent NAMEs.  The `-a' option means to treat each NAME as"
#~ msgstr "somente para leitura.  A opção `-a' faz tratar cada NOME como uma"

#~ msgid "an array variable.  An argument of `--' disables further option"
#~ msgstr "variável tipo array.  Um argumento `--' desabilita o processamento de"

#~ msgid "The positional parameters from $N+1 ... are renamed to $1 ...  If N is"
#~ msgstr "Os parâmetros posicionais a partir de $N+1 ... são deslocados para $1 ..."

#~ msgid "not given, it is assumed to be 1."
#~ msgstr "Se N não for especificado, o valor 1 é assumido ($2 vira $1 ...)."

#~ msgid "Read and execute commands from FILENAME and return.  The pathnames"
#~ msgstr "Ler e executar os comandos em ARQUIVO e retornar.  Os caminhos em"

#~ msgid "in $PATH are used to find the directory containing FILENAME."
#~ msgstr "$PATH são usados para encontrar o diretório contendo o ARQUIVO."

#~ msgid "Suspend the execution of this shell until it receives a SIGCONT"
#~ msgstr "Suspender a execução desta shell até que o sinal SIGCONT seja recebido."

#~ msgid "signal.  The `-f' if specified says not to complain about this"
#~ msgstr "Se a opção `-f' for especificada indica para não reclamar sobre ser"

#~ msgid "being a login shell if it is; just suspend anyway."
#~ msgstr "uma `shell de login', caso seja; simplesmente suspender de qualquer forma."

#~ msgid "Exits with a status of 0 (trueness) or 1 (falseness) depending on"
#~ msgstr "Termina com status 0 (verdadeiro) ou 1 (falso) conforme EXPR for avaliada."

#~ msgid "the evaluation of EXPR.  Expressions may be unary or binary.  Unary"
#~ msgstr "As expressões podem ser unárias ou binárias. As expressões unárias são"

#~ msgid "expressions are often used to examine the status of a file.  There"
#~ msgstr "muito usadas para examinar o status de um arquivo.  Existem, também,"

#~ msgid "are string operators as well, and numeric comparison operators."
#~ msgstr "operadores para cadeias de caracteres (strings) e comparações numéricas."

#~ msgid "File operators:"
#~ msgstr "Operadores para arquivos:"

#~ msgid "    -b FILE        True if file is block special."
#~ msgstr "    -b ARQUIVO  Verdade se o arquivo for do tipo especial de bloco."

#~ msgid "    -c FILE        True if file is character special."
#~ msgstr "    -c ARQUIVO  Verdade se o arquivo for do tipo especial de caracter."

#~ msgid "    -d FILE        True if file is a directory."
#~ msgstr "    -d ARQUIVO  Verdade se o arquivo for um diretório."

#~ msgid "    -e FILE        True if file exists."
#~ msgstr "    -e ARQUIVO  Verdade se o arquivo existir."

#~ msgid "    -f FILE        True if file exists and is a regular file."
#~ msgstr "    -f ARQUIVO  Verdade se o arquivo existir e for do tipo regular."

#~ msgid "    -g FILE        True if file is set-group-id."
#~ msgstr "    -g ARQUIVO  Verdade se o arquivo tiver o bit \"set-group-id\" ativo."

#~ msgid "    -h FILE        True if file is a symbolic link.  Use \"-L\"."
#~ msgstr "    -h ARQUIVO  Verdade se arquivo for um vínculo simbólico.  Usar \"-L\"."

#~ msgid "    -L FILE        True if file is a symbolic link."
#~ msgstr "    -L ARQUIVO  Verdade se o arquivo for um vínculo simbólico."

#~ msgid "    -k FILE        True if file has its \"sticky\" bit set."
#~ msgstr "    -k ARQUIVO  Verdade se o arquivo tiver o bit \"sticky\" ativo."

#~ msgid "    -p FILE        True if file is a named pipe."
#~ msgstr "    -p ARQUIVO  Verdade se o arquivo for um `named pipe'."

#~ msgid "    -r FILE        True if file is readable by you."
#~ msgstr "    -r ARQUIVO  Verdade se você tiver autorização para ler o arquivo."

#~ msgid "    -s FILE        True if file exists and is not empty."
#~ msgstr "    -s ARQUIVO  Verdade se o arquivo existir e não estiver vazio."

#~ msgid "    -S FILE        True if file is a socket."
#~ msgstr "    -S ARQUIVO  Verdade se o arquivo for um soquete."

#~ msgid "    -t FD          True if FD is opened on a terminal."
#~ msgstr ""
#~ "    -t FD       Verdade se o descritor de arquivo (FD) estiver aberto\n"
#~ "                    em um terminal."

#~ msgid "    -u FILE        True if the file is set-user-id."
#~ msgstr "    -u ARQUIVO  Verdade se o arquivo tiver o bit \"set-user-id\" ativo."

#~ msgid "    -w FILE        True if the file is writable by you."
#~ msgstr "    -w ARQUIVO  Verdade se você tiver autorização para escrever no arquivo."

#~ msgid "    -x FILE        True if the file is executable by you."
#~ msgstr "    -x ARQUIVO  Verdade se você tiver autorização para executar o arquivo."

#~ msgid "    -O FILE        True if the file is effectively owned by you."
#~ msgstr "    -O ARQUIVO  Verdade se o arquivo pertencer ao seu usuário efetivo."

#~ msgid "    -G FILE        True if the file is effectively owned by your group."
#~ msgstr "    -G ARQUIVO  Verdade se o arquivo pertencer ao seu grupo efetivo."

#~ msgid "  FILE1 -nt FILE2  True if file1 is newer than (according to"
#~ msgstr "  ARQ1 -nt ARQ2 Verdade se ARQ1 for mais novo (conforme a data"

#~ msgid "                   modification date) file2."
#~ msgstr "                de modificação) do que ARQ2."

#~ msgid "  FILE1 -ot FILE2  True if file1 is older than file2."
#~ msgstr "  ARQ1 -ot ARQ2 Verdade se ARQ1 for mais antigo que ARQ2."

#~ msgid "  FILE1 -ef FILE2  True if file1 is a hard link to file2."
#~ msgstr ""
#~ "  ARQ1 -ef ARQ2 Verdade se ARQ1 for um vínculo direto para ARQ2.\n"
#~ "                    (mesma unidade e mesmo número do inode)"

#~ msgid "String operators:"
#~ msgstr "Operadores para cadeias de caracteres (strings):"

#~ msgid "    -z STRING      True if string is empty."
#~ msgstr "    -z STRING   Verdade se STRING estiver vazia."

#~ msgid "    -n STRING"
#~ msgstr "    -n STRING"

#~ msgid "    STRING         True if string is not empty."
#~ msgstr "    STRING      Verdade se STRING não estiver vazia."

#~ msgid "    STRING1 = STRING2"
#~ msgstr "    STRING1 = STRING2"

#~ msgid "                   True if the strings are equal."
#~ msgstr "                Verdade se STRING1 for idêntica à STRING2."

#~ msgid "    STRING1 != STRING2"
#~ msgstr "    STRING1 != STRING2"

#~ msgid "                   True if the strings are not equal."
#~ msgstr "                Verdade se STRING1 não for idêntica à STRING2."

#~ msgid "    STRING1 < STRING2"
#~ msgstr "    STRING1 < STRING2"

#~ msgid "                   True if STRING1 sorts before STRING2 lexicographically"
#~ msgstr "                Verdade se STRING1 tiver ordenação anterior à STRING2."

#~ msgid "    STRING1 > STRING2"
#~ msgstr "    STRING1 > STRING2"

#~ msgid "                   True if STRING1 sorts after STRING2 lexicographically"
#~ msgstr "                Verdade se STRING1 tiver ordenação posterior à STRING2."

#~ msgid "Other operators:"
#~ msgstr "Outros operadores:"

#~ msgid "    ! EXPR         True if expr is false."
#~ msgstr "    ! EXPR         Verdade se a expressão EXPR for falsa."

#~ msgid "    EXPR1 -a EXPR2 True if both expr1 AND expr2 are true."
#~ msgstr "    EXPR1 -a EXPR2 Verdade se EXPR1 `E' EXPR2 forem verdadeiras."

#~ msgid "    EXPR1 -o EXPR2 True if either expr1 OR expr2 is true."
#~ msgstr "    EXPR1 -o EXPR2 Verdade se EXPR1 `OU' EXPR2 for verdadeira."

#~ msgid "    arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,"
#~ msgstr "    arg1 OP arg2   Testes aritméticos.  OP pode ser -eq, -ne,"

#~ msgid "                   -lt, -le, -gt, or -ge."
#~ msgstr "                   -lt, -le, -gt, ou -ge."

#~ msgid "Arithmetic binary operators return true if ARG1 is equal, not-equal,"
#~ msgstr "Operadores aritméticos binários retornam verdadeiro se ARG1 for igual,"

#~ msgid "less-than, less-than-or-equal, greater-than, or greater-than-or-equal"
#~ msgstr "diferente, menor, menor ou igual, maior, ou maior ou igual do que"

#~ msgid "than ARG2."
#~ msgstr "ARG2, respectivamente."

#~ msgid "This is a synonym for the \"test\" builtin, but the last"
#~ msgstr "É um sinônimo para o comando interno \"test\", mas o último"

#~ msgid "argument must be a literal `]', to match the opening `['."
#~ msgstr "argumento deve ser o literal `]', para fechar o `[' de abertura."

#~ msgid "Print the accumulated user and system times for processes run from"
#~ msgstr "Exibe os tempos acumulados do usuário e do sistema para os processos"

#~ msgid "the shell."
#~ msgstr "executados por esta shell."

#~ msgid "The command ARG is to be read and executed when the shell receives"
#~ msgstr "O comando em ARG é para ser lido e executado quando a shell receber o(s)"

#~ msgid "signal(s) SIGNAL_SPEC.  If ARG is absent all specified signals are"
#~ msgstr "sinal(is) SINAL-ESPEC.  Se ARG for omitido, todos os sinais especificados"

#~ msgid "reset to their original values.  If ARG is the null string each"
#~ msgstr "retornam aos seus valores originais.  Se ARG for uma string nula, cada"

#~ msgid "SIGNAL_SPEC is ignored by the shell and by the commands it invokes."
#~ msgstr "SINAL-ESPEC é ignorado pela shell e pelos comandos chamados por ela."

#~ msgid "If SIGNAL_SPEC is EXIT (0) the command ARG is executed on exit from"
#~ msgstr "Se SINAL-ESPEC for EXIT (0) o comando em ARG é executado na saída da"

#~ msgid "the shell.  If SIGNAL_SPEC is DEBUG, ARG is executed after every"
#~ msgstr "shell.  Se SINAL-ESPEC for DEBUG, o comando em ARG é executado após cada"

#~ msgid "command.  If ARG is `-p' then the trap commands associated with"
#~ msgstr "comando.  Se ARG for `-p' então os comandos de captura associados com cada"

#~ msgid "each SIGNAL_SPEC are displayed.  If no arguments are supplied or if"
#~ msgstr "SINAL-ESPEC são exibidos.  Se nenhum argumento for fornecido, ou se"

#~ msgid "only `-p' is given, trap prints the list of commands associated with"
#~ msgstr "somente `-p' for fornecido, é exibida a lista dos comandos associados"

#~ msgid "each signal number.  SIGNAL_SPEC is either a signal name in <signal.h>"
#~ msgstr "com cada número de sinal.  SINAL-ESPEC é um nome de sinal em <signal.h> ou"

#~ msgid "or a signal number.  `trap -l' prints a list of signal names and their"
#~ msgstr "um número de sinal.  `trap -l' exibe a lista de nomes de sinais com seus"

#~ msgid "corresponding numbers.  Note that a signal can be sent to the shell"
#~ msgstr "números correspondentes.  Note que o sinal pode ser enviado para a shell"

#~ msgid "with \"kill -signal $$\"."
#~ msgstr "através do comando \"kill -SINAL $$\"."

#~ msgid "For each NAME, indicate how it would be interpreted if used as a"
#~ msgstr "Para cada NOME, indica como este deve ser interpretado caso seja"

#~ msgid "If the -t option is used, returns a single word which is one of"
#~ msgstr "Se a opção -t for fornecida, `type' retorna uma única palavra dentre"

#~ msgid "`alias', `keyword', `function', `builtin', `file' or `', if NAME is an"
#~ msgstr "`alias', `keyword', `function', `builtin', `file' ou `', se NOME for um"

#~ msgid "alias, shell reserved word, shell function, shell builtin, disk file,"
#~ msgstr "alias, uma palavra reservada, função ou comando interno da shell, um arquivo"

#~ msgid "or unfound, respectively."
#~ msgstr "em disco, ou não for encontrado, respectivamente."

#~ msgid "If the -p flag is used, either returns the name of the disk file"
#~ msgstr "Se a opção -p for fornecida, retorna o nome do arquivo em disco que"

#~ msgid "that would be executed, or nothing if -t would not return `file'."
#~ msgstr "deve ser executado, ou nada, caso -t não retorne `file'."

#~ msgid "If the -a flag is used, displays all of the places that contain an"
#~ msgstr "Se a opção -a for fornecida, exibe todos os locais que contém um"

#~ msgid "executable named `file'.  This includes aliases and functions, if and"
#~ msgstr "arquivo executável chamado `ARQUIVO', incluindo os aliases e funções,"

#~ msgid "only if the -p flag is not also used."
#~ msgstr "mas somente se a opção -p não for fornecida conjuntamente."

#~ msgid "Type accepts -all, -path, and -type in place of -a, -p, and -t,"
#~ msgstr "O comando `type' aceita -all, -path, e -type no lugar de"

#~ msgid "respectively."
#~ msgstr "-a, -p, and -t, respectivamente."

#~ msgid "Ulimit provides control over the resources available to processes"
#~ msgstr "Ulimit estabelece controle sobre os recursos disponíveis para os processos"

#~ msgid "started by the shell, on systems that allow such control.  If an"
#~ msgstr "iniciados por esta shell, em sistemas que permitem estes controles. Se uma"

#~ msgid "option is given, it is interpreted as follows:"
#~ msgstr "opção for fornecida, é interpretada como mostrado a seguir:"

#~ msgid "    -S\tuse the `soft' resource limit"
#~ msgstr "    -S\tutilizar os limites correntes (`soft') dos recursos"

#~ msgid "    -H\tuse the `hard' resource limit"
#~ msgstr "    -H\tutilizar os limites absolutos (`hard') dos recursos"

#~ msgid "    -a\tall current limits are reported"
#~ msgstr "    -a\ttodos os limites correntes são informados"

#~ msgid "    -c\tthe maximum size of core files created"
#~ msgstr "    -c\to tamanho máximo para os arquivos de imagem do núcleo criados"

#~ msgid "    -d\tthe maximum size of a process's data segment"
#~ msgstr "    -d\to tamanho máximo do segmento de dados de um processo"

#~ msgid "    -m\tthe maximum resident set size"
#~ msgstr "    -m\to tamanho máximo do conjunto de processos residentes em memória"

#~ msgid "    -s\tthe maximum stack size"
#~ msgstr "    -s\to tamanho máximo da pilha"

#~ msgid "    -t\tthe maximum amount of cpu time in seconds"
#~ msgstr "    -t\ta quantidade máxima de tempo de CPU em segundos"

#~ msgid "    -f\tthe maximum size of files created by the shell"
#~ msgstr "    -f\to tamanho máximo dos arquivos criados pela shell"

#~ msgid "    -p\tthe pipe buffer size"
#~ msgstr "    -p\to tamanho da área intermediária (buffer) do `pipe'"

#~ msgid "    -n\tthe maximum number of open file descriptors"
#~ msgstr "    -n\to número máximo de descritores de arquivos abertos"

#~ msgid "    -u\tthe maximum number of user processes"
#~ msgstr "    -u\to número máximo de processos do usuário"

#~ msgid "    -v\tthe size of virtual memory"
#~ msgstr "    -v\to tamanho da memória virtual"

#~ msgid "If LIMIT is given, it is the new value of the specified resource."
#~ msgstr "Se LIMITE for fornecido, torna-se o novo valor do recurso especificado."

#~ msgid "Otherwise, the current value of the specified resource is printed."
#~ msgstr "Senão, o valor atual do recurso especificado é exibido."

#~ msgid "If no option is given, then -f is assumed.  Values are in 1k"
#~ msgstr "Se nenhuma opção for fornecida, então -f é assumido. Os valores são em"

#~ msgid "increments, except for -t, which is in seconds, -p, which is in"
#~ msgstr "incrementos de 1k, exceto para -t, que é em segundos, -p, que é em"

#~ msgid "increments of 512 bytes, and -u, which is an unscaled number of"
#~ msgstr "incrementos de 512 bytes, e -u, que é o número cardinal de"

#~ msgid "processes."
#~ msgstr "processos."

#~ msgid "The user file-creation mask is set to MODE.  If MODE is omitted, or if"
#~ msgstr "MODO é atribuído à máscara de criação de arquivos do usuário.  Se omitido,"

#~ msgid "`-S' is supplied, the current value of the mask is printed.  The `-S'"
#~ msgstr "ou se `-S' for especificado, a máscara em uso é exibida.  A opção `-S'"

#~ msgid "option makes the output symbolic; otherwise an octal number is output."
#~ msgstr "exibe símbolos na saída; sem esta opção um número octal é exibido."

#~ msgid "If MODE begins with a digit, it is interpreted as an octal number,"
#~ msgstr "Se MODO começar por um dígito, é interpretado como sendo um número octal,"

#~ msgid "otherwise it is a symbolic mode string like that accepted by chmod(1)."
#~ msgstr "senão devem ser caracteres simbólicos, como os aceitos por chmod(1)."

#~ msgid "Wait for the specified process and report its termination status.  If"
#~ msgstr "Aguardar pelo processo especificado e informar seu status de término. Se N"

#~ msgid "N is not given, all currently active child processes are waited for,"
#~ msgstr "não for especificado, todos os processos filhos ativos são aguardados,"

#~ msgid "and the return code is zero.  N may be a process ID or a job"
#~ msgstr "e o código de retorno é zero.  N pode ser o ID de um processo ou a"

#~ msgid "specification; if a job spec is given, all processes in the job's"
#~ msgstr "especificação de um trabalho; Se for a especificação de um trabalho, todos"

#~ msgid "pipeline are waited for."
#~ msgstr "os processos presentes no `pipeline' do trabalho são aguardados."

#~ msgid "and the return code is zero.  N is a process ID; if it is not given,"
#~ msgstr "e o código de retorno é zero.  N é o ID de um processo; se N não for"

#~ msgid "all child processes of the shell are waited for."
#~ msgstr "especificado, todos os processos filhos da shell são aguardados."

#~ msgid "The `for' loop executes a sequence of commands for each member in a"
#~ msgstr "O laço `for' executa a sequência de comandos para cada membro na lista de"

#~ msgid "list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is"
#~ msgstr "items.  Se `in PALAVRAS ...;' não estiver presente, então `in \"$@\"'"

#~ msgid "assumed.  For each element in WORDS, NAME is set to that element, and"
#~ msgstr "(parâmetros posicionais) é assumido. Para cada elemento em PALAVRAS, NOME"

#~ msgid "the COMMANDS are executed."
#~ msgstr "assume seu valor, e os COMANDOS são executados."

#~ msgid "The WORDS are expanded, generating a list of words.  The"
#~ msgstr "As palavras são expandidas, gerando uma lista de palavras. O conjunto"

#~ msgid "set of expanded words is printed on the standard error, each"
#~ msgstr "de palavras expandidas é enviado para a saída de erro padrão, cada uma"

#~ msgid "preceded by a number.  If `in WORDS' is not present, `in \"$@\"'"
#~ msgstr "precedida por um número.  Se `in PALAVRAS' for omitido, `in \"$@\"' é"

#~ msgid "is assumed.  The PS3 prompt is then displayed and a line read"
#~ msgstr "assumido.  Em seguida o prompt PS3 é exibido, e uma linha é lida da"

#~ msgid "from the standard input.  If the line consists of the number"
#~ msgstr "entrada padrão.  Se a linha consistir do número correspondente ao número"

#~ msgid "corresponding to one of the displayed words, then NAME is set"
#~ msgstr "de uma das palavras exibidas, então NOME é atribuído para esta"

#~ msgid "to that word.  If the line is empty, WORDS and the prompt are"
#~ msgstr "PALAVRA.  Se a linha estiver vazia, PALAVRAS e o prompt são exibidos"

#~ msgid "redisplayed.  If EOF is read, the command completes.  Any other"
#~ msgstr "novamente.  Se EOF for lido, o comando termina.  Qualquer outro valor"

#~ msgid "value read causes NAME to be set to null.  The line read is saved"
#~ msgstr "lido faz com que NOME seja tornado nulo.  A linha lida é salva"

#~ msgid "in the variable REPLY.  COMMANDS are executed after each selection"
#~ msgstr "na variável REPLY.  COMANDOS são executados após cada seleção"

#~ msgid "until a break or return command is executed."
#~ msgstr "até que o comando `break' ou `return' seja executado."

#~ msgid "Selectively execute COMMANDS based upon WORD matching PATTERN.  The"
#~ msgstr "Executar seletivamente COMANDOS tomando por base a correspondência entre"

#~ msgid "`|' is used to separate multiple patterns."
#~ msgstr "PALAVRA e PADRÃO. O caracter `|' é usado para separar múltiplos padrões."

#~ msgid "The if COMMANDS are executed.  If the exit status is zero, then the then"
#~ msgstr "Os COMANDOS `if' são executados. Se os status de saída for zero, então os"

#~ msgid "COMMANDS are executed.  Otherwise, each of the elif COMMANDS are executed"
#~ msgstr "COMANDOS `then' são executados, senão, os COMANDOS `elif' são executados em"

#~ msgid "in turn, and if the exit status is zero, the corresponding then COMMANDS"
#~ msgstr "sequência e, se o status de saída for zero, os COMANDOS `then' associados"

#~ msgid "are executed and the if command completes.  Otherwise, the else COMMANDS"
#~ msgstr "são executados e o `if' termina.  Senão, os COMANDOS da cláusula `else'"

#~ msgid "are executed, if present.  The exit status is the exit status of the last"
#~ msgstr "são executados, se houver.  O status de saída é o status de saída do"

#~ msgid "command executed, or zero if no condition tested true."
#~ msgstr "último comando executado, ou zero, se nenhuma condição for verdadeira."

#~ msgid "Expand and execute COMMANDS as long as the final command in the"
#~ msgstr "Expande e executa COMANDOS enquanto o comando final nos"

#~ msgid "`while' COMMANDS has an exit status of zero."
#~ msgstr "COMANDOS `while' tiver um status de saída igual a zero."

#~ msgid "`until' COMMANDS has an exit status which is not zero."
#~ msgstr "COMANDOS `until' tiver um status de saída diferente de zero."

#~ msgid "Create a simple command invoked by NAME which runs COMMANDS."
#~ msgstr "Cria um comando chamado NOME o qual executa COMANDOS."

#~ msgid "Arguments on the command line along with NAME are passed to the"
#~ msgstr "Os argumentos na linha de comando juntamente com NOME são passados"

#~ msgid "function as $0 .. $n."
#~ msgstr "para a função como $0 .. $n."

#~ msgid "Run a set of commands in a group.  This is one way to redirect an"
#~ msgstr "Executa um conjunto de comandos agrupando-os.  Esta é uma forma de"

#~ msgid "entire set of commands."
#~ msgstr "redirecionar todo um conjunto de comandos."

#~ msgid "This is similar to the `fg' command.  Resume a stopped or background"
#~ msgstr "Semelhante ao comando `fg'. Prossegue a execução de um trabalho parado ou"

#~ msgid "job.  If you specifiy DIGITS, then that job is used.  If you specify"
#~ msgstr "em segundo plano. Se DÍGITOS for especificado, então este trabalho é usado."

#~ msgid "WORD, then the job whose name begins with WORD is used.  Following the"
#~ msgstr "Se for especificado PALAVRA, o trabalho começado por PALAVRA é usado."

#~ msgid "job specification with a `&' places the job in the background."
#~ msgstr "Seguindo-se a especificação por um `&' põe o trabalho em segundo plano."

#~ msgid "BASH_VERSION    The version numbers of this Bash."
#~ msgstr "BASH_VERSION    Os números da versão desta `bash'."

#~ msgid "CDPATH          A colon separated list of directories to search"
#~ msgstr "CDPATH          Uma lista, separada por dois pontos, de diretórios"

#~ msgid "\t\twhen the argument to `cd' is not found in the current"
#~ msgstr "\t\ta serem pesquisados quando o argumento para `cd' não for"

#~ msgid "\t\tdirectory."
#~ msgstr "\t\tencontrado no diretório atual."

#~ msgid "HISTFILE        The name of the file where your command history is stored."
#~ msgstr "HISTFILE        O nome do arquivo onde o histórico de comandos é armazenado."

#~ msgid "HISTFILESIZE    The maximum number of lines this file can contain."
#~ msgstr "HISTFILESIZE    O número máximo de linhas que este arquivo pode conter."

#~ msgid "HISTSIZE        The maximum number of history lines that a running"
#~ msgstr "HISTSIZE        O número máximo de linhas do histórico que uma"

#~ msgid "\t\tshell can access."
#~ msgstr "\t\tshell em execução pode acessar."

#~ msgid "HOME            The complete pathname to your login directory."
#~ msgstr "HOME            O nome completo do caminho do seu diretório de login."

#~ msgid "HOSTTYPE        The type of CPU this version of Bash is running under."
#~ msgstr "HOSTTYPE        O tipo de CPU sob a qual esta `bash' está executando."

#~ msgid "IGNOREEOF       Controls the action of the shell on receipt of an EOF"
#~ msgstr "IGNOREEOF       Controla a ação da shell ao receber um caracter"

#~ msgid "\t\tcharacter as the sole input.  If set, then the value"
#~ msgstr "\t\tEOF como única entrada.  Se estiver ativa, então o valor da"

#~ msgid "\t\tof it is the number of EOF characters that can be seen"
#~ msgstr "\t\tvariável é o número de caracteres EOF que podem ser recebidos,"

#~ msgid "\t\tin a row on an empty line before the shell will exit"
#~ msgstr "\t\tde forma seguida em uma linha vazia, antes da shell terminar"

#~ msgid "\t\t(default 10).  When unset, EOF signifies the end of input."
#~ msgstr "\t\t(padrão 10).  Caso contrário, EOF significa o fim da entrada de dados."

#~ msgid "MAILCHECK\tHow often, in seconds, Bash checks for new mail."
#~ msgstr "MAILCHECK\tFreqüência, em segundos, para a `bash' verificar novo e-mail."

#~ msgid "MAILPATH\tA colon-separated list of filenames which Bash checks"
#~ msgstr "MAILPATH\tUma lista, separada por dois pontos, de nomes de arquivos,"

#~ msgid "\t\tfor new mail."
#~ msgstr "\t\tnos quais a `bash' vai verificar se existe novo e-mail."

#~ msgid "OSTYPE\t\tThe version of Unix this version of Bash is running on."
#~ msgstr "OSTYPE\t\tA versão do Unix sob a qual a `bash' está executando."

#~ msgid "PATH            A colon-separated list of directories to search when"
#~ msgstr "PATH            Uma lista, separada por dois pontos, de diretórios a"

#~ msgid "\t\tlooking for commands."
#~ msgstr "\t\tserem pesquisados quando os comandos forem procurados."

#~ msgid "PROMPT_COMMAND  A command to be executed before the printing of each"
#~ msgstr "PROMPT_COMMAND  O comando a ser executado antes da exibição de cada"

#~ msgid "\t\tprimary prompt."
#~ msgstr "\t\tmensagem de prompt primária."

#~ msgid "PS1             The primary prompt string."
#~ msgstr "PS1             A mensagem primária de prompt exibida."

#~ msgid "PS2             The secondary prompt string."
#~ msgstr "PS2             A mensagem secundária de prompt exibida."

#~ msgid "TERM            The name of the current terminal type."
#~ msgstr "TERM            O nome do tipo de terminal em uso no momento."

#~ msgid "auto_resume     Non-null means a command word appearing on a line by"
#~ msgstr "auto_resume     Não nulo significa que um comando aparecendo sozinho em"

#~ msgid "\t\titself is first looked for in the list of currently"
#~ msgstr "\t\tlinha deve ser procurado primeiro na lista de trabalhos parados."

#~ msgid "\t\tstopped jobs.  If found there, that job is foregrounded."
#~ msgstr "\t\tSe for encontrado na lista, o trabalho vai para o primeiro plano."

#~ msgid "\t\tA value of `exact' means that the command word must"
#~ msgstr "\t\tO valor `exact' significa que a palavra do comando deve corresponder"

#~ msgid "\t\texactly match a command in the list of stopped jobs.  A"
#~ msgstr "\t\texatamente a um comando da lista de trabalhos parados."

#~ msgid "\t\tvalue of `substring' means that the command word must"
#~ msgstr "\t\tO valor `substring' significa que a palavra do comando deve"

#~ msgid "\t\tmatch a substring of the job.  Any other value means that"
#~ msgstr "\t\tcorresponder a uma parte do trabalho.  Qualquer outro valor"

#~ msgid "\t\tthe command must be a prefix of a stopped job."
#~ msgstr "\t\tsignifica que o comando deve ser um prefixo de um trabalho parado."

#~ msgid "command_oriented_history"
#~ msgstr "command_oriented_history"

#~ msgid "                Non-null means to save multiple-line commands together on"
#~ msgstr "                Se não for nulo significa salvar comandos com múltiplas"

#~ msgid "                a single history line."
#~ msgstr "                linhas, juntas em uma única linha do histórico."

#~ msgid "histchars       Characters controlling history expansion and quick"
#~ msgstr "histchars       Caracteres que controlam a expansão do histórico e a"

#~ msgid "\t\tsubstitution.  The first character is the history"
#~ msgstr "\t\tsubstituição rápida.  O primeiro caracter é o de substituição"

#~ msgid "\t\tsubstitution character, usually `!'.  The second is"
#~ msgstr "\t\tdo histórico, geralmente o `!'.  O segundo caracter é o"

#~ msgid "\t\tthe `quick substitution' character, usually `^'.  The"
#~ msgstr "\t\tde substituição rápida, geralmente o `^'.  O terceiro caracter"

#~ msgid "\t\tthird is the `history comment' character, usually `#'."
#~ msgstr "\t\té o de comentário do histórico, geralmente o `#'."

#~ msgid "HISTCONTROL\tSet to a value of `ignorespace', it means don't enter"
#~ msgstr "HISTCONTROL\tCom valor igual a `ignorespace', significa não introduzir"

#~ msgid "\t\tlines which begin with a space or tab on the history"
#~ msgstr "\t\tlinhas que iniciam por espaço ou tabulação na lista de histórico."

#~ msgid "\t\tlist.  Set to a value of `ignoredups', it means don't"
#~ msgstr "\t\tCom valor igual a `ignoredups', significa não introduzir linhas"

#~ msgid "\t\tenter lines which match the last entered line.  Set to"
#~ msgstr "\t\tque correspondam à última linha introduzida.  Com valor igual a"

#~ msgid "\t\t`ignoreboth' means to combine the two options.  Unset,"
#~ msgstr "\t\t`ignoreboth' significa combinar as duas opções.  Remover,"

#~ msgid "\t\tor set to any other value than those above means to save"
#~ msgstr "\t\tou atribuir algum outro valor que não os acima, significa salvar"

#~ msgid "\t\tall lines on the history list."
#~ msgstr "\t\ttodas as linhas na lista de histórico."

#~ msgid "Adds a directory to the top of the directory stack, or rotates"
#~ msgstr "Adiciona o diretório no topo da pilha de diretórios, ou rotaciona a"

#~ msgid "the stack, making the new top of the stack the current working"
#~ msgstr "pilha, fazendo o diretório atual de trabalho ficar no topo da pilha."

#~ msgid "directory.  With no arguments, exchanges the top two directories."
#~ msgstr "Sem nenhum argumento, troca os dois diretórios do topo."

#~ msgid "+N\tRotates the stack so that the Nth directory (counting"
#~ msgstr "+N\tRotaciona a pilha de tal forma que o n-ésimo diretório (contado a"

#~ msgid "\tfrom the left of the list shown by `dirs') is at the top."
#~ msgstr "\tpartir da esquerda da lista exibida por `dirs') fique no topo."

#~ msgid "-N\tRotates the stack so that the Nth directory (counting"
#~ msgstr "-N\tRotaciona a pilha de tal forma que o n-ésimo diretório (contado a"

#~ msgid "\tfrom the right) is at the top."
#~ msgstr "\tpartir da direita) fique no topo."

#~ msgid "-n\tsuppress the normal change of directory when adding directories"
#~ msgstr "-n\tsuprime a troca normal de diretório ao se adicionar diretórios"

#~ msgid "\tto the stack, so only the stack is manipulated."
#~ msgstr "\tà pilha, fazendo com que somente a pilha seja manipulada."

#~ msgid "dir\tadds DIR to the directory stack at the top, making it the"
#~ msgstr "dir\tadiciona DIR à pilha de diretórios, no topo, tornando-o o"

#~ msgid "You can see the directory stack with the `dirs' command."
#~ msgstr "Você pode exibir a pilha de diretórios através do comando `dirs'."

#~ msgid "Removes entries from the directory stack.  With no arguments,"
#~ msgstr "Remove entradas da pilha de diretórios.  Sem nenhum argumento,"

#~ msgid "removes the top directory from the stack, and cd's to the new"
#~ msgstr "remove o diretório que está no topo da pilha, e executa `cd' para"

#~ msgid "+N\tremoves the Nth entry counting from the left of the list"
#~ msgstr "+N\tremove a n-ésima entrada contada a partir da esquerda da lista"

#~ msgid "\tshown by `dirs', starting with zero.  For example: `popd +0'"
#~ msgstr "\texibida por `dirs', começando por zero.  Por exemplo: `popd +0'"

#~ msgid "\tremoves the first directory, `popd +1' the second."
#~ msgstr "\tremove o primeiro diretório, `popd +1' o segundo."

#~ msgid "-N\tremoves the Nth entry counting from the right of the list"
#~ msgstr "-N\tremove a n-ésima entrada contada a partir da direita da lista"

#~ msgid "\tshown by `dirs', starting with zero.  For example: `popd -0'"
#~ msgstr "\texibida por `dirs', começando por zero.  Por exemplo: `popd -0'"

#~ msgid "\tremoves the last directory, `popd -1' the next to last."
#~ msgstr "\tremove o último diretório, `popd -1' o penúltimo."

#~ msgid "-n\tsuppress the normal change of directory when removing directories"
#~ msgstr "-n\tsuprime a troca normal de diretório ao remover-se diretórios"

#~ msgid "\tfrom the stack, so only the stack is manipulated."
#~ msgstr "\tda pilha, fazendo com que somente a pilha seja manipulada."

#~ msgid "Display the list of currently remembered directories.  Directories"
#~ msgstr "Exibe a lista atual de diretórios memorizados. Os diretórios são"

#~ msgid "find their way onto the list with the `pushd' command; you can get"
#~ msgstr "introduzidos na lista através do comando `pushd'; os diretórios são"

#~ msgid "back up through the list with the `popd' command."
#~ msgstr "removidos da lista através do comando `popd'."

#~ msgid "The -l flag specifies that `dirs' should not print shorthand versions"
#~ msgstr "A opção -l especifica que `dirs' não deve exibir a versão resumida"

#~ msgid "of directories which are relative to your home directory.  This means"
#~ msgstr "dos diretórios relativos ao seu diretório `home'. Isto significa que"

#~ msgid "that `~/bin' might be displayed as `/homes/bfox/bin'.  The -v flag"
#~ msgstr "`~/bin' deve ser exibido como `/home/você/bin'.  A opção -v faz com que"

#~ msgid "causes `dirs' to print the directory stack with one entry per line,"
#~ msgstr "`dirs' exiba a pilha de diretórios com uma entrada por linha,"

#~ msgid "prepending the directory name with its position in the stack.  The -p"
#~ msgstr "antecedendo o nome do diretório com a sua posição na pilha. A opção"

#~ msgid "flag does the same thing, but the stack position is not prepended."
#~ msgstr "-p faz a mesma coisa, mas a posição na pilha não é exibida. A opção"

#~ msgid "The -c flag clears the directory stack by deleting all of the elements."
#~ msgstr "-c limpa a pilha de diretórios apagando todos os seus elementos."

#~ msgid "+N\tdisplays the Nth entry counting from the left of the list shown by"
#~ msgstr "+N\texibe a n-ésima entrada contada a partir da esquerda da lista exibida"

#~ msgid "\tdirs when invoked without options, starting with zero."
#~ msgstr "\tpor `dirs', quando este é chamado sem opções, começando por zero."

#~ msgid "-N\tdisplays the Nth entry counting from the right of the list shown by"
#~ msgstr "-N\texibe a n-ésima entrada contada a partir da direita da lista exibida"

#~ msgid "Toggle the values of variables controlling optional behavior."
#~ msgstr "Alterna os valores das variáveis controladoras de comportamentos opcionais."

#~ msgid "The -s flag means to enable (set) each OPTNAME; the -u flag"
#~ msgstr "A opção -s ativa (set) cada NOME-OPÇÃO; a opção -u desativa cada"

#~ msgid "unsets each OPTNAME.  The -q flag suppresses output; the exit"
#~ msgstr "NOME-OPÇÃO. A opção -q suprime a saída; o status de término indica se"

#~ msgid "status indicates whether each OPTNAME is set or unset.  The -o"
#~ msgstr "cada NOME-OPÇÃO foi ativado ou desativado  A opção -o restringe"

#~ msgid "option restricts the OPTNAMEs to those defined for use with"
#~ msgstr "NOME-OPÇÃO para aqueles definidos para uso através de `set -o'."

#~ msgid "`set -o'.  With no options, or with the -p option, a list of all"
#~ msgstr "Sem nenhuma opção, ou com a opção -p, uma lista com todas as"

#~ msgid "settable options is displayed, with an indication of whether or"
#~ msgstr "opções que podem ser ativadas é exibida, com indicação sobre se cada uma"

#~ msgid "not each is set."
#~ msgstr "das opções está ativa ou não."
